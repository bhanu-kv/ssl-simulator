// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: robot.proto

#include "robot.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_robot_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_Command_robot_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_robot_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ControllerInput_robot_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_robot_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ExtendedError_robot_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_robot_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_LimitParameters_robot_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_robot_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Polynomial_robot_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_robot_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SimulationLimits_robot_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_robot_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_Specs_robot_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_robot_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SpeedStatus_robot_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_robot_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SpeedVector_robot_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_robot_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Spline_robot_2eproto;
namespace robot {
class LimitParametersDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<LimitParameters> _instance;
} _LimitParameters_default_instance_;
class SimulationLimitsDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<SimulationLimits> _instance;
} _SimulationLimits_default_instance_;
class SpecsDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Specs> _instance;
} _Specs_default_instance_;
class GenerationDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Generation> _instance;
} _Generation_default_instance_;
class TeamDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Team> _instance;
} _Team_default_instance_;
class PolynomialDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Polynomial> _instance;
} _Polynomial_default_instance_;
class SplineDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Spline> _instance;
} _Spline_default_instance_;
class ControllerInputDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ControllerInput> _instance;
} _ControllerInput_default_instance_;
class SpeedVectorDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<SpeedVector> _instance;
} _SpeedVector_default_instance_;
class CommandDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Command> _instance;
} _Command_default_instance_;
class RadioCommandDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<RadioCommand> _instance;
} _RadioCommand_default_instance_;
class SpeedStatusDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<SpeedStatus> _instance;
} _SpeedStatus_default_instance_;
class ExtendedErrorDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ExtendedError> _instance;
} _ExtendedError_default_instance_;
class RadioResponseDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<RadioResponse> _instance;
} _RadioResponse_default_instance_;
}  // namespace robot
static void InitDefaultsscc_info_Command_robot_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::robot::_Command_default_instance_;
    new (ptr) ::robot::Command();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::robot::Command::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_Command_robot_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_Command_robot_2eproto}, {
      &scc_info_ControllerInput_robot_2eproto.base,
      &scc_info_SpeedVector_robot_2eproto.base,}};

static void InitDefaultsscc_info_ControllerInput_robot_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::robot::_ControllerInput_default_instance_;
    new (ptr) ::robot::ControllerInput();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::robot::ControllerInput::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ControllerInput_robot_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_ControllerInput_robot_2eproto}, {
      &scc_info_Spline_robot_2eproto.base,}};

static void InitDefaultsscc_info_ExtendedError_robot_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::robot::_ExtendedError_default_instance_;
    new (ptr) ::robot::ExtendedError();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::robot::ExtendedError::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ExtendedError_robot_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_ExtendedError_robot_2eproto}, {}};

static void InitDefaultsscc_info_Generation_robot_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::robot::_Generation_default_instance_;
    new (ptr) ::robot::Generation();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::robot::Generation::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Generation_robot_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_Generation_robot_2eproto}, {
      &scc_info_Specs_robot_2eproto.base,}};

static void InitDefaultsscc_info_LimitParameters_robot_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::robot::_LimitParameters_default_instance_;
    new (ptr) ::robot::LimitParameters();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::robot::LimitParameters::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_LimitParameters_robot_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_LimitParameters_robot_2eproto}, {}};

static void InitDefaultsscc_info_Polynomial_robot_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::robot::_Polynomial_default_instance_;
    new (ptr) ::robot::Polynomial();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::robot::Polynomial::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Polynomial_robot_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_Polynomial_robot_2eproto}, {}};

static void InitDefaultsscc_info_RadioCommand_robot_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::robot::_RadioCommand_default_instance_;
    new (ptr) ::robot::RadioCommand();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::robot::RadioCommand::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_RadioCommand_robot_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_RadioCommand_robot_2eproto}, {
      &scc_info_Command_robot_2eproto.base,}};

static void InitDefaultsscc_info_RadioResponse_robot_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::robot::_RadioResponse_default_instance_;
    new (ptr) ::robot::RadioResponse();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::robot::RadioResponse::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_RadioResponse_robot_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_RadioResponse_robot_2eproto}, {
      &scc_info_SpeedStatus_robot_2eproto.base,
      &scc_info_ExtendedError_robot_2eproto.base,}};

static void InitDefaultsscc_info_SimulationLimits_robot_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::robot::_SimulationLimits_default_instance_;
    new (ptr) ::robot::SimulationLimits();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::robot::SimulationLimits::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SimulationLimits_robot_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_SimulationLimits_robot_2eproto}, {}};

static void InitDefaultsscc_info_Specs_robot_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::robot::_Specs_default_instance_;
    new (ptr) ::robot::Specs();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::robot::Specs::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_Specs_robot_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_Specs_robot_2eproto}, {
      &scc_info_LimitParameters_robot_2eproto.base,
      &scc_info_SimulationLimits_robot_2eproto.base,}};

static void InitDefaultsscc_info_SpeedStatus_robot_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::robot::_SpeedStatus_default_instance_;
    new (ptr) ::robot::SpeedStatus();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::robot::SpeedStatus::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SpeedStatus_robot_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_SpeedStatus_robot_2eproto}, {}};

static void InitDefaultsscc_info_SpeedVector_robot_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::robot::_SpeedVector_default_instance_;
    new (ptr) ::robot::SpeedVector();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::robot::SpeedVector::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SpeedVector_robot_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_SpeedVector_robot_2eproto}, {}};

static void InitDefaultsscc_info_Spline_robot_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::robot::_Spline_default_instance_;
    new (ptr) ::robot::Spline();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::robot::Spline::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Spline_robot_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_Spline_robot_2eproto}, {
      &scc_info_Polynomial_robot_2eproto.base,}};

static void InitDefaultsscc_info_Team_robot_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::robot::_Team_default_instance_;
    new (ptr) ::robot::Team();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::robot::Team::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Team_robot_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_Team_robot_2eproto}, {
      &scc_info_Specs_robot_2eproto.base,}};

static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_robot_2eproto[14];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_robot_2eproto[2];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_robot_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_robot_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::robot::LimitParameters, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::robot::LimitParameters, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::robot::LimitParameters, a_speedup_f_max_),
  PROTOBUF_FIELD_OFFSET(::robot::LimitParameters, a_speedup_s_max_),
  PROTOBUF_FIELD_OFFSET(::robot::LimitParameters, a_speedup_phi_max_),
  PROTOBUF_FIELD_OFFSET(::robot::LimitParameters, a_brake_f_max_),
  PROTOBUF_FIELD_OFFSET(::robot::LimitParameters, a_brake_s_max_),
  PROTOBUF_FIELD_OFFSET(::robot::LimitParameters, a_brake_phi_max_),
  0,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::robot::SimulationLimits, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::robot::SimulationLimits, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::robot::SimulationLimits, a_speedup_wheel_max_),
  PROTOBUF_FIELD_OFFSET(::robot::SimulationLimits, a_brake_wheel_max_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::robot::Specs, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::robot::Specs, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::robot::Specs, generation_),
  PROTOBUF_FIELD_OFFSET(::robot::Specs, year_),
  PROTOBUF_FIELD_OFFSET(::robot::Specs, id_),
  PROTOBUF_FIELD_OFFSET(::robot::Specs, type_),
  PROTOBUF_FIELD_OFFSET(::robot::Specs, radius_),
  PROTOBUF_FIELD_OFFSET(::robot::Specs, height_),
  PROTOBUF_FIELD_OFFSET(::robot::Specs, mass_),
  PROTOBUF_FIELD_OFFSET(::robot::Specs, angle_),
  PROTOBUF_FIELD_OFFSET(::robot::Specs, v_max_),
  PROTOBUF_FIELD_OFFSET(::robot::Specs, omega_max_),
  PROTOBUF_FIELD_OFFSET(::robot::Specs, shot_linear_max_),
  PROTOBUF_FIELD_OFFSET(::robot::Specs, shot_chip_max_),
  PROTOBUF_FIELD_OFFSET(::robot::Specs, dribbler_width_),
  PROTOBUF_FIELD_OFFSET(::robot::Specs, acceleration_),
  PROTOBUF_FIELD_OFFSET(::robot::Specs, strategy_),
  PROTOBUF_FIELD_OFFSET(::robot::Specs, ir_param_),
  PROTOBUF_FIELD_OFFSET(::robot::Specs, shoot_radius_),
  PROTOBUF_FIELD_OFFSET(::robot::Specs, dribbler_height_),
  PROTOBUF_FIELD_OFFSET(::robot::Specs, simulation_limits_),
  PROTOBUF_FIELD_OFFSET(::robot::Specs, can_shoot_),
  PROTOBUF_FIELD_OFFSET(::robot::Specs, can_dribble_),
  3,
  4,
  5,
  20,
  17,
  18,
  6,
  7,
  8,
  9,
  19,
  10,
  11,
  0,
  1,
  12,
  13,
  14,
  2,
  15,
  16,
  PROTOBUF_FIELD_OFFSET(::robot::Generation, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::robot::Generation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::robot::Generation, default__),
  PROTOBUF_FIELD_OFFSET(::robot::Generation, robot_),
  0,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::robot::Team, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::robot::Team, robot_),
  PROTOBUF_FIELD_OFFSET(::robot::Polynomial, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::robot::Polynomial, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::robot::Polynomial, a0_),
  PROTOBUF_FIELD_OFFSET(::robot::Polynomial, a1_),
  PROTOBUF_FIELD_OFFSET(::robot::Polynomial, a2_),
  PROTOBUF_FIELD_OFFSET(::robot::Polynomial, a3_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::robot::Spline, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::robot::Spline, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::robot::Spline, t_start_),
  PROTOBUF_FIELD_OFFSET(::robot::Spline, t_end_),
  PROTOBUF_FIELD_OFFSET(::robot::Spline, x_),
  PROTOBUF_FIELD_OFFSET(::robot::Spline, y_),
  PROTOBUF_FIELD_OFFSET(::robot::Spline, phi_),
  3,
  4,
  0,
  1,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::robot::ControllerInput, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::robot::ControllerInput, spline_),
  PROTOBUF_FIELD_OFFSET(::robot::SpeedVector, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::robot::SpeedVector, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::robot::SpeedVector, v_s_),
  PROTOBUF_FIELD_OFFSET(::robot::SpeedVector, v_f_),
  PROTOBUF_FIELD_OFFSET(::robot::SpeedVector, omega_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::robot::Command, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::robot::Command, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::robot::Command, controller_),
  PROTOBUF_FIELD_OFFSET(::robot::Command, v_f_),
  PROTOBUF_FIELD_OFFSET(::robot::Command, v_s_),
  PROTOBUF_FIELD_OFFSET(::robot::Command, omega_),
  PROTOBUF_FIELD_OFFSET(::robot::Command, kick_style_),
  PROTOBUF_FIELD_OFFSET(::robot::Command, kick_power_),
  PROTOBUF_FIELD_OFFSET(::robot::Command, dribbler_),
  PROTOBUF_FIELD_OFFSET(::robot::Command, local_),
  PROTOBUF_FIELD_OFFSET(::robot::Command, standby_),
  PROTOBUF_FIELD_OFFSET(::robot::Command, strategy_controlled_),
  PROTOBUF_FIELD_OFFSET(::robot::Command, force_kick_),
  PROTOBUF_FIELD_OFFSET(::robot::Command, network_controlled_),
  PROTOBUF_FIELD_OFFSET(::robot::Command, eject_sdcard_),
  PROTOBUF_FIELD_OFFSET(::robot::Command, cur_v_f_),
  PROTOBUF_FIELD_OFFSET(::robot::Command, cur_v_s_),
  PROTOBUF_FIELD_OFFSET(::robot::Command, cur_omega_),
  PROTOBUF_FIELD_OFFSET(::robot::Command, output0_),
  PROTOBUF_FIELD_OFFSET(::robot::Command, output1_),
  PROTOBUF_FIELD_OFFSET(::robot::Command, output2_),
  0,
  4,
  5,
  6,
  18,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::robot::RadioCommand, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::robot::RadioCommand, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::robot::RadioCommand, generation_),
  PROTOBUF_FIELD_OFFSET(::robot::RadioCommand, id_),
  PROTOBUF_FIELD_OFFSET(::robot::RadioCommand, is_blue_),
  PROTOBUF_FIELD_OFFSET(::robot::RadioCommand, command_),
  PROTOBUF_FIELD_OFFSET(::robot::RadioCommand, command_time_),
  1,
  2,
  4,
  0,
  3,
  PROTOBUF_FIELD_OFFSET(::robot::SpeedStatus, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::robot::SpeedStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::robot::SpeedStatus, v_f_),
  PROTOBUF_FIELD_OFFSET(::robot::SpeedStatus, v_s_),
  PROTOBUF_FIELD_OFFSET(::robot::SpeedStatus, omega_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::robot::ExtendedError, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::robot::ExtendedError, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::robot::ExtendedError, motor_1_error_),
  PROTOBUF_FIELD_OFFSET(::robot::ExtendedError, motor_2_error_),
  PROTOBUF_FIELD_OFFSET(::robot::ExtendedError, motor_3_error_),
  PROTOBUF_FIELD_OFFSET(::robot::ExtendedError, motor_4_error_),
  PROTOBUF_FIELD_OFFSET(::robot::ExtendedError, dribbler_error_),
  PROTOBUF_FIELD_OFFSET(::robot::ExtendedError, kicker_error_),
  PROTOBUF_FIELD_OFFSET(::robot::ExtendedError, kicker_break_beam_error_),
  PROTOBUF_FIELD_OFFSET(::robot::ExtendedError, motor_encoder_error_),
  PROTOBUF_FIELD_OFFSET(::robot::ExtendedError, main_sensor_error_),
  PROTOBUF_FIELD_OFFSET(::robot::ExtendedError, temperature_),
  0,
  1,
  2,
  3,
  5,
  6,
  7,
  8,
  9,
  4,
  PROTOBUF_FIELD_OFFSET(::robot::RadioResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::robot::RadioResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::robot::RadioResponse, time_),
  PROTOBUF_FIELD_OFFSET(::robot::RadioResponse, generation_),
  PROTOBUF_FIELD_OFFSET(::robot::RadioResponse, id_),
  PROTOBUF_FIELD_OFFSET(::robot::RadioResponse, battery_),
  PROTOBUF_FIELD_OFFSET(::robot::RadioResponse, packet_loss_rx_),
  PROTOBUF_FIELD_OFFSET(::robot::RadioResponse, packet_loss_tx_),
  PROTOBUF_FIELD_OFFSET(::robot::RadioResponse, estimated_speed_),
  PROTOBUF_FIELD_OFFSET(::robot::RadioResponse, ball_detected_),
  PROTOBUF_FIELD_OFFSET(::robot::RadioResponse, cap_charged_),
  PROTOBUF_FIELD_OFFSET(::robot::RadioResponse, error_present_),
  PROTOBUF_FIELD_OFFSET(::robot::RadioResponse, radio_rtt_),
  PROTOBUF_FIELD_OFFSET(::robot::RadioResponse, extended_error_),
  PROTOBUF_FIELD_OFFSET(::robot::RadioResponse, is_blue_),
  11,
  2,
  3,
  4,
  5,
  6,
  0,
  7,
  8,
  9,
  12,
  1,
  10,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 11, sizeof(::robot::LimitParameters)},
  { 17, 24, sizeof(::robot::SimulationLimits)},
  { 26, 52, sizeof(::robot::Specs)},
  { 73, 80, sizeof(::robot::Generation)},
  { 82, -1, sizeof(::robot::Team)},
  { 88, 97, sizeof(::robot::Polynomial)},
  { 101, 111, sizeof(::robot::Spline)},
  { 116, -1, sizeof(::robot::ControllerInput)},
  { 122, 130, sizeof(::robot::SpeedVector)},
  { 133, 157, sizeof(::robot::Command)},
  { 176, 186, sizeof(::robot::RadioCommand)},
  { 191, 199, sizeof(::robot::SpeedStatus)},
  { 202, 217, sizeof(::robot::ExtendedError)},
  { 227, 245, sizeof(::robot::RadioResponse)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::robot::_LimitParameters_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::robot::_SimulationLimits_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::robot::_Specs_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::robot::_Generation_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::robot::_Team_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::robot::_Polynomial_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::robot::_Spline_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::robot::_ControllerInput_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::robot::_SpeedVector_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::robot::_Command_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::robot::_RadioCommand_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::robot::_SpeedStatus_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::robot::_ExtendedError_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::robot::_RadioResponse_default_instance_),
};

const char descriptor_table_protodef_robot_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\013robot.proto\022\005robot\"\245\001\n\017LimitParameters"
  "\022\027\n\017a_speedup_f_max\030\001 \001(\002\022\027\n\017a_speedup_s"
  "_max\030\002 \001(\002\022\031\n\021a_speedup_phi_max\030\003 \001(\002\022\025\n"
  "\ra_brake_f_max\030\004 \001(\002\022\025\n\ra_brake_s_max\030\005 "
  "\001(\002\022\027\n\017a_brake_phi_max\030\006 \001(\002\"J\n\020Simulati"
  "onLimits\022\033\n\023a_speedup_wheel_max\030\001 \001(\002\022\031\n"
  "\021a_brake_wheel_max\030\002 \001(\002\"\306\004\n\005Specs\022\022\n\nge"
  "neration\030\001 \002(\r\022\014\n\004year\030\002 \002(\r\022\n\n\002id\030\003 \002(\r"
  "\022)\n\004type\030\023 \001(\0162\033.robot.Specs.GenerationT"
  "ype\022\024\n\006radius\030\004 \001(\002:\0040.09\022\024\n\006height\030\005 \001("
  "\002:\0040.15\022\014\n\004mass\030\006 \001(\002\022\r\n\005angle\030\007 \001(\002\022\r\n\005"
  "v_max\030\010 \001(\002\022\021\n\tomega_max\030\t \001(\002\022\032\n\017shot_l"
  "inear_max\030\n \001(\002:\0018\022\025\n\rshot_chip_max\030\013 \001("
  "\002\022\026\n\016dribbler_width\030\014 \001(\002\022,\n\014acceleratio"
  "n\030\r \001(\0132\026.robot.LimitParameters\022(\n\010strat"
  "egy\030\020 \001(\0132\026.robot.LimitParameters\022\020\n\010ir_"
  "param\030\017 \001(\002\022\024\n\014shoot_radius\030\021 \001(\002\022\027\n\017dri"
  "bbler_height\030\022 \001(\002\0222\n\021simulation_limits\030"
  "\025 \001(\0132\027.robot.SimulationLimits\022\027\n\tcan_sh"
  "oot\030\026 \001(\010:\004true\022\031\n\013can_dribble\030\027 \001(\010:\004tr"
  "ue\"\'\n\016GenerationType\022\013\n\007Regular\020\001\022\010\n\004All"
  "y\020\002J\004\010\024\020\025\"H\n\nGeneration\022\035\n\007default\030\001 \002(\013"
  "2\014.robot.Specs\022\033\n\005robot\030\002 \003(\0132\014.robot.Sp"
  "ecs\"#\n\004Team\022\033\n\005robot\030\001 \003(\0132\014.robot.Specs"
  "\"<\n\nPolynomial\022\n\n\002a0\030\001 \002(\002\022\n\n\002a1\030\002 \002(\002\022\n"
  "\n\002a2\030\003 \002(\002\022\n\n\002a3\030\004 \002(\002\"\204\001\n\006Spline\022\017\n\007t_s"
  "tart\030\001 \002(\002\022\r\n\005t_end\030\002 \002(\002\022\034\n\001x\030\003 \002(\0132\021.r"
  "obot.Polynomial\022\034\n\001y\030\004 \002(\0132\021.robot.Polyn"
  "omial\022\036\n\003phi\030\005 \002(\0132\021.robot.Polynomial\"0\n"
  "\017ControllerInput\022\035\n\006spline\030\001 \003(\0132\r.robot"
  ".Spline\"6\n\013SpeedVector\022\013\n\003v_s\030\001 \001(\002\022\013\n\003v"
  "_f\030\002 \001(\002\022\r\n\005omega\030\003 \001(\002\"\374\003\n\007Command\022*\n\nc"
  "ontroller\030\001 \001(\0132\026.robot.ControllerInput\022"
  "\013\n\003v_f\030\002 \001(\002\022\013\n\003v_s\030\003 \001(\002\022\r\n\005omega\030\004 \001(\002"
  "\022,\n\nkick_style\030\005 \001(\0162\030.robot.Command.Kic"
  "kStyle\022\022\n\nkick_power\030\006 \001(\002\022\020\n\010dribbler\030\007"
  " \001(\002\022\r\n\005local\030\010 \001(\010\022\017\n\007standby\030\013 \001(\010\022\033\n\023"
  "strategy_controlled\030\r \001(\010\022\022\n\nforce_kick\030"
  "\016 \001(\010\022\032\n\022network_controlled\030\017 \001(\010\022\024\n\014eje"
  "ct_sdcard\030\020 \001(\010\022\017\n\007cur_v_f\030\021 \001(\002\022\017\n\007cur_"
  "v_s\030\022 \001(\002\022\021\n\tcur_omega\030\023 \001(\002\022#\n\007output0\030"
  "\024 \001(\0132\022.robot.SpeedVector\022#\n\007output1\030\025 \001"
  "(\0132\022.robot.SpeedVector\022#\n\007output2\030\026 \001(\0132"
  "\022.robot.SpeedVector\"!\n\tKickStyle\022\n\n\006Line"
  "ar\020\001\022\010\n\004Chip\020\002\"v\n\014RadioCommand\022\022\n\ngenera"
  "tion\030\001 \002(\r\022\n\n\002id\030\002 \002(\r\022\017\n\007is_blue\030\004 \001(\010\022"
  "\037\n\007command\030\003 \002(\0132\016.robot.Command\022\024\n\014comm"
  "and_time\030\005 \001(\003\"6\n\013SpeedStatus\022\013\n\003v_f\030\001 \002"
  "(\002\022\013\n\003v_s\030\002 \002(\002\022\r\n\005omega\030\003 \002(\002\"\207\002\n\rExten"
  "dedError\022\025\n\rmotor_1_error\030\001 \002(\010\022\025\n\rmotor"
  "_2_error\030\002 \002(\010\022\025\n\rmotor_3_error\030\003 \002(\010\022\025\n"
  "\rmotor_4_error\030\004 \002(\010\022\026\n\016dribbler_error\030\005"
  " \002(\010\022\024\n\014kicker_error\030\006 \002(\010\022\037\n\027kicker_bre"
  "ak_beam_error\030\013 \001(\010\022\033\n\023motor_encoder_err"
  "or\030\t \001(\010\022\031\n\021main_sensor_error\030\n \001(\010\022\023\n\013t"
  "emperature\030\007 \001(\005\"\300\002\n\rRadioResponse\022\014\n\004ti"
  "me\030\n \001(\003\022\022\n\ngeneration\030\001 \002(\r\022\n\n\002id\030\002 \002(\r"
  "\022\017\n\007battery\030\003 \001(\002\022\026\n\016packet_loss_rx\030\004 \001("
  "\002\022\026\n\016packet_loss_tx\030\005 \001(\002\022+\n\017estimated_s"
  "peed\030\006 \001(\0132\022.robot.SpeedStatus\022\025\n\rball_d"
  "etected\030\007 \001(\010\022\023\n\013cap_charged\030\010 \001(\010\022\025\n\rer"
  "ror_present\030\t \001(\010\022\021\n\tradio_rtt\030\013 \001(\002\022,\n\016"
  "extended_error\030\014 \001(\0132\024.robot.ExtendedErr"
  "or\022\017\n\007is_blue\030\r \001(\010B\003\370\001\001"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_robot_2eproto_deps[1] = {
};
static ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase*const descriptor_table_robot_2eproto_sccs[14] = {
  &scc_info_Command_robot_2eproto.base,
  &scc_info_ControllerInput_robot_2eproto.base,
  &scc_info_ExtendedError_robot_2eproto.base,
  &scc_info_Generation_robot_2eproto.base,
  &scc_info_LimitParameters_robot_2eproto.base,
  &scc_info_Polynomial_robot_2eproto.base,
  &scc_info_RadioCommand_robot_2eproto.base,
  &scc_info_RadioResponse_robot_2eproto.base,
  &scc_info_SimulationLimits_robot_2eproto.base,
  &scc_info_Specs_robot_2eproto.base,
  &scc_info_SpeedStatus_robot_2eproto.base,
  &scc_info_SpeedVector_robot_2eproto.base,
  &scc_info_Spline_robot_2eproto.base,
  &scc_info_Team_robot_2eproto.base,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_robot_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_robot_2eproto = {
  false, false, descriptor_table_protodef_robot_2eproto, "robot.proto", 2544,
  &descriptor_table_robot_2eproto_once, descriptor_table_robot_2eproto_sccs, descriptor_table_robot_2eproto_deps, 14, 0,
  schemas, file_default_instances, TableStruct_robot_2eproto::offsets,
  file_level_metadata_robot_2eproto, 14, file_level_enum_descriptors_robot_2eproto, file_level_service_descriptors_robot_2eproto,
};

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_robot_2eproto = (static_cast<void>(::PROTOBUF_NAMESPACE_ID::internal::AddDescriptors(&descriptor_table_robot_2eproto)), true);
namespace robot {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Specs_GenerationType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_robot_2eproto);
  return file_level_enum_descriptors_robot_2eproto[0];
}
bool Specs_GenerationType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr Specs_GenerationType Specs::Regular;
constexpr Specs_GenerationType Specs::Ally;
constexpr Specs_GenerationType Specs::GenerationType_MIN;
constexpr Specs_GenerationType Specs::GenerationType_MAX;
constexpr int Specs::GenerationType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Command_KickStyle_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_robot_2eproto);
  return file_level_enum_descriptors_robot_2eproto[1];
}
bool Command_KickStyle_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr Command_KickStyle Command::Linear;
constexpr Command_KickStyle Command::Chip;
constexpr Command_KickStyle Command::KickStyle_MIN;
constexpr Command_KickStyle Command::KickStyle_MAX;
constexpr int Command::KickStyle_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)

// ===================================================================

void LimitParameters::InitAsDefaultInstance() {
}
class LimitParameters::_Internal {
 public:
  using HasBits = decltype(std::declval<LimitParameters>()._has_bits_);
  static void set_has_a_speedup_f_max(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_a_speedup_s_max(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_a_speedup_phi_max(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_a_brake_f_max(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_a_brake_s_max(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_a_brake_phi_max(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

LimitParameters::LimitParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:robot.LimitParameters)
}
LimitParameters::LimitParameters(const LimitParameters& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&a_speedup_f_max_, &from.a_speedup_f_max_,
    static_cast<size_t>(reinterpret_cast<char*>(&a_brake_phi_max_) -
    reinterpret_cast<char*>(&a_speedup_f_max_)) + sizeof(a_brake_phi_max_));
  // @@protoc_insertion_point(copy_constructor:robot.LimitParameters)
}

void LimitParameters::SharedCtor() {
  ::memset(&a_speedup_f_max_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&a_brake_phi_max_) -
      reinterpret_cast<char*>(&a_speedup_f_max_)) + sizeof(a_brake_phi_max_));
}

LimitParameters::~LimitParameters() {
  // @@protoc_insertion_point(destructor:robot.LimitParameters)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void LimitParameters::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void LimitParameters::ArenaDtor(void* object) {
  LimitParameters* _this = reinterpret_cast< LimitParameters* >(object);
  (void)_this;
}
void LimitParameters::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LimitParameters::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const LimitParameters& LimitParameters::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_LimitParameters_robot_2eproto.base);
  return *internal_default_instance();
}


void LimitParameters::Clear() {
// @@protoc_insertion_point(message_clear_start:robot.LimitParameters)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&a_speedup_f_max_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&a_brake_phi_max_) -
        reinterpret_cast<char*>(&a_speedup_f_max_)) + sizeof(a_brake_phi_max_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LimitParameters::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional float a_speedup_f_max = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_a_speedup_f_max(&has_bits);
          a_speedup_f_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float a_speedup_s_max = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_a_speedup_s_max(&has_bits);
          a_speedup_s_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float a_speedup_phi_max = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_a_speedup_phi_max(&has_bits);
          a_speedup_phi_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float a_brake_f_max = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_a_brake_f_max(&has_bits);
          a_brake_f_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float a_brake_s_max = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          _Internal::set_has_a_brake_s_max(&has_bits);
          a_brake_s_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float a_brake_phi_max = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 53)) {
          _Internal::set_has_a_brake_phi_max(&has_bits);
          a_brake_phi_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* LimitParameters::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:robot.LimitParameters)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float a_speedup_f_max = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_a_speedup_f_max(), target);
  }

  // optional float a_speedup_s_max = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_a_speedup_s_max(), target);
  }

  // optional float a_speedup_phi_max = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_a_speedup_phi_max(), target);
  }

  // optional float a_brake_f_max = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_a_brake_f_max(), target);
  }

  // optional float a_brake_s_max = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_a_brake_s_max(), target);
  }

  // optional float a_brake_phi_max = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(6, this->_internal_a_brake_phi_max(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robot.LimitParameters)
  return target;
}

size_t LimitParameters::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:robot.LimitParameters)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional float a_speedup_f_max = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float a_speedup_s_max = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float a_speedup_phi_max = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float a_brake_f_max = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float a_brake_s_max = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float a_brake_phi_max = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LimitParameters::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robot.LimitParameters)
  GOOGLE_DCHECK_NE(&from, this);
  const LimitParameters* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<LimitParameters>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robot.LimitParameters)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robot.LimitParameters)
    MergeFrom(*source);
  }
}

void LimitParameters::MergeFrom(const LimitParameters& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robot.LimitParameters)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      a_speedup_f_max_ = from.a_speedup_f_max_;
    }
    if (cached_has_bits & 0x00000002u) {
      a_speedup_s_max_ = from.a_speedup_s_max_;
    }
    if (cached_has_bits & 0x00000004u) {
      a_speedup_phi_max_ = from.a_speedup_phi_max_;
    }
    if (cached_has_bits & 0x00000008u) {
      a_brake_f_max_ = from.a_brake_f_max_;
    }
    if (cached_has_bits & 0x00000010u) {
      a_brake_s_max_ = from.a_brake_s_max_;
    }
    if (cached_has_bits & 0x00000020u) {
      a_brake_phi_max_ = from.a_brake_phi_max_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void LimitParameters::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robot.LimitParameters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LimitParameters::CopyFrom(const LimitParameters& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robot.LimitParameters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LimitParameters::IsInitialized() const {
  return true;
}

void LimitParameters::InternalSwap(LimitParameters* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LimitParameters, a_brake_phi_max_)
      + sizeof(LimitParameters::a_brake_phi_max_)
      - PROTOBUF_FIELD_OFFSET(LimitParameters, a_speedup_f_max_)>(
          reinterpret_cast<char*>(&a_speedup_f_max_),
          reinterpret_cast<char*>(&other->a_speedup_f_max_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LimitParameters::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void SimulationLimits::InitAsDefaultInstance() {
}
class SimulationLimits::_Internal {
 public:
  using HasBits = decltype(std::declval<SimulationLimits>()._has_bits_);
  static void set_has_a_speedup_wheel_max(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_a_brake_wheel_max(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

SimulationLimits::SimulationLimits(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:robot.SimulationLimits)
}
SimulationLimits::SimulationLimits(const SimulationLimits& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&a_speedup_wheel_max_, &from.a_speedup_wheel_max_,
    static_cast<size_t>(reinterpret_cast<char*>(&a_brake_wheel_max_) -
    reinterpret_cast<char*>(&a_speedup_wheel_max_)) + sizeof(a_brake_wheel_max_));
  // @@protoc_insertion_point(copy_constructor:robot.SimulationLimits)
}

void SimulationLimits::SharedCtor() {
  ::memset(&a_speedup_wheel_max_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&a_brake_wheel_max_) -
      reinterpret_cast<char*>(&a_speedup_wheel_max_)) + sizeof(a_brake_wheel_max_));
}

SimulationLimits::~SimulationLimits() {
  // @@protoc_insertion_point(destructor:robot.SimulationLimits)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void SimulationLimits::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void SimulationLimits::ArenaDtor(void* object) {
  SimulationLimits* _this = reinterpret_cast< SimulationLimits* >(object);
  (void)_this;
}
void SimulationLimits::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SimulationLimits::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SimulationLimits& SimulationLimits::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_SimulationLimits_robot_2eproto.base);
  return *internal_default_instance();
}


void SimulationLimits::Clear() {
// @@protoc_insertion_point(message_clear_start:robot.SimulationLimits)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&a_speedup_wheel_max_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&a_brake_wheel_max_) -
        reinterpret_cast<char*>(&a_speedup_wheel_max_)) + sizeof(a_brake_wheel_max_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SimulationLimits::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional float a_speedup_wheel_max = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_a_speedup_wheel_max(&has_bits);
          a_speedup_wheel_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float a_brake_wheel_max = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_a_brake_wheel_max(&has_bits);
          a_brake_wheel_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SimulationLimits::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:robot.SimulationLimits)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float a_speedup_wheel_max = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_a_speedup_wheel_max(), target);
  }

  // optional float a_brake_wheel_max = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_a_brake_wheel_max(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robot.SimulationLimits)
  return target;
}

size_t SimulationLimits::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:robot.SimulationLimits)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional float a_speedup_wheel_max = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float a_brake_wheel_max = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SimulationLimits::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robot.SimulationLimits)
  GOOGLE_DCHECK_NE(&from, this);
  const SimulationLimits* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<SimulationLimits>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robot.SimulationLimits)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robot.SimulationLimits)
    MergeFrom(*source);
  }
}

void SimulationLimits::MergeFrom(const SimulationLimits& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robot.SimulationLimits)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      a_speedup_wheel_max_ = from.a_speedup_wheel_max_;
    }
    if (cached_has_bits & 0x00000002u) {
      a_brake_wheel_max_ = from.a_brake_wheel_max_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SimulationLimits::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robot.SimulationLimits)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SimulationLimits::CopyFrom(const SimulationLimits& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robot.SimulationLimits)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SimulationLimits::IsInitialized() const {
  return true;
}

void SimulationLimits::InternalSwap(SimulationLimits* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SimulationLimits, a_brake_wheel_max_)
      + sizeof(SimulationLimits::a_brake_wheel_max_)
      - PROTOBUF_FIELD_OFFSET(SimulationLimits, a_speedup_wheel_max_)>(
          reinterpret_cast<char*>(&a_speedup_wheel_max_),
          reinterpret_cast<char*>(&other->a_speedup_wheel_max_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SimulationLimits::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Specs::InitAsDefaultInstance() {
  ::robot::_Specs_default_instance_._instance.get_mutable()->acceleration_ = const_cast< ::robot::LimitParameters*>(
      ::robot::LimitParameters::internal_default_instance());
  ::robot::_Specs_default_instance_._instance.get_mutable()->strategy_ = const_cast< ::robot::LimitParameters*>(
      ::robot::LimitParameters::internal_default_instance());
  ::robot::_Specs_default_instance_._instance.get_mutable()->simulation_limits_ = const_cast< ::robot::SimulationLimits*>(
      ::robot::SimulationLimits::internal_default_instance());
}
class Specs::_Internal {
 public:
  using HasBits = decltype(std::declval<Specs>()._has_bits_);
  static void set_has_generation(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_year(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_radius(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_height(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_mass(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_angle(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_v_max(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_omega_max(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_shot_linear_max(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_shot_chip_max(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_dribbler_width(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::robot::LimitParameters& acceleration(const Specs* msg);
  static void set_has_acceleration(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::robot::LimitParameters& strategy(const Specs* msg);
  static void set_has_strategy(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ir_param(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_shoot_radius(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_dribbler_height(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static const ::robot::SimulationLimits& simulation_limits(const Specs* msg);
  static void set_has_simulation_limits(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_can_shoot(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_can_dribble(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000038) ^ 0x00000038) != 0;
  }
};

const ::robot::LimitParameters&
Specs::_Internal::acceleration(const Specs* msg) {
  return *msg->acceleration_;
}
const ::robot::LimitParameters&
Specs::_Internal::strategy(const Specs* msg) {
  return *msg->strategy_;
}
const ::robot::SimulationLimits&
Specs::_Internal::simulation_limits(const Specs* msg) {
  return *msg->simulation_limits_;
}
Specs::Specs(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:robot.Specs)
}
Specs::Specs(const Specs& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_acceleration()) {
    acceleration_ = new ::robot::LimitParameters(*from.acceleration_);
  } else {
    acceleration_ = nullptr;
  }
  if (from._internal_has_strategy()) {
    strategy_ = new ::robot::LimitParameters(*from.strategy_);
  } else {
    strategy_ = nullptr;
  }
  if (from._internal_has_simulation_limits()) {
    simulation_limits_ = new ::robot::SimulationLimits(*from.simulation_limits_);
  } else {
    simulation_limits_ = nullptr;
  }
  ::memcpy(&generation_, &from.generation_,
    static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&generation_)) + sizeof(type_));
  // @@protoc_insertion_point(copy_constructor:robot.Specs)
}

void Specs::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Specs_robot_2eproto.base);
  ::memset(&acceleration_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&dribbler_height_) -
      reinterpret_cast<char*>(&acceleration_)) + sizeof(dribbler_height_));
  can_shoot_ = true;
  can_dribble_ = true;
  radius_ = 0.09f;
  height_ = 0.15f;
  shot_linear_max_ = 8;
  type_ = 1;
}

Specs::~Specs() {
  // @@protoc_insertion_point(destructor:robot.Specs)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Specs::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete acceleration_;
  if (this != internal_default_instance()) delete strategy_;
  if (this != internal_default_instance()) delete simulation_limits_;
}

void Specs::ArenaDtor(void* object) {
  Specs* _this = reinterpret_cast< Specs* >(object);
  (void)_this;
}
void Specs::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Specs::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Specs& Specs::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Specs_robot_2eproto.base);
  return *internal_default_instance();
}


void Specs::Clear() {
// @@protoc_insertion_point(message_clear_start:robot.Specs)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(acceleration_ != nullptr);
      acceleration_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(strategy_ != nullptr);
      strategy_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(simulation_limits_ != nullptr);
      simulation_limits_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&generation_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&angle_) -
        reinterpret_cast<char*>(&generation_)) + sizeof(angle_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&v_max_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&dribbler_height_) -
        reinterpret_cast<char*>(&v_max_)) + sizeof(dribbler_height_));
    can_shoot_ = true;
  }
  if (cached_has_bits & 0x001f0000u) {
    can_dribble_ = true;
    radius_ = 0.09f;
    height_ = 0.15f;
    shot_linear_max_ = 8;
    type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Specs::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint32 generation = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_generation(&has_bits);
          generation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 year = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_year(&has_bits);
          year_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_id(&has_bits);
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float radius = 4 [default = 0.09];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_radius(&has_bits);
          radius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float height = 5 [default = 0.15];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          _Internal::set_has_height(&has_bits);
          height_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float mass = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 53)) {
          _Internal::set_has_mass(&has_bits);
          mass_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float angle = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 61)) {
          _Internal::set_has_angle(&has_bits);
          angle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float v_max = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 69)) {
          _Internal::set_has_v_max(&has_bits);
          v_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float omega_max = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 77)) {
          _Internal::set_has_omega_max(&has_bits);
          omega_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float shot_linear_max = 10 [default = 8];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 85)) {
          _Internal::set_has_shot_linear_max(&has_bits);
          shot_linear_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float shot_chip_max = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 93)) {
          _Internal::set_has_shot_chip_max(&has_bits);
          shot_chip_max_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float dribbler_width = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 101)) {
          _Internal::set_has_dribbler_width(&has_bits);
          dribbler_width_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional .robot.LimitParameters acceleration = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_acceleration(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float ir_param = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 125)) {
          _Internal::set_has_ir_param(&has_bits);
          ir_param_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional .robot.LimitParameters strategy = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_strategy(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float shoot_radius = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 141)) {
          _Internal::set_has_shoot_radius(&has_bits);
          shoot_radius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float dribbler_height = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 149)) {
          _Internal::set_has_dribbler_height(&has_bits);
          dribbler_height_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional .robot.Specs.GenerationType type = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 152)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::robot::Specs_GenerationType_IsValid(val))) {
            _internal_set_type(static_cast<::robot::Specs_GenerationType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(19, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .robot.SimulationLimits simulation_limits = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_simulation_limits(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool can_shoot = 22 [default = true];
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 176)) {
          _Internal::set_has_can_shoot(&has_bits);
          can_shoot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool can_dribble = 23 [default = true];
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 184)) {
          _Internal::set_has_can_dribble(&has_bits);
          can_dribble_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Specs::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:robot.Specs)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 generation = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_generation(), target);
  }

  // required uint32 year = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_year(), target);
  }

  // required uint32 id = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_id(), target);
  }

  // optional float radius = 4 [default = 0.09];
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_radius(), target);
  }

  // optional float height = 5 [default = 0.15];
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_height(), target);
  }

  // optional float mass = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(6, this->_internal_mass(), target);
  }

  // optional float angle = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(7, this->_internal_angle(), target);
  }

  // optional float v_max = 8;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(8, this->_internal_v_max(), target);
  }

  // optional float omega_max = 9;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(9, this->_internal_omega_max(), target);
  }

  // optional float shot_linear_max = 10 [default = 8];
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(10, this->_internal_shot_linear_max(), target);
  }

  // optional float shot_chip_max = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(11, this->_internal_shot_chip_max(), target);
  }

  // optional float dribbler_width = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(12, this->_internal_dribbler_width(), target);
  }

  // optional .robot.LimitParameters acceleration = 13;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        13, _Internal::acceleration(this), target, stream);
  }

  // optional float ir_param = 15;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(15, this->_internal_ir_param(), target);
  }

  // optional .robot.LimitParameters strategy = 16;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        16, _Internal::strategy(this), target, stream);
  }

  // optional float shoot_radius = 17;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(17, this->_internal_shoot_radius(), target);
  }

  // optional float dribbler_height = 18;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(18, this->_internal_dribbler_height(), target);
  }

  // optional .robot.Specs.GenerationType type = 19;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      19, this->_internal_type(), target);
  }

  // optional .robot.SimulationLimits simulation_limits = 21;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        21, _Internal::simulation_limits(this), target, stream);
  }

  // optional bool can_shoot = 22 [default = true];
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(22, this->_internal_can_shoot(), target);
  }

  // optional bool can_dribble = 23 [default = true];
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(23, this->_internal_can_dribble(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robot.Specs)
  return target;
}

size_t Specs::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:robot.Specs)
  size_t total_size = 0;

  if (_internal_has_generation()) {
    // required uint32 generation = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_generation());
  }

  if (_internal_has_year()) {
    // required uint32 year = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_year());
  }

  if (_internal_has_id()) {
    // required uint32 id = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_id());
  }

  return total_size;
}
size_t Specs::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:robot.Specs)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000038) ^ 0x00000038) == 0) {  // All required fields are present.
    // required uint32 generation = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_generation());

    // required uint32 year = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_year());

    // required uint32 id = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .robot.LimitParameters acceleration = 13;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *acceleration_);
    }

    // optional .robot.LimitParameters strategy = 16;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *strategy_);
    }

    // optional .robot.SimulationLimits simulation_limits = 21;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *simulation_limits_);
    }

  }
  if (cached_has_bits & 0x000000c0u) {
    // optional float mass = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional float angle = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional float v_max = 8;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional float omega_max = 9;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 4;
    }

    // optional float shot_chip_max = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 4;
    }

    // optional float dribbler_width = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 4;
    }

    // optional float ir_param = 15;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 4;
    }

    // optional float shoot_radius = 17;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 + 4;
    }

    // optional float dribbler_height = 18;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + 4;
    }

    // optional bool can_shoot = 22 [default = true];
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0x001f0000u) {
    // optional bool can_dribble = 23 [default = true];
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 + 1;
    }

    // optional float radius = 4 [default = 0.09];
    if (cached_has_bits & 0x00020000u) {
      total_size += 1 + 4;
    }

    // optional float height = 5 [default = 0.15];
    if (cached_has_bits & 0x00040000u) {
      total_size += 1 + 4;
    }

    // optional float shot_linear_max = 10 [default = 8];
    if (cached_has_bits & 0x00080000u) {
      total_size += 1 + 4;
    }

    // optional .robot.Specs.GenerationType type = 19;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Specs::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robot.Specs)
  GOOGLE_DCHECK_NE(&from, this);
  const Specs* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Specs>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robot.Specs)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robot.Specs)
    MergeFrom(*source);
  }
}

void Specs::MergeFrom(const Specs& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robot.Specs)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_acceleration()->::robot::LimitParameters::MergeFrom(from._internal_acceleration());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_strategy()->::robot::LimitParameters::MergeFrom(from._internal_strategy());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_simulation_limits()->::robot::SimulationLimits::MergeFrom(from._internal_simulation_limits());
    }
    if (cached_has_bits & 0x00000008u) {
      generation_ = from.generation_;
    }
    if (cached_has_bits & 0x00000010u) {
      year_ = from.year_;
    }
    if (cached_has_bits & 0x00000020u) {
      id_ = from.id_;
    }
    if (cached_has_bits & 0x00000040u) {
      mass_ = from.mass_;
    }
    if (cached_has_bits & 0x00000080u) {
      angle_ = from.angle_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      v_max_ = from.v_max_;
    }
    if (cached_has_bits & 0x00000200u) {
      omega_max_ = from.omega_max_;
    }
    if (cached_has_bits & 0x00000400u) {
      shot_chip_max_ = from.shot_chip_max_;
    }
    if (cached_has_bits & 0x00000800u) {
      dribbler_width_ = from.dribbler_width_;
    }
    if (cached_has_bits & 0x00001000u) {
      ir_param_ = from.ir_param_;
    }
    if (cached_has_bits & 0x00002000u) {
      shoot_radius_ = from.shoot_radius_;
    }
    if (cached_has_bits & 0x00004000u) {
      dribbler_height_ = from.dribbler_height_;
    }
    if (cached_has_bits & 0x00008000u) {
      can_shoot_ = from.can_shoot_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x001f0000u) {
    if (cached_has_bits & 0x00010000u) {
      can_dribble_ = from.can_dribble_;
    }
    if (cached_has_bits & 0x00020000u) {
      radius_ = from.radius_;
    }
    if (cached_has_bits & 0x00040000u) {
      height_ = from.height_;
    }
    if (cached_has_bits & 0x00080000u) {
      shot_linear_max_ = from.shot_linear_max_;
    }
    if (cached_has_bits & 0x00100000u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Specs::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robot.Specs)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Specs::CopyFrom(const Specs& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robot.Specs)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Specs::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void Specs::InternalSwap(Specs* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Specs, dribbler_height_)
      + sizeof(Specs::dribbler_height_)
      - PROTOBUF_FIELD_OFFSET(Specs, acceleration_)>(
          reinterpret_cast<char*>(&acceleration_),
          reinterpret_cast<char*>(&other->acceleration_));
  swap(can_shoot_, other->can_shoot_);
  swap(can_dribble_, other->can_dribble_);
  swap(radius_, other->radius_);
  swap(height_, other->height_);
  swap(shot_linear_max_, other->shot_linear_max_);
  swap(type_, other->type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Specs::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Generation::InitAsDefaultInstance() {
  ::robot::_Generation_default_instance_._instance.get_mutable()->default__ = const_cast< ::robot::Specs*>(
      ::robot::Specs::internal_default_instance());
}
class Generation::_Internal {
 public:
  using HasBits = decltype(std::declval<Generation>()._has_bits_);
  static const ::robot::Specs& default_(const Generation* msg);
  static void set_has_default_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::robot::Specs&
Generation::_Internal::default_(const Generation* msg) {
  return *msg->default__;
}
Generation::Generation(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  robot_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:robot.Generation)
}
Generation::Generation(const Generation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      robot_(from.robot_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_default_()) {
    default__ = new ::robot::Specs(*from.default__);
  } else {
    default__ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:robot.Generation)
}

void Generation::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Generation_robot_2eproto.base);
  default__ = nullptr;
}

Generation::~Generation() {
  // @@protoc_insertion_point(destructor:robot.Generation)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Generation::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete default__;
}

void Generation::ArenaDtor(void* object) {
  Generation* _this = reinterpret_cast< Generation* >(object);
  (void)_this;
}
void Generation::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Generation::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Generation& Generation::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Generation_robot_2eproto.base);
  return *internal_default_instance();
}


void Generation::Clear() {
// @@protoc_insertion_point(message_clear_start:robot.Generation)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  robot_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(default__ != nullptr);
    default__->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Generation::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .robot.Specs default = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_default_(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .robot.Specs robot = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_robot(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Generation::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:robot.Generation)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .robot.Specs default = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::default_(this), target, stream);
  }

  // repeated .robot.Specs robot = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_robot_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_robot(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robot.Generation)
  return target;
}

size_t Generation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:robot.Generation)
  size_t total_size = 0;

  // required .robot.Specs default = 1;
  if (_internal_has_default_()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *default__);
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .robot.Specs robot = 2;
  total_size += 1UL * this->_internal_robot_size();
  for (const auto& msg : this->robot_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Generation::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robot.Generation)
  GOOGLE_DCHECK_NE(&from, this);
  const Generation* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Generation>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robot.Generation)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robot.Generation)
    MergeFrom(*source);
  }
}

void Generation::MergeFrom(const Generation& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robot.Generation)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  robot_.MergeFrom(from.robot_);
  if (from._internal_has_default_()) {
    _internal_mutable_default_()->::robot::Specs::MergeFrom(from._internal_default_());
  }
}

void Generation::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robot.Generation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Generation::CopyFrom(const Generation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robot.Generation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Generation::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(robot_)) return false;
  if (_internal_has_default_()) {
    if (!default__->IsInitialized()) return false;
  }
  return true;
}

void Generation::InternalSwap(Generation* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  robot_.InternalSwap(&other->robot_);
  swap(default__, other->default__);
}

::PROTOBUF_NAMESPACE_ID::Metadata Generation::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Team::InitAsDefaultInstance() {
}
class Team::_Internal {
 public:
};

Team::Team(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  robot_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:robot.Team)
}
Team::Team(const Team& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      robot_(from.robot_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:robot.Team)
}

void Team::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Team_robot_2eproto.base);
}

Team::~Team() {
  // @@protoc_insertion_point(destructor:robot.Team)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Team::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void Team::ArenaDtor(void* object) {
  Team* _this = reinterpret_cast< Team* >(object);
  (void)_this;
}
void Team::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Team::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Team& Team::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Team_robot_2eproto.base);
  return *internal_default_instance();
}


void Team::Clear() {
// @@protoc_insertion_point(message_clear_start:robot.Team)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  robot_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Team::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .robot.Specs robot = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_robot(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Team::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:robot.Team)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .robot.Specs robot = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_robot_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_robot(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robot.Team)
  return target;
}

size_t Team::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:robot.Team)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .robot.Specs robot = 1;
  total_size += 1UL * this->_internal_robot_size();
  for (const auto& msg : this->robot_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Team::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robot.Team)
  GOOGLE_DCHECK_NE(&from, this);
  const Team* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Team>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robot.Team)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robot.Team)
    MergeFrom(*source);
  }
}

void Team::MergeFrom(const Team& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robot.Team)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  robot_.MergeFrom(from.robot_);
}

void Team::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robot.Team)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Team::CopyFrom(const Team& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robot.Team)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Team::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(robot_)) return false;
  return true;
}

void Team::InternalSwap(Team* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  robot_.InternalSwap(&other->robot_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Team::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Polynomial::InitAsDefaultInstance() {
}
class Polynomial::_Internal {
 public:
  using HasBits = decltype(std::declval<Polynomial>()._has_bits_);
  static void set_has_a0(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_a1(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_a2(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_a3(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

Polynomial::Polynomial(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:robot.Polynomial)
}
Polynomial::Polynomial(const Polynomial& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&a0_, &from.a0_,
    static_cast<size_t>(reinterpret_cast<char*>(&a3_) -
    reinterpret_cast<char*>(&a0_)) + sizeof(a3_));
  // @@protoc_insertion_point(copy_constructor:robot.Polynomial)
}

void Polynomial::SharedCtor() {
  ::memset(&a0_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&a3_) -
      reinterpret_cast<char*>(&a0_)) + sizeof(a3_));
}

Polynomial::~Polynomial() {
  // @@protoc_insertion_point(destructor:robot.Polynomial)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Polynomial::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void Polynomial::ArenaDtor(void* object) {
  Polynomial* _this = reinterpret_cast< Polynomial* >(object);
  (void)_this;
}
void Polynomial::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Polynomial::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Polynomial& Polynomial::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Polynomial_robot_2eproto.base);
  return *internal_default_instance();
}


void Polynomial::Clear() {
// @@protoc_insertion_point(message_clear_start:robot.Polynomial)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&a0_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&a3_) -
        reinterpret_cast<char*>(&a0_)) + sizeof(a3_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Polynomial::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required float a0 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_a0(&has_bits);
          a0_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required float a1 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_a1(&has_bits);
          a1_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required float a2 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_a2(&has_bits);
          a2_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required float a3 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_a3(&has_bits);
          a3_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Polynomial::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:robot.Polynomial)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required float a0 = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_a0(), target);
  }

  // required float a1 = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_a1(), target);
  }

  // required float a2 = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_a2(), target);
  }

  // required float a3 = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_a3(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robot.Polynomial)
  return target;
}

size_t Polynomial::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:robot.Polynomial)
  size_t total_size = 0;

  if (_internal_has_a0()) {
    // required float a0 = 1;
    total_size += 1 + 4;
  }

  if (_internal_has_a1()) {
    // required float a1 = 2;
    total_size += 1 + 4;
  }

  if (_internal_has_a2()) {
    // required float a2 = 3;
    total_size += 1 + 4;
  }

  if (_internal_has_a3()) {
    // required float a3 = 4;
    total_size += 1 + 4;
  }

  return total_size;
}
size_t Polynomial::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:robot.Polynomial)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required float a0 = 1;
    total_size += 1 + 4;

    // required float a1 = 2;
    total_size += 1 + 4;

    // required float a2 = 3;
    total_size += 1 + 4;

    // required float a3 = 4;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Polynomial::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robot.Polynomial)
  GOOGLE_DCHECK_NE(&from, this);
  const Polynomial* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Polynomial>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robot.Polynomial)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robot.Polynomial)
    MergeFrom(*source);
  }
}

void Polynomial::MergeFrom(const Polynomial& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robot.Polynomial)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      a0_ = from.a0_;
    }
    if (cached_has_bits & 0x00000002u) {
      a1_ = from.a1_;
    }
    if (cached_has_bits & 0x00000004u) {
      a2_ = from.a2_;
    }
    if (cached_has_bits & 0x00000008u) {
      a3_ = from.a3_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Polynomial::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robot.Polynomial)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Polynomial::CopyFrom(const Polynomial& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robot.Polynomial)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Polynomial::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void Polynomial::InternalSwap(Polynomial* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Polynomial, a3_)
      + sizeof(Polynomial::a3_)
      - PROTOBUF_FIELD_OFFSET(Polynomial, a0_)>(
          reinterpret_cast<char*>(&a0_),
          reinterpret_cast<char*>(&other->a0_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Polynomial::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Spline::InitAsDefaultInstance() {
  ::robot::_Spline_default_instance_._instance.get_mutable()->x_ = const_cast< ::robot::Polynomial*>(
      ::robot::Polynomial::internal_default_instance());
  ::robot::_Spline_default_instance_._instance.get_mutable()->y_ = const_cast< ::robot::Polynomial*>(
      ::robot::Polynomial::internal_default_instance());
  ::robot::_Spline_default_instance_._instance.get_mutable()->phi_ = const_cast< ::robot::Polynomial*>(
      ::robot::Polynomial::internal_default_instance());
}
class Spline::_Internal {
 public:
  using HasBits = decltype(std::declval<Spline>()._has_bits_);
  static void set_has_t_start(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_t_end(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::robot::Polynomial& x(const Spline* msg);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::robot::Polynomial& y(const Spline* msg);
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::robot::Polynomial& phi(const Spline* msg);
  static void set_has_phi(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

const ::robot::Polynomial&
Spline::_Internal::x(const Spline* msg) {
  return *msg->x_;
}
const ::robot::Polynomial&
Spline::_Internal::y(const Spline* msg) {
  return *msg->y_;
}
const ::robot::Polynomial&
Spline::_Internal::phi(const Spline* msg) {
  return *msg->phi_;
}
Spline::Spline(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:robot.Spline)
}
Spline::Spline(const Spline& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_x()) {
    x_ = new ::robot::Polynomial(*from.x_);
  } else {
    x_ = nullptr;
  }
  if (from._internal_has_y()) {
    y_ = new ::robot::Polynomial(*from.y_);
  } else {
    y_ = nullptr;
  }
  if (from._internal_has_phi()) {
    phi_ = new ::robot::Polynomial(*from.phi_);
  } else {
    phi_ = nullptr;
  }
  ::memcpy(&t_start_, &from.t_start_,
    static_cast<size_t>(reinterpret_cast<char*>(&t_end_) -
    reinterpret_cast<char*>(&t_start_)) + sizeof(t_end_));
  // @@protoc_insertion_point(copy_constructor:robot.Spline)
}

void Spline::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Spline_robot_2eproto.base);
  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&t_end_) -
      reinterpret_cast<char*>(&x_)) + sizeof(t_end_));
}

Spline::~Spline() {
  // @@protoc_insertion_point(destructor:robot.Spline)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Spline::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete x_;
  if (this != internal_default_instance()) delete y_;
  if (this != internal_default_instance()) delete phi_;
}

void Spline::ArenaDtor(void* object) {
  Spline* _this = reinterpret_cast< Spline* >(object);
  (void)_this;
}
void Spline::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Spline::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Spline& Spline::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Spline_robot_2eproto.base);
  return *internal_default_instance();
}


void Spline::Clear() {
// @@protoc_insertion_point(message_clear_start:robot.Spline)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(x_ != nullptr);
      x_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(y_ != nullptr);
      y_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(phi_ != nullptr);
      phi_->Clear();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&t_start_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&t_end_) -
        reinterpret_cast<char*>(&t_start_)) + sizeof(t_end_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Spline::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required float t_start = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_t_start(&has_bits);
          t_start_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required float t_end = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_t_end(&has_bits);
          t_end_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required .robot.Polynomial x = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_x(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .robot.Polynomial y = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_y(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .robot.Polynomial phi = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_phi(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Spline::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:robot.Spline)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required float t_start = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_t_start(), target);
  }

  // required float t_end = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_t_end(), target);
  }

  // required .robot.Polynomial x = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::x(this), target, stream);
  }

  // required .robot.Polynomial y = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::y(this), target, stream);
  }

  // required .robot.Polynomial phi = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::phi(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robot.Spline)
  return target;
}

size_t Spline::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:robot.Spline)
  size_t total_size = 0;

  if (_internal_has_x()) {
    // required .robot.Polynomial x = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *x_);
  }

  if (_internal_has_y()) {
    // required .robot.Polynomial y = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *y_);
  }

  if (_internal_has_phi()) {
    // required .robot.Polynomial phi = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *phi_);
  }

  if (_internal_has_t_start()) {
    // required float t_start = 1;
    total_size += 1 + 4;
  }

  if (_internal_has_t_end()) {
    // required float t_end = 2;
    total_size += 1 + 4;
  }

  return total_size;
}
size_t Spline::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:robot.Spline)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required .robot.Polynomial x = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *x_);

    // required .robot.Polynomial y = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *y_);

    // required .robot.Polynomial phi = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *phi_);

    // required float t_start = 1;
    total_size += 1 + 4;

    // required float t_end = 2;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Spline::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robot.Spline)
  GOOGLE_DCHECK_NE(&from, this);
  const Spline* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Spline>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robot.Spline)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robot.Spline)
    MergeFrom(*source);
  }
}

void Spline::MergeFrom(const Spline& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robot.Spline)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_x()->::robot::Polynomial::MergeFrom(from._internal_x());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_y()->::robot::Polynomial::MergeFrom(from._internal_y());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_phi()->::robot::Polynomial::MergeFrom(from._internal_phi());
    }
    if (cached_has_bits & 0x00000008u) {
      t_start_ = from.t_start_;
    }
    if (cached_has_bits & 0x00000010u) {
      t_end_ = from.t_end_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Spline::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robot.Spline)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Spline::CopyFrom(const Spline& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robot.Spline)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Spline::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_x()) {
    if (!x_->IsInitialized()) return false;
  }
  if (_internal_has_y()) {
    if (!y_->IsInitialized()) return false;
  }
  if (_internal_has_phi()) {
    if (!phi_->IsInitialized()) return false;
  }
  return true;
}

void Spline::InternalSwap(Spline* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Spline, t_end_)
      + sizeof(Spline::t_end_)
      - PROTOBUF_FIELD_OFFSET(Spline, x_)>(
          reinterpret_cast<char*>(&x_),
          reinterpret_cast<char*>(&other->x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Spline::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void ControllerInput::InitAsDefaultInstance() {
}
class ControllerInput::_Internal {
 public:
};

ControllerInput::ControllerInput(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  spline_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:robot.ControllerInput)
}
ControllerInput::ControllerInput(const ControllerInput& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      spline_(from.spline_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:robot.ControllerInput)
}

void ControllerInput::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ControllerInput_robot_2eproto.base);
}

ControllerInput::~ControllerInput() {
  // @@protoc_insertion_point(destructor:robot.ControllerInput)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void ControllerInput::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void ControllerInput::ArenaDtor(void* object) {
  ControllerInput* _this = reinterpret_cast< ControllerInput* >(object);
  (void)_this;
}
void ControllerInput::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ControllerInput::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ControllerInput& ControllerInput::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ControllerInput_robot_2eproto.base);
  return *internal_default_instance();
}


void ControllerInput::Clear() {
// @@protoc_insertion_point(message_clear_start:robot.ControllerInput)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  spline_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ControllerInput::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .robot.Spline spline = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_spline(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ControllerInput::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:robot.ControllerInput)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .robot.Spline spline = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_spline_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_spline(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robot.ControllerInput)
  return target;
}

size_t ControllerInput::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:robot.ControllerInput)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .robot.Spline spline = 1;
  total_size += 1UL * this->_internal_spline_size();
  for (const auto& msg : this->spline_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ControllerInput::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robot.ControllerInput)
  GOOGLE_DCHECK_NE(&from, this);
  const ControllerInput* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ControllerInput>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robot.ControllerInput)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robot.ControllerInput)
    MergeFrom(*source);
  }
}

void ControllerInput::MergeFrom(const ControllerInput& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robot.ControllerInput)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  spline_.MergeFrom(from.spline_);
}

void ControllerInput::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robot.ControllerInput)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ControllerInput::CopyFrom(const ControllerInput& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robot.ControllerInput)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ControllerInput::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(spline_)) return false;
  return true;
}

void ControllerInput::InternalSwap(ControllerInput* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  spline_.InternalSwap(&other->spline_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ControllerInput::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void SpeedVector::InitAsDefaultInstance() {
}
class SpeedVector::_Internal {
 public:
  using HasBits = decltype(std::declval<SpeedVector>()._has_bits_);
  static void set_has_v_s(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_v_f(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_omega(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

SpeedVector::SpeedVector(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:robot.SpeedVector)
}
SpeedVector::SpeedVector(const SpeedVector& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&v_s_, &from.v_s_,
    static_cast<size_t>(reinterpret_cast<char*>(&omega_) -
    reinterpret_cast<char*>(&v_s_)) + sizeof(omega_));
  // @@protoc_insertion_point(copy_constructor:robot.SpeedVector)
}

void SpeedVector::SharedCtor() {
  ::memset(&v_s_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&omega_) -
      reinterpret_cast<char*>(&v_s_)) + sizeof(omega_));
}

SpeedVector::~SpeedVector() {
  // @@protoc_insertion_point(destructor:robot.SpeedVector)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void SpeedVector::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void SpeedVector::ArenaDtor(void* object) {
  SpeedVector* _this = reinterpret_cast< SpeedVector* >(object);
  (void)_this;
}
void SpeedVector::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SpeedVector::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SpeedVector& SpeedVector::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_SpeedVector_robot_2eproto.base);
  return *internal_default_instance();
}


void SpeedVector::Clear() {
// @@protoc_insertion_point(message_clear_start:robot.SpeedVector)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&v_s_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&omega_) -
        reinterpret_cast<char*>(&v_s_)) + sizeof(omega_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SpeedVector::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional float v_s = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_v_s(&has_bits);
          v_s_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float v_f = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_v_f(&has_bits);
          v_f_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float omega = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_omega(&has_bits);
          omega_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SpeedVector::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:robot.SpeedVector)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float v_s = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_v_s(), target);
  }

  // optional float v_f = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_v_f(), target);
  }

  // optional float omega = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_omega(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robot.SpeedVector)
  return target;
}

size_t SpeedVector::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:robot.SpeedVector)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional float v_s = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float v_f = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float omega = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SpeedVector::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robot.SpeedVector)
  GOOGLE_DCHECK_NE(&from, this);
  const SpeedVector* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<SpeedVector>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robot.SpeedVector)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robot.SpeedVector)
    MergeFrom(*source);
  }
}

void SpeedVector::MergeFrom(const SpeedVector& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robot.SpeedVector)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      v_s_ = from.v_s_;
    }
    if (cached_has_bits & 0x00000002u) {
      v_f_ = from.v_f_;
    }
    if (cached_has_bits & 0x00000004u) {
      omega_ = from.omega_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SpeedVector::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robot.SpeedVector)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SpeedVector::CopyFrom(const SpeedVector& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robot.SpeedVector)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpeedVector::IsInitialized() const {
  return true;
}

void SpeedVector::InternalSwap(SpeedVector* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SpeedVector, omega_)
      + sizeof(SpeedVector::omega_)
      - PROTOBUF_FIELD_OFFSET(SpeedVector, v_s_)>(
          reinterpret_cast<char*>(&v_s_),
          reinterpret_cast<char*>(&other->v_s_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SpeedVector::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Command::InitAsDefaultInstance() {
  ::robot::_Command_default_instance_._instance.get_mutable()->controller_ = const_cast< ::robot::ControllerInput*>(
      ::robot::ControllerInput::internal_default_instance());
  ::robot::_Command_default_instance_._instance.get_mutable()->output0_ = const_cast< ::robot::SpeedVector*>(
      ::robot::SpeedVector::internal_default_instance());
  ::robot::_Command_default_instance_._instance.get_mutable()->output1_ = const_cast< ::robot::SpeedVector*>(
      ::robot::SpeedVector::internal_default_instance());
  ::robot::_Command_default_instance_._instance.get_mutable()->output2_ = const_cast< ::robot::SpeedVector*>(
      ::robot::SpeedVector::internal_default_instance());
}
class Command::_Internal {
 public:
  using HasBits = decltype(std::declval<Command>()._has_bits_);
  static const ::robot::ControllerInput& controller(const Command* msg);
  static void set_has_controller(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_v_f(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_v_s(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_omega(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_kick_style(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_kick_power(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_dribbler(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_local(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_standby(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_strategy_controlled(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_force_kick(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_network_controlled(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_eject_sdcard(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_cur_v_f(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_cur_v_s(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_cur_omega(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static const ::robot::SpeedVector& output0(const Command* msg);
  static void set_has_output0(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::robot::SpeedVector& output1(const Command* msg);
  static void set_has_output1(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::robot::SpeedVector& output2(const Command* msg);
  static void set_has_output2(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::robot::ControllerInput&
Command::_Internal::controller(const Command* msg) {
  return *msg->controller_;
}
const ::robot::SpeedVector&
Command::_Internal::output0(const Command* msg) {
  return *msg->output0_;
}
const ::robot::SpeedVector&
Command::_Internal::output1(const Command* msg) {
  return *msg->output1_;
}
const ::robot::SpeedVector&
Command::_Internal::output2(const Command* msg) {
  return *msg->output2_;
}
Command::Command(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:robot.Command)
}
Command::Command(const Command& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_controller()) {
    controller_ = new ::robot::ControllerInput(*from.controller_);
  } else {
    controller_ = nullptr;
  }
  if (from._internal_has_output0()) {
    output0_ = new ::robot::SpeedVector(*from.output0_);
  } else {
    output0_ = nullptr;
  }
  if (from._internal_has_output1()) {
    output1_ = new ::robot::SpeedVector(*from.output1_);
  } else {
    output1_ = nullptr;
  }
  if (from._internal_has_output2()) {
    output2_ = new ::robot::SpeedVector(*from.output2_);
  } else {
    output2_ = nullptr;
  }
  ::memcpy(&v_f_, &from.v_f_,
    static_cast<size_t>(reinterpret_cast<char*>(&kick_style_) -
    reinterpret_cast<char*>(&v_f_)) + sizeof(kick_style_));
  // @@protoc_insertion_point(copy_constructor:robot.Command)
}

void Command::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Command_robot_2eproto.base);
  ::memset(&controller_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&cur_omega_) -
      reinterpret_cast<char*>(&controller_)) + sizeof(cur_omega_));
  kick_style_ = 1;
}

Command::~Command() {
  // @@protoc_insertion_point(destructor:robot.Command)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Command::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete controller_;
  if (this != internal_default_instance()) delete output0_;
  if (this != internal_default_instance()) delete output1_;
  if (this != internal_default_instance()) delete output2_;
}

void Command::ArenaDtor(void* object) {
  Command* _this = reinterpret_cast< Command* >(object);
  (void)_this;
}
void Command::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Command::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Command& Command::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Command_robot_2eproto.base);
  return *internal_default_instance();
}


void Command::Clear() {
// @@protoc_insertion_point(message_clear_start:robot.Command)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(controller_ != nullptr);
      controller_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(output0_ != nullptr);
      output0_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(output1_ != nullptr);
      output1_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(output2_ != nullptr);
      output2_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&v_f_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&kick_power_) -
        reinterpret_cast<char*>(&v_f_)) + sizeof(kick_power_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&dribbler_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&cur_v_f_) -
        reinterpret_cast<char*>(&dribbler_)) + sizeof(cur_v_f_));
  }
  if (cached_has_bits & 0x00070000u) {
    ::memset(&cur_v_s_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&cur_omega_) -
        reinterpret_cast<char*>(&cur_v_s_)) + sizeof(cur_omega_));
    kick_style_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Command::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .robot.ControllerInput controller = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_controller(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float v_f = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_v_f(&has_bits);
          v_f_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float v_s = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_v_s(&has_bits);
          v_s_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float omega = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_omega(&has_bits);
          omega_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional .robot.Command.KickStyle kick_style = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::robot::Command_KickStyle_IsValid(val))) {
            _internal_set_kick_style(static_cast<::robot::Command_KickStyle>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional float kick_power = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 53)) {
          _Internal::set_has_kick_power(&has_bits);
          kick_power_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float dribbler = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 61)) {
          _Internal::set_has_dribbler(&has_bits);
          dribbler_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional bool local = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_local(&has_bits);
          local_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool standby = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_standby(&has_bits);
          standby_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool strategy_controlled = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          _Internal::set_has_strategy_controlled(&has_bits);
          strategy_controlled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool force_kick = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 112)) {
          _Internal::set_has_force_kick(&has_bits);
          force_kick_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool network_controlled = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 120)) {
          _Internal::set_has_network_controlled(&has_bits);
          network_controlled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool eject_sdcard = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 128)) {
          _Internal::set_has_eject_sdcard(&has_bits);
          eject_sdcard_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float cur_v_f = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 141)) {
          _Internal::set_has_cur_v_f(&has_bits);
          cur_v_f_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float cur_v_s = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 149)) {
          _Internal::set_has_cur_v_s(&has_bits);
          cur_v_s_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float cur_omega = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 157)) {
          _Internal::set_has_cur_omega(&has_bits);
          cur_omega_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional .robot.SpeedVector output0 = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_output0(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .robot.SpeedVector output1 = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_output1(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .robot.SpeedVector output2 = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_output2(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Command::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:robot.Command)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .robot.ControllerInput controller = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::controller(this), target, stream);
  }

  // optional float v_f = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_v_f(), target);
  }

  // optional float v_s = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_v_s(), target);
  }

  // optional float omega = 4;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_omega(), target);
  }

  // optional .robot.Command.KickStyle kick_style = 5;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      5, this->_internal_kick_style(), target);
  }

  // optional float kick_power = 6;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(6, this->_internal_kick_power(), target);
  }

  // optional float dribbler = 7;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(7, this->_internal_dribbler(), target);
  }

  // optional bool local = 8;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->_internal_local(), target);
  }

  // optional bool standby = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(11, this->_internal_standby(), target);
  }

  // optional bool strategy_controlled = 13;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(13, this->_internal_strategy_controlled(), target);
  }

  // optional bool force_kick = 14;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(14, this->_internal_force_kick(), target);
  }

  // optional bool network_controlled = 15;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(15, this->_internal_network_controlled(), target);
  }

  // optional bool eject_sdcard = 16;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(16, this->_internal_eject_sdcard(), target);
  }

  // optional float cur_v_f = 17;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(17, this->_internal_cur_v_f(), target);
  }

  // optional float cur_v_s = 18;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(18, this->_internal_cur_v_s(), target);
  }

  // optional float cur_omega = 19;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(19, this->_internal_cur_omega(), target);
  }

  // optional .robot.SpeedVector output0 = 20;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        20, _Internal::output0(this), target, stream);
  }

  // optional .robot.SpeedVector output1 = 21;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        21, _Internal::output1(this), target, stream);
  }

  // optional .robot.SpeedVector output2 = 22;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        22, _Internal::output2(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robot.Command)
  return target;
}

size_t Command::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:robot.Command)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .robot.ControllerInput controller = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *controller_);
    }

    // optional .robot.SpeedVector output0 = 20;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *output0_);
    }

    // optional .robot.SpeedVector output1 = 21;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *output1_);
    }

    // optional .robot.SpeedVector output2 = 22;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *output2_);
    }

    // optional float v_f = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float v_s = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float omega = 4;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional float kick_power = 6;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional float dribbler = 7;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional bool local = 8;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool standby = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional bool strategy_controlled = 13;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

    // optional bool force_kick = 14;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

    // optional bool network_controlled = 15;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 1;
    }

    // optional bool eject_sdcard = 16;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + 1;
    }

    // optional float cur_v_f = 17;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 4;
    }

  }
  if (cached_has_bits & 0x00070000u) {
    // optional float cur_v_s = 18;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 + 4;
    }

    // optional float cur_omega = 19;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 4;
    }

    // optional .robot.Command.KickStyle kick_style = 5;
    if (cached_has_bits & 0x00040000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_kick_style());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Command::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robot.Command)
  GOOGLE_DCHECK_NE(&from, this);
  const Command* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Command>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robot.Command)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robot.Command)
    MergeFrom(*source);
  }
}

void Command::MergeFrom(const Command& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robot.Command)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_controller()->::robot::ControllerInput::MergeFrom(from._internal_controller());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_output0()->::robot::SpeedVector::MergeFrom(from._internal_output0());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_output1()->::robot::SpeedVector::MergeFrom(from._internal_output1());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_output2()->::robot::SpeedVector::MergeFrom(from._internal_output2());
    }
    if (cached_has_bits & 0x00000010u) {
      v_f_ = from.v_f_;
    }
    if (cached_has_bits & 0x00000020u) {
      v_s_ = from.v_s_;
    }
    if (cached_has_bits & 0x00000040u) {
      omega_ = from.omega_;
    }
    if (cached_has_bits & 0x00000080u) {
      kick_power_ = from.kick_power_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      dribbler_ = from.dribbler_;
    }
    if (cached_has_bits & 0x00000200u) {
      local_ = from.local_;
    }
    if (cached_has_bits & 0x00000400u) {
      standby_ = from.standby_;
    }
    if (cached_has_bits & 0x00000800u) {
      strategy_controlled_ = from.strategy_controlled_;
    }
    if (cached_has_bits & 0x00001000u) {
      force_kick_ = from.force_kick_;
    }
    if (cached_has_bits & 0x00002000u) {
      network_controlled_ = from.network_controlled_;
    }
    if (cached_has_bits & 0x00004000u) {
      eject_sdcard_ = from.eject_sdcard_;
    }
    if (cached_has_bits & 0x00008000u) {
      cur_v_f_ = from.cur_v_f_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00070000u) {
    if (cached_has_bits & 0x00010000u) {
      cur_v_s_ = from.cur_v_s_;
    }
    if (cached_has_bits & 0x00020000u) {
      cur_omega_ = from.cur_omega_;
    }
    if (cached_has_bits & 0x00040000u) {
      kick_style_ = from.kick_style_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Command::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robot.Command)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Command::CopyFrom(const Command& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robot.Command)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Command::IsInitialized() const {
  if (_internal_has_controller()) {
    if (!controller_->IsInitialized()) return false;
  }
  return true;
}

void Command::InternalSwap(Command* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Command, cur_omega_)
      + sizeof(Command::cur_omega_)
      - PROTOBUF_FIELD_OFFSET(Command, controller_)>(
          reinterpret_cast<char*>(&controller_),
          reinterpret_cast<char*>(&other->controller_));
  swap(kick_style_, other->kick_style_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Command::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void RadioCommand::InitAsDefaultInstance() {
  ::robot::_RadioCommand_default_instance_._instance.get_mutable()->command_ = const_cast< ::robot::Command*>(
      ::robot::Command::internal_default_instance());
}
class RadioCommand::_Internal {
 public:
  using HasBits = decltype(std::declval<RadioCommand>()._has_bits_);
  static void set_has_generation(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_is_blue(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::robot::Command& command(const RadioCommand* msg);
  static void set_has_command(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_command_time(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::robot::Command&
RadioCommand::_Internal::command(const RadioCommand* msg) {
  return *msg->command_;
}
RadioCommand::RadioCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:robot.RadioCommand)
}
RadioCommand::RadioCommand(const RadioCommand& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_command()) {
    command_ = new ::robot::Command(*from.command_);
  } else {
    command_ = nullptr;
  }
  ::memcpy(&generation_, &from.generation_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_blue_) -
    reinterpret_cast<char*>(&generation_)) + sizeof(is_blue_));
  // @@protoc_insertion_point(copy_constructor:robot.RadioCommand)
}

void RadioCommand::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_RadioCommand_robot_2eproto.base);
  ::memset(&command_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&is_blue_) -
      reinterpret_cast<char*>(&command_)) + sizeof(is_blue_));
}

RadioCommand::~RadioCommand() {
  // @@protoc_insertion_point(destructor:robot.RadioCommand)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void RadioCommand::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete command_;
}

void RadioCommand::ArenaDtor(void* object) {
  RadioCommand* _this = reinterpret_cast< RadioCommand* >(object);
  (void)_this;
}
void RadioCommand::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RadioCommand::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const RadioCommand& RadioCommand::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_RadioCommand_robot_2eproto.base);
  return *internal_default_instance();
}


void RadioCommand::Clear() {
// @@protoc_insertion_point(message_clear_start:robot.RadioCommand)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(command_ != nullptr);
    command_->Clear();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&generation_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_blue_) -
        reinterpret_cast<char*>(&generation_)) + sizeof(is_blue_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RadioCommand::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint32 generation = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_generation(&has_bits);
          generation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_id(&has_bits);
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .robot.Command command = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_command(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool is_blue = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_is_blue(&has_bits);
          is_blue_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 command_time = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_command_time(&has_bits);
          command_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* RadioCommand::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:robot.RadioCommand)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 generation = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_generation(), target);
  }

  // required uint32 id = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_id(), target);
  }

  // required .robot.Command command = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::command(this), target, stream);
  }

  // optional bool is_blue = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_is_blue(), target);
  }

  // optional int64 command_time = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(5, this->_internal_command_time(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robot.RadioCommand)
  return target;
}

size_t RadioCommand::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:robot.RadioCommand)
  size_t total_size = 0;

  if (_internal_has_command()) {
    // required .robot.Command command = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *command_);
  }

  if (_internal_has_generation()) {
    // required uint32 generation = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_generation());
  }

  if (_internal_has_id()) {
    // required uint32 id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_id());
  }

  return total_size;
}
size_t RadioCommand::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:robot.RadioCommand)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .robot.Command command = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *command_);

    // required uint32 generation = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_generation());

    // required uint32 id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000018u) {
    // optional int64 command_time = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_command_time());
    }

    // optional bool is_blue = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RadioCommand::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robot.RadioCommand)
  GOOGLE_DCHECK_NE(&from, this);
  const RadioCommand* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<RadioCommand>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robot.RadioCommand)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robot.RadioCommand)
    MergeFrom(*source);
  }
}

void RadioCommand::MergeFrom(const RadioCommand& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robot.RadioCommand)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_command()->::robot::Command::MergeFrom(from._internal_command());
    }
    if (cached_has_bits & 0x00000002u) {
      generation_ = from.generation_;
    }
    if (cached_has_bits & 0x00000004u) {
      id_ = from.id_;
    }
    if (cached_has_bits & 0x00000008u) {
      command_time_ = from.command_time_;
    }
    if (cached_has_bits & 0x00000010u) {
      is_blue_ = from.is_blue_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void RadioCommand::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robot.RadioCommand)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RadioCommand::CopyFrom(const RadioCommand& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robot.RadioCommand)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RadioCommand::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_command()) {
    if (!command_->IsInitialized()) return false;
  }
  return true;
}

void RadioCommand::InternalSwap(RadioCommand* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RadioCommand, is_blue_)
      + sizeof(RadioCommand::is_blue_)
      - PROTOBUF_FIELD_OFFSET(RadioCommand, command_)>(
          reinterpret_cast<char*>(&command_),
          reinterpret_cast<char*>(&other->command_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RadioCommand::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void SpeedStatus::InitAsDefaultInstance() {
}
class SpeedStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<SpeedStatus>()._has_bits_);
  static void set_has_v_f(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_v_s(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_omega(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

SpeedStatus::SpeedStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:robot.SpeedStatus)
}
SpeedStatus::SpeedStatus(const SpeedStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&v_f_, &from.v_f_,
    static_cast<size_t>(reinterpret_cast<char*>(&omega_) -
    reinterpret_cast<char*>(&v_f_)) + sizeof(omega_));
  // @@protoc_insertion_point(copy_constructor:robot.SpeedStatus)
}

void SpeedStatus::SharedCtor() {
  ::memset(&v_f_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&omega_) -
      reinterpret_cast<char*>(&v_f_)) + sizeof(omega_));
}

SpeedStatus::~SpeedStatus() {
  // @@protoc_insertion_point(destructor:robot.SpeedStatus)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void SpeedStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void SpeedStatus::ArenaDtor(void* object) {
  SpeedStatus* _this = reinterpret_cast< SpeedStatus* >(object);
  (void)_this;
}
void SpeedStatus::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SpeedStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SpeedStatus& SpeedStatus::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_SpeedStatus_robot_2eproto.base);
  return *internal_default_instance();
}


void SpeedStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:robot.SpeedStatus)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&v_f_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&omega_) -
        reinterpret_cast<char*>(&v_f_)) + sizeof(omega_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SpeedStatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required float v_f = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_v_f(&has_bits);
          v_f_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required float v_s = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_v_s(&has_bits);
          v_s_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required float omega = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_omega(&has_bits);
          omega_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SpeedStatus::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:robot.SpeedStatus)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required float v_f = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_v_f(), target);
  }

  // required float v_s = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_v_s(), target);
  }

  // required float omega = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_omega(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robot.SpeedStatus)
  return target;
}

size_t SpeedStatus::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:robot.SpeedStatus)
  size_t total_size = 0;

  if (_internal_has_v_f()) {
    // required float v_f = 1;
    total_size += 1 + 4;
  }

  if (_internal_has_v_s()) {
    // required float v_s = 2;
    total_size += 1 + 4;
  }

  if (_internal_has_omega()) {
    // required float omega = 3;
    total_size += 1 + 4;
  }

  return total_size;
}
size_t SpeedStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:robot.SpeedStatus)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required float v_f = 1;
    total_size += 1 + 4;

    // required float v_s = 2;
    total_size += 1 + 4;

    // required float omega = 3;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SpeedStatus::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robot.SpeedStatus)
  GOOGLE_DCHECK_NE(&from, this);
  const SpeedStatus* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<SpeedStatus>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robot.SpeedStatus)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robot.SpeedStatus)
    MergeFrom(*source);
  }
}

void SpeedStatus::MergeFrom(const SpeedStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robot.SpeedStatus)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      v_f_ = from.v_f_;
    }
    if (cached_has_bits & 0x00000002u) {
      v_s_ = from.v_s_;
    }
    if (cached_has_bits & 0x00000004u) {
      omega_ = from.omega_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SpeedStatus::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robot.SpeedStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SpeedStatus::CopyFrom(const SpeedStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robot.SpeedStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpeedStatus::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void SpeedStatus::InternalSwap(SpeedStatus* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SpeedStatus, omega_)
      + sizeof(SpeedStatus::omega_)
      - PROTOBUF_FIELD_OFFSET(SpeedStatus, v_f_)>(
          reinterpret_cast<char*>(&v_f_),
          reinterpret_cast<char*>(&other->v_f_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SpeedStatus::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void ExtendedError::InitAsDefaultInstance() {
}
class ExtendedError::_Internal {
 public:
  using HasBits = decltype(std::declval<ExtendedError>()._has_bits_);
  static void set_has_motor_1_error(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_motor_2_error(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_motor_3_error(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_motor_4_error(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_dribbler_error(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_kicker_error(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_kicker_break_beam_error(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_motor_encoder_error(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_main_sensor_error(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_temperature(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000006f) ^ 0x0000006f) != 0;
  }
};

ExtendedError::ExtendedError(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:robot.ExtendedError)
}
ExtendedError::ExtendedError(const ExtendedError& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&motor_1_error_, &from.motor_1_error_,
    static_cast<size_t>(reinterpret_cast<char*>(&main_sensor_error_) -
    reinterpret_cast<char*>(&motor_1_error_)) + sizeof(main_sensor_error_));
  // @@protoc_insertion_point(copy_constructor:robot.ExtendedError)
}

void ExtendedError::SharedCtor() {
  ::memset(&motor_1_error_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&main_sensor_error_) -
      reinterpret_cast<char*>(&motor_1_error_)) + sizeof(main_sensor_error_));
}

ExtendedError::~ExtendedError() {
  // @@protoc_insertion_point(destructor:robot.ExtendedError)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void ExtendedError::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void ExtendedError::ArenaDtor(void* object) {
  ExtendedError* _this = reinterpret_cast< ExtendedError* >(object);
  (void)_this;
}
void ExtendedError::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ExtendedError::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ExtendedError& ExtendedError::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ExtendedError_robot_2eproto.base);
  return *internal_default_instance();
}


void ExtendedError::Clear() {
// @@protoc_insertion_point(message_clear_start:robot.ExtendedError)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&motor_1_error_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&kicker_break_beam_error_) -
        reinterpret_cast<char*>(&motor_1_error_)) + sizeof(kicker_break_beam_error_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&motor_encoder_error_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&main_sensor_error_) -
        reinterpret_cast<char*>(&motor_encoder_error_)) + sizeof(main_sensor_error_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ExtendedError::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bool motor_1_error = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_motor_1_error(&has_bits);
          motor_1_error_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bool motor_2_error = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_motor_2_error(&has_bits);
          motor_2_error_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bool motor_3_error = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_motor_3_error(&has_bits);
          motor_3_error_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bool motor_4_error = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_motor_4_error(&has_bits);
          motor_4_error_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bool dribbler_error = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_dribbler_error(&has_bits);
          dribbler_error_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bool kicker_error = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_kicker_error(&has_bits);
          kicker_error_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 temperature = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_temperature(&has_bits);
          temperature_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool motor_encoder_error = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_motor_encoder_error(&has_bits);
          motor_encoder_error_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool main_sensor_error = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_main_sensor_error(&has_bits);
          main_sensor_error_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool kicker_break_beam_error = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_kicker_break_beam_error(&has_bits);
          kicker_break_beam_error_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ExtendedError::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:robot.ExtendedError)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bool motor_1_error = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_motor_1_error(), target);
  }

  // required bool motor_2_error = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_motor_2_error(), target);
  }

  // required bool motor_3_error = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_motor_3_error(), target);
  }

  // required bool motor_4_error = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_motor_4_error(), target);
  }

  // required bool dribbler_error = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_dribbler_error(), target);
  }

  // required bool kicker_error = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_kicker_error(), target);
  }

  // optional int32 temperature = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(7, this->_internal_temperature(), target);
  }

  // optional bool motor_encoder_error = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(9, this->_internal_motor_encoder_error(), target);
  }

  // optional bool main_sensor_error = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(10, this->_internal_main_sensor_error(), target);
  }

  // optional bool kicker_break_beam_error = 11;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(11, this->_internal_kicker_break_beam_error(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robot.ExtendedError)
  return target;
}

size_t ExtendedError::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:robot.ExtendedError)
  size_t total_size = 0;

  if (_internal_has_motor_1_error()) {
    // required bool motor_1_error = 1;
    total_size += 1 + 1;
  }

  if (_internal_has_motor_2_error()) {
    // required bool motor_2_error = 2;
    total_size += 1 + 1;
  }

  if (_internal_has_motor_3_error()) {
    // required bool motor_3_error = 3;
    total_size += 1 + 1;
  }

  if (_internal_has_motor_4_error()) {
    // required bool motor_4_error = 4;
    total_size += 1 + 1;
  }

  if (_internal_has_dribbler_error()) {
    // required bool dribbler_error = 5;
    total_size += 1 + 1;
  }

  if (_internal_has_kicker_error()) {
    // required bool kicker_error = 6;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t ExtendedError::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:robot.ExtendedError)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000006f) ^ 0x0000006f) == 0) {  // All required fields are present.
    // required bool motor_1_error = 1;
    total_size += 1 + 1;

    // required bool motor_2_error = 2;
    total_size += 1 + 1;

    // required bool motor_3_error = 3;
    total_size += 1 + 1;

    // required bool motor_4_error = 4;
    total_size += 1 + 1;

    // required bool dribbler_error = 5;
    total_size += 1 + 1;

    // required bool kicker_error = 6;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 temperature = 7;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000010u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_temperature());
  }

  // optional bool kicker_break_beam_error = 11;
  if (cached_has_bits & 0x00000080u) {
    total_size += 1 + 1;
  }

  if (cached_has_bits & 0x00000300u) {
    // optional bool motor_encoder_error = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool main_sensor_error = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ExtendedError::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robot.ExtendedError)
  GOOGLE_DCHECK_NE(&from, this);
  const ExtendedError* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ExtendedError>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robot.ExtendedError)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robot.ExtendedError)
    MergeFrom(*source);
  }
}

void ExtendedError::MergeFrom(const ExtendedError& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robot.ExtendedError)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      motor_1_error_ = from.motor_1_error_;
    }
    if (cached_has_bits & 0x00000002u) {
      motor_2_error_ = from.motor_2_error_;
    }
    if (cached_has_bits & 0x00000004u) {
      motor_3_error_ = from.motor_3_error_;
    }
    if (cached_has_bits & 0x00000008u) {
      motor_4_error_ = from.motor_4_error_;
    }
    if (cached_has_bits & 0x00000010u) {
      temperature_ = from.temperature_;
    }
    if (cached_has_bits & 0x00000020u) {
      dribbler_error_ = from.dribbler_error_;
    }
    if (cached_has_bits & 0x00000040u) {
      kicker_error_ = from.kicker_error_;
    }
    if (cached_has_bits & 0x00000080u) {
      kicker_break_beam_error_ = from.kicker_break_beam_error_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      motor_encoder_error_ = from.motor_encoder_error_;
    }
    if (cached_has_bits & 0x00000200u) {
      main_sensor_error_ = from.main_sensor_error_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ExtendedError::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robot.ExtendedError)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ExtendedError::CopyFrom(const ExtendedError& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robot.ExtendedError)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExtendedError::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void ExtendedError::InternalSwap(ExtendedError* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ExtendedError, main_sensor_error_)
      + sizeof(ExtendedError::main_sensor_error_)
      - PROTOBUF_FIELD_OFFSET(ExtendedError, motor_1_error_)>(
          reinterpret_cast<char*>(&motor_1_error_),
          reinterpret_cast<char*>(&other->motor_1_error_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ExtendedError::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void RadioResponse::InitAsDefaultInstance() {
  ::robot::_RadioResponse_default_instance_._instance.get_mutable()->estimated_speed_ = const_cast< ::robot::SpeedStatus*>(
      ::robot::SpeedStatus::internal_default_instance());
  ::robot::_RadioResponse_default_instance_._instance.get_mutable()->extended_error_ = const_cast< ::robot::ExtendedError*>(
      ::robot::ExtendedError::internal_default_instance());
}
class RadioResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<RadioResponse>()._has_bits_);
  static void set_has_time(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_generation(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_battery(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_packet_loss_rx(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_packet_loss_tx(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::robot::SpeedStatus& estimated_speed(const RadioResponse* msg);
  static void set_has_estimated_speed(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ball_detected(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_cap_charged(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_error_present(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_radio_rtt(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static const ::robot::ExtendedError& extended_error(const RadioResponse* msg);
  static void set_has_extended_error(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_is_blue(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000c) ^ 0x0000000c) != 0;
  }
};

const ::robot::SpeedStatus&
RadioResponse::_Internal::estimated_speed(const RadioResponse* msg) {
  return *msg->estimated_speed_;
}
const ::robot::ExtendedError&
RadioResponse::_Internal::extended_error(const RadioResponse* msg) {
  return *msg->extended_error_;
}
RadioResponse::RadioResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:robot.RadioResponse)
}
RadioResponse::RadioResponse(const RadioResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_estimated_speed()) {
    estimated_speed_ = new ::robot::SpeedStatus(*from.estimated_speed_);
  } else {
    estimated_speed_ = nullptr;
  }
  if (from._internal_has_extended_error()) {
    extended_error_ = new ::robot::ExtendedError(*from.extended_error_);
  } else {
    extended_error_ = nullptr;
  }
  ::memcpy(&generation_, &from.generation_,
    static_cast<size_t>(reinterpret_cast<char*>(&radio_rtt_) -
    reinterpret_cast<char*>(&generation_)) + sizeof(radio_rtt_));
  // @@protoc_insertion_point(copy_constructor:robot.RadioResponse)
}

void RadioResponse::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_RadioResponse_robot_2eproto.base);
  ::memset(&estimated_speed_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&radio_rtt_) -
      reinterpret_cast<char*>(&estimated_speed_)) + sizeof(radio_rtt_));
}

RadioResponse::~RadioResponse() {
  // @@protoc_insertion_point(destructor:robot.RadioResponse)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void RadioResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete estimated_speed_;
  if (this != internal_default_instance()) delete extended_error_;
}

void RadioResponse::ArenaDtor(void* object) {
  RadioResponse* _this = reinterpret_cast< RadioResponse* >(object);
  (void)_this;
}
void RadioResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RadioResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const RadioResponse& RadioResponse::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_RadioResponse_robot_2eproto.base);
  return *internal_default_instance();
}


void RadioResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:robot.RadioResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(estimated_speed_ != nullptr);
      estimated_speed_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(extended_error_ != nullptr);
      extended_error_->Clear();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&generation_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ball_detected_) -
        reinterpret_cast<char*>(&generation_)) + sizeof(ball_detected_));
  }
  if (cached_has_bits & 0x00001f00u) {
    ::memset(&cap_charged_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&radio_rtt_) -
        reinterpret_cast<char*>(&cap_charged_)) + sizeof(radio_rtt_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RadioResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint32 generation = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_generation(&has_bits);
          generation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_id(&has_bits);
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float battery = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_battery(&has_bits);
          battery_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float packet_loss_rx = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_packet_loss_rx(&has_bits);
          packet_loss_rx_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float packet_loss_tx = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          _Internal::set_has_packet_loss_tx(&has_bits);
          packet_loss_tx_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional .robot.SpeedStatus estimated_speed = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_estimated_speed(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool ball_detected = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_ball_detected(&has_bits);
          ball_detected_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool cap_charged = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_cap_charged(&has_bits);
          cap_charged_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool error_present = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_error_present(&has_bits);
          error_present_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 time = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          _Internal::set_has_time(&has_bits);
          time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float radio_rtt = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 93)) {
          _Internal::set_has_radio_rtt(&has_bits);
          radio_rtt_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional .robot.ExtendedError extended_error = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_extended_error(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool is_blue = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          _Internal::set_has_is_blue(&has_bits);
          is_blue_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* RadioResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:robot.RadioResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 generation = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_generation(), target);
  }

  // required uint32 id = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_id(), target);
  }

  // optional float battery = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_battery(), target);
  }

  // optional float packet_loss_rx = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_packet_loss_rx(), target);
  }

  // optional float packet_loss_tx = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_packet_loss_tx(), target);
  }

  // optional .robot.SpeedStatus estimated_speed = 6;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::estimated_speed(this), target, stream);
  }

  // optional bool ball_detected = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->_internal_ball_detected(), target);
  }

  // optional bool cap_charged = 8;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->_internal_cap_charged(), target);
  }

  // optional bool error_present = 9;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(9, this->_internal_error_present(), target);
  }

  // optional int64 time = 10;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(10, this->_internal_time(), target);
  }

  // optional float radio_rtt = 11;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(11, this->_internal_radio_rtt(), target);
  }

  // optional .robot.ExtendedError extended_error = 12;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        12, _Internal::extended_error(this), target, stream);
  }

  // optional bool is_blue = 13;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(13, this->_internal_is_blue(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robot.RadioResponse)
  return target;
}

size_t RadioResponse::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:robot.RadioResponse)
  size_t total_size = 0;

  if (_internal_has_generation()) {
    // required uint32 generation = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_generation());
  }

  if (_internal_has_id()) {
    // required uint32 id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_id());
  }

  return total_size;
}
size_t RadioResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:robot.RadioResponse)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000c) ^ 0x0000000c) == 0) {  // All required fields are present.
    // required uint32 generation = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_generation());

    // required uint32 id = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .robot.SpeedStatus estimated_speed = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *estimated_speed_);
    }

    // optional .robot.ExtendedError extended_error = 12;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *extended_error_);
    }

  }
  if (cached_has_bits & 0x000000f0u) {
    // optional float battery = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float packet_loss_rx = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float packet_loss_tx = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional bool ball_detected = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00001f00u) {
    // optional bool cap_charged = 8;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool error_present = 9;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool is_blue = 13;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional int64 time = 10;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_time());
    }

    // optional float radio_rtt = 11;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RadioResponse::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robot.RadioResponse)
  GOOGLE_DCHECK_NE(&from, this);
  const RadioResponse* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<RadioResponse>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robot.RadioResponse)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robot.RadioResponse)
    MergeFrom(*source);
  }
}

void RadioResponse::MergeFrom(const RadioResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robot.RadioResponse)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_estimated_speed()->::robot::SpeedStatus::MergeFrom(from._internal_estimated_speed());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_extended_error()->::robot::ExtendedError::MergeFrom(from._internal_extended_error());
    }
    if (cached_has_bits & 0x00000004u) {
      generation_ = from.generation_;
    }
    if (cached_has_bits & 0x00000008u) {
      id_ = from.id_;
    }
    if (cached_has_bits & 0x00000010u) {
      battery_ = from.battery_;
    }
    if (cached_has_bits & 0x00000020u) {
      packet_loss_rx_ = from.packet_loss_rx_;
    }
    if (cached_has_bits & 0x00000040u) {
      packet_loss_tx_ = from.packet_loss_tx_;
    }
    if (cached_has_bits & 0x00000080u) {
      ball_detected_ = from.ball_detected_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00001f00u) {
    if (cached_has_bits & 0x00000100u) {
      cap_charged_ = from.cap_charged_;
    }
    if (cached_has_bits & 0x00000200u) {
      error_present_ = from.error_present_;
    }
    if (cached_has_bits & 0x00000400u) {
      is_blue_ = from.is_blue_;
    }
    if (cached_has_bits & 0x00000800u) {
      time_ = from.time_;
    }
    if (cached_has_bits & 0x00001000u) {
      radio_rtt_ = from.radio_rtt_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void RadioResponse::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robot.RadioResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RadioResponse::CopyFrom(const RadioResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robot.RadioResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RadioResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_estimated_speed()) {
    if (!estimated_speed_->IsInitialized()) return false;
  }
  if (_internal_has_extended_error()) {
    if (!extended_error_->IsInitialized()) return false;
  }
  return true;
}

void RadioResponse::InternalSwap(RadioResponse* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RadioResponse, radio_rtt_)
      + sizeof(RadioResponse::radio_rtt_)
      - PROTOBUF_FIELD_OFFSET(RadioResponse, estimated_speed_)>(
          reinterpret_cast<char*>(&estimated_speed_),
          reinterpret_cast<char*>(&other->estimated_speed_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RadioResponse::GetMetadata() const {
  return GetMetadataStatic();
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace robot
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::robot::LimitParameters* Arena::CreateMaybeMessage< ::robot::LimitParameters >(Arena* arena) {
  return Arena::CreateMessageInternal< ::robot::LimitParameters >(arena);
}
template<> PROTOBUF_NOINLINE ::robot::SimulationLimits* Arena::CreateMaybeMessage< ::robot::SimulationLimits >(Arena* arena) {
  return Arena::CreateMessageInternal< ::robot::SimulationLimits >(arena);
}
template<> PROTOBUF_NOINLINE ::robot::Specs* Arena::CreateMaybeMessage< ::robot::Specs >(Arena* arena) {
  return Arena::CreateMessageInternal< ::robot::Specs >(arena);
}
template<> PROTOBUF_NOINLINE ::robot::Generation* Arena::CreateMaybeMessage< ::robot::Generation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::robot::Generation >(arena);
}
template<> PROTOBUF_NOINLINE ::robot::Team* Arena::CreateMaybeMessage< ::robot::Team >(Arena* arena) {
  return Arena::CreateMessageInternal< ::robot::Team >(arena);
}
template<> PROTOBUF_NOINLINE ::robot::Polynomial* Arena::CreateMaybeMessage< ::robot::Polynomial >(Arena* arena) {
  return Arena::CreateMessageInternal< ::robot::Polynomial >(arena);
}
template<> PROTOBUF_NOINLINE ::robot::Spline* Arena::CreateMaybeMessage< ::robot::Spline >(Arena* arena) {
  return Arena::CreateMessageInternal< ::robot::Spline >(arena);
}
template<> PROTOBUF_NOINLINE ::robot::ControllerInput* Arena::CreateMaybeMessage< ::robot::ControllerInput >(Arena* arena) {
  return Arena::CreateMessageInternal< ::robot::ControllerInput >(arena);
}
template<> PROTOBUF_NOINLINE ::robot::SpeedVector* Arena::CreateMaybeMessage< ::robot::SpeedVector >(Arena* arena) {
  return Arena::CreateMessageInternal< ::robot::SpeedVector >(arena);
}
template<> PROTOBUF_NOINLINE ::robot::Command* Arena::CreateMaybeMessage< ::robot::Command >(Arena* arena) {
  return Arena::CreateMessageInternal< ::robot::Command >(arena);
}
template<> PROTOBUF_NOINLINE ::robot::RadioCommand* Arena::CreateMaybeMessage< ::robot::RadioCommand >(Arena* arena) {
  return Arena::CreateMessageInternal< ::robot::RadioCommand >(arena);
}
template<> PROTOBUF_NOINLINE ::robot::SpeedStatus* Arena::CreateMaybeMessage< ::robot::SpeedStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::robot::SpeedStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::robot::ExtendedError* Arena::CreateMaybeMessage< ::robot::ExtendedError >(Arena* arena) {
  return Arena::CreateMessageInternal< ::robot::ExtendedError >(arena);
}
template<> PROTOBUF_NOINLINE ::robot::RadioResponse* Arena::CreateMaybeMessage< ::robot::RadioResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::robot::RadioResponse >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
