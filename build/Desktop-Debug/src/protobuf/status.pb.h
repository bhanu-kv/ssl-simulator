// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: status.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_status_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_status_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "debug.pb.h"
#include "gamestate.pb.h"
#include "robot.pb.h"
#include "world.pb.h"
#include "userinput.pb.h"
#include "logfile.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_status_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_status_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[15]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_status_2eproto;
namespace amun {
class GitInfo;
class GitInfoDefaultTypeInternal;
extern GitInfoDefaultTypeInternal _GitInfo_default_instance_;
class LogPlaybackInfo;
class LogPlaybackInfoDefaultTypeInternal;
extern LogPlaybackInfoDefaultTypeInternal _LogPlaybackInfo_default_instance_;
class LogfileOpenInfo;
class LogfileOpenInfoDefaultTypeInternal;
extern LogfileOpenInfoDefaultTypeInternal _LogfileOpenInfo_default_instance_;
class LoggingInfo;
class LoggingInfoDefaultTypeInternal;
extern LoggingInfoDefaultTypeInternal _LoggingInfo_default_instance_;
class OptionStatus;
class OptionStatusDefaultTypeInternal;
extern OptionStatusDefaultTypeInternal _OptionStatus_default_instance_;
class PortBindError;
class PortBindErrorDefaultTypeInternal;
extern PortBindErrorDefaultTypeInternal _PortBindError_default_instance_;
class Status;
class StatusDefaultTypeInternal;
extern StatusDefaultTypeInternal _Status_default_instance_;
class StatusAmun;
class StatusAmunDefaultTypeInternal;
extern StatusAmunDefaultTypeInternal _StatusAmun_default_instance_;
class StatusGameController;
class StatusGameControllerDefaultTypeInternal;
extern StatusGameControllerDefaultTypeInternal _StatusGameController_default_instance_;
class StatusStrategy;
class StatusStrategyDefaultTypeInternal;
extern StatusStrategyDefaultTypeInternal _StatusStrategy_default_instance_;
class StatusStrategyWrapper;
class StatusStrategyWrapperDefaultTypeInternal;
extern StatusStrategyWrapperDefaultTypeInternal _StatusStrategyWrapper_default_instance_;
class StatusTransceiver;
class StatusTransceiverDefaultTypeInternal;
extern StatusTransceiverDefaultTypeInternal _StatusTransceiver_default_instance_;
class StrategyOption;
class StrategyOptionDefaultTypeInternal;
extern StrategyOptionDefaultTypeInternal _StrategyOption_default_instance_;
class Timing;
class TimingDefaultTypeInternal;
extern TimingDefaultTypeInternal _Timing_default_instance_;
class UiResponse;
class UiResponseDefaultTypeInternal;
extern UiResponseDefaultTypeInternal _UiResponse_default_instance_;
}  // namespace amun
PROTOBUF_NAMESPACE_OPEN
template<> ::amun::GitInfo* Arena::CreateMaybeMessage<::amun::GitInfo>(Arena*);
template<> ::amun::LogPlaybackInfo* Arena::CreateMaybeMessage<::amun::LogPlaybackInfo>(Arena*);
template<> ::amun::LogfileOpenInfo* Arena::CreateMaybeMessage<::amun::LogfileOpenInfo>(Arena*);
template<> ::amun::LoggingInfo* Arena::CreateMaybeMessage<::amun::LoggingInfo>(Arena*);
template<> ::amun::OptionStatus* Arena::CreateMaybeMessage<::amun::OptionStatus>(Arena*);
template<> ::amun::PortBindError* Arena::CreateMaybeMessage<::amun::PortBindError>(Arena*);
template<> ::amun::Status* Arena::CreateMaybeMessage<::amun::Status>(Arena*);
template<> ::amun::StatusAmun* Arena::CreateMaybeMessage<::amun::StatusAmun>(Arena*);
template<> ::amun::StatusGameController* Arena::CreateMaybeMessage<::amun::StatusGameController>(Arena*);
template<> ::amun::StatusStrategy* Arena::CreateMaybeMessage<::amun::StatusStrategy>(Arena*);
template<> ::amun::StatusStrategyWrapper* Arena::CreateMaybeMessage<::amun::StatusStrategyWrapper>(Arena*);
template<> ::amun::StatusTransceiver* Arena::CreateMaybeMessage<::amun::StatusTransceiver>(Arena*);
template<> ::amun::StrategyOption* Arena::CreateMaybeMessage<::amun::StrategyOption>(Arena*);
template<> ::amun::Timing* Arena::CreateMaybeMessage<::amun::Timing>(Arena*);
template<> ::amun::UiResponse* Arena::CreateMaybeMessage<::amun::UiResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace amun {

enum StatusStrategy_STATE : int {
  StatusStrategy_STATE_CLOSED = 1,
  StatusStrategy_STATE_RUNNING = 3,
  StatusStrategy_STATE_FAILED = 4,
  StatusStrategy_STATE_COMPILING = 5
};
bool StatusStrategy_STATE_IsValid(int value);
constexpr StatusStrategy_STATE StatusStrategy_STATE_STATE_MIN = StatusStrategy_STATE_CLOSED;
constexpr StatusStrategy_STATE StatusStrategy_STATE_STATE_MAX = StatusStrategy_STATE_COMPILING;
constexpr int StatusStrategy_STATE_STATE_ARRAYSIZE = StatusStrategy_STATE_STATE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StatusStrategy_STATE_descriptor();
template<typename T>
inline const std::string& StatusStrategy_STATE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StatusStrategy_STATE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StatusStrategy_STATE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StatusStrategy_STATE_descriptor(), enum_t_value);
}
inline bool StatusStrategy_STATE_Parse(
    const std::string& name, StatusStrategy_STATE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StatusStrategy_STATE>(
    StatusStrategy_STATE_descriptor(), name, value);
}
enum GitInfo_Kind : int {
  GitInfo_Kind_BLUE = 1,
  GitInfo_Kind_YELLOW = 2,
  GitInfo_Kind_AUTOREF = 3,
  GitInfo_Kind_RA = 4,
  GitInfo_Kind_CONFIG = 5
};
bool GitInfo_Kind_IsValid(int value);
constexpr GitInfo_Kind GitInfo_Kind_Kind_MIN = GitInfo_Kind_BLUE;
constexpr GitInfo_Kind GitInfo_Kind_Kind_MAX = GitInfo_Kind_CONFIG;
constexpr int GitInfo_Kind_Kind_ARRAYSIZE = GitInfo_Kind_Kind_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GitInfo_Kind_descriptor();
template<typename T>
inline const std::string& GitInfo_Kind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GitInfo_Kind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GitInfo_Kind_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GitInfo_Kind_descriptor(), enum_t_value);
}
inline bool GitInfo_Kind_Parse(
    const std::string& name, GitInfo_Kind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GitInfo_Kind>(
    GitInfo_Kind_descriptor(), name, value);
}
enum StatusStrategyWrapper_StrategyType : int {
  StatusStrategyWrapper_StrategyType_BLUE = 1,
  StatusStrategyWrapper_StrategyType_YELLOW = 2,
  StatusStrategyWrapper_StrategyType_AUTOREF = 3,
  StatusStrategyWrapper_StrategyType_REPLAY_BLUE = 4,
  StatusStrategyWrapper_StrategyType_REPLAY_YELLOW = 5
};
bool StatusStrategyWrapper_StrategyType_IsValid(int value);
constexpr StatusStrategyWrapper_StrategyType StatusStrategyWrapper_StrategyType_StrategyType_MIN = StatusStrategyWrapper_StrategyType_BLUE;
constexpr StatusStrategyWrapper_StrategyType StatusStrategyWrapper_StrategyType_StrategyType_MAX = StatusStrategyWrapper_StrategyType_REPLAY_YELLOW;
constexpr int StatusStrategyWrapper_StrategyType_StrategyType_ARRAYSIZE = StatusStrategyWrapper_StrategyType_StrategyType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StatusStrategyWrapper_StrategyType_descriptor();
template<typename T>
inline const std::string& StatusStrategyWrapper_StrategyType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StatusStrategyWrapper_StrategyType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StatusStrategyWrapper_StrategyType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StatusStrategyWrapper_StrategyType_descriptor(), enum_t_value);
}
inline bool StatusStrategyWrapper_StrategyType_Parse(
    const std::string& name, StatusStrategyWrapper_StrategyType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StatusStrategyWrapper_StrategyType>(
    StatusStrategyWrapper_StrategyType_descriptor(), name, value);
}
enum StatusGameController_GameControllerState : int {
  StatusGameController_GameControllerState_STOPPED = 1,
  StatusGameController_GameControllerState_STARTING = 2,
  StatusGameController_GameControllerState_RUNNING = 3,
  StatusGameController_GameControllerState_CRASHED = 4,
  StatusGameController_GameControllerState_NOT_RESPONDING = 5
};
bool StatusGameController_GameControllerState_IsValid(int value);
constexpr StatusGameController_GameControllerState StatusGameController_GameControllerState_GameControllerState_MIN = StatusGameController_GameControllerState_STOPPED;
constexpr StatusGameController_GameControllerState StatusGameController_GameControllerState_GameControllerState_MAX = StatusGameController_GameControllerState_NOT_RESPONDING;
constexpr int StatusGameController_GameControllerState_GameControllerState_ARRAYSIZE = StatusGameController_GameControllerState_GameControllerState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StatusGameController_GameControllerState_descriptor();
template<typename T>
inline const std::string& StatusGameController_GameControllerState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StatusGameController_GameControllerState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StatusGameController_GameControllerState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    StatusGameController_GameControllerState_descriptor(), enum_t_value);
}
inline bool StatusGameController_GameControllerState_Parse(
    const std::string& name, StatusGameController_GameControllerState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<StatusGameController_GameControllerState>(
    StatusGameController_GameControllerState_descriptor(), name, value);
}
// ===================================================================

class StrategyOption PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:amun.StrategyOption) */ {
 public:
  inline StrategyOption() : StrategyOption(nullptr) {};
  virtual ~StrategyOption();

  StrategyOption(const StrategyOption& from);
  StrategyOption(StrategyOption&& from) noexcept
    : StrategyOption() {
    *this = ::std::move(from);
  }

  inline StrategyOption& operator=(const StrategyOption& from) {
    CopyFrom(from);
    return *this;
  }
  inline StrategyOption& operator=(StrategyOption&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StrategyOption& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StrategyOption* internal_default_instance() {
    return reinterpret_cast<const StrategyOption*>(
               &_StrategyOption_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(StrategyOption& a, StrategyOption& b) {
    a.Swap(&b);
  }
  inline void Swap(StrategyOption* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StrategyOption* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StrategyOption* New() const final {
    return CreateMaybeMessage<StrategyOption>(nullptr);
  }

  StrategyOption* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StrategyOption>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StrategyOption& from);
  void MergeFrom(const StrategyOption& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StrategyOption* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "amun.StrategyOption";
  }
  protected:
  explicit StrategyOption(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_status_2eproto);
    return ::descriptor_table_status_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDefaultValueFieldNumber = 2,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional bool default_value = 2;
  bool has_default_value() const;
  private:
  bool _internal_has_default_value() const;
  public:
  void clear_default_value();
  bool default_value() const;
  void set_default_value(bool value);
  private:
  bool _internal_default_value() const;
  void _internal_set_default_value(bool value);
  public:

  // @@protoc_insertion_point(class_scope:amun.StrategyOption)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  bool default_value_;
  friend struct ::TableStruct_status_2eproto;
};
// -------------------------------------------------------------------

class StatusStrategy PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:amun.StatusStrategy) */ {
 public:
  inline StatusStrategy() : StatusStrategy(nullptr) {};
  virtual ~StatusStrategy();

  StatusStrategy(const StatusStrategy& from);
  StatusStrategy(StatusStrategy&& from) noexcept
    : StatusStrategy() {
    *this = ::std::move(from);
  }

  inline StatusStrategy& operator=(const StatusStrategy& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusStrategy& operator=(StatusStrategy&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StatusStrategy& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StatusStrategy* internal_default_instance() {
    return reinterpret_cast<const StatusStrategy*>(
               &_StatusStrategy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(StatusStrategy& a, StatusStrategy& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusStrategy* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusStrategy* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StatusStrategy* New() const final {
    return CreateMaybeMessage<StatusStrategy>(nullptr);
  }

  StatusStrategy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StatusStrategy>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StatusStrategy& from);
  void MergeFrom(const StatusStrategy& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusStrategy* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "amun.StatusStrategy";
  }
  protected:
  explicit StatusStrategy(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_status_2eproto);
    return ::descriptor_table_status_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef StatusStrategy_STATE STATE;
  static constexpr STATE CLOSED =
    StatusStrategy_STATE_CLOSED;
  static constexpr STATE RUNNING =
    StatusStrategy_STATE_RUNNING;
  static constexpr STATE FAILED =
    StatusStrategy_STATE_FAILED;
  static constexpr STATE COMPILING =
    StatusStrategy_STATE_COMPILING;
  static inline bool STATE_IsValid(int value) {
    return StatusStrategy_STATE_IsValid(value);
  }
  static constexpr STATE STATE_MIN =
    StatusStrategy_STATE_STATE_MIN;
  static constexpr STATE STATE_MAX =
    StatusStrategy_STATE_STATE_MAX;
  static constexpr int STATE_ARRAYSIZE =
    StatusStrategy_STATE_STATE_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  STATE_descriptor() {
    return StatusStrategy_STATE_descriptor();
  }
  template<typename T>
  static inline const std::string& STATE_Name(T enum_t_value) {
    static_assert(::std::is_same<T, STATE>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function STATE_Name.");
    return StatusStrategy_STATE_Name(enum_t_value);
  }
  static inline bool STATE_Parse(const std::string& name,
      STATE* value) {
    return StatusStrategy_STATE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEntryPointFieldNumber = 5,
    kOptionsFieldNumber = 8,
    kFilenameFieldNumber = 2,
    kNameFieldNumber = 3,
    kCurrentEntryPointFieldNumber = 4,
    kHasDebuggerFieldNumber = 7,
    kStateFieldNumber = 1,
  };
  // repeated string entry_point = 5;
  int entry_point_size() const;
  private:
  int _internal_entry_point_size() const;
  public:
  void clear_entry_point();
  const std::string& entry_point(int index) const;
  std::string* mutable_entry_point(int index);
  void set_entry_point(int index, const std::string& value);
  void set_entry_point(int index, std::string&& value);
  void set_entry_point(int index, const char* value);
  void set_entry_point(int index, const char* value, size_t size);
  std::string* add_entry_point();
  void add_entry_point(const std::string& value);
  void add_entry_point(std::string&& value);
  void add_entry_point(const char* value);
  void add_entry_point(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& entry_point() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_entry_point();
  private:
  const std::string& _internal_entry_point(int index) const;
  std::string* _internal_add_entry_point();
  public:

  // repeated .amun.StrategyOption options = 8;
  int options_size() const;
  private:
  int _internal_options_size() const;
  public:
  void clear_options();
  ::amun::StrategyOption* mutable_options(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::amun::StrategyOption >*
      mutable_options();
  private:
  const ::amun::StrategyOption& _internal_options(int index) const;
  ::amun::StrategyOption* _internal_add_options();
  public:
  const ::amun::StrategyOption& options(int index) const;
  ::amun::StrategyOption* add_options();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::amun::StrategyOption >&
      options() const;

  // optional string filename = 2;
  bool has_filename() const;
  private:
  bool _internal_has_filename() const;
  public:
  void clear_filename();
  const std::string& filename() const;
  void set_filename(const std::string& value);
  void set_filename(std::string&& value);
  void set_filename(const char* value);
  void set_filename(const char* value, size_t size);
  std::string* mutable_filename();
  std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_filename();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_filename(
      std::string* filename);
  private:
  const std::string& _internal_filename() const;
  void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // optional string name = 3;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string current_entry_point = 4;
  bool has_current_entry_point() const;
  private:
  bool _internal_has_current_entry_point() const;
  public:
  void clear_current_entry_point();
  const std::string& current_entry_point() const;
  void set_current_entry_point(const std::string& value);
  void set_current_entry_point(std::string&& value);
  void set_current_entry_point(const char* value);
  void set_current_entry_point(const char* value, size_t size);
  std::string* mutable_current_entry_point();
  std::string* release_current_entry_point();
  void set_allocated_current_entry_point(std::string* current_entry_point);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_current_entry_point();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_current_entry_point(
      std::string* current_entry_point);
  private:
  const std::string& _internal_current_entry_point() const;
  void _internal_set_current_entry_point(const std::string& value);
  std::string* _internal_mutable_current_entry_point();
  public:

  // optional bool has_debugger = 7;
  bool has_has_debugger() const;
  private:
  bool _internal_has_has_debugger() const;
  public:
  void clear_has_debugger();
  bool has_debugger() const;
  void set_has_debugger(bool value);
  private:
  bool _internal_has_debugger() const;
  void _internal_set_has_debugger(bool value);
  public:

  // required .amun.StatusStrategy.STATE state = 1;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  ::amun::StatusStrategy_STATE state() const;
  void set_state(::amun::StatusStrategy_STATE value);
  private:
  ::amun::StatusStrategy_STATE _internal_state() const;
  void _internal_set_state(::amun::StatusStrategy_STATE value);
  public:

  // @@protoc_insertion_point(class_scope:amun.StatusStrategy)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> entry_point_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::amun::StrategyOption > options_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr current_entry_point_;
  bool has_debugger_;
  int state_;
  friend struct ::TableStruct_status_2eproto;
};
// -------------------------------------------------------------------

class GitInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:amun.GitInfo) */ {
 public:
  inline GitInfo() : GitInfo(nullptr) {};
  virtual ~GitInfo();

  GitInfo(const GitInfo& from);
  GitInfo(GitInfo&& from) noexcept
    : GitInfo() {
    *this = ::std::move(from);
  }

  inline GitInfo& operator=(const GitInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline GitInfo& operator=(GitInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GitInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GitInfo* internal_default_instance() {
    return reinterpret_cast<const GitInfo*>(
               &_GitInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GitInfo& a, GitInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(GitInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GitInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GitInfo* New() const final {
    return CreateMaybeMessage<GitInfo>(nullptr);
  }

  GitInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GitInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GitInfo& from);
  void MergeFrom(const GitInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GitInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "amun.GitInfo";
  }
  protected:
  explicit GitInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_status_2eproto);
    return ::descriptor_table_status_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef GitInfo_Kind Kind;
  static constexpr Kind BLUE =
    GitInfo_Kind_BLUE;
  static constexpr Kind YELLOW =
    GitInfo_Kind_YELLOW;
  static constexpr Kind AUTOREF =
    GitInfo_Kind_AUTOREF;
  static constexpr Kind RA =
    GitInfo_Kind_RA;
  static constexpr Kind CONFIG =
    GitInfo_Kind_CONFIG;
  static inline bool Kind_IsValid(int value) {
    return GitInfo_Kind_IsValid(value);
  }
  static constexpr Kind Kind_MIN =
    GitInfo_Kind_Kind_MIN;
  static constexpr Kind Kind_MAX =
    GitInfo_Kind_Kind_MAX;
  static constexpr int Kind_ARRAYSIZE =
    GitInfo_Kind_Kind_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Kind_descriptor() {
    return GitInfo_Kind_descriptor();
  }
  template<typename T>
  static inline const std::string& Kind_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Kind>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Kind_Name.");
    return GitInfo_Kind_Name(enum_t_value);
  }
  static inline bool Kind_Parse(const std::string& name,
      Kind* value) {
    return GitInfo_Kind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHashFieldNumber = 2,
    kDiffFieldNumber = 3,
    kMinHashFieldNumber = 4,
    kErrorFieldNumber = 5,
    kKindFieldNumber = 1,
  };
  // required string hash = 2;
  bool has_hash() const;
  private:
  bool _internal_has_hash() const;
  public:
  void clear_hash();
  const std::string& hash() const;
  void set_hash(const std::string& value);
  void set_hash(std::string&& value);
  void set_hash(const char* value);
  void set_hash(const char* value, size_t size);
  std::string* mutable_hash();
  std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_hash();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_hash(
      std::string* hash);
  private:
  const std::string& _internal_hash() const;
  void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // required string diff = 3;
  bool has_diff() const;
  private:
  bool _internal_has_diff() const;
  public:
  void clear_diff();
  const std::string& diff() const;
  void set_diff(const std::string& value);
  void set_diff(std::string&& value);
  void set_diff(const char* value);
  void set_diff(const char* value, size_t size);
  std::string* mutable_diff();
  std::string* release_diff();
  void set_allocated_diff(std::string* diff);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_diff();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_diff(
      std::string* diff);
  private:
  const std::string& _internal_diff() const;
  void _internal_set_diff(const std::string& value);
  std::string* _internal_mutable_diff();
  public:

  // required string min_hash = 4;
  bool has_min_hash() const;
  private:
  bool _internal_has_min_hash() const;
  public:
  void clear_min_hash();
  const std::string& min_hash() const;
  void set_min_hash(const std::string& value);
  void set_min_hash(std::string&& value);
  void set_min_hash(const char* value);
  void set_min_hash(const char* value, size_t size);
  std::string* mutable_min_hash();
  std::string* release_min_hash();
  void set_allocated_min_hash(std::string* min_hash);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_min_hash();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_min_hash(
      std::string* min_hash);
  private:
  const std::string& _internal_min_hash() const;
  void _internal_set_min_hash(const std::string& value);
  std::string* _internal_mutable_min_hash();
  public:

  // required string error = 5;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  void set_error(const std::string& value);
  void set_error(std::string&& value);
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  std::string* mutable_error();
  std::string* release_error();
  void set_allocated_error(std::string* error);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_error();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_error(
      std::string* error);
  private:
  const std::string& _internal_error() const;
  void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // required .amun.GitInfo.Kind kind = 1;
  bool has_kind() const;
  private:
  bool _internal_has_kind() const;
  public:
  void clear_kind();
  ::amun::GitInfo_Kind kind() const;
  void set_kind(::amun::GitInfo_Kind value);
  private:
  ::amun::GitInfo_Kind _internal_kind() const;
  void _internal_set_kind(::amun::GitInfo_Kind value);
  public:

  // @@protoc_insertion_point(class_scope:amun.GitInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr diff_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr min_hash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  int kind_;
  friend struct ::TableStruct_status_2eproto;
};
// -------------------------------------------------------------------

class StatusStrategyWrapper PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:amun.StatusStrategyWrapper) */ {
 public:
  inline StatusStrategyWrapper() : StatusStrategyWrapper(nullptr) {};
  virtual ~StatusStrategyWrapper();

  StatusStrategyWrapper(const StatusStrategyWrapper& from);
  StatusStrategyWrapper(StatusStrategyWrapper&& from) noexcept
    : StatusStrategyWrapper() {
    *this = ::std::move(from);
  }

  inline StatusStrategyWrapper& operator=(const StatusStrategyWrapper& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusStrategyWrapper& operator=(StatusStrategyWrapper&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StatusStrategyWrapper& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StatusStrategyWrapper* internal_default_instance() {
    return reinterpret_cast<const StatusStrategyWrapper*>(
               &_StatusStrategyWrapper_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(StatusStrategyWrapper& a, StatusStrategyWrapper& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusStrategyWrapper* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusStrategyWrapper* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StatusStrategyWrapper* New() const final {
    return CreateMaybeMessage<StatusStrategyWrapper>(nullptr);
  }

  StatusStrategyWrapper* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StatusStrategyWrapper>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StatusStrategyWrapper& from);
  void MergeFrom(const StatusStrategyWrapper& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusStrategyWrapper* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "amun.StatusStrategyWrapper";
  }
  protected:
  explicit StatusStrategyWrapper(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_status_2eproto);
    return ::descriptor_table_status_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef StatusStrategyWrapper_StrategyType StrategyType;
  static constexpr StrategyType BLUE =
    StatusStrategyWrapper_StrategyType_BLUE;
  static constexpr StrategyType YELLOW =
    StatusStrategyWrapper_StrategyType_YELLOW;
  static constexpr StrategyType AUTOREF =
    StatusStrategyWrapper_StrategyType_AUTOREF;
  static constexpr StrategyType REPLAY_BLUE =
    StatusStrategyWrapper_StrategyType_REPLAY_BLUE;
  static constexpr StrategyType REPLAY_YELLOW =
    StatusStrategyWrapper_StrategyType_REPLAY_YELLOW;
  static inline bool StrategyType_IsValid(int value) {
    return StatusStrategyWrapper_StrategyType_IsValid(value);
  }
  static constexpr StrategyType StrategyType_MIN =
    StatusStrategyWrapper_StrategyType_StrategyType_MIN;
  static constexpr StrategyType StrategyType_MAX =
    StatusStrategyWrapper_StrategyType_StrategyType_MAX;
  static constexpr int StrategyType_ARRAYSIZE =
    StatusStrategyWrapper_StrategyType_StrategyType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  StrategyType_descriptor() {
    return StatusStrategyWrapper_StrategyType_descriptor();
  }
  template<typename T>
  static inline const std::string& StrategyType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, StrategyType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function StrategyType_Name.");
    return StatusStrategyWrapper_StrategyType_Name(enum_t_value);
  }
  static inline bool StrategyType_Parse(const std::string& name,
      StrategyType* value) {
    return StatusStrategyWrapper_StrategyType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStatusFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // required .amun.StatusStrategy status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::amun::StatusStrategy& status() const;
  ::amun::StatusStrategy* release_status();
  ::amun::StatusStrategy* mutable_status();
  void set_allocated_status(::amun::StatusStrategy* status);
  private:
  const ::amun::StatusStrategy& _internal_status() const;
  ::amun::StatusStrategy* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::amun::StatusStrategy* status);
  ::amun::StatusStrategy* unsafe_arena_release_status();

  // required .amun.StatusStrategyWrapper.StrategyType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::amun::StatusStrategyWrapper_StrategyType type() const;
  void set_type(::amun::StatusStrategyWrapper_StrategyType value);
  private:
  ::amun::StatusStrategyWrapper_StrategyType _internal_type() const;
  void _internal_set_type(::amun::StatusStrategyWrapper_StrategyType value);
  public:

  // @@protoc_insertion_point(class_scope:amun.StatusStrategyWrapper)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::amun::StatusStrategy* status_;
  int type_;
  friend struct ::TableStruct_status_2eproto;
};
// -------------------------------------------------------------------

class Timing PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:amun.Timing) */ {
 public:
  inline Timing() : Timing(nullptr) {};
  virtual ~Timing();

  Timing(const Timing& from);
  Timing(Timing&& from) noexcept
    : Timing() {
    *this = ::std::move(from);
  }

  inline Timing& operator=(const Timing& from) {
    CopyFrom(from);
    return *this;
  }
  inline Timing& operator=(Timing&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Timing& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Timing* internal_default_instance() {
    return reinterpret_cast<const Timing*>(
               &_Timing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Timing& a, Timing& b) {
    a.Swap(&b);
  }
  inline void Swap(Timing* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Timing* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Timing* New() const final {
    return CreateMaybeMessage<Timing>(nullptr);
  }

  Timing* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Timing>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Timing& from);
  void MergeFrom(const Timing& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Timing* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "amun.Timing";
  }
  protected:
  explicit Timing(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_status_2eproto);
    return ::descriptor_table_status_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlueTotalFieldNumber = 1,
    kBluePathFieldNumber = 2,
    kYellowTotalFieldNumber = 3,
    kYellowPathFieldNumber = 4,
    kTrackingFieldNumber = 5,
    kTransceiverFieldNumber = 6,
    kSimulatorFieldNumber = 7,
    kControllerFieldNumber = 8,
    kTransceiverRttFieldNumber = 9,
    kAutorefTotalFieldNumber = 10,
  };
  // optional float blue_total = 1;
  bool has_blue_total() const;
  private:
  bool _internal_has_blue_total() const;
  public:
  void clear_blue_total();
  float blue_total() const;
  void set_blue_total(float value);
  private:
  float _internal_blue_total() const;
  void _internal_set_blue_total(float value);
  public:

  // optional float blue_path = 2;
  bool has_blue_path() const;
  private:
  bool _internal_has_blue_path() const;
  public:
  void clear_blue_path();
  float blue_path() const;
  void set_blue_path(float value);
  private:
  float _internal_blue_path() const;
  void _internal_set_blue_path(float value);
  public:

  // optional float yellow_total = 3;
  bool has_yellow_total() const;
  private:
  bool _internal_has_yellow_total() const;
  public:
  void clear_yellow_total();
  float yellow_total() const;
  void set_yellow_total(float value);
  private:
  float _internal_yellow_total() const;
  void _internal_set_yellow_total(float value);
  public:

  // optional float yellow_path = 4;
  bool has_yellow_path() const;
  private:
  bool _internal_has_yellow_path() const;
  public:
  void clear_yellow_path();
  float yellow_path() const;
  void set_yellow_path(float value);
  private:
  float _internal_yellow_path() const;
  void _internal_set_yellow_path(float value);
  public:

  // optional float tracking = 5;
  bool has_tracking() const;
  private:
  bool _internal_has_tracking() const;
  public:
  void clear_tracking();
  float tracking() const;
  void set_tracking(float value);
  private:
  float _internal_tracking() const;
  void _internal_set_tracking(float value);
  public:

  // optional float transceiver = 6;
  bool has_transceiver() const;
  private:
  bool _internal_has_transceiver() const;
  public:
  void clear_transceiver();
  float transceiver() const;
  void set_transceiver(float value);
  private:
  float _internal_transceiver() const;
  void _internal_set_transceiver(float value);
  public:

  // optional float simulator = 7;
  bool has_simulator() const;
  private:
  bool _internal_has_simulator() const;
  public:
  void clear_simulator();
  float simulator() const;
  void set_simulator(float value);
  private:
  float _internal_simulator() const;
  void _internal_set_simulator(float value);
  public:

  // optional float controller = 8;
  bool has_controller() const;
  private:
  bool _internal_has_controller() const;
  public:
  void clear_controller();
  float controller() const;
  void set_controller(float value);
  private:
  float _internal_controller() const;
  void _internal_set_controller(float value);
  public:

  // optional float transceiver_rtt = 9;
  bool has_transceiver_rtt() const;
  private:
  bool _internal_has_transceiver_rtt() const;
  public:
  void clear_transceiver_rtt();
  float transceiver_rtt() const;
  void set_transceiver_rtt(float value);
  private:
  float _internal_transceiver_rtt() const;
  void _internal_set_transceiver_rtt(float value);
  public:

  // optional float autoref_total = 10;
  bool has_autoref_total() const;
  private:
  bool _internal_has_autoref_total() const;
  public:
  void clear_autoref_total();
  float autoref_total() const;
  void set_autoref_total(float value);
  private:
  float _internal_autoref_total() const;
  void _internal_set_autoref_total(float value);
  public:

  // @@protoc_insertion_point(class_scope:amun.Timing)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float blue_total_;
  float blue_path_;
  float yellow_total_;
  float yellow_path_;
  float tracking_;
  float transceiver_;
  float simulator_;
  float controller_;
  float transceiver_rtt_;
  float autoref_total_;
  friend struct ::TableStruct_status_2eproto;
};
// -------------------------------------------------------------------

class StatusTransceiver PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:amun.StatusTransceiver) */ {
 public:
  inline StatusTransceiver() : StatusTransceiver(nullptr) {};
  virtual ~StatusTransceiver();

  StatusTransceiver(const StatusTransceiver& from);
  StatusTransceiver(StatusTransceiver&& from) noexcept
    : StatusTransceiver() {
    *this = ::std::move(from);
  }

  inline StatusTransceiver& operator=(const StatusTransceiver& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusTransceiver& operator=(StatusTransceiver&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StatusTransceiver& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StatusTransceiver* internal_default_instance() {
    return reinterpret_cast<const StatusTransceiver*>(
               &_StatusTransceiver_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(StatusTransceiver& a, StatusTransceiver& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusTransceiver* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusTransceiver* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StatusTransceiver* New() const final {
    return CreateMaybeMessage<StatusTransceiver>(nullptr);
  }

  StatusTransceiver* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StatusTransceiver>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StatusTransceiver& from);
  void MergeFrom(const StatusTransceiver& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusTransceiver* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "amun.StatusTransceiver";
  }
  protected:
  explicit StatusTransceiver(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_status_2eproto);
    return ::descriptor_table_status_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 2,
    kActiveFieldNumber = 1,
    kDroppedUsbPacketsFieldNumber = 3,
    kDroppedCommandsFieldNumber = 4,
  };
  // optional string error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  void set_error(const std::string& value);
  void set_error(std::string&& value);
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  std::string* mutable_error();
  std::string* release_error();
  void set_allocated_error(std::string* error);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_error();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_error(
      std::string* error);
  private:
  const std::string& _internal_error() const;
  void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // required bool active = 1;
  bool has_active() const;
  private:
  bool _internal_has_active() const;
  public:
  void clear_active();
  bool active() const;
  void set_active(bool value);
  private:
  bool _internal_active() const;
  void _internal_set_active(bool value);
  public:

  // optional int32 dropped_usb_packets = 3;
  bool has_dropped_usb_packets() const;
  private:
  bool _internal_has_dropped_usb_packets() const;
  public:
  void clear_dropped_usb_packets();
  ::PROTOBUF_NAMESPACE_ID::int32 dropped_usb_packets() const;
  void set_dropped_usb_packets(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_dropped_usb_packets() const;
  void _internal_set_dropped_usb_packets(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 dropped_commands = 4;
  bool has_dropped_commands() const;
  private:
  bool _internal_has_dropped_commands() const;
  public:
  void clear_dropped_commands();
  ::PROTOBUF_NAMESPACE_ID::int32 dropped_commands() const;
  void set_dropped_commands(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_dropped_commands() const;
  void _internal_set_dropped_commands(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:amun.StatusTransceiver)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  bool active_;
  ::PROTOBUF_NAMESPACE_ID::int32 dropped_usb_packets_;
  ::PROTOBUF_NAMESPACE_ID::int32 dropped_commands_;
  friend struct ::TableStruct_status_2eproto;
};
// -------------------------------------------------------------------

class PortBindError PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:amun.PortBindError) */ {
 public:
  inline PortBindError() : PortBindError(nullptr) {};
  virtual ~PortBindError();

  PortBindError(const PortBindError& from);
  PortBindError(PortBindError&& from) noexcept
    : PortBindError() {
    *this = ::std::move(from);
  }

  inline PortBindError& operator=(const PortBindError& from) {
    CopyFrom(from);
    return *this;
  }
  inline PortBindError& operator=(PortBindError&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PortBindError& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PortBindError* internal_default_instance() {
    return reinterpret_cast<const PortBindError*>(
               &_PortBindError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PortBindError& a, PortBindError& b) {
    a.Swap(&b);
  }
  inline void Swap(PortBindError* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PortBindError* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PortBindError* New() const final {
    return CreateMaybeMessage<PortBindError>(nullptr);
  }

  PortBindError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PortBindError>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PortBindError& from);
  void MergeFrom(const PortBindError& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PortBindError* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "amun.PortBindError";
  }
  protected:
  explicit PortBindError(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_status_2eproto);
    return ::descriptor_table_status_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortFieldNumber = 1,
  };
  // required uint32 port = 1;
  bool has_port() const;
  private:
  bool _internal_has_port() const;
  public:
  void clear_port();
  ::PROTOBUF_NAMESPACE_ID::uint32 port() const;
  void set_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_port() const;
  void _internal_set_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:amun.PortBindError)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 port_;
  friend struct ::TableStruct_status_2eproto;
};
// -------------------------------------------------------------------

class OptionStatus PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:amun.OptionStatus) */ {
 public:
  inline OptionStatus() : OptionStatus(nullptr) {};
  virtual ~OptionStatus();

  OptionStatus(const OptionStatus& from);
  OptionStatus(OptionStatus&& from) noexcept
    : OptionStatus() {
    *this = ::std::move(from);
  }

  inline OptionStatus& operator=(const OptionStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline OptionStatus& operator=(OptionStatus&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OptionStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OptionStatus* internal_default_instance() {
    return reinterpret_cast<const OptionStatus*>(
               &_OptionStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(OptionStatus& a, OptionStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(OptionStatus* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OptionStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OptionStatus* New() const final {
    return CreateMaybeMessage<OptionStatus>(nullptr);
  }

  OptionStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OptionStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OptionStatus& from);
  void MergeFrom(const OptionStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OptionStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "amun.OptionStatus";
  }
  protected:
  explicit OptionStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_status_2eproto);
    return ::descriptor_table_status_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kValueFieldNumber = 3,
  };
  // required string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required bool value = 3;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  bool value() const;
  void set_value(bool value);
  private:
  bool _internal_value() const;
  void _internal_set_value(bool value);
  public:

  // @@protoc_insertion_point(class_scope:amun.OptionStatus)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  bool value_;
  friend struct ::TableStruct_status_2eproto;
};
// -------------------------------------------------------------------

class StatusGameController PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:amun.StatusGameController) */ {
 public:
  inline StatusGameController() : StatusGameController(nullptr) {};
  virtual ~StatusGameController();

  StatusGameController(const StatusGameController& from);
  StatusGameController(StatusGameController&& from) noexcept
    : StatusGameController() {
    *this = ::std::move(from);
  }

  inline StatusGameController& operator=(const StatusGameController& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusGameController& operator=(StatusGameController&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StatusGameController& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StatusGameController* internal_default_instance() {
    return reinterpret_cast<const StatusGameController*>(
               &_StatusGameController_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(StatusGameController& a, StatusGameController& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusGameController* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusGameController* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StatusGameController* New() const final {
    return CreateMaybeMessage<StatusGameController>(nullptr);
  }

  StatusGameController* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StatusGameController>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StatusGameController& from);
  void MergeFrom(const StatusGameController& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusGameController* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "amun.StatusGameController";
  }
  protected:
  explicit StatusGameController(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_status_2eproto);
    return ::descriptor_table_status_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef StatusGameController_GameControllerState GameControllerState;
  static constexpr GameControllerState STOPPED =
    StatusGameController_GameControllerState_STOPPED;
  static constexpr GameControllerState STARTING =
    StatusGameController_GameControllerState_STARTING;
  static constexpr GameControllerState RUNNING =
    StatusGameController_GameControllerState_RUNNING;
  static constexpr GameControllerState CRASHED =
    StatusGameController_GameControllerState_CRASHED;
  static constexpr GameControllerState NOT_RESPONDING =
    StatusGameController_GameControllerState_NOT_RESPONDING;
  static inline bool GameControllerState_IsValid(int value) {
    return StatusGameController_GameControllerState_IsValid(value);
  }
  static constexpr GameControllerState GameControllerState_MIN =
    StatusGameController_GameControllerState_GameControllerState_MIN;
  static constexpr GameControllerState GameControllerState_MAX =
    StatusGameController_GameControllerState_GameControllerState_MAX;
  static constexpr int GameControllerState_ARRAYSIZE =
    StatusGameController_GameControllerState_GameControllerState_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  GameControllerState_descriptor() {
    return StatusGameController_GameControllerState_descriptor();
  }
  template<typename T>
  static inline const std::string& GameControllerState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, GameControllerState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function GameControllerState_Name.");
    return StatusGameController_GameControllerState_Name(enum_t_value);
  }
  static inline bool GameControllerState_Parse(const std::string& name,
      GameControllerState* value) {
    return StatusGameController_GameControllerState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kCurrentStateFieldNumber = 1,
  };
  // optional .amun.StatusGameController.GameControllerState current_state = 1;
  bool has_current_state() const;
  private:
  bool _internal_has_current_state() const;
  public:
  void clear_current_state();
  ::amun::StatusGameController_GameControllerState current_state() const;
  void set_current_state(::amun::StatusGameController_GameControllerState value);
  private:
  ::amun::StatusGameController_GameControllerState _internal_current_state() const;
  void _internal_set_current_state(::amun::StatusGameController_GameControllerState value);
  public:

  // @@protoc_insertion_point(class_scope:amun.StatusGameController)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int current_state_;
  friend struct ::TableStruct_status_2eproto;
};
// -------------------------------------------------------------------

class StatusAmun PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:amun.StatusAmun) */ {
 public:
  inline StatusAmun() : StatusAmun(nullptr) {};
  virtual ~StatusAmun();

  StatusAmun(const StatusAmun& from);
  StatusAmun(StatusAmun&& from) noexcept
    : StatusAmun() {
    *this = ::std::move(from);
  }

  inline StatusAmun& operator=(const StatusAmun& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatusAmun& operator=(StatusAmun&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StatusAmun& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StatusAmun* internal_default_instance() {
    return reinterpret_cast<const StatusAmun*>(
               &_StatusAmun_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(StatusAmun& a, StatusAmun& b) {
    a.Swap(&b);
  }
  inline void Swap(StatusAmun* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatusAmun* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StatusAmun* New() const final {
    return CreateMaybeMessage<StatusAmun>(nullptr);
  }

  StatusAmun* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StatusAmun>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StatusAmun& from);
  void MergeFrom(const StatusAmun& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatusAmun* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "amun.StatusAmun";
  }
  protected:
  explicit StatusAmun(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_status_2eproto);
    return ::descriptor_table_status_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOptionsFieldNumber = 2,
    kPortBindErrorFieldNumber = 1,
    kGameControllerFieldNumber = 3,
  };
  // repeated .amun.OptionStatus options = 2;
  int options_size() const;
  private:
  int _internal_options_size() const;
  public:
  void clear_options();
  ::amun::OptionStatus* mutable_options(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::amun::OptionStatus >*
      mutable_options();
  private:
  const ::amun::OptionStatus& _internal_options(int index) const;
  ::amun::OptionStatus* _internal_add_options();
  public:
  const ::amun::OptionStatus& options(int index) const;
  ::amun::OptionStatus* add_options();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::amun::OptionStatus >&
      options() const;

  // optional .amun.PortBindError port_bind_error = 1;
  bool has_port_bind_error() const;
  private:
  bool _internal_has_port_bind_error() const;
  public:
  void clear_port_bind_error();
  const ::amun::PortBindError& port_bind_error() const;
  ::amun::PortBindError* release_port_bind_error();
  ::amun::PortBindError* mutable_port_bind_error();
  void set_allocated_port_bind_error(::amun::PortBindError* port_bind_error);
  private:
  const ::amun::PortBindError& _internal_port_bind_error() const;
  ::amun::PortBindError* _internal_mutable_port_bind_error();
  public:
  void unsafe_arena_set_allocated_port_bind_error(
      ::amun::PortBindError* port_bind_error);
  ::amun::PortBindError* unsafe_arena_release_port_bind_error();

  // optional .amun.StatusGameController game_controller = 3;
  bool has_game_controller() const;
  private:
  bool _internal_has_game_controller() const;
  public:
  void clear_game_controller();
  const ::amun::StatusGameController& game_controller() const;
  ::amun::StatusGameController* release_game_controller();
  ::amun::StatusGameController* mutable_game_controller();
  void set_allocated_game_controller(::amun::StatusGameController* game_controller);
  private:
  const ::amun::StatusGameController& _internal_game_controller() const;
  ::amun::StatusGameController* _internal_mutable_game_controller();
  public:
  void unsafe_arena_set_allocated_game_controller(
      ::amun::StatusGameController* game_controller);
  ::amun::StatusGameController* unsafe_arena_release_game_controller();

  // @@protoc_insertion_point(class_scope:amun.StatusAmun)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::amun::OptionStatus > options_;
  ::amun::PortBindError* port_bind_error_;
  ::amun::StatusGameController* game_controller_;
  friend struct ::TableStruct_status_2eproto;
};
// -------------------------------------------------------------------

class Status PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:amun.Status) */ {
 public:
  inline Status() : Status(nullptr) {};
  virtual ~Status();

  Status(const Status& from);
  Status(Status&& from) noexcept
    : Status() {
    *this = ::std::move(from);
  }

  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }
  inline Status& operator=(Status&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Status& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Status* internal_default_instance() {
    return reinterpret_cast<const Status*>(
               &_Status_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Status& a, Status& b) {
    a.Swap(&b);
  }
  inline void Swap(Status* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Status* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Status* New() const final {
    return CreateMaybeMessage<Status>(nullptr);
  }

  Status* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Status>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Status& from);
  void MergeFrom(const Status& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Status* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "amun.Status";
  }
  protected:
  explicit Status(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_status_2eproto);
    return ::descriptor_table_status_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDebugFieldNumber = 10,
    kRadioCommandFieldNumber = 12,
    kGitInfoFieldNumber = 31,
    kWorldStateFieldNumber = 3,
    kGeometryFieldNumber = 4,
    kTeamBlueFieldNumber = 5,
    kTeamYellowFieldNumber = 6,
    kStrategyBlueFieldNumber = 7,
    kStrategyYellowFieldNumber = 8,
    kTimingFieldNumber = 11,
    kTransceiverFieldNumber = 13,
    kGameStateFieldNumber = 15,
    kUserInputBlueFieldNumber = 16,
    kUserInputYellowFieldNumber = 17,
    kStrategyAutorefFieldNumber = 18,
    kAmunStateFieldNumber = 19,
    kExecutionStateFieldNumber = 23,
    kExecutionGameStateFieldNumber = 24,
    kExecutionUserInputFieldNumber = 25,
    kLogIdFieldNumber = 27,
    kStatusStrategyFieldNumber = 29,
    kPureUiResponseFieldNumber = 30,
    kTimeFieldNumber = 1,
    kTimerScalingFieldNumber = 20,
    kBlueRunningFieldNumber = 21,
    kYellowRunningFieldNumber = 22,
    kAutorefRunningFieldNumber = 26,
    kOriginalFrameNumberFieldNumber = 28,
  };
  // repeated .amun.DebugValues debug = 10;
  int debug_size() const;
  private:
  int _internal_debug_size() const;
  public:
  void clear_debug();
  ::amun::DebugValues* mutable_debug(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::amun::DebugValues >*
      mutable_debug();
  private:
  const ::amun::DebugValues& _internal_debug(int index) const;
  ::amun::DebugValues* _internal_add_debug();
  public:
  const ::amun::DebugValues& debug(int index) const;
  ::amun::DebugValues* add_debug();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::amun::DebugValues >&
      debug() const;

  // repeated .robot.RadioCommand radio_command = 12;
  int radio_command_size() const;
  private:
  int _internal_radio_command_size() const;
  public:
  void clear_radio_command();
  ::robot::RadioCommand* mutable_radio_command(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::RadioCommand >*
      mutable_radio_command();
  private:
  const ::robot::RadioCommand& _internal_radio_command(int index) const;
  ::robot::RadioCommand* _internal_add_radio_command();
  public:
  const ::robot::RadioCommand& radio_command(int index) const;
  ::robot::RadioCommand* add_radio_command();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::RadioCommand >&
      radio_command() const;

  // repeated .amun.GitInfo git_info = 31;
  int git_info_size() const;
  private:
  int _internal_git_info_size() const;
  public:
  void clear_git_info();
  ::amun::GitInfo* mutable_git_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::amun::GitInfo >*
      mutable_git_info();
  private:
  const ::amun::GitInfo& _internal_git_info(int index) const;
  ::amun::GitInfo* _internal_add_git_info();
  public:
  const ::amun::GitInfo& git_info(int index) const;
  ::amun::GitInfo* add_git_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::amun::GitInfo >&
      git_info() const;

  // optional .world.State world_state = 3;
  bool has_world_state() const;
  private:
  bool _internal_has_world_state() const;
  public:
  void clear_world_state();
  const ::world::State& world_state() const;
  ::world::State* release_world_state();
  ::world::State* mutable_world_state();
  void set_allocated_world_state(::world::State* world_state);
  private:
  const ::world::State& _internal_world_state() const;
  ::world::State* _internal_mutable_world_state();
  public:
  void unsafe_arena_set_allocated_world_state(
      ::world::State* world_state);
  ::world::State* unsafe_arena_release_world_state();

  // optional .world.Geometry geometry = 4;
  bool has_geometry() const;
  private:
  bool _internal_has_geometry() const;
  public:
  void clear_geometry();
  const ::world::Geometry& geometry() const;
  ::world::Geometry* release_geometry();
  ::world::Geometry* mutable_geometry();
  void set_allocated_geometry(::world::Geometry* geometry);
  private:
  const ::world::Geometry& _internal_geometry() const;
  ::world::Geometry* _internal_mutable_geometry();
  public:
  void unsafe_arena_set_allocated_geometry(
      ::world::Geometry* geometry);
  ::world::Geometry* unsafe_arena_release_geometry();

  // optional .robot.Team team_blue = 5;
  bool has_team_blue() const;
  private:
  bool _internal_has_team_blue() const;
  public:
  void clear_team_blue();
  const ::robot::Team& team_blue() const;
  ::robot::Team* release_team_blue();
  ::robot::Team* mutable_team_blue();
  void set_allocated_team_blue(::robot::Team* team_blue);
  private:
  const ::robot::Team& _internal_team_blue() const;
  ::robot::Team* _internal_mutable_team_blue();
  public:
  void unsafe_arena_set_allocated_team_blue(
      ::robot::Team* team_blue);
  ::robot::Team* unsafe_arena_release_team_blue();

  // optional .robot.Team team_yellow = 6;
  bool has_team_yellow() const;
  private:
  bool _internal_has_team_yellow() const;
  public:
  void clear_team_yellow();
  const ::robot::Team& team_yellow() const;
  ::robot::Team* release_team_yellow();
  ::robot::Team* mutable_team_yellow();
  void set_allocated_team_yellow(::robot::Team* team_yellow);
  private:
  const ::robot::Team& _internal_team_yellow() const;
  ::robot::Team* _internal_mutable_team_yellow();
  public:
  void unsafe_arena_set_allocated_team_yellow(
      ::robot::Team* team_yellow);
  ::robot::Team* unsafe_arena_release_team_yellow();

  // optional .amun.StatusStrategy strategy_blue = 7;
  bool has_strategy_blue() const;
  private:
  bool _internal_has_strategy_blue() const;
  public:
  void clear_strategy_blue();
  const ::amun::StatusStrategy& strategy_blue() const;
  ::amun::StatusStrategy* release_strategy_blue();
  ::amun::StatusStrategy* mutable_strategy_blue();
  void set_allocated_strategy_blue(::amun::StatusStrategy* strategy_blue);
  private:
  const ::amun::StatusStrategy& _internal_strategy_blue() const;
  ::amun::StatusStrategy* _internal_mutable_strategy_blue();
  public:
  void unsafe_arena_set_allocated_strategy_blue(
      ::amun::StatusStrategy* strategy_blue);
  ::amun::StatusStrategy* unsafe_arena_release_strategy_blue();

  // optional .amun.StatusStrategy strategy_yellow = 8;
  bool has_strategy_yellow() const;
  private:
  bool _internal_has_strategy_yellow() const;
  public:
  void clear_strategy_yellow();
  const ::amun::StatusStrategy& strategy_yellow() const;
  ::amun::StatusStrategy* release_strategy_yellow();
  ::amun::StatusStrategy* mutable_strategy_yellow();
  void set_allocated_strategy_yellow(::amun::StatusStrategy* strategy_yellow);
  private:
  const ::amun::StatusStrategy& _internal_strategy_yellow() const;
  ::amun::StatusStrategy* _internal_mutable_strategy_yellow();
  public:
  void unsafe_arena_set_allocated_strategy_yellow(
      ::amun::StatusStrategy* strategy_yellow);
  ::amun::StatusStrategy* unsafe_arena_release_strategy_yellow();

  // optional .amun.Timing timing = 11;
  bool has_timing() const;
  private:
  bool _internal_has_timing() const;
  public:
  void clear_timing();
  const ::amun::Timing& timing() const;
  ::amun::Timing* release_timing();
  ::amun::Timing* mutable_timing();
  void set_allocated_timing(::amun::Timing* timing);
  private:
  const ::amun::Timing& _internal_timing() const;
  ::amun::Timing* _internal_mutable_timing();
  public:
  void unsafe_arena_set_allocated_timing(
      ::amun::Timing* timing);
  ::amun::Timing* unsafe_arena_release_timing();

  // optional .amun.StatusTransceiver transceiver = 13;
  bool has_transceiver() const;
  private:
  bool _internal_has_transceiver() const;
  public:
  void clear_transceiver();
  const ::amun::StatusTransceiver& transceiver() const;
  ::amun::StatusTransceiver* release_transceiver();
  ::amun::StatusTransceiver* mutable_transceiver();
  void set_allocated_transceiver(::amun::StatusTransceiver* transceiver);
  private:
  const ::amun::StatusTransceiver& _internal_transceiver() const;
  ::amun::StatusTransceiver* _internal_mutable_transceiver();
  public:
  void unsafe_arena_set_allocated_transceiver(
      ::amun::StatusTransceiver* transceiver);
  ::amun::StatusTransceiver* unsafe_arena_release_transceiver();

  // optional .amun.GameState game_state = 15;
  bool has_game_state() const;
  private:
  bool _internal_has_game_state() const;
  public:
  void clear_game_state();
  const ::amun::GameState& game_state() const;
  ::amun::GameState* release_game_state();
  ::amun::GameState* mutable_game_state();
  void set_allocated_game_state(::amun::GameState* game_state);
  private:
  const ::amun::GameState& _internal_game_state() const;
  ::amun::GameState* _internal_mutable_game_state();
  public:
  void unsafe_arena_set_allocated_game_state(
      ::amun::GameState* game_state);
  ::amun::GameState* unsafe_arena_release_game_state();

  // optional .amun.UserInput user_input_blue = 16;
  bool has_user_input_blue() const;
  private:
  bool _internal_has_user_input_blue() const;
  public:
  void clear_user_input_blue();
  const ::amun::UserInput& user_input_blue() const;
  ::amun::UserInput* release_user_input_blue();
  ::amun::UserInput* mutable_user_input_blue();
  void set_allocated_user_input_blue(::amun::UserInput* user_input_blue);
  private:
  const ::amun::UserInput& _internal_user_input_blue() const;
  ::amun::UserInput* _internal_mutable_user_input_blue();
  public:
  void unsafe_arena_set_allocated_user_input_blue(
      ::amun::UserInput* user_input_blue);
  ::amun::UserInput* unsafe_arena_release_user_input_blue();

  // optional .amun.UserInput user_input_yellow = 17;
  bool has_user_input_yellow() const;
  private:
  bool _internal_has_user_input_yellow() const;
  public:
  void clear_user_input_yellow();
  const ::amun::UserInput& user_input_yellow() const;
  ::amun::UserInput* release_user_input_yellow();
  ::amun::UserInput* mutable_user_input_yellow();
  void set_allocated_user_input_yellow(::amun::UserInput* user_input_yellow);
  private:
  const ::amun::UserInput& _internal_user_input_yellow() const;
  ::amun::UserInput* _internal_mutable_user_input_yellow();
  public:
  void unsafe_arena_set_allocated_user_input_yellow(
      ::amun::UserInput* user_input_yellow);
  ::amun::UserInput* unsafe_arena_release_user_input_yellow();

  // optional .amun.StatusStrategy strategy_autoref = 18;
  bool has_strategy_autoref() const;
  private:
  bool _internal_has_strategy_autoref() const;
  public:
  void clear_strategy_autoref();
  const ::amun::StatusStrategy& strategy_autoref() const;
  ::amun::StatusStrategy* release_strategy_autoref();
  ::amun::StatusStrategy* mutable_strategy_autoref();
  void set_allocated_strategy_autoref(::amun::StatusStrategy* strategy_autoref);
  private:
  const ::amun::StatusStrategy& _internal_strategy_autoref() const;
  ::amun::StatusStrategy* _internal_mutable_strategy_autoref();
  public:
  void unsafe_arena_set_allocated_strategy_autoref(
      ::amun::StatusStrategy* strategy_autoref);
  ::amun::StatusStrategy* unsafe_arena_release_strategy_autoref();

  // optional .amun.StatusAmun amun_state = 19;
  bool has_amun_state() const;
  private:
  bool _internal_has_amun_state() const;
  public:
  void clear_amun_state();
  const ::amun::StatusAmun& amun_state() const;
  ::amun::StatusAmun* release_amun_state();
  ::amun::StatusAmun* mutable_amun_state();
  void set_allocated_amun_state(::amun::StatusAmun* amun_state);
  private:
  const ::amun::StatusAmun& _internal_amun_state() const;
  ::amun::StatusAmun* _internal_mutable_amun_state();
  public:
  void unsafe_arena_set_allocated_amun_state(
      ::amun::StatusAmun* amun_state);
  ::amun::StatusAmun* unsafe_arena_release_amun_state();

  // optional .world.State execution_state = 23;
  bool has_execution_state() const;
  private:
  bool _internal_has_execution_state() const;
  public:
  void clear_execution_state();
  const ::world::State& execution_state() const;
  ::world::State* release_execution_state();
  ::world::State* mutable_execution_state();
  void set_allocated_execution_state(::world::State* execution_state);
  private:
  const ::world::State& _internal_execution_state() const;
  ::world::State* _internal_mutable_execution_state();
  public:
  void unsafe_arena_set_allocated_execution_state(
      ::world::State* execution_state);
  ::world::State* unsafe_arena_release_execution_state();

  // optional .amun.GameState execution_game_state = 24;
  bool has_execution_game_state() const;
  private:
  bool _internal_has_execution_game_state() const;
  public:
  void clear_execution_game_state();
  const ::amun::GameState& execution_game_state() const;
  ::amun::GameState* release_execution_game_state();
  ::amun::GameState* mutable_execution_game_state();
  void set_allocated_execution_game_state(::amun::GameState* execution_game_state);
  private:
  const ::amun::GameState& _internal_execution_game_state() const;
  ::amun::GameState* _internal_mutable_execution_game_state();
  public:
  void unsafe_arena_set_allocated_execution_game_state(
      ::amun::GameState* execution_game_state);
  ::amun::GameState* unsafe_arena_release_execution_game_state();

  // optional .amun.UserInput execution_user_input = 25;
  bool has_execution_user_input() const;
  private:
  bool _internal_has_execution_user_input() const;
  public:
  void clear_execution_user_input();
  const ::amun::UserInput& execution_user_input() const;
  ::amun::UserInput* release_execution_user_input();
  ::amun::UserInput* mutable_execution_user_input();
  void set_allocated_execution_user_input(::amun::UserInput* execution_user_input);
  private:
  const ::amun::UserInput& _internal_execution_user_input() const;
  ::amun::UserInput* _internal_mutable_execution_user_input();
  public:
  void unsafe_arena_set_allocated_execution_user_input(
      ::amun::UserInput* execution_user_input);
  ::amun::UserInput* unsafe_arena_release_execution_user_input();

  // optional .logfile.Uid log_id = 27;
  bool has_log_id() const;
  private:
  bool _internal_has_log_id() const;
  public:
  void clear_log_id();
  const ::logfile::Uid& log_id() const;
  ::logfile::Uid* release_log_id();
  ::logfile::Uid* mutable_log_id();
  void set_allocated_log_id(::logfile::Uid* log_id);
  private:
  const ::logfile::Uid& _internal_log_id() const;
  ::logfile::Uid* _internal_mutable_log_id();
  public:
  void unsafe_arena_set_allocated_log_id(
      ::logfile::Uid* log_id);
  ::logfile::Uid* unsafe_arena_release_log_id();

  // optional .amun.StatusStrategyWrapper status_strategy = 29;
  bool has_status_strategy() const;
  private:
  bool _internal_has_status_strategy() const;
  public:
  void clear_status_strategy();
  const ::amun::StatusStrategyWrapper& status_strategy() const;
  ::amun::StatusStrategyWrapper* release_status_strategy();
  ::amun::StatusStrategyWrapper* mutable_status_strategy();
  void set_allocated_status_strategy(::amun::StatusStrategyWrapper* status_strategy);
  private:
  const ::amun::StatusStrategyWrapper& _internal_status_strategy() const;
  ::amun::StatusStrategyWrapper* _internal_mutable_status_strategy();
  public:
  void unsafe_arena_set_allocated_status_strategy(
      ::amun::StatusStrategyWrapper* status_strategy);
  ::amun::StatusStrategyWrapper* unsafe_arena_release_status_strategy();

  // optional .amun.UiResponse pure_ui_response = 30;
  bool has_pure_ui_response() const;
  private:
  bool _internal_has_pure_ui_response() const;
  public:
  void clear_pure_ui_response();
  const ::amun::UiResponse& pure_ui_response() const;
  ::amun::UiResponse* release_pure_ui_response();
  ::amun::UiResponse* mutable_pure_ui_response();
  void set_allocated_pure_ui_response(::amun::UiResponse* pure_ui_response);
  private:
  const ::amun::UiResponse& _internal_pure_ui_response() const;
  ::amun::UiResponse* _internal_mutable_pure_ui_response();
  public:
  void unsafe_arena_set_allocated_pure_ui_response(
      ::amun::UiResponse* pure_ui_response);
  ::amun::UiResponse* unsafe_arena_release_pure_ui_response();

  // required int64 time = 1;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  ::PROTOBUF_NAMESPACE_ID::int64 time() const;
  void set_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_time() const;
  void _internal_set_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional float timer_scaling = 20;
  bool has_timer_scaling() const;
  private:
  bool _internal_has_timer_scaling() const;
  public:
  void clear_timer_scaling();
  float timer_scaling() const;
  void set_timer_scaling(float value);
  private:
  float _internal_timer_scaling() const;
  void _internal_set_timer_scaling(float value);
  public:

  // optional bool blue_running = 21;
  bool has_blue_running() const;
  private:
  bool _internal_has_blue_running() const;
  public:
  void clear_blue_running();
  bool blue_running() const;
  void set_blue_running(bool value);
  private:
  bool _internal_blue_running() const;
  void _internal_set_blue_running(bool value);
  public:

  // optional bool yellow_running = 22;
  bool has_yellow_running() const;
  private:
  bool _internal_has_yellow_running() const;
  public:
  void clear_yellow_running();
  bool yellow_running() const;
  void set_yellow_running(bool value);
  private:
  bool _internal_yellow_running() const;
  void _internal_set_yellow_running(bool value);
  public:

  // optional bool autoref_running = 26;
  bool has_autoref_running() const;
  private:
  bool _internal_has_autoref_running() const;
  public:
  void clear_autoref_running();
  bool autoref_running() const;
  void set_autoref_running(bool value);
  private:
  bool _internal_autoref_running() const;
  void _internal_set_autoref_running(bool value);
  public:

  // optional uint64 original_frame_number = 28;
  bool has_original_frame_number() const;
  private:
  bool _internal_has_original_frame_number() const;
  public:
  void clear_original_frame_number();
  ::PROTOBUF_NAMESPACE_ID::uint64 original_frame_number() const;
  void set_original_frame_number(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_original_frame_number() const;
  void _internal_set_original_frame_number(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:amun.Status)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::amun::DebugValues > debug_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::RadioCommand > radio_command_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::amun::GitInfo > git_info_;
  ::world::State* world_state_;
  ::world::Geometry* geometry_;
  ::robot::Team* team_blue_;
  ::robot::Team* team_yellow_;
  ::amun::StatusStrategy* strategy_blue_;
  ::amun::StatusStrategy* strategy_yellow_;
  ::amun::Timing* timing_;
  ::amun::StatusTransceiver* transceiver_;
  ::amun::GameState* game_state_;
  ::amun::UserInput* user_input_blue_;
  ::amun::UserInput* user_input_yellow_;
  ::amun::StatusStrategy* strategy_autoref_;
  ::amun::StatusAmun* amun_state_;
  ::world::State* execution_state_;
  ::amun::GameState* execution_game_state_;
  ::amun::UserInput* execution_user_input_;
  ::logfile::Uid* log_id_;
  ::amun::StatusStrategyWrapper* status_strategy_;
  ::amun::UiResponse* pure_ui_response_;
  ::PROTOBUF_NAMESPACE_ID::int64 time_;
  float timer_scaling_;
  bool blue_running_;
  bool yellow_running_;
  bool autoref_running_;
  ::PROTOBUF_NAMESPACE_ID::uint64 original_frame_number_;
  friend struct ::TableStruct_status_2eproto;
};
// -------------------------------------------------------------------

class UiResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:amun.UiResponse) */ {
 public:
  inline UiResponse() : UiResponse(nullptr) {};
  virtual ~UiResponse();

  UiResponse(const UiResponse& from);
  UiResponse(UiResponse&& from) noexcept
    : UiResponse() {
    *this = ::std::move(from);
  }

  inline UiResponse& operator=(const UiResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UiResponse& operator=(UiResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UiResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UiResponse* internal_default_instance() {
    return reinterpret_cast<const UiResponse*>(
               &_UiResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(UiResponse& a, UiResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UiResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UiResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UiResponse* New() const final {
    return CreateMaybeMessage<UiResponse>(nullptr);
  }

  UiResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UiResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UiResponse& from);
  void MergeFrom(const UiResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UiResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "amun.UiResponse";
  }
  protected:
  explicit UiResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_status_2eproto);
    return ::descriptor_table_status_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLoggerStatusFieldNumber = 3,
    kExportVisionlogErrorFieldNumber = 10,
    kRequestedLogUidFieldNumber = 11,
    kLogUidParserErrorFieldNumber = 13,
    kLoggingInfoFieldNumber = 2,
    kLogInfoFieldNumber = 6,
    kLogOpenFieldNumber = 9,
    kLogOffersFieldNumber = 12,
    kFrameNumberFieldNumber = 7,
    kEnableLoggingFieldNumber = 1,
    kPlaybackBurstEndFieldNumber = 4,
    kPlaybackPausedFieldNumber = 5,
    kForceRaHorusFieldNumber = 8,
  };
  // repeated .amun.Status logger_status = 3;
  int logger_status_size() const;
  private:
  int _internal_logger_status_size() const;
  public:
  void clear_logger_status();
  ::amun::Status* mutable_logger_status(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::amun::Status >*
      mutable_logger_status();
  private:
  const ::amun::Status& _internal_logger_status(int index) const;
  ::amun::Status* _internal_add_logger_status();
  public:
  const ::amun::Status& logger_status(int index) const;
  ::amun::Status* add_logger_status();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::amun::Status >&
      logger_status() const;

  // optional string export_visionlog_error = 10;
  bool has_export_visionlog_error() const;
  private:
  bool _internal_has_export_visionlog_error() const;
  public:
  void clear_export_visionlog_error();
  const std::string& export_visionlog_error() const;
  void set_export_visionlog_error(const std::string& value);
  void set_export_visionlog_error(std::string&& value);
  void set_export_visionlog_error(const char* value);
  void set_export_visionlog_error(const char* value, size_t size);
  std::string* mutable_export_visionlog_error();
  std::string* release_export_visionlog_error();
  void set_allocated_export_visionlog_error(std::string* export_visionlog_error);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_export_visionlog_error();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_export_visionlog_error(
      std::string* export_visionlog_error);
  private:
  const std::string& _internal_export_visionlog_error() const;
  void _internal_set_export_visionlog_error(const std::string& value);
  std::string* _internal_mutable_export_visionlog_error();
  public:

  // optional string requested_log_uid = 11;
  bool has_requested_log_uid() const;
  private:
  bool _internal_has_requested_log_uid() const;
  public:
  void clear_requested_log_uid();
  const std::string& requested_log_uid() const;
  void set_requested_log_uid(const std::string& value);
  void set_requested_log_uid(std::string&& value);
  void set_requested_log_uid(const char* value);
  void set_requested_log_uid(const char* value, size_t size);
  std::string* mutable_requested_log_uid();
  std::string* release_requested_log_uid();
  void set_allocated_requested_log_uid(std::string* requested_log_uid);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_requested_log_uid();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_requested_log_uid(
      std::string* requested_log_uid);
  private:
  const std::string& _internal_requested_log_uid() const;
  void _internal_set_requested_log_uid(const std::string& value);
  std::string* _internal_mutable_requested_log_uid();
  public:

  // optional string log_uid_parser_error = 13;
  bool has_log_uid_parser_error() const;
  private:
  bool _internal_has_log_uid_parser_error() const;
  public:
  void clear_log_uid_parser_error();
  const std::string& log_uid_parser_error() const;
  void set_log_uid_parser_error(const std::string& value);
  void set_log_uid_parser_error(std::string&& value);
  void set_log_uid_parser_error(const char* value);
  void set_log_uid_parser_error(const char* value, size_t size);
  std::string* mutable_log_uid_parser_error();
  std::string* release_log_uid_parser_error();
  void set_allocated_log_uid_parser_error(std::string* log_uid_parser_error);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_log_uid_parser_error();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_log_uid_parser_error(
      std::string* log_uid_parser_error);
  private:
  const std::string& _internal_log_uid_parser_error() const;
  void _internal_set_log_uid_parser_error(const std::string& value);
  std::string* _internal_mutable_log_uid_parser_error();
  public:

  // optional .amun.LoggingInfo logging_info = 2;
  bool has_logging_info() const;
  private:
  bool _internal_has_logging_info() const;
  public:
  void clear_logging_info();
  const ::amun::LoggingInfo& logging_info() const;
  ::amun::LoggingInfo* release_logging_info();
  ::amun::LoggingInfo* mutable_logging_info();
  void set_allocated_logging_info(::amun::LoggingInfo* logging_info);
  private:
  const ::amun::LoggingInfo& _internal_logging_info() const;
  ::amun::LoggingInfo* _internal_mutable_logging_info();
  public:
  void unsafe_arena_set_allocated_logging_info(
      ::amun::LoggingInfo* logging_info);
  ::amun::LoggingInfo* unsafe_arena_release_logging_info();

  // optional .amun.LogPlaybackInfo log_info = 6;
  bool has_log_info() const;
  private:
  bool _internal_has_log_info() const;
  public:
  void clear_log_info();
  const ::amun::LogPlaybackInfo& log_info() const;
  ::amun::LogPlaybackInfo* release_log_info();
  ::amun::LogPlaybackInfo* mutable_log_info();
  void set_allocated_log_info(::amun::LogPlaybackInfo* log_info);
  private:
  const ::amun::LogPlaybackInfo& _internal_log_info() const;
  ::amun::LogPlaybackInfo* _internal_mutable_log_info();
  public:
  void unsafe_arena_set_allocated_log_info(
      ::amun::LogPlaybackInfo* log_info);
  ::amun::LogPlaybackInfo* unsafe_arena_release_log_info();

  // optional .amun.LogfileOpenInfo log_open = 9;
  bool has_log_open() const;
  private:
  bool _internal_has_log_open() const;
  public:
  void clear_log_open();
  const ::amun::LogfileOpenInfo& log_open() const;
  ::amun::LogfileOpenInfo* release_log_open();
  ::amun::LogfileOpenInfo* mutable_log_open();
  void set_allocated_log_open(::amun::LogfileOpenInfo* log_open);
  private:
  const ::amun::LogfileOpenInfo& _internal_log_open() const;
  ::amun::LogfileOpenInfo* _internal_mutable_log_open();
  public:
  void unsafe_arena_set_allocated_log_open(
      ::amun::LogfileOpenInfo* log_open);
  ::amun::LogfileOpenInfo* unsafe_arena_release_log_open();

  // optional .logfile.LogOffer log_offers = 12;
  bool has_log_offers() const;
  private:
  bool _internal_has_log_offers() const;
  public:
  void clear_log_offers();
  const ::logfile::LogOffer& log_offers() const;
  ::logfile::LogOffer* release_log_offers();
  ::logfile::LogOffer* mutable_log_offers();
  void set_allocated_log_offers(::logfile::LogOffer* log_offers);
  private:
  const ::logfile::LogOffer& _internal_log_offers() const;
  ::logfile::LogOffer* _internal_mutable_log_offers();
  public:
  void unsafe_arena_set_allocated_log_offers(
      ::logfile::LogOffer* log_offers);
  ::logfile::LogOffer* unsafe_arena_release_log_offers();

  // optional int64 frame_number = 7;
  bool has_frame_number() const;
  private:
  bool _internal_has_frame_number() const;
  public:
  void clear_frame_number();
  ::PROTOBUF_NAMESPACE_ID::int64 frame_number() const;
  void set_frame_number(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_frame_number() const;
  void _internal_set_frame_number(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional bool enable_logging = 1;
  bool has_enable_logging() const;
  private:
  bool _internal_has_enable_logging() const;
  public:
  void clear_enable_logging();
  bool enable_logging() const;
  void set_enable_logging(bool value);
  private:
  bool _internal_enable_logging() const;
  void _internal_set_enable_logging(bool value);
  public:

  // optional bool playback_burst_end = 4;
  bool has_playback_burst_end() const;
  private:
  bool _internal_has_playback_burst_end() const;
  public:
  void clear_playback_burst_end();
  bool playback_burst_end() const;
  void set_playback_burst_end(bool value);
  private:
  bool _internal_playback_burst_end() const;
  void _internal_set_playback_burst_end(bool value);
  public:

  // optional bool playback_paused = 5;
  bool has_playback_paused() const;
  private:
  bool _internal_has_playback_paused() const;
  public:
  void clear_playback_paused();
  bool playback_paused() const;
  void set_playback_paused(bool value);
  private:
  bool _internal_playback_paused() const;
  void _internal_set_playback_paused(bool value);
  public:

  // optional bool force_ra_horus = 8;
  bool has_force_ra_horus() const;
  private:
  bool _internal_has_force_ra_horus() const;
  public:
  void clear_force_ra_horus();
  bool force_ra_horus() const;
  void set_force_ra_horus(bool value);
  private:
  bool _internal_force_ra_horus() const;
  void _internal_set_force_ra_horus(bool value);
  public:

  // @@protoc_insertion_point(class_scope:amun.UiResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::amun::Status > logger_status_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr export_visionlog_error_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr requested_log_uid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr log_uid_parser_error_;
  ::amun::LoggingInfo* logging_info_;
  ::amun::LogPlaybackInfo* log_info_;
  ::amun::LogfileOpenInfo* log_open_;
  ::logfile::LogOffer* log_offers_;
  ::PROTOBUF_NAMESPACE_ID::int64 frame_number_;
  bool enable_logging_;
  bool playback_burst_end_;
  bool playback_paused_;
  bool force_ra_horus_;
  friend struct ::TableStruct_status_2eproto;
};
// -------------------------------------------------------------------

class LoggingInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:amun.LoggingInfo) */ {
 public:
  inline LoggingInfo() : LoggingInfo(nullptr) {};
  virtual ~LoggingInfo();

  LoggingInfo(const LoggingInfo& from);
  LoggingInfo(LoggingInfo&& from) noexcept
    : LoggingInfo() {
    *this = ::std::move(from);
  }

  inline LoggingInfo& operator=(const LoggingInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoggingInfo& operator=(LoggingInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LoggingInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoggingInfo* internal_default_instance() {
    return reinterpret_cast<const LoggingInfo*>(
               &_LoggingInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(LoggingInfo& a, LoggingInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(LoggingInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoggingInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LoggingInfo* New() const final {
    return CreateMaybeMessage<LoggingInfo>(nullptr);
  }

  LoggingInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LoggingInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LoggingInfo& from);
  void MergeFrom(const LoggingInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoggingInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "amun.LoggingInfo";
  }
  protected:
  explicit LoggingInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_status_2eproto);
    return ::descriptor_table_status_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsLoggingFieldNumber = 1,
    kIsReplayLoggerFieldNumber = 2,
  };
  // required bool is_logging = 1;
  bool has_is_logging() const;
  private:
  bool _internal_has_is_logging() const;
  public:
  void clear_is_logging();
  bool is_logging() const;
  void set_is_logging(bool value);
  private:
  bool _internal_is_logging() const;
  void _internal_set_is_logging(bool value);
  public:

  // required bool is_replay_logger = 2;
  bool has_is_replay_logger() const;
  private:
  bool _internal_has_is_replay_logger() const;
  public:
  void clear_is_replay_logger();
  bool is_replay_logger() const;
  void set_is_replay_logger(bool value);
  private:
  bool _internal_is_replay_logger() const;
  void _internal_set_is_replay_logger(bool value);
  public:

  // @@protoc_insertion_point(class_scope:amun.LoggingInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool is_logging_;
  bool is_replay_logger_;
  friend struct ::TableStruct_status_2eproto;
};
// -------------------------------------------------------------------

class LogPlaybackInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:amun.LogPlaybackInfo) */ {
 public:
  inline LogPlaybackInfo() : LogPlaybackInfo(nullptr) {};
  virtual ~LogPlaybackInfo();

  LogPlaybackInfo(const LogPlaybackInfo& from);
  LogPlaybackInfo(LogPlaybackInfo&& from) noexcept
    : LogPlaybackInfo() {
    *this = ::std::move(from);
  }

  inline LogPlaybackInfo& operator=(const LogPlaybackInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogPlaybackInfo& operator=(LogPlaybackInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LogPlaybackInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogPlaybackInfo* internal_default_instance() {
    return reinterpret_cast<const LogPlaybackInfo*>(
               &_LogPlaybackInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(LogPlaybackInfo& a, LogPlaybackInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(LogPlaybackInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogPlaybackInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LogPlaybackInfo* New() const final {
    return CreateMaybeMessage<LogPlaybackInfo>(nullptr);
  }

  LogPlaybackInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LogPlaybackInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LogPlaybackInfo& from);
  void MergeFrom(const LogPlaybackInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogPlaybackInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "amun.LogPlaybackInfo";
  }
  protected:
  explicit LogPlaybackInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_status_2eproto);
    return ::descriptor_table_status_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartTimeFieldNumber = 1,
    kDurationFieldNumber = 2,
    kPacketCountFieldNumber = 3,
  };
  // required int64 start_time = 1;
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  ::PROTOBUF_NAMESPACE_ID::int64 start_time() const;
  void set_start_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_start_time() const;
  void _internal_set_start_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required int64 duration = 2;
  bool has_duration() const;
  private:
  bool _internal_has_duration() const;
  public:
  void clear_duration();
  ::PROTOBUF_NAMESPACE_ID::int64 duration() const;
  void set_duration(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_duration() const;
  void _internal_set_duration(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required int64 packet_count = 3;
  bool has_packet_count() const;
  private:
  bool _internal_has_packet_count() const;
  public:
  void clear_packet_count();
  ::PROTOBUF_NAMESPACE_ID::int64 packet_count() const;
  void set_packet_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_packet_count() const;
  void _internal_set_packet_count(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:amun.LogPlaybackInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 start_time_;
  ::PROTOBUF_NAMESPACE_ID::int64 duration_;
  ::PROTOBUF_NAMESPACE_ID::int64 packet_count_;
  friend struct ::TableStruct_status_2eproto;
};
// -------------------------------------------------------------------

class LogfileOpenInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:amun.LogfileOpenInfo) */ {
 public:
  inline LogfileOpenInfo() : LogfileOpenInfo(nullptr) {};
  virtual ~LogfileOpenInfo();

  LogfileOpenInfo(const LogfileOpenInfo& from);
  LogfileOpenInfo(LogfileOpenInfo&& from) noexcept
    : LogfileOpenInfo() {
    *this = ::std::move(from);
  }

  inline LogfileOpenInfo& operator=(const LogfileOpenInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogfileOpenInfo& operator=(LogfileOpenInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LogfileOpenInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogfileOpenInfo* internal_default_instance() {
    return reinterpret_cast<const LogfileOpenInfo*>(
               &_LogfileOpenInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(LogfileOpenInfo& a, LogfileOpenInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(LogfileOpenInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogfileOpenInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LogfileOpenInfo* New() const final {
    return CreateMaybeMessage<LogfileOpenInfo>(nullptr);
  }

  LogfileOpenInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LogfileOpenInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LogfileOpenInfo& from);
  void MergeFrom(const LogfileOpenInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogfileOpenInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "amun.LogfileOpenInfo";
  }
  protected:
  explicit LogfileOpenInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_status_2eproto);
    return ::descriptor_table_status_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilenameFieldNumber = 2,
    kSuccessFieldNumber = 1,
  };
  // required string filename = 2;
  bool has_filename() const;
  private:
  bool _internal_has_filename() const;
  public:
  void clear_filename();
  const std::string& filename() const;
  void set_filename(const std::string& value);
  void set_filename(std::string&& value);
  void set_filename(const char* value);
  void set_filename(const char* value, size_t size);
  std::string* mutable_filename();
  std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_filename();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_filename(
      std::string* filename);
  private:
  const std::string& _internal_filename() const;
  void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // required bool success = 1;
  bool has_success() const;
  private:
  bool _internal_has_success() const;
  public:
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:amun.LogfileOpenInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
  bool success_;
  friend struct ::TableStruct_status_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// StrategyOption

// required string name = 1;
inline bool StrategyOption::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StrategyOption::has_name() const {
  return _internal_has_name();
}
inline void StrategyOption::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StrategyOption::name() const {
  // @@protoc_insertion_point(field_get:amun.StrategyOption.name)
  return _internal_name();
}
inline void StrategyOption::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:amun.StrategyOption.name)
}
inline std::string* StrategyOption::mutable_name() {
  // @@protoc_insertion_point(field_mutable:amun.StrategyOption.name)
  return _internal_mutable_name();
}
inline const std::string& StrategyOption::_internal_name() const {
  return name_.Get();
}
inline void StrategyOption::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void StrategyOption::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:amun.StrategyOption.name)
}
inline void StrategyOption::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:amun.StrategyOption.name)
}
inline void StrategyOption::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:amun.StrategyOption.name)
}
inline std::string* StrategyOption::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* StrategyOption::release_name() {
  // @@protoc_insertion_point(field_release:amun.StrategyOption.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void StrategyOption::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:amun.StrategyOption.name)
}
inline std::string* StrategyOption::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:amun.StrategyOption.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void StrategyOption::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.StrategyOption.name)
}

// optional bool default_value = 2;
inline bool StrategyOption::_internal_has_default_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StrategyOption::has_default_value() const {
  return _internal_has_default_value();
}
inline void StrategyOption::clear_default_value() {
  default_value_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool StrategyOption::_internal_default_value() const {
  return default_value_;
}
inline bool StrategyOption::default_value() const {
  // @@protoc_insertion_point(field_get:amun.StrategyOption.default_value)
  return _internal_default_value();
}
inline void StrategyOption::_internal_set_default_value(bool value) {
  _has_bits_[0] |= 0x00000002u;
  default_value_ = value;
}
inline void StrategyOption::set_default_value(bool value) {
  _internal_set_default_value(value);
  // @@protoc_insertion_point(field_set:amun.StrategyOption.default_value)
}

// -------------------------------------------------------------------

// StatusStrategy

// required .amun.StatusStrategy.STATE state = 1;
inline bool StatusStrategy::_internal_has_state() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool StatusStrategy::has_state() const {
  return _internal_has_state();
}
inline void StatusStrategy::clear_state() {
  state_ = 1;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::amun::StatusStrategy_STATE StatusStrategy::_internal_state() const {
  return static_cast< ::amun::StatusStrategy_STATE >(state_);
}
inline ::amun::StatusStrategy_STATE StatusStrategy::state() const {
  // @@protoc_insertion_point(field_get:amun.StatusStrategy.state)
  return _internal_state();
}
inline void StatusStrategy::_internal_set_state(::amun::StatusStrategy_STATE value) {
  assert(::amun::StatusStrategy_STATE_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  state_ = value;
}
inline void StatusStrategy::set_state(::amun::StatusStrategy_STATE value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:amun.StatusStrategy.state)
}

// optional string filename = 2;
inline bool StatusStrategy::_internal_has_filename() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StatusStrategy::has_filename() const {
  return _internal_has_filename();
}
inline void StatusStrategy::clear_filename() {
  filename_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StatusStrategy::filename() const {
  // @@protoc_insertion_point(field_get:amun.StatusStrategy.filename)
  return _internal_filename();
}
inline void StatusStrategy::set_filename(const std::string& value) {
  _internal_set_filename(value);
  // @@protoc_insertion_point(field_set:amun.StatusStrategy.filename)
}
inline std::string* StatusStrategy::mutable_filename() {
  // @@protoc_insertion_point(field_mutable:amun.StatusStrategy.filename)
  return _internal_mutable_filename();
}
inline const std::string& StatusStrategy::_internal_filename() const {
  return filename_.Get();
}
inline void StatusStrategy::_internal_set_filename(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  filename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void StatusStrategy::set_filename(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  filename_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:amun.StatusStrategy.filename)
}
inline void StatusStrategy::set_filename(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  filename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:amun.StatusStrategy.filename)
}
inline void StatusStrategy::set_filename(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  filename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:amun.StatusStrategy.filename)
}
inline std::string* StatusStrategy::_internal_mutable_filename() {
  _has_bits_[0] |= 0x00000001u;
  return filename_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* StatusStrategy::release_filename() {
  // @@protoc_insertion_point(field_release:amun.StatusStrategy.filename)
  if (!_internal_has_filename()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return filename_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void StatusStrategy::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  filename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filename,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:amun.StatusStrategy.filename)
}
inline std::string* StatusStrategy::unsafe_arena_release_filename() {
  // @@protoc_insertion_point(field_unsafe_arena_release:amun.StatusStrategy.filename)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return filename_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void StatusStrategy::unsafe_arena_set_allocated_filename(
    std::string* filename) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (filename != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  filename_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      filename, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.StatusStrategy.filename)
}

// optional string name = 3;
inline bool StatusStrategy::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StatusStrategy::has_name() const {
  return _internal_has_name();
}
inline void StatusStrategy::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StatusStrategy::name() const {
  // @@protoc_insertion_point(field_get:amun.StatusStrategy.name)
  return _internal_name();
}
inline void StatusStrategy::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:amun.StatusStrategy.name)
}
inline std::string* StatusStrategy::mutable_name() {
  // @@protoc_insertion_point(field_mutable:amun.StatusStrategy.name)
  return _internal_mutable_name();
}
inline const std::string& StatusStrategy::_internal_name() const {
  return name_.Get();
}
inline void StatusStrategy::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void StatusStrategy::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:amun.StatusStrategy.name)
}
inline void StatusStrategy::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:amun.StatusStrategy.name)
}
inline void StatusStrategy::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:amun.StatusStrategy.name)
}
inline std::string* StatusStrategy::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000002u;
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* StatusStrategy::release_name() {
  // @@protoc_insertion_point(field_release:amun.StatusStrategy.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void StatusStrategy::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:amun.StatusStrategy.name)
}
inline std::string* StatusStrategy::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:amun.StatusStrategy.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void StatusStrategy::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.StatusStrategy.name)
}

// optional string current_entry_point = 4;
inline bool StatusStrategy::_internal_has_current_entry_point() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StatusStrategy::has_current_entry_point() const {
  return _internal_has_current_entry_point();
}
inline void StatusStrategy::clear_current_entry_point() {
  current_entry_point_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& StatusStrategy::current_entry_point() const {
  // @@protoc_insertion_point(field_get:amun.StatusStrategy.current_entry_point)
  return _internal_current_entry_point();
}
inline void StatusStrategy::set_current_entry_point(const std::string& value) {
  _internal_set_current_entry_point(value);
  // @@protoc_insertion_point(field_set:amun.StatusStrategy.current_entry_point)
}
inline std::string* StatusStrategy::mutable_current_entry_point() {
  // @@protoc_insertion_point(field_mutable:amun.StatusStrategy.current_entry_point)
  return _internal_mutable_current_entry_point();
}
inline const std::string& StatusStrategy::_internal_current_entry_point() const {
  return current_entry_point_.Get();
}
inline void StatusStrategy::_internal_set_current_entry_point(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  current_entry_point_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void StatusStrategy::set_current_entry_point(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  current_entry_point_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:amun.StatusStrategy.current_entry_point)
}
inline void StatusStrategy::set_current_entry_point(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  current_entry_point_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:amun.StatusStrategy.current_entry_point)
}
inline void StatusStrategy::set_current_entry_point(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  current_entry_point_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:amun.StatusStrategy.current_entry_point)
}
inline std::string* StatusStrategy::_internal_mutable_current_entry_point() {
  _has_bits_[0] |= 0x00000004u;
  return current_entry_point_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* StatusStrategy::release_current_entry_point() {
  // @@protoc_insertion_point(field_release:amun.StatusStrategy.current_entry_point)
  if (!_internal_has_current_entry_point()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return current_entry_point_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void StatusStrategy::set_allocated_current_entry_point(std::string* current_entry_point) {
  if (current_entry_point != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  current_entry_point_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), current_entry_point,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:amun.StatusStrategy.current_entry_point)
}
inline std::string* StatusStrategy::unsafe_arena_release_current_entry_point() {
  // @@protoc_insertion_point(field_unsafe_arena_release:amun.StatusStrategy.current_entry_point)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000004u;
  return current_entry_point_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void StatusStrategy::unsafe_arena_set_allocated_current_entry_point(
    std::string* current_entry_point) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (current_entry_point != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  current_entry_point_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      current_entry_point, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.StatusStrategy.current_entry_point)
}

// repeated string entry_point = 5;
inline int StatusStrategy::_internal_entry_point_size() const {
  return entry_point_.size();
}
inline int StatusStrategy::entry_point_size() const {
  return _internal_entry_point_size();
}
inline void StatusStrategy::clear_entry_point() {
  entry_point_.Clear();
}
inline std::string* StatusStrategy::add_entry_point() {
  // @@protoc_insertion_point(field_add_mutable:amun.StatusStrategy.entry_point)
  return _internal_add_entry_point();
}
inline const std::string& StatusStrategy::_internal_entry_point(int index) const {
  return entry_point_.Get(index);
}
inline const std::string& StatusStrategy::entry_point(int index) const {
  // @@protoc_insertion_point(field_get:amun.StatusStrategy.entry_point)
  return _internal_entry_point(index);
}
inline std::string* StatusStrategy::mutable_entry_point(int index) {
  // @@protoc_insertion_point(field_mutable:amun.StatusStrategy.entry_point)
  return entry_point_.Mutable(index);
}
inline void StatusStrategy::set_entry_point(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:amun.StatusStrategy.entry_point)
  entry_point_.Mutable(index)->assign(value);
}
inline void StatusStrategy::set_entry_point(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:amun.StatusStrategy.entry_point)
  entry_point_.Mutable(index)->assign(std::move(value));
}
inline void StatusStrategy::set_entry_point(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  entry_point_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:amun.StatusStrategy.entry_point)
}
inline void StatusStrategy::set_entry_point(int index, const char* value, size_t size) {
  entry_point_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:amun.StatusStrategy.entry_point)
}
inline std::string* StatusStrategy::_internal_add_entry_point() {
  return entry_point_.Add();
}
inline void StatusStrategy::add_entry_point(const std::string& value) {
  entry_point_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:amun.StatusStrategy.entry_point)
}
inline void StatusStrategy::add_entry_point(std::string&& value) {
  entry_point_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:amun.StatusStrategy.entry_point)
}
inline void StatusStrategy::add_entry_point(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  entry_point_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:amun.StatusStrategy.entry_point)
}
inline void StatusStrategy::add_entry_point(const char* value, size_t size) {
  entry_point_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:amun.StatusStrategy.entry_point)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StatusStrategy::entry_point() const {
  // @@protoc_insertion_point(field_list:amun.StatusStrategy.entry_point)
  return entry_point_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StatusStrategy::mutable_entry_point() {
  // @@protoc_insertion_point(field_mutable_list:amun.StatusStrategy.entry_point)
  return &entry_point_;
}

// optional bool has_debugger = 7;
inline bool StatusStrategy::_internal_has_has_debugger() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool StatusStrategy::has_has_debugger() const {
  return _internal_has_has_debugger();
}
inline void StatusStrategy::clear_has_debugger() {
  has_debugger_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool StatusStrategy::_internal_has_debugger() const {
  return has_debugger_;
}
inline bool StatusStrategy::has_debugger() const {
  // @@protoc_insertion_point(field_get:amun.StatusStrategy.has_debugger)
  return _internal_has_debugger();
}
inline void StatusStrategy::_internal_set_has_debugger(bool value) {
  _has_bits_[0] |= 0x00000008u;
  has_debugger_ = value;
}
inline void StatusStrategy::set_has_debugger(bool value) {
  _internal_set_has_debugger(value);
  // @@protoc_insertion_point(field_set:amun.StatusStrategy.has_debugger)
}

// repeated .amun.StrategyOption options = 8;
inline int StatusStrategy::_internal_options_size() const {
  return options_.size();
}
inline int StatusStrategy::options_size() const {
  return _internal_options_size();
}
inline void StatusStrategy::clear_options() {
  options_.Clear();
}
inline ::amun::StrategyOption* StatusStrategy::mutable_options(int index) {
  // @@protoc_insertion_point(field_mutable:amun.StatusStrategy.options)
  return options_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::amun::StrategyOption >*
StatusStrategy::mutable_options() {
  // @@protoc_insertion_point(field_mutable_list:amun.StatusStrategy.options)
  return &options_;
}
inline const ::amun::StrategyOption& StatusStrategy::_internal_options(int index) const {
  return options_.Get(index);
}
inline const ::amun::StrategyOption& StatusStrategy::options(int index) const {
  // @@protoc_insertion_point(field_get:amun.StatusStrategy.options)
  return _internal_options(index);
}
inline ::amun::StrategyOption* StatusStrategy::_internal_add_options() {
  return options_.Add();
}
inline ::amun::StrategyOption* StatusStrategy::add_options() {
  // @@protoc_insertion_point(field_add:amun.StatusStrategy.options)
  return _internal_add_options();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::amun::StrategyOption >&
StatusStrategy::options() const {
  // @@protoc_insertion_point(field_list:amun.StatusStrategy.options)
  return options_;
}

// -------------------------------------------------------------------

// GitInfo

// required .amun.GitInfo.Kind kind = 1;
inline bool GitInfo::_internal_has_kind() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool GitInfo::has_kind() const {
  return _internal_has_kind();
}
inline void GitInfo::clear_kind() {
  kind_ = 1;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::amun::GitInfo_Kind GitInfo::_internal_kind() const {
  return static_cast< ::amun::GitInfo_Kind >(kind_);
}
inline ::amun::GitInfo_Kind GitInfo::kind() const {
  // @@protoc_insertion_point(field_get:amun.GitInfo.kind)
  return _internal_kind();
}
inline void GitInfo::_internal_set_kind(::amun::GitInfo_Kind value) {
  assert(::amun::GitInfo_Kind_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  kind_ = value;
}
inline void GitInfo::set_kind(::amun::GitInfo_Kind value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:amun.GitInfo.kind)
}

// required string hash = 2;
inline bool GitInfo::_internal_has_hash() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GitInfo::has_hash() const {
  return _internal_has_hash();
}
inline void GitInfo::clear_hash() {
  hash_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GitInfo::hash() const {
  // @@protoc_insertion_point(field_get:amun.GitInfo.hash)
  return _internal_hash();
}
inline void GitInfo::set_hash(const std::string& value) {
  _internal_set_hash(value);
  // @@protoc_insertion_point(field_set:amun.GitInfo.hash)
}
inline std::string* GitInfo::mutable_hash() {
  // @@protoc_insertion_point(field_mutable:amun.GitInfo.hash)
  return _internal_mutable_hash();
}
inline const std::string& GitInfo::_internal_hash() const {
  return hash_.Get();
}
inline void GitInfo::_internal_set_hash(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GitInfo::set_hash(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  hash_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:amun.GitInfo.hash)
}
inline void GitInfo::set_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:amun.GitInfo.hash)
}
inline void GitInfo::set_hash(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:amun.GitInfo.hash)
}
inline std::string* GitInfo::_internal_mutable_hash() {
  _has_bits_[0] |= 0x00000001u;
  return hash_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GitInfo::release_hash() {
  // @@protoc_insertion_point(field_release:amun.GitInfo.hash)
  if (!_internal_has_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return hash_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GitInfo::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hash,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:amun.GitInfo.hash)
}
inline std::string* GitInfo::unsafe_arena_release_hash() {
  // @@protoc_insertion_point(field_unsafe_arena_release:amun.GitInfo.hash)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return hash_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GitInfo::unsafe_arena_set_allocated_hash(
    std::string* hash) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (hash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  hash_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      hash, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.GitInfo.hash)
}

// required string diff = 3;
inline bool GitInfo::_internal_has_diff() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GitInfo::has_diff() const {
  return _internal_has_diff();
}
inline void GitInfo::clear_diff() {
  diff_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GitInfo::diff() const {
  // @@protoc_insertion_point(field_get:amun.GitInfo.diff)
  return _internal_diff();
}
inline void GitInfo::set_diff(const std::string& value) {
  _internal_set_diff(value);
  // @@protoc_insertion_point(field_set:amun.GitInfo.diff)
}
inline std::string* GitInfo::mutable_diff() {
  // @@protoc_insertion_point(field_mutable:amun.GitInfo.diff)
  return _internal_mutable_diff();
}
inline const std::string& GitInfo::_internal_diff() const {
  return diff_.Get();
}
inline void GitInfo::_internal_set_diff(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  diff_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GitInfo::set_diff(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  diff_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:amun.GitInfo.diff)
}
inline void GitInfo::set_diff(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  diff_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:amun.GitInfo.diff)
}
inline void GitInfo::set_diff(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  diff_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:amun.GitInfo.diff)
}
inline std::string* GitInfo::_internal_mutable_diff() {
  _has_bits_[0] |= 0x00000002u;
  return diff_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GitInfo::release_diff() {
  // @@protoc_insertion_point(field_release:amun.GitInfo.diff)
  if (!_internal_has_diff()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return diff_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GitInfo::set_allocated_diff(std::string* diff) {
  if (diff != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  diff_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), diff,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:amun.GitInfo.diff)
}
inline std::string* GitInfo::unsafe_arena_release_diff() {
  // @@protoc_insertion_point(field_unsafe_arena_release:amun.GitInfo.diff)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return diff_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GitInfo::unsafe_arena_set_allocated_diff(
    std::string* diff) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (diff != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  diff_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      diff, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.GitInfo.diff)
}

// required string min_hash = 4;
inline bool GitInfo::_internal_has_min_hash() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GitInfo::has_min_hash() const {
  return _internal_has_min_hash();
}
inline void GitInfo::clear_min_hash() {
  min_hash_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& GitInfo::min_hash() const {
  // @@protoc_insertion_point(field_get:amun.GitInfo.min_hash)
  return _internal_min_hash();
}
inline void GitInfo::set_min_hash(const std::string& value) {
  _internal_set_min_hash(value);
  // @@protoc_insertion_point(field_set:amun.GitInfo.min_hash)
}
inline std::string* GitInfo::mutable_min_hash() {
  // @@protoc_insertion_point(field_mutable:amun.GitInfo.min_hash)
  return _internal_mutable_min_hash();
}
inline const std::string& GitInfo::_internal_min_hash() const {
  return min_hash_.Get();
}
inline void GitInfo::_internal_set_min_hash(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  min_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GitInfo::set_min_hash(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  min_hash_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:amun.GitInfo.min_hash)
}
inline void GitInfo::set_min_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  min_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:amun.GitInfo.min_hash)
}
inline void GitInfo::set_min_hash(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  min_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:amun.GitInfo.min_hash)
}
inline std::string* GitInfo::_internal_mutable_min_hash() {
  _has_bits_[0] |= 0x00000004u;
  return min_hash_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GitInfo::release_min_hash() {
  // @@protoc_insertion_point(field_release:amun.GitInfo.min_hash)
  if (!_internal_has_min_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return min_hash_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GitInfo::set_allocated_min_hash(std::string* min_hash) {
  if (min_hash != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  min_hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), min_hash,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:amun.GitInfo.min_hash)
}
inline std::string* GitInfo::unsafe_arena_release_min_hash() {
  // @@protoc_insertion_point(field_unsafe_arena_release:amun.GitInfo.min_hash)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000004u;
  return min_hash_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GitInfo::unsafe_arena_set_allocated_min_hash(
    std::string* min_hash) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (min_hash != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  min_hash_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      min_hash, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.GitInfo.min_hash)
}

// required string error = 5;
inline bool GitInfo::_internal_has_error() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool GitInfo::has_error() const {
  return _internal_has_error();
}
inline void GitInfo::clear_error() {
  error_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& GitInfo::error() const {
  // @@protoc_insertion_point(field_get:amun.GitInfo.error)
  return _internal_error();
}
inline void GitInfo::set_error(const std::string& value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:amun.GitInfo.error)
}
inline std::string* GitInfo::mutable_error() {
  // @@protoc_insertion_point(field_mutable:amun.GitInfo.error)
  return _internal_mutable_error();
}
inline const std::string& GitInfo::_internal_error() const {
  return error_.Get();
}
inline void GitInfo::_internal_set_error(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GitInfo::set_error(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  error_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:amun.GitInfo.error)
}
inline void GitInfo::set_error(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:amun.GitInfo.error)
}
inline void GitInfo::set_error(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000008u;
  error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:amun.GitInfo.error)
}
inline std::string* GitInfo::_internal_mutable_error() {
  _has_bits_[0] |= 0x00000008u;
  return error_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GitInfo::release_error() {
  // @@protoc_insertion_point(field_release:amun.GitInfo.error)
  if (!_internal_has_error()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return error_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GitInfo::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:amun.GitInfo.error)
}
inline std::string* GitInfo::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:amun.GitInfo.error)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000008u;
  return error_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GitInfo::unsafe_arena_set_allocated_error(
    std::string* error) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (error != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  error_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      error, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.GitInfo.error)
}

// -------------------------------------------------------------------

// StatusStrategyWrapper

// required .amun.StatusStrategyWrapper.StrategyType type = 1;
inline bool StatusStrategyWrapper::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StatusStrategyWrapper::has_type() const {
  return _internal_has_type();
}
inline void StatusStrategyWrapper::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::amun::StatusStrategyWrapper_StrategyType StatusStrategyWrapper::_internal_type() const {
  return static_cast< ::amun::StatusStrategyWrapper_StrategyType >(type_);
}
inline ::amun::StatusStrategyWrapper_StrategyType StatusStrategyWrapper::type() const {
  // @@protoc_insertion_point(field_get:amun.StatusStrategyWrapper.type)
  return _internal_type();
}
inline void StatusStrategyWrapper::_internal_set_type(::amun::StatusStrategyWrapper_StrategyType value) {
  assert(::amun::StatusStrategyWrapper_StrategyType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
}
inline void StatusStrategyWrapper::set_type(::amun::StatusStrategyWrapper_StrategyType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:amun.StatusStrategyWrapper.type)
}

// required .amun.StatusStrategy status = 2;
inline bool StatusStrategyWrapper::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || status_ != nullptr);
  return value;
}
inline bool StatusStrategyWrapper::has_status() const {
  return _internal_has_status();
}
inline void StatusStrategyWrapper::clear_status() {
  if (status_ != nullptr) status_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::amun::StatusStrategy& StatusStrategyWrapper::_internal_status() const {
  const ::amun::StatusStrategy* p = status_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::StatusStrategy*>(
      &::amun::_StatusStrategy_default_instance_);
}
inline const ::amun::StatusStrategy& StatusStrategyWrapper::status() const {
  // @@protoc_insertion_point(field_get:amun.StatusStrategyWrapper.status)
  return _internal_status();
}
inline void StatusStrategyWrapper::unsafe_arena_set_allocated_status(
    ::amun::StatusStrategy* status) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.StatusStrategyWrapper.status)
}
inline ::amun::StatusStrategy* StatusStrategyWrapper::release_status() {
  auto temp = unsafe_arena_release_status();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::StatusStrategy* StatusStrategyWrapper::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:amun.StatusStrategyWrapper.status)
  _has_bits_[0] &= ~0x00000001u;
  ::amun::StatusStrategy* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::amun::StatusStrategy* StatusStrategyWrapper::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000001u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::StatusStrategy>(GetArena());
    status_ = p;
  }
  return status_;
}
inline ::amun::StatusStrategy* StatusStrategyWrapper::mutable_status() {
  // @@protoc_insertion_point(field_mutable:amun.StatusStrategyWrapper.status)
  return _internal_mutable_status();
}
inline void StatusStrategyWrapper::set_allocated_status(::amun::StatusStrategy* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:amun.StatusStrategyWrapper.status)
}

// -------------------------------------------------------------------

// Timing

// optional float blue_total = 1;
inline bool Timing::_internal_has_blue_total() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Timing::has_blue_total() const {
  return _internal_has_blue_total();
}
inline void Timing::clear_blue_total() {
  blue_total_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float Timing::_internal_blue_total() const {
  return blue_total_;
}
inline float Timing::blue_total() const {
  // @@protoc_insertion_point(field_get:amun.Timing.blue_total)
  return _internal_blue_total();
}
inline void Timing::_internal_set_blue_total(float value) {
  _has_bits_[0] |= 0x00000001u;
  blue_total_ = value;
}
inline void Timing::set_blue_total(float value) {
  _internal_set_blue_total(value);
  // @@protoc_insertion_point(field_set:amun.Timing.blue_total)
}

// optional float blue_path = 2;
inline bool Timing::_internal_has_blue_path() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Timing::has_blue_path() const {
  return _internal_has_blue_path();
}
inline void Timing::clear_blue_path() {
  blue_path_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float Timing::_internal_blue_path() const {
  return blue_path_;
}
inline float Timing::blue_path() const {
  // @@protoc_insertion_point(field_get:amun.Timing.blue_path)
  return _internal_blue_path();
}
inline void Timing::_internal_set_blue_path(float value) {
  _has_bits_[0] |= 0x00000002u;
  blue_path_ = value;
}
inline void Timing::set_blue_path(float value) {
  _internal_set_blue_path(value);
  // @@protoc_insertion_point(field_set:amun.Timing.blue_path)
}

// optional float yellow_total = 3;
inline bool Timing::_internal_has_yellow_total() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Timing::has_yellow_total() const {
  return _internal_has_yellow_total();
}
inline void Timing::clear_yellow_total() {
  yellow_total_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float Timing::_internal_yellow_total() const {
  return yellow_total_;
}
inline float Timing::yellow_total() const {
  // @@protoc_insertion_point(field_get:amun.Timing.yellow_total)
  return _internal_yellow_total();
}
inline void Timing::_internal_set_yellow_total(float value) {
  _has_bits_[0] |= 0x00000004u;
  yellow_total_ = value;
}
inline void Timing::set_yellow_total(float value) {
  _internal_set_yellow_total(value);
  // @@protoc_insertion_point(field_set:amun.Timing.yellow_total)
}

// optional float yellow_path = 4;
inline bool Timing::_internal_has_yellow_path() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Timing::has_yellow_path() const {
  return _internal_has_yellow_path();
}
inline void Timing::clear_yellow_path() {
  yellow_path_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float Timing::_internal_yellow_path() const {
  return yellow_path_;
}
inline float Timing::yellow_path() const {
  // @@protoc_insertion_point(field_get:amun.Timing.yellow_path)
  return _internal_yellow_path();
}
inline void Timing::_internal_set_yellow_path(float value) {
  _has_bits_[0] |= 0x00000008u;
  yellow_path_ = value;
}
inline void Timing::set_yellow_path(float value) {
  _internal_set_yellow_path(value);
  // @@protoc_insertion_point(field_set:amun.Timing.yellow_path)
}

// optional float autoref_total = 10;
inline bool Timing::_internal_has_autoref_total() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Timing::has_autoref_total() const {
  return _internal_has_autoref_total();
}
inline void Timing::clear_autoref_total() {
  autoref_total_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline float Timing::_internal_autoref_total() const {
  return autoref_total_;
}
inline float Timing::autoref_total() const {
  // @@protoc_insertion_point(field_get:amun.Timing.autoref_total)
  return _internal_autoref_total();
}
inline void Timing::_internal_set_autoref_total(float value) {
  _has_bits_[0] |= 0x00000200u;
  autoref_total_ = value;
}
inline void Timing::set_autoref_total(float value) {
  _internal_set_autoref_total(value);
  // @@protoc_insertion_point(field_set:amun.Timing.autoref_total)
}

// optional float tracking = 5;
inline bool Timing::_internal_has_tracking() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Timing::has_tracking() const {
  return _internal_has_tracking();
}
inline void Timing::clear_tracking() {
  tracking_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float Timing::_internal_tracking() const {
  return tracking_;
}
inline float Timing::tracking() const {
  // @@protoc_insertion_point(field_get:amun.Timing.tracking)
  return _internal_tracking();
}
inline void Timing::_internal_set_tracking(float value) {
  _has_bits_[0] |= 0x00000010u;
  tracking_ = value;
}
inline void Timing::set_tracking(float value) {
  _internal_set_tracking(value);
  // @@protoc_insertion_point(field_set:amun.Timing.tracking)
}

// optional float controller = 8;
inline bool Timing::_internal_has_controller() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Timing::has_controller() const {
  return _internal_has_controller();
}
inline void Timing::clear_controller() {
  controller_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline float Timing::_internal_controller() const {
  return controller_;
}
inline float Timing::controller() const {
  // @@protoc_insertion_point(field_get:amun.Timing.controller)
  return _internal_controller();
}
inline void Timing::_internal_set_controller(float value) {
  _has_bits_[0] |= 0x00000080u;
  controller_ = value;
}
inline void Timing::set_controller(float value) {
  _internal_set_controller(value);
  // @@protoc_insertion_point(field_set:amun.Timing.controller)
}

// optional float transceiver = 6;
inline bool Timing::_internal_has_transceiver() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Timing::has_transceiver() const {
  return _internal_has_transceiver();
}
inline void Timing::clear_transceiver() {
  transceiver_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline float Timing::_internal_transceiver() const {
  return transceiver_;
}
inline float Timing::transceiver() const {
  // @@protoc_insertion_point(field_get:amun.Timing.transceiver)
  return _internal_transceiver();
}
inline void Timing::_internal_set_transceiver(float value) {
  _has_bits_[0] |= 0x00000020u;
  transceiver_ = value;
}
inline void Timing::set_transceiver(float value) {
  _internal_set_transceiver(value);
  // @@protoc_insertion_point(field_set:amun.Timing.transceiver)
}

// optional float transceiver_rtt = 9;
inline bool Timing::_internal_has_transceiver_rtt() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Timing::has_transceiver_rtt() const {
  return _internal_has_transceiver_rtt();
}
inline void Timing::clear_transceiver_rtt() {
  transceiver_rtt_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline float Timing::_internal_transceiver_rtt() const {
  return transceiver_rtt_;
}
inline float Timing::transceiver_rtt() const {
  // @@protoc_insertion_point(field_get:amun.Timing.transceiver_rtt)
  return _internal_transceiver_rtt();
}
inline void Timing::_internal_set_transceiver_rtt(float value) {
  _has_bits_[0] |= 0x00000100u;
  transceiver_rtt_ = value;
}
inline void Timing::set_transceiver_rtt(float value) {
  _internal_set_transceiver_rtt(value);
  // @@protoc_insertion_point(field_set:amun.Timing.transceiver_rtt)
}

// optional float simulator = 7;
inline bool Timing::_internal_has_simulator() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Timing::has_simulator() const {
  return _internal_has_simulator();
}
inline void Timing::clear_simulator() {
  simulator_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline float Timing::_internal_simulator() const {
  return simulator_;
}
inline float Timing::simulator() const {
  // @@protoc_insertion_point(field_get:amun.Timing.simulator)
  return _internal_simulator();
}
inline void Timing::_internal_set_simulator(float value) {
  _has_bits_[0] |= 0x00000040u;
  simulator_ = value;
}
inline void Timing::set_simulator(float value) {
  _internal_set_simulator(value);
  // @@protoc_insertion_point(field_set:amun.Timing.simulator)
}

// -------------------------------------------------------------------

// StatusTransceiver

// required bool active = 1;
inline bool StatusTransceiver::_internal_has_active() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StatusTransceiver::has_active() const {
  return _internal_has_active();
}
inline void StatusTransceiver::clear_active() {
  active_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool StatusTransceiver::_internal_active() const {
  return active_;
}
inline bool StatusTransceiver::active() const {
  // @@protoc_insertion_point(field_get:amun.StatusTransceiver.active)
  return _internal_active();
}
inline void StatusTransceiver::_internal_set_active(bool value) {
  _has_bits_[0] |= 0x00000002u;
  active_ = value;
}
inline void StatusTransceiver::set_active(bool value) {
  _internal_set_active(value);
  // @@protoc_insertion_point(field_set:amun.StatusTransceiver.active)
}

// optional string error = 2;
inline bool StatusTransceiver::_internal_has_error() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StatusTransceiver::has_error() const {
  return _internal_has_error();
}
inline void StatusTransceiver::clear_error() {
  error_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StatusTransceiver::error() const {
  // @@protoc_insertion_point(field_get:amun.StatusTransceiver.error)
  return _internal_error();
}
inline void StatusTransceiver::set_error(const std::string& value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:amun.StatusTransceiver.error)
}
inline std::string* StatusTransceiver::mutable_error() {
  // @@protoc_insertion_point(field_mutable:amun.StatusTransceiver.error)
  return _internal_mutable_error();
}
inline const std::string& StatusTransceiver::_internal_error() const {
  return error_.Get();
}
inline void StatusTransceiver::_internal_set_error(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void StatusTransceiver::set_error(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  error_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:amun.StatusTransceiver.error)
}
inline void StatusTransceiver::set_error(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:amun.StatusTransceiver.error)
}
inline void StatusTransceiver::set_error(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:amun.StatusTransceiver.error)
}
inline std::string* StatusTransceiver::_internal_mutable_error() {
  _has_bits_[0] |= 0x00000001u;
  return error_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* StatusTransceiver::release_error() {
  // @@protoc_insertion_point(field_release:amun.StatusTransceiver.error)
  if (!_internal_has_error()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return error_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void StatusTransceiver::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:amun.StatusTransceiver.error)
}
inline std::string* StatusTransceiver::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:amun.StatusTransceiver.error)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return error_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void StatusTransceiver::unsafe_arena_set_allocated_error(
    std::string* error) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (error != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  error_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      error, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.StatusTransceiver.error)
}

// optional int32 dropped_usb_packets = 3;
inline bool StatusTransceiver::_internal_has_dropped_usb_packets() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StatusTransceiver::has_dropped_usb_packets() const {
  return _internal_has_dropped_usb_packets();
}
inline void StatusTransceiver::clear_dropped_usb_packets() {
  dropped_usb_packets_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StatusTransceiver::_internal_dropped_usb_packets() const {
  return dropped_usb_packets_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StatusTransceiver::dropped_usb_packets() const {
  // @@protoc_insertion_point(field_get:amun.StatusTransceiver.dropped_usb_packets)
  return _internal_dropped_usb_packets();
}
inline void StatusTransceiver::_internal_set_dropped_usb_packets(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  dropped_usb_packets_ = value;
}
inline void StatusTransceiver::set_dropped_usb_packets(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_dropped_usb_packets(value);
  // @@protoc_insertion_point(field_set:amun.StatusTransceiver.dropped_usb_packets)
}

// optional int32 dropped_commands = 4;
inline bool StatusTransceiver::_internal_has_dropped_commands() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool StatusTransceiver::has_dropped_commands() const {
  return _internal_has_dropped_commands();
}
inline void StatusTransceiver::clear_dropped_commands() {
  dropped_commands_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StatusTransceiver::_internal_dropped_commands() const {
  return dropped_commands_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 StatusTransceiver::dropped_commands() const {
  // @@protoc_insertion_point(field_get:amun.StatusTransceiver.dropped_commands)
  return _internal_dropped_commands();
}
inline void StatusTransceiver::_internal_set_dropped_commands(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  dropped_commands_ = value;
}
inline void StatusTransceiver::set_dropped_commands(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_dropped_commands(value);
  // @@protoc_insertion_point(field_set:amun.StatusTransceiver.dropped_commands)
}

// -------------------------------------------------------------------

// PortBindError

// required uint32 port = 1;
inline bool PortBindError::_internal_has_port() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PortBindError::has_port() const {
  return _internal_has_port();
}
inline void PortBindError::clear_port() {
  port_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PortBindError::_internal_port() const {
  return port_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PortBindError::port() const {
  // @@protoc_insertion_point(field_get:amun.PortBindError.port)
  return _internal_port();
}
inline void PortBindError::_internal_set_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  port_ = value;
}
inline void PortBindError::set_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:amun.PortBindError.port)
}

// -------------------------------------------------------------------

// OptionStatus

// required string name = 2;
inline bool OptionStatus::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OptionStatus::has_name() const {
  return _internal_has_name();
}
inline void OptionStatus::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OptionStatus::name() const {
  // @@protoc_insertion_point(field_get:amun.OptionStatus.name)
  return _internal_name();
}
inline void OptionStatus::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:amun.OptionStatus.name)
}
inline std::string* OptionStatus::mutable_name() {
  // @@protoc_insertion_point(field_mutable:amun.OptionStatus.name)
  return _internal_mutable_name();
}
inline const std::string& OptionStatus::_internal_name() const {
  return name_.Get();
}
inline void OptionStatus::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void OptionStatus::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:amun.OptionStatus.name)
}
inline void OptionStatus::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:amun.OptionStatus.name)
}
inline void OptionStatus::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:amun.OptionStatus.name)
}
inline std::string* OptionStatus::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* OptionStatus::release_name() {
  // @@protoc_insertion_point(field_release:amun.OptionStatus.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void OptionStatus::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:amun.OptionStatus.name)
}
inline std::string* OptionStatus::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:amun.OptionStatus.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void OptionStatus::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.OptionStatus.name)
}

// required bool value = 3;
inline bool OptionStatus::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool OptionStatus::has_value() const {
  return _internal_has_value();
}
inline void OptionStatus::clear_value() {
  value_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool OptionStatus::_internal_value() const {
  return value_;
}
inline bool OptionStatus::value() const {
  // @@protoc_insertion_point(field_get:amun.OptionStatus.value)
  return _internal_value();
}
inline void OptionStatus::_internal_set_value(bool value) {
  _has_bits_[0] |= 0x00000002u;
  value_ = value;
}
inline void OptionStatus::set_value(bool value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:amun.OptionStatus.value)
}

// -------------------------------------------------------------------

// StatusGameController

// optional .amun.StatusGameController.GameControllerState current_state = 1;
inline bool StatusGameController::_internal_has_current_state() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StatusGameController::has_current_state() const {
  return _internal_has_current_state();
}
inline void StatusGameController::clear_current_state() {
  current_state_ = 1;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::amun::StatusGameController_GameControllerState StatusGameController::_internal_current_state() const {
  return static_cast< ::amun::StatusGameController_GameControllerState >(current_state_);
}
inline ::amun::StatusGameController_GameControllerState StatusGameController::current_state() const {
  // @@protoc_insertion_point(field_get:amun.StatusGameController.current_state)
  return _internal_current_state();
}
inline void StatusGameController::_internal_set_current_state(::amun::StatusGameController_GameControllerState value) {
  assert(::amun::StatusGameController_GameControllerState_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  current_state_ = value;
}
inline void StatusGameController::set_current_state(::amun::StatusGameController_GameControllerState value) {
  _internal_set_current_state(value);
  // @@protoc_insertion_point(field_set:amun.StatusGameController.current_state)
}

// -------------------------------------------------------------------

// StatusAmun

// optional .amun.PortBindError port_bind_error = 1;
inline bool StatusAmun::_internal_has_port_bind_error() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || port_bind_error_ != nullptr);
  return value;
}
inline bool StatusAmun::has_port_bind_error() const {
  return _internal_has_port_bind_error();
}
inline void StatusAmun::clear_port_bind_error() {
  if (port_bind_error_ != nullptr) port_bind_error_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::amun::PortBindError& StatusAmun::_internal_port_bind_error() const {
  const ::amun::PortBindError* p = port_bind_error_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::PortBindError*>(
      &::amun::_PortBindError_default_instance_);
}
inline const ::amun::PortBindError& StatusAmun::port_bind_error() const {
  // @@protoc_insertion_point(field_get:amun.StatusAmun.port_bind_error)
  return _internal_port_bind_error();
}
inline void StatusAmun::unsafe_arena_set_allocated_port_bind_error(
    ::amun::PortBindError* port_bind_error) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(port_bind_error_);
  }
  port_bind_error_ = port_bind_error;
  if (port_bind_error) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.StatusAmun.port_bind_error)
}
inline ::amun::PortBindError* StatusAmun::release_port_bind_error() {
  auto temp = unsafe_arena_release_port_bind_error();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::PortBindError* StatusAmun::unsafe_arena_release_port_bind_error() {
  // @@protoc_insertion_point(field_release:amun.StatusAmun.port_bind_error)
  _has_bits_[0] &= ~0x00000001u;
  ::amun::PortBindError* temp = port_bind_error_;
  port_bind_error_ = nullptr;
  return temp;
}
inline ::amun::PortBindError* StatusAmun::_internal_mutable_port_bind_error() {
  _has_bits_[0] |= 0x00000001u;
  if (port_bind_error_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::PortBindError>(GetArena());
    port_bind_error_ = p;
  }
  return port_bind_error_;
}
inline ::amun::PortBindError* StatusAmun::mutable_port_bind_error() {
  // @@protoc_insertion_point(field_mutable:amun.StatusAmun.port_bind_error)
  return _internal_mutable_port_bind_error();
}
inline void StatusAmun::set_allocated_port_bind_error(::amun::PortBindError* port_bind_error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete port_bind_error_;
  }
  if (port_bind_error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(port_bind_error);
    if (message_arena != submessage_arena) {
      port_bind_error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, port_bind_error, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  port_bind_error_ = port_bind_error;
  // @@protoc_insertion_point(field_set_allocated:amun.StatusAmun.port_bind_error)
}

// repeated .amun.OptionStatus options = 2;
inline int StatusAmun::_internal_options_size() const {
  return options_.size();
}
inline int StatusAmun::options_size() const {
  return _internal_options_size();
}
inline void StatusAmun::clear_options() {
  options_.Clear();
}
inline ::amun::OptionStatus* StatusAmun::mutable_options(int index) {
  // @@protoc_insertion_point(field_mutable:amun.StatusAmun.options)
  return options_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::amun::OptionStatus >*
StatusAmun::mutable_options() {
  // @@protoc_insertion_point(field_mutable_list:amun.StatusAmun.options)
  return &options_;
}
inline const ::amun::OptionStatus& StatusAmun::_internal_options(int index) const {
  return options_.Get(index);
}
inline const ::amun::OptionStatus& StatusAmun::options(int index) const {
  // @@protoc_insertion_point(field_get:amun.StatusAmun.options)
  return _internal_options(index);
}
inline ::amun::OptionStatus* StatusAmun::_internal_add_options() {
  return options_.Add();
}
inline ::amun::OptionStatus* StatusAmun::add_options() {
  // @@protoc_insertion_point(field_add:amun.StatusAmun.options)
  return _internal_add_options();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::amun::OptionStatus >&
StatusAmun::options() const {
  // @@protoc_insertion_point(field_list:amun.StatusAmun.options)
  return options_;
}

// optional .amun.StatusGameController game_controller = 3;
inline bool StatusAmun::_internal_has_game_controller() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || game_controller_ != nullptr);
  return value;
}
inline bool StatusAmun::has_game_controller() const {
  return _internal_has_game_controller();
}
inline void StatusAmun::clear_game_controller() {
  if (game_controller_ != nullptr) game_controller_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::amun::StatusGameController& StatusAmun::_internal_game_controller() const {
  const ::amun::StatusGameController* p = game_controller_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::StatusGameController*>(
      &::amun::_StatusGameController_default_instance_);
}
inline const ::amun::StatusGameController& StatusAmun::game_controller() const {
  // @@protoc_insertion_point(field_get:amun.StatusAmun.game_controller)
  return _internal_game_controller();
}
inline void StatusAmun::unsafe_arena_set_allocated_game_controller(
    ::amun::StatusGameController* game_controller) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(game_controller_);
  }
  game_controller_ = game_controller;
  if (game_controller) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.StatusAmun.game_controller)
}
inline ::amun::StatusGameController* StatusAmun::release_game_controller() {
  auto temp = unsafe_arena_release_game_controller();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::StatusGameController* StatusAmun::unsafe_arena_release_game_controller() {
  // @@protoc_insertion_point(field_release:amun.StatusAmun.game_controller)
  _has_bits_[0] &= ~0x00000002u;
  ::amun::StatusGameController* temp = game_controller_;
  game_controller_ = nullptr;
  return temp;
}
inline ::amun::StatusGameController* StatusAmun::_internal_mutable_game_controller() {
  _has_bits_[0] |= 0x00000002u;
  if (game_controller_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::StatusGameController>(GetArena());
    game_controller_ = p;
  }
  return game_controller_;
}
inline ::amun::StatusGameController* StatusAmun::mutable_game_controller() {
  // @@protoc_insertion_point(field_mutable:amun.StatusAmun.game_controller)
  return _internal_mutable_game_controller();
}
inline void StatusAmun::set_allocated_game_controller(::amun::StatusGameController* game_controller) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete game_controller_;
  }
  if (game_controller) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(game_controller);
    if (message_arena != submessage_arena) {
      game_controller = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, game_controller, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  game_controller_ = game_controller;
  // @@protoc_insertion_point(field_set_allocated:amun.StatusAmun.game_controller)
}

// -------------------------------------------------------------------

// Status

// required int64 time = 1;
inline bool Status::_internal_has_time() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool Status::has_time() const {
  return _internal_has_time();
}
inline void Status::clear_time() {
  time_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00080000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Status::_internal_time() const {
  return time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Status::time() const {
  // @@protoc_insertion_point(field_get:amun.Status.time)
  return _internal_time();
}
inline void Status::_internal_set_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00080000u;
  time_ = value;
}
inline void Status::set_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:amun.Status.time)
}

// optional .amun.GameState game_state = 15;
inline bool Status::_internal_has_game_state() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || game_state_ != nullptr);
  return value;
}
inline bool Status::has_game_state() const {
  return _internal_has_game_state();
}
inline const ::amun::GameState& Status::_internal_game_state() const {
  const ::amun::GameState* p = game_state_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::GameState*>(
      &::amun::_GameState_default_instance_);
}
inline const ::amun::GameState& Status::game_state() const {
  // @@protoc_insertion_point(field_get:amun.Status.game_state)
  return _internal_game_state();
}
inline void Status::unsafe_arena_set_allocated_game_state(
    ::amun::GameState* game_state) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(game_state_);
  }
  game_state_ = game_state;
  if (game_state) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.Status.game_state)
}
inline ::amun::GameState* Status::release_game_state() {
  auto temp = unsafe_arena_release_game_state();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::GameState* Status::unsafe_arena_release_game_state() {
  // @@protoc_insertion_point(field_release:amun.Status.game_state)
  _has_bits_[0] &= ~0x00000100u;
  ::amun::GameState* temp = game_state_;
  game_state_ = nullptr;
  return temp;
}
inline ::amun::GameState* Status::_internal_mutable_game_state() {
  _has_bits_[0] |= 0x00000100u;
  if (game_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::GameState>(GetArena());
    game_state_ = p;
  }
  return game_state_;
}
inline ::amun::GameState* Status::mutable_game_state() {
  // @@protoc_insertion_point(field_mutable:amun.Status.game_state)
  return _internal_mutable_game_state();
}
inline void Status::set_allocated_game_state(::amun::GameState* game_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(game_state_);
  }
  if (game_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(game_state)->GetArena();
    if (message_arena != submessage_arena) {
      game_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, game_state, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  game_state_ = game_state;
  // @@protoc_insertion_point(field_set_allocated:amun.Status.game_state)
}

// optional .world.State world_state = 3;
inline bool Status::_internal_has_world_state() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || world_state_ != nullptr);
  return value;
}
inline bool Status::has_world_state() const {
  return _internal_has_world_state();
}
inline const ::world::State& Status::_internal_world_state() const {
  const ::world::State* p = world_state_;
  return p != nullptr ? *p : *reinterpret_cast<const ::world::State*>(
      &::world::_State_default_instance_);
}
inline const ::world::State& Status::world_state() const {
  // @@protoc_insertion_point(field_get:amun.Status.world_state)
  return _internal_world_state();
}
inline void Status::unsafe_arena_set_allocated_world_state(
    ::world::State* world_state) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(world_state_);
  }
  world_state_ = world_state;
  if (world_state) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.Status.world_state)
}
inline ::world::State* Status::release_world_state() {
  auto temp = unsafe_arena_release_world_state();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::world::State* Status::unsafe_arena_release_world_state() {
  // @@protoc_insertion_point(field_release:amun.Status.world_state)
  _has_bits_[0] &= ~0x00000001u;
  ::world::State* temp = world_state_;
  world_state_ = nullptr;
  return temp;
}
inline ::world::State* Status::_internal_mutable_world_state() {
  _has_bits_[0] |= 0x00000001u;
  if (world_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::world::State>(GetArena());
    world_state_ = p;
  }
  return world_state_;
}
inline ::world::State* Status::mutable_world_state() {
  // @@protoc_insertion_point(field_mutable:amun.Status.world_state)
  return _internal_mutable_world_state();
}
inline void Status::set_allocated_world_state(::world::State* world_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(world_state_);
  }
  if (world_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(world_state)->GetArena();
    if (message_arena != submessage_arena) {
      world_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, world_state, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  world_state_ = world_state;
  // @@protoc_insertion_point(field_set_allocated:amun.Status.world_state)
}

// optional .world.Geometry geometry = 4;
inline bool Status::_internal_has_geometry() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || geometry_ != nullptr);
  return value;
}
inline bool Status::has_geometry() const {
  return _internal_has_geometry();
}
inline const ::world::Geometry& Status::_internal_geometry() const {
  const ::world::Geometry* p = geometry_;
  return p != nullptr ? *p : *reinterpret_cast<const ::world::Geometry*>(
      &::world::_Geometry_default_instance_);
}
inline const ::world::Geometry& Status::geometry() const {
  // @@protoc_insertion_point(field_get:amun.Status.geometry)
  return _internal_geometry();
}
inline void Status::unsafe_arena_set_allocated_geometry(
    ::world::Geometry* geometry) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(geometry_);
  }
  geometry_ = geometry;
  if (geometry) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.Status.geometry)
}
inline ::world::Geometry* Status::release_geometry() {
  auto temp = unsafe_arena_release_geometry();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::world::Geometry* Status::unsafe_arena_release_geometry() {
  // @@protoc_insertion_point(field_release:amun.Status.geometry)
  _has_bits_[0] &= ~0x00000002u;
  ::world::Geometry* temp = geometry_;
  geometry_ = nullptr;
  return temp;
}
inline ::world::Geometry* Status::_internal_mutable_geometry() {
  _has_bits_[0] |= 0x00000002u;
  if (geometry_ == nullptr) {
    auto* p = CreateMaybeMessage<::world::Geometry>(GetArena());
    geometry_ = p;
  }
  return geometry_;
}
inline ::world::Geometry* Status::mutable_geometry() {
  // @@protoc_insertion_point(field_mutable:amun.Status.geometry)
  return _internal_mutable_geometry();
}
inline void Status::set_allocated_geometry(::world::Geometry* geometry) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(geometry_);
  }
  if (geometry) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(geometry)->GetArena();
    if (message_arena != submessage_arena) {
      geometry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, geometry, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  geometry_ = geometry;
  // @@protoc_insertion_point(field_set_allocated:amun.Status.geometry)
}

// optional .robot.Team team_blue = 5;
inline bool Status::_internal_has_team_blue() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || team_blue_ != nullptr);
  return value;
}
inline bool Status::has_team_blue() const {
  return _internal_has_team_blue();
}
inline const ::robot::Team& Status::_internal_team_blue() const {
  const ::robot::Team* p = team_blue_;
  return p != nullptr ? *p : *reinterpret_cast<const ::robot::Team*>(
      &::robot::_Team_default_instance_);
}
inline const ::robot::Team& Status::team_blue() const {
  // @@protoc_insertion_point(field_get:amun.Status.team_blue)
  return _internal_team_blue();
}
inline void Status::unsafe_arena_set_allocated_team_blue(
    ::robot::Team* team_blue) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(team_blue_);
  }
  team_blue_ = team_blue;
  if (team_blue) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.Status.team_blue)
}
inline ::robot::Team* Status::release_team_blue() {
  auto temp = unsafe_arena_release_team_blue();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::robot::Team* Status::unsafe_arena_release_team_blue() {
  // @@protoc_insertion_point(field_release:amun.Status.team_blue)
  _has_bits_[0] &= ~0x00000004u;
  ::robot::Team* temp = team_blue_;
  team_blue_ = nullptr;
  return temp;
}
inline ::robot::Team* Status::_internal_mutable_team_blue() {
  _has_bits_[0] |= 0x00000004u;
  if (team_blue_ == nullptr) {
    auto* p = CreateMaybeMessage<::robot::Team>(GetArena());
    team_blue_ = p;
  }
  return team_blue_;
}
inline ::robot::Team* Status::mutable_team_blue() {
  // @@protoc_insertion_point(field_mutable:amun.Status.team_blue)
  return _internal_mutable_team_blue();
}
inline void Status::set_allocated_team_blue(::robot::Team* team_blue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(team_blue_);
  }
  if (team_blue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(team_blue)->GetArena();
    if (message_arena != submessage_arena) {
      team_blue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, team_blue, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  team_blue_ = team_blue;
  // @@protoc_insertion_point(field_set_allocated:amun.Status.team_blue)
}

// optional .robot.Team team_yellow = 6;
inline bool Status::_internal_has_team_yellow() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || team_yellow_ != nullptr);
  return value;
}
inline bool Status::has_team_yellow() const {
  return _internal_has_team_yellow();
}
inline const ::robot::Team& Status::_internal_team_yellow() const {
  const ::robot::Team* p = team_yellow_;
  return p != nullptr ? *p : *reinterpret_cast<const ::robot::Team*>(
      &::robot::_Team_default_instance_);
}
inline const ::robot::Team& Status::team_yellow() const {
  // @@protoc_insertion_point(field_get:amun.Status.team_yellow)
  return _internal_team_yellow();
}
inline void Status::unsafe_arena_set_allocated_team_yellow(
    ::robot::Team* team_yellow) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(team_yellow_);
  }
  team_yellow_ = team_yellow;
  if (team_yellow) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.Status.team_yellow)
}
inline ::robot::Team* Status::release_team_yellow() {
  auto temp = unsafe_arena_release_team_yellow();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::robot::Team* Status::unsafe_arena_release_team_yellow() {
  // @@protoc_insertion_point(field_release:amun.Status.team_yellow)
  _has_bits_[0] &= ~0x00000008u;
  ::robot::Team* temp = team_yellow_;
  team_yellow_ = nullptr;
  return temp;
}
inline ::robot::Team* Status::_internal_mutable_team_yellow() {
  _has_bits_[0] |= 0x00000008u;
  if (team_yellow_ == nullptr) {
    auto* p = CreateMaybeMessage<::robot::Team>(GetArena());
    team_yellow_ = p;
  }
  return team_yellow_;
}
inline ::robot::Team* Status::mutable_team_yellow() {
  // @@protoc_insertion_point(field_mutable:amun.Status.team_yellow)
  return _internal_mutable_team_yellow();
}
inline void Status::set_allocated_team_yellow(::robot::Team* team_yellow) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(team_yellow_);
  }
  if (team_yellow) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(team_yellow)->GetArena();
    if (message_arena != submessage_arena) {
      team_yellow = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, team_yellow, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  team_yellow_ = team_yellow;
  // @@protoc_insertion_point(field_set_allocated:amun.Status.team_yellow)
}

// optional .amun.StatusStrategy strategy_blue = 7;
inline bool Status::_internal_has_strategy_blue() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || strategy_blue_ != nullptr);
  return value;
}
inline bool Status::has_strategy_blue() const {
  return _internal_has_strategy_blue();
}
inline void Status::clear_strategy_blue() {
  if (strategy_blue_ != nullptr) strategy_blue_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::amun::StatusStrategy& Status::_internal_strategy_blue() const {
  const ::amun::StatusStrategy* p = strategy_blue_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::StatusStrategy*>(
      &::amun::_StatusStrategy_default_instance_);
}
inline const ::amun::StatusStrategy& Status::strategy_blue() const {
  // @@protoc_insertion_point(field_get:amun.Status.strategy_blue)
  return _internal_strategy_blue();
}
inline void Status::unsafe_arena_set_allocated_strategy_blue(
    ::amun::StatusStrategy* strategy_blue) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(strategy_blue_);
  }
  strategy_blue_ = strategy_blue;
  if (strategy_blue) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.Status.strategy_blue)
}
inline ::amun::StatusStrategy* Status::release_strategy_blue() {
  auto temp = unsafe_arena_release_strategy_blue();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::StatusStrategy* Status::unsafe_arena_release_strategy_blue() {
  // @@protoc_insertion_point(field_release:amun.Status.strategy_blue)
  _has_bits_[0] &= ~0x00000010u;
  ::amun::StatusStrategy* temp = strategy_blue_;
  strategy_blue_ = nullptr;
  return temp;
}
inline ::amun::StatusStrategy* Status::_internal_mutable_strategy_blue() {
  _has_bits_[0] |= 0x00000010u;
  if (strategy_blue_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::StatusStrategy>(GetArena());
    strategy_blue_ = p;
  }
  return strategy_blue_;
}
inline ::amun::StatusStrategy* Status::mutable_strategy_blue() {
  // @@protoc_insertion_point(field_mutable:amun.Status.strategy_blue)
  return _internal_mutable_strategy_blue();
}
inline void Status::set_allocated_strategy_blue(::amun::StatusStrategy* strategy_blue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete strategy_blue_;
  }
  if (strategy_blue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(strategy_blue);
    if (message_arena != submessage_arena) {
      strategy_blue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, strategy_blue, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  strategy_blue_ = strategy_blue;
  // @@protoc_insertion_point(field_set_allocated:amun.Status.strategy_blue)
}

// optional .amun.StatusStrategy strategy_yellow = 8;
inline bool Status::_internal_has_strategy_yellow() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || strategy_yellow_ != nullptr);
  return value;
}
inline bool Status::has_strategy_yellow() const {
  return _internal_has_strategy_yellow();
}
inline void Status::clear_strategy_yellow() {
  if (strategy_yellow_ != nullptr) strategy_yellow_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::amun::StatusStrategy& Status::_internal_strategy_yellow() const {
  const ::amun::StatusStrategy* p = strategy_yellow_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::StatusStrategy*>(
      &::amun::_StatusStrategy_default_instance_);
}
inline const ::amun::StatusStrategy& Status::strategy_yellow() const {
  // @@protoc_insertion_point(field_get:amun.Status.strategy_yellow)
  return _internal_strategy_yellow();
}
inline void Status::unsafe_arena_set_allocated_strategy_yellow(
    ::amun::StatusStrategy* strategy_yellow) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(strategy_yellow_);
  }
  strategy_yellow_ = strategy_yellow;
  if (strategy_yellow) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.Status.strategy_yellow)
}
inline ::amun::StatusStrategy* Status::release_strategy_yellow() {
  auto temp = unsafe_arena_release_strategy_yellow();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::StatusStrategy* Status::unsafe_arena_release_strategy_yellow() {
  // @@protoc_insertion_point(field_release:amun.Status.strategy_yellow)
  _has_bits_[0] &= ~0x00000020u;
  ::amun::StatusStrategy* temp = strategy_yellow_;
  strategy_yellow_ = nullptr;
  return temp;
}
inline ::amun::StatusStrategy* Status::_internal_mutable_strategy_yellow() {
  _has_bits_[0] |= 0x00000020u;
  if (strategy_yellow_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::StatusStrategy>(GetArena());
    strategy_yellow_ = p;
  }
  return strategy_yellow_;
}
inline ::amun::StatusStrategy* Status::mutable_strategy_yellow() {
  // @@protoc_insertion_point(field_mutable:amun.Status.strategy_yellow)
  return _internal_mutable_strategy_yellow();
}
inline void Status::set_allocated_strategy_yellow(::amun::StatusStrategy* strategy_yellow) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete strategy_yellow_;
  }
  if (strategy_yellow) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(strategy_yellow);
    if (message_arena != submessage_arena) {
      strategy_yellow = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, strategy_yellow, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  strategy_yellow_ = strategy_yellow;
  // @@protoc_insertion_point(field_set_allocated:amun.Status.strategy_yellow)
}

// optional .amun.StatusStrategy strategy_autoref = 18;
inline bool Status::_internal_has_strategy_autoref() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || strategy_autoref_ != nullptr);
  return value;
}
inline bool Status::has_strategy_autoref() const {
  return _internal_has_strategy_autoref();
}
inline void Status::clear_strategy_autoref() {
  if (strategy_autoref_ != nullptr) strategy_autoref_->Clear();
  _has_bits_[0] &= ~0x00000800u;
}
inline const ::amun::StatusStrategy& Status::_internal_strategy_autoref() const {
  const ::amun::StatusStrategy* p = strategy_autoref_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::StatusStrategy*>(
      &::amun::_StatusStrategy_default_instance_);
}
inline const ::amun::StatusStrategy& Status::strategy_autoref() const {
  // @@protoc_insertion_point(field_get:amun.Status.strategy_autoref)
  return _internal_strategy_autoref();
}
inline void Status::unsafe_arena_set_allocated_strategy_autoref(
    ::amun::StatusStrategy* strategy_autoref) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(strategy_autoref_);
  }
  strategy_autoref_ = strategy_autoref;
  if (strategy_autoref) {
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.Status.strategy_autoref)
}
inline ::amun::StatusStrategy* Status::release_strategy_autoref() {
  auto temp = unsafe_arena_release_strategy_autoref();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::StatusStrategy* Status::unsafe_arena_release_strategy_autoref() {
  // @@protoc_insertion_point(field_release:amun.Status.strategy_autoref)
  _has_bits_[0] &= ~0x00000800u;
  ::amun::StatusStrategy* temp = strategy_autoref_;
  strategy_autoref_ = nullptr;
  return temp;
}
inline ::amun::StatusStrategy* Status::_internal_mutable_strategy_autoref() {
  _has_bits_[0] |= 0x00000800u;
  if (strategy_autoref_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::StatusStrategy>(GetArena());
    strategy_autoref_ = p;
  }
  return strategy_autoref_;
}
inline ::amun::StatusStrategy* Status::mutable_strategy_autoref() {
  // @@protoc_insertion_point(field_mutable:amun.Status.strategy_autoref)
  return _internal_mutable_strategy_autoref();
}
inline void Status::set_allocated_strategy_autoref(::amun::StatusStrategy* strategy_autoref) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete strategy_autoref_;
  }
  if (strategy_autoref) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(strategy_autoref);
    if (message_arena != submessage_arena) {
      strategy_autoref = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, strategy_autoref, submessage_arena);
    }
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  strategy_autoref_ = strategy_autoref;
  // @@protoc_insertion_point(field_set_allocated:amun.Status.strategy_autoref)
}

// repeated .amun.DebugValues debug = 10;
inline int Status::_internal_debug_size() const {
  return debug_.size();
}
inline int Status::debug_size() const {
  return _internal_debug_size();
}
inline ::amun::DebugValues* Status::mutable_debug(int index) {
  // @@protoc_insertion_point(field_mutable:amun.Status.debug)
  return debug_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::amun::DebugValues >*
Status::mutable_debug() {
  // @@protoc_insertion_point(field_mutable_list:amun.Status.debug)
  return &debug_;
}
inline const ::amun::DebugValues& Status::_internal_debug(int index) const {
  return debug_.Get(index);
}
inline const ::amun::DebugValues& Status::debug(int index) const {
  // @@protoc_insertion_point(field_get:amun.Status.debug)
  return _internal_debug(index);
}
inline ::amun::DebugValues* Status::_internal_add_debug() {
  return debug_.Add();
}
inline ::amun::DebugValues* Status::add_debug() {
  // @@protoc_insertion_point(field_add:amun.Status.debug)
  return _internal_add_debug();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::amun::DebugValues >&
Status::debug() const {
  // @@protoc_insertion_point(field_list:amun.Status.debug)
  return debug_;
}

// optional .amun.Timing timing = 11;
inline bool Status::_internal_has_timing() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || timing_ != nullptr);
  return value;
}
inline bool Status::has_timing() const {
  return _internal_has_timing();
}
inline void Status::clear_timing() {
  if (timing_ != nullptr) timing_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::amun::Timing& Status::_internal_timing() const {
  const ::amun::Timing* p = timing_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::Timing*>(
      &::amun::_Timing_default_instance_);
}
inline const ::amun::Timing& Status::timing() const {
  // @@protoc_insertion_point(field_get:amun.Status.timing)
  return _internal_timing();
}
inline void Status::unsafe_arena_set_allocated_timing(
    ::amun::Timing* timing) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timing_);
  }
  timing_ = timing;
  if (timing) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.Status.timing)
}
inline ::amun::Timing* Status::release_timing() {
  auto temp = unsafe_arena_release_timing();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::Timing* Status::unsafe_arena_release_timing() {
  // @@protoc_insertion_point(field_release:amun.Status.timing)
  _has_bits_[0] &= ~0x00000040u;
  ::amun::Timing* temp = timing_;
  timing_ = nullptr;
  return temp;
}
inline ::amun::Timing* Status::_internal_mutable_timing() {
  _has_bits_[0] |= 0x00000040u;
  if (timing_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::Timing>(GetArena());
    timing_ = p;
  }
  return timing_;
}
inline ::amun::Timing* Status::mutable_timing() {
  // @@protoc_insertion_point(field_mutable:amun.Status.timing)
  return _internal_mutable_timing();
}
inline void Status::set_allocated_timing(::amun::Timing* timing) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete timing_;
  }
  if (timing) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(timing);
    if (message_arena != submessage_arena) {
      timing = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timing, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  timing_ = timing;
  // @@protoc_insertion_point(field_set_allocated:amun.Status.timing)
}

// repeated .robot.RadioCommand radio_command = 12;
inline int Status::_internal_radio_command_size() const {
  return radio_command_.size();
}
inline int Status::radio_command_size() const {
  return _internal_radio_command_size();
}
inline ::robot::RadioCommand* Status::mutable_radio_command(int index) {
  // @@protoc_insertion_point(field_mutable:amun.Status.radio_command)
  return radio_command_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::RadioCommand >*
Status::mutable_radio_command() {
  // @@protoc_insertion_point(field_mutable_list:amun.Status.radio_command)
  return &radio_command_;
}
inline const ::robot::RadioCommand& Status::_internal_radio_command(int index) const {
  return radio_command_.Get(index);
}
inline const ::robot::RadioCommand& Status::radio_command(int index) const {
  // @@protoc_insertion_point(field_get:amun.Status.radio_command)
  return _internal_radio_command(index);
}
inline ::robot::RadioCommand* Status::_internal_add_radio_command() {
  return radio_command_.Add();
}
inline ::robot::RadioCommand* Status::add_radio_command() {
  // @@protoc_insertion_point(field_add:amun.Status.radio_command)
  return _internal_add_radio_command();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::RadioCommand >&
Status::radio_command() const {
  // @@protoc_insertion_point(field_list:amun.Status.radio_command)
  return radio_command_;
}

// optional .amun.StatusTransceiver transceiver = 13;
inline bool Status::_internal_has_transceiver() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || transceiver_ != nullptr);
  return value;
}
inline bool Status::has_transceiver() const {
  return _internal_has_transceiver();
}
inline void Status::clear_transceiver() {
  if (transceiver_ != nullptr) transceiver_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::amun::StatusTransceiver& Status::_internal_transceiver() const {
  const ::amun::StatusTransceiver* p = transceiver_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::StatusTransceiver*>(
      &::amun::_StatusTransceiver_default_instance_);
}
inline const ::amun::StatusTransceiver& Status::transceiver() const {
  // @@protoc_insertion_point(field_get:amun.Status.transceiver)
  return _internal_transceiver();
}
inline void Status::unsafe_arena_set_allocated_transceiver(
    ::amun::StatusTransceiver* transceiver) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transceiver_);
  }
  transceiver_ = transceiver;
  if (transceiver) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.Status.transceiver)
}
inline ::amun::StatusTransceiver* Status::release_transceiver() {
  auto temp = unsafe_arena_release_transceiver();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::StatusTransceiver* Status::unsafe_arena_release_transceiver() {
  // @@protoc_insertion_point(field_release:amun.Status.transceiver)
  _has_bits_[0] &= ~0x00000080u;
  ::amun::StatusTransceiver* temp = transceiver_;
  transceiver_ = nullptr;
  return temp;
}
inline ::amun::StatusTransceiver* Status::_internal_mutable_transceiver() {
  _has_bits_[0] |= 0x00000080u;
  if (transceiver_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::StatusTransceiver>(GetArena());
    transceiver_ = p;
  }
  return transceiver_;
}
inline ::amun::StatusTransceiver* Status::mutable_transceiver() {
  // @@protoc_insertion_point(field_mutable:amun.Status.transceiver)
  return _internal_mutable_transceiver();
}
inline void Status::set_allocated_transceiver(::amun::StatusTransceiver* transceiver) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete transceiver_;
  }
  if (transceiver) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(transceiver);
    if (message_arena != submessage_arena) {
      transceiver = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transceiver, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  transceiver_ = transceiver;
  // @@protoc_insertion_point(field_set_allocated:amun.Status.transceiver)
}

// optional .amun.UserInput user_input_blue = 16;
inline bool Status::_internal_has_user_input_blue() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || user_input_blue_ != nullptr);
  return value;
}
inline bool Status::has_user_input_blue() const {
  return _internal_has_user_input_blue();
}
inline const ::amun::UserInput& Status::_internal_user_input_blue() const {
  const ::amun::UserInput* p = user_input_blue_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::UserInput*>(
      &::amun::_UserInput_default_instance_);
}
inline const ::amun::UserInput& Status::user_input_blue() const {
  // @@protoc_insertion_point(field_get:amun.Status.user_input_blue)
  return _internal_user_input_blue();
}
inline void Status::unsafe_arena_set_allocated_user_input_blue(
    ::amun::UserInput* user_input_blue) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_input_blue_);
  }
  user_input_blue_ = user_input_blue;
  if (user_input_blue) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.Status.user_input_blue)
}
inline ::amun::UserInput* Status::release_user_input_blue() {
  auto temp = unsafe_arena_release_user_input_blue();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::UserInput* Status::unsafe_arena_release_user_input_blue() {
  // @@protoc_insertion_point(field_release:amun.Status.user_input_blue)
  _has_bits_[0] &= ~0x00000200u;
  ::amun::UserInput* temp = user_input_blue_;
  user_input_blue_ = nullptr;
  return temp;
}
inline ::amun::UserInput* Status::_internal_mutable_user_input_blue() {
  _has_bits_[0] |= 0x00000200u;
  if (user_input_blue_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::UserInput>(GetArena());
    user_input_blue_ = p;
  }
  return user_input_blue_;
}
inline ::amun::UserInput* Status::mutable_user_input_blue() {
  // @@protoc_insertion_point(field_mutable:amun.Status.user_input_blue)
  return _internal_mutable_user_input_blue();
}
inline void Status::set_allocated_user_input_blue(::amun::UserInput* user_input_blue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_input_blue_);
  }
  if (user_input_blue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_input_blue)->GetArena();
    if (message_arena != submessage_arena) {
      user_input_blue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_input_blue, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  user_input_blue_ = user_input_blue;
  // @@protoc_insertion_point(field_set_allocated:amun.Status.user_input_blue)
}

// optional .amun.UserInput user_input_yellow = 17;
inline bool Status::_internal_has_user_input_yellow() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || user_input_yellow_ != nullptr);
  return value;
}
inline bool Status::has_user_input_yellow() const {
  return _internal_has_user_input_yellow();
}
inline const ::amun::UserInput& Status::_internal_user_input_yellow() const {
  const ::amun::UserInput* p = user_input_yellow_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::UserInput*>(
      &::amun::_UserInput_default_instance_);
}
inline const ::amun::UserInput& Status::user_input_yellow() const {
  // @@protoc_insertion_point(field_get:amun.Status.user_input_yellow)
  return _internal_user_input_yellow();
}
inline void Status::unsafe_arena_set_allocated_user_input_yellow(
    ::amun::UserInput* user_input_yellow) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_input_yellow_);
  }
  user_input_yellow_ = user_input_yellow;
  if (user_input_yellow) {
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.Status.user_input_yellow)
}
inline ::amun::UserInput* Status::release_user_input_yellow() {
  auto temp = unsafe_arena_release_user_input_yellow();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::UserInput* Status::unsafe_arena_release_user_input_yellow() {
  // @@protoc_insertion_point(field_release:amun.Status.user_input_yellow)
  _has_bits_[0] &= ~0x00000400u;
  ::amun::UserInput* temp = user_input_yellow_;
  user_input_yellow_ = nullptr;
  return temp;
}
inline ::amun::UserInput* Status::_internal_mutable_user_input_yellow() {
  _has_bits_[0] |= 0x00000400u;
  if (user_input_yellow_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::UserInput>(GetArena());
    user_input_yellow_ = p;
  }
  return user_input_yellow_;
}
inline ::amun::UserInput* Status::mutable_user_input_yellow() {
  // @@protoc_insertion_point(field_mutable:amun.Status.user_input_yellow)
  return _internal_mutable_user_input_yellow();
}
inline void Status::set_allocated_user_input_yellow(::amun::UserInput* user_input_yellow) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_input_yellow_);
  }
  if (user_input_yellow) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_input_yellow)->GetArena();
    if (message_arena != submessage_arena) {
      user_input_yellow = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_input_yellow, submessage_arena);
    }
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  user_input_yellow_ = user_input_yellow;
  // @@protoc_insertion_point(field_set_allocated:amun.Status.user_input_yellow)
}

// optional .amun.StatusAmun amun_state = 19;
inline bool Status::_internal_has_amun_state() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || amun_state_ != nullptr);
  return value;
}
inline bool Status::has_amun_state() const {
  return _internal_has_amun_state();
}
inline void Status::clear_amun_state() {
  if (amun_state_ != nullptr) amun_state_->Clear();
  _has_bits_[0] &= ~0x00001000u;
}
inline const ::amun::StatusAmun& Status::_internal_amun_state() const {
  const ::amun::StatusAmun* p = amun_state_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::StatusAmun*>(
      &::amun::_StatusAmun_default_instance_);
}
inline const ::amun::StatusAmun& Status::amun_state() const {
  // @@protoc_insertion_point(field_get:amun.Status.amun_state)
  return _internal_amun_state();
}
inline void Status::unsafe_arena_set_allocated_amun_state(
    ::amun::StatusAmun* amun_state) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(amun_state_);
  }
  amun_state_ = amun_state;
  if (amun_state) {
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.Status.amun_state)
}
inline ::amun::StatusAmun* Status::release_amun_state() {
  auto temp = unsafe_arena_release_amun_state();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::StatusAmun* Status::unsafe_arena_release_amun_state() {
  // @@protoc_insertion_point(field_release:amun.Status.amun_state)
  _has_bits_[0] &= ~0x00001000u;
  ::amun::StatusAmun* temp = amun_state_;
  amun_state_ = nullptr;
  return temp;
}
inline ::amun::StatusAmun* Status::_internal_mutable_amun_state() {
  _has_bits_[0] |= 0x00001000u;
  if (amun_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::StatusAmun>(GetArena());
    amun_state_ = p;
  }
  return amun_state_;
}
inline ::amun::StatusAmun* Status::mutable_amun_state() {
  // @@protoc_insertion_point(field_mutable:amun.Status.amun_state)
  return _internal_mutable_amun_state();
}
inline void Status::set_allocated_amun_state(::amun::StatusAmun* amun_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete amun_state_;
  }
  if (amun_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(amun_state);
    if (message_arena != submessage_arena) {
      amun_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, amun_state, submessage_arena);
    }
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  amun_state_ = amun_state;
  // @@protoc_insertion_point(field_set_allocated:amun.Status.amun_state)
}

// optional float timer_scaling = 20;
inline bool Status::_internal_has_timer_scaling() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool Status::has_timer_scaling() const {
  return _internal_has_timer_scaling();
}
inline void Status::clear_timer_scaling() {
  timer_scaling_ = 0;
  _has_bits_[0] &= ~0x00100000u;
}
inline float Status::_internal_timer_scaling() const {
  return timer_scaling_;
}
inline float Status::timer_scaling() const {
  // @@protoc_insertion_point(field_get:amun.Status.timer_scaling)
  return _internal_timer_scaling();
}
inline void Status::_internal_set_timer_scaling(float value) {
  _has_bits_[0] |= 0x00100000u;
  timer_scaling_ = value;
}
inline void Status::set_timer_scaling(float value) {
  _internal_set_timer_scaling(value);
  // @@protoc_insertion_point(field_set:amun.Status.timer_scaling)
}

// optional bool blue_running = 21;
inline bool Status::_internal_has_blue_running() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool Status::has_blue_running() const {
  return _internal_has_blue_running();
}
inline void Status::clear_blue_running() {
  blue_running_ = false;
  _has_bits_[0] &= ~0x00200000u;
}
inline bool Status::_internal_blue_running() const {
  return blue_running_;
}
inline bool Status::blue_running() const {
  // @@protoc_insertion_point(field_get:amun.Status.blue_running)
  return _internal_blue_running();
}
inline void Status::_internal_set_blue_running(bool value) {
  _has_bits_[0] |= 0x00200000u;
  blue_running_ = value;
}
inline void Status::set_blue_running(bool value) {
  _internal_set_blue_running(value);
  // @@protoc_insertion_point(field_set:amun.Status.blue_running)
}

// optional bool yellow_running = 22;
inline bool Status::_internal_has_yellow_running() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool Status::has_yellow_running() const {
  return _internal_has_yellow_running();
}
inline void Status::clear_yellow_running() {
  yellow_running_ = false;
  _has_bits_[0] &= ~0x00400000u;
}
inline bool Status::_internal_yellow_running() const {
  return yellow_running_;
}
inline bool Status::yellow_running() const {
  // @@protoc_insertion_point(field_get:amun.Status.yellow_running)
  return _internal_yellow_running();
}
inline void Status::_internal_set_yellow_running(bool value) {
  _has_bits_[0] |= 0x00400000u;
  yellow_running_ = value;
}
inline void Status::set_yellow_running(bool value) {
  _internal_set_yellow_running(value);
  // @@protoc_insertion_point(field_set:amun.Status.yellow_running)
}

// optional bool autoref_running = 26;
inline bool Status::_internal_has_autoref_running() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool Status::has_autoref_running() const {
  return _internal_has_autoref_running();
}
inline void Status::clear_autoref_running() {
  autoref_running_ = false;
  _has_bits_[0] &= ~0x00800000u;
}
inline bool Status::_internal_autoref_running() const {
  return autoref_running_;
}
inline bool Status::autoref_running() const {
  // @@protoc_insertion_point(field_get:amun.Status.autoref_running)
  return _internal_autoref_running();
}
inline void Status::_internal_set_autoref_running(bool value) {
  _has_bits_[0] |= 0x00800000u;
  autoref_running_ = value;
}
inline void Status::set_autoref_running(bool value) {
  _internal_set_autoref_running(value);
  // @@protoc_insertion_point(field_set:amun.Status.autoref_running)
}

// optional .world.State execution_state = 23;
inline bool Status::_internal_has_execution_state() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || execution_state_ != nullptr);
  return value;
}
inline bool Status::has_execution_state() const {
  return _internal_has_execution_state();
}
inline const ::world::State& Status::_internal_execution_state() const {
  const ::world::State* p = execution_state_;
  return p != nullptr ? *p : *reinterpret_cast<const ::world::State*>(
      &::world::_State_default_instance_);
}
inline const ::world::State& Status::execution_state() const {
  // @@protoc_insertion_point(field_get:amun.Status.execution_state)
  return _internal_execution_state();
}
inline void Status::unsafe_arena_set_allocated_execution_state(
    ::world::State* execution_state) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(execution_state_);
  }
  execution_state_ = execution_state;
  if (execution_state) {
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.Status.execution_state)
}
inline ::world::State* Status::release_execution_state() {
  auto temp = unsafe_arena_release_execution_state();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::world::State* Status::unsafe_arena_release_execution_state() {
  // @@protoc_insertion_point(field_release:amun.Status.execution_state)
  _has_bits_[0] &= ~0x00002000u;
  ::world::State* temp = execution_state_;
  execution_state_ = nullptr;
  return temp;
}
inline ::world::State* Status::_internal_mutable_execution_state() {
  _has_bits_[0] |= 0x00002000u;
  if (execution_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::world::State>(GetArena());
    execution_state_ = p;
  }
  return execution_state_;
}
inline ::world::State* Status::mutable_execution_state() {
  // @@protoc_insertion_point(field_mutable:amun.Status.execution_state)
  return _internal_mutable_execution_state();
}
inline void Status::set_allocated_execution_state(::world::State* execution_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(execution_state_);
  }
  if (execution_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(execution_state)->GetArena();
    if (message_arena != submessage_arena) {
      execution_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, execution_state, submessage_arena);
    }
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  execution_state_ = execution_state;
  // @@protoc_insertion_point(field_set_allocated:amun.Status.execution_state)
}

// optional .amun.GameState execution_game_state = 24;
inline bool Status::_internal_has_execution_game_state() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!value || execution_game_state_ != nullptr);
  return value;
}
inline bool Status::has_execution_game_state() const {
  return _internal_has_execution_game_state();
}
inline const ::amun::GameState& Status::_internal_execution_game_state() const {
  const ::amun::GameState* p = execution_game_state_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::GameState*>(
      &::amun::_GameState_default_instance_);
}
inline const ::amun::GameState& Status::execution_game_state() const {
  // @@protoc_insertion_point(field_get:amun.Status.execution_game_state)
  return _internal_execution_game_state();
}
inline void Status::unsafe_arena_set_allocated_execution_game_state(
    ::amun::GameState* execution_game_state) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(execution_game_state_);
  }
  execution_game_state_ = execution_game_state;
  if (execution_game_state) {
    _has_bits_[0] |= 0x00004000u;
  } else {
    _has_bits_[0] &= ~0x00004000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.Status.execution_game_state)
}
inline ::amun::GameState* Status::release_execution_game_state() {
  auto temp = unsafe_arena_release_execution_game_state();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::GameState* Status::unsafe_arena_release_execution_game_state() {
  // @@protoc_insertion_point(field_release:amun.Status.execution_game_state)
  _has_bits_[0] &= ~0x00004000u;
  ::amun::GameState* temp = execution_game_state_;
  execution_game_state_ = nullptr;
  return temp;
}
inline ::amun::GameState* Status::_internal_mutable_execution_game_state() {
  _has_bits_[0] |= 0x00004000u;
  if (execution_game_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::GameState>(GetArena());
    execution_game_state_ = p;
  }
  return execution_game_state_;
}
inline ::amun::GameState* Status::mutable_execution_game_state() {
  // @@protoc_insertion_point(field_mutable:amun.Status.execution_game_state)
  return _internal_mutable_execution_game_state();
}
inline void Status::set_allocated_execution_game_state(::amun::GameState* execution_game_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(execution_game_state_);
  }
  if (execution_game_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(execution_game_state)->GetArena();
    if (message_arena != submessage_arena) {
      execution_game_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, execution_game_state, submessage_arena);
    }
    _has_bits_[0] |= 0x00004000u;
  } else {
    _has_bits_[0] &= ~0x00004000u;
  }
  execution_game_state_ = execution_game_state;
  // @@protoc_insertion_point(field_set_allocated:amun.Status.execution_game_state)
}

// optional .amun.UserInput execution_user_input = 25;
inline bool Status::_internal_has_execution_user_input() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  PROTOBUF_ASSUME(!value || execution_user_input_ != nullptr);
  return value;
}
inline bool Status::has_execution_user_input() const {
  return _internal_has_execution_user_input();
}
inline const ::amun::UserInput& Status::_internal_execution_user_input() const {
  const ::amun::UserInput* p = execution_user_input_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::UserInput*>(
      &::amun::_UserInput_default_instance_);
}
inline const ::amun::UserInput& Status::execution_user_input() const {
  // @@protoc_insertion_point(field_get:amun.Status.execution_user_input)
  return _internal_execution_user_input();
}
inline void Status::unsafe_arena_set_allocated_execution_user_input(
    ::amun::UserInput* execution_user_input) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(execution_user_input_);
  }
  execution_user_input_ = execution_user_input;
  if (execution_user_input) {
    _has_bits_[0] |= 0x00008000u;
  } else {
    _has_bits_[0] &= ~0x00008000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.Status.execution_user_input)
}
inline ::amun::UserInput* Status::release_execution_user_input() {
  auto temp = unsafe_arena_release_execution_user_input();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::UserInput* Status::unsafe_arena_release_execution_user_input() {
  // @@protoc_insertion_point(field_release:amun.Status.execution_user_input)
  _has_bits_[0] &= ~0x00008000u;
  ::amun::UserInput* temp = execution_user_input_;
  execution_user_input_ = nullptr;
  return temp;
}
inline ::amun::UserInput* Status::_internal_mutable_execution_user_input() {
  _has_bits_[0] |= 0x00008000u;
  if (execution_user_input_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::UserInput>(GetArena());
    execution_user_input_ = p;
  }
  return execution_user_input_;
}
inline ::amun::UserInput* Status::mutable_execution_user_input() {
  // @@protoc_insertion_point(field_mutable:amun.Status.execution_user_input)
  return _internal_mutable_execution_user_input();
}
inline void Status::set_allocated_execution_user_input(::amun::UserInput* execution_user_input) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(execution_user_input_);
  }
  if (execution_user_input) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(execution_user_input)->GetArena();
    if (message_arena != submessage_arena) {
      execution_user_input = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, execution_user_input, submessage_arena);
    }
    _has_bits_[0] |= 0x00008000u;
  } else {
    _has_bits_[0] &= ~0x00008000u;
  }
  execution_user_input_ = execution_user_input;
  // @@protoc_insertion_point(field_set_allocated:amun.Status.execution_user_input)
}

// optional .logfile.Uid log_id = 27;
inline bool Status::_internal_has_log_id() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  PROTOBUF_ASSUME(!value || log_id_ != nullptr);
  return value;
}
inline bool Status::has_log_id() const {
  return _internal_has_log_id();
}
inline const ::logfile::Uid& Status::_internal_log_id() const {
  const ::logfile::Uid* p = log_id_;
  return p != nullptr ? *p : *reinterpret_cast<const ::logfile::Uid*>(
      &::logfile::_Uid_default_instance_);
}
inline const ::logfile::Uid& Status::log_id() const {
  // @@protoc_insertion_point(field_get:amun.Status.log_id)
  return _internal_log_id();
}
inline void Status::unsafe_arena_set_allocated_log_id(
    ::logfile::Uid* log_id) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(log_id_);
  }
  log_id_ = log_id;
  if (log_id) {
    _has_bits_[0] |= 0x00010000u;
  } else {
    _has_bits_[0] &= ~0x00010000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.Status.log_id)
}
inline ::logfile::Uid* Status::release_log_id() {
  auto temp = unsafe_arena_release_log_id();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::logfile::Uid* Status::unsafe_arena_release_log_id() {
  // @@protoc_insertion_point(field_release:amun.Status.log_id)
  _has_bits_[0] &= ~0x00010000u;
  ::logfile::Uid* temp = log_id_;
  log_id_ = nullptr;
  return temp;
}
inline ::logfile::Uid* Status::_internal_mutable_log_id() {
  _has_bits_[0] |= 0x00010000u;
  if (log_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::logfile::Uid>(GetArena());
    log_id_ = p;
  }
  return log_id_;
}
inline ::logfile::Uid* Status::mutable_log_id() {
  // @@protoc_insertion_point(field_mutable:amun.Status.log_id)
  return _internal_mutable_log_id();
}
inline void Status::set_allocated_log_id(::logfile::Uid* log_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(log_id_);
  }
  if (log_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(log_id)->GetArena();
    if (message_arena != submessage_arena) {
      log_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, log_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00010000u;
  } else {
    _has_bits_[0] &= ~0x00010000u;
  }
  log_id_ = log_id;
  // @@protoc_insertion_point(field_set_allocated:amun.Status.log_id)
}

// optional uint64 original_frame_number = 28;
inline bool Status::_internal_has_original_frame_number() const {
  bool value = (_has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool Status::has_original_frame_number() const {
  return _internal_has_original_frame_number();
}
inline void Status::clear_original_frame_number() {
  original_frame_number_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x01000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Status::_internal_original_frame_number() const {
  return original_frame_number_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Status::original_frame_number() const {
  // @@protoc_insertion_point(field_get:amun.Status.original_frame_number)
  return _internal_original_frame_number();
}
inline void Status::_internal_set_original_frame_number(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x01000000u;
  original_frame_number_ = value;
}
inline void Status::set_original_frame_number(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_original_frame_number(value);
  // @@protoc_insertion_point(field_set:amun.Status.original_frame_number)
}

// optional .amun.StatusStrategyWrapper status_strategy = 29;
inline bool Status::_internal_has_status_strategy() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  PROTOBUF_ASSUME(!value || status_strategy_ != nullptr);
  return value;
}
inline bool Status::has_status_strategy() const {
  return _internal_has_status_strategy();
}
inline void Status::clear_status_strategy() {
  if (status_strategy_ != nullptr) status_strategy_->Clear();
  _has_bits_[0] &= ~0x00020000u;
}
inline const ::amun::StatusStrategyWrapper& Status::_internal_status_strategy() const {
  const ::amun::StatusStrategyWrapper* p = status_strategy_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::StatusStrategyWrapper*>(
      &::amun::_StatusStrategyWrapper_default_instance_);
}
inline const ::amun::StatusStrategyWrapper& Status::status_strategy() const {
  // @@protoc_insertion_point(field_get:amun.Status.status_strategy)
  return _internal_status_strategy();
}
inline void Status::unsafe_arena_set_allocated_status_strategy(
    ::amun::StatusStrategyWrapper* status_strategy) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_strategy_);
  }
  status_strategy_ = status_strategy;
  if (status_strategy) {
    _has_bits_[0] |= 0x00020000u;
  } else {
    _has_bits_[0] &= ~0x00020000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.Status.status_strategy)
}
inline ::amun::StatusStrategyWrapper* Status::release_status_strategy() {
  auto temp = unsafe_arena_release_status_strategy();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::StatusStrategyWrapper* Status::unsafe_arena_release_status_strategy() {
  // @@protoc_insertion_point(field_release:amun.Status.status_strategy)
  _has_bits_[0] &= ~0x00020000u;
  ::amun::StatusStrategyWrapper* temp = status_strategy_;
  status_strategy_ = nullptr;
  return temp;
}
inline ::amun::StatusStrategyWrapper* Status::_internal_mutable_status_strategy() {
  _has_bits_[0] |= 0x00020000u;
  if (status_strategy_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::StatusStrategyWrapper>(GetArena());
    status_strategy_ = p;
  }
  return status_strategy_;
}
inline ::amun::StatusStrategyWrapper* Status::mutable_status_strategy() {
  // @@protoc_insertion_point(field_mutable:amun.Status.status_strategy)
  return _internal_mutable_status_strategy();
}
inline void Status::set_allocated_status_strategy(::amun::StatusStrategyWrapper* status_strategy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete status_strategy_;
  }
  if (status_strategy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(status_strategy);
    if (message_arena != submessage_arena) {
      status_strategy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status_strategy, submessage_arena);
    }
    _has_bits_[0] |= 0x00020000u;
  } else {
    _has_bits_[0] &= ~0x00020000u;
  }
  status_strategy_ = status_strategy;
  // @@protoc_insertion_point(field_set_allocated:amun.Status.status_strategy)
}

// optional .amun.UiResponse pure_ui_response = 30;
inline bool Status::_internal_has_pure_ui_response() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  PROTOBUF_ASSUME(!value || pure_ui_response_ != nullptr);
  return value;
}
inline bool Status::has_pure_ui_response() const {
  return _internal_has_pure_ui_response();
}
inline void Status::clear_pure_ui_response() {
  if (pure_ui_response_ != nullptr) pure_ui_response_->Clear();
  _has_bits_[0] &= ~0x00040000u;
}
inline const ::amun::UiResponse& Status::_internal_pure_ui_response() const {
  const ::amun::UiResponse* p = pure_ui_response_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::UiResponse*>(
      &::amun::_UiResponse_default_instance_);
}
inline const ::amun::UiResponse& Status::pure_ui_response() const {
  // @@protoc_insertion_point(field_get:amun.Status.pure_ui_response)
  return _internal_pure_ui_response();
}
inline void Status::unsafe_arena_set_allocated_pure_ui_response(
    ::amun::UiResponse* pure_ui_response) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pure_ui_response_);
  }
  pure_ui_response_ = pure_ui_response;
  if (pure_ui_response) {
    _has_bits_[0] |= 0x00040000u;
  } else {
    _has_bits_[0] &= ~0x00040000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.Status.pure_ui_response)
}
inline ::amun::UiResponse* Status::release_pure_ui_response() {
  auto temp = unsafe_arena_release_pure_ui_response();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::UiResponse* Status::unsafe_arena_release_pure_ui_response() {
  // @@protoc_insertion_point(field_release:amun.Status.pure_ui_response)
  _has_bits_[0] &= ~0x00040000u;
  ::amun::UiResponse* temp = pure_ui_response_;
  pure_ui_response_ = nullptr;
  return temp;
}
inline ::amun::UiResponse* Status::_internal_mutable_pure_ui_response() {
  _has_bits_[0] |= 0x00040000u;
  if (pure_ui_response_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::UiResponse>(GetArena());
    pure_ui_response_ = p;
  }
  return pure_ui_response_;
}
inline ::amun::UiResponse* Status::mutable_pure_ui_response() {
  // @@protoc_insertion_point(field_mutable:amun.Status.pure_ui_response)
  return _internal_mutable_pure_ui_response();
}
inline void Status::set_allocated_pure_ui_response(::amun::UiResponse* pure_ui_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete pure_ui_response_;
  }
  if (pure_ui_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(pure_ui_response);
    if (message_arena != submessage_arena) {
      pure_ui_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pure_ui_response, submessage_arena);
    }
    _has_bits_[0] |= 0x00040000u;
  } else {
    _has_bits_[0] &= ~0x00040000u;
  }
  pure_ui_response_ = pure_ui_response;
  // @@protoc_insertion_point(field_set_allocated:amun.Status.pure_ui_response)
}

// repeated .amun.GitInfo git_info = 31;
inline int Status::_internal_git_info_size() const {
  return git_info_.size();
}
inline int Status::git_info_size() const {
  return _internal_git_info_size();
}
inline void Status::clear_git_info() {
  git_info_.Clear();
}
inline ::amun::GitInfo* Status::mutable_git_info(int index) {
  // @@protoc_insertion_point(field_mutable:amun.Status.git_info)
  return git_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::amun::GitInfo >*
Status::mutable_git_info() {
  // @@protoc_insertion_point(field_mutable_list:amun.Status.git_info)
  return &git_info_;
}
inline const ::amun::GitInfo& Status::_internal_git_info(int index) const {
  return git_info_.Get(index);
}
inline const ::amun::GitInfo& Status::git_info(int index) const {
  // @@protoc_insertion_point(field_get:amun.Status.git_info)
  return _internal_git_info(index);
}
inline ::amun::GitInfo* Status::_internal_add_git_info() {
  return git_info_.Add();
}
inline ::amun::GitInfo* Status::add_git_info() {
  // @@protoc_insertion_point(field_add:amun.Status.git_info)
  return _internal_add_git_info();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::amun::GitInfo >&
Status::git_info() const {
  // @@protoc_insertion_point(field_list:amun.Status.git_info)
  return git_info_;
}

// -------------------------------------------------------------------

// UiResponse

// optional bool enable_logging = 1;
inline bool UiResponse::_internal_has_enable_logging() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool UiResponse::has_enable_logging() const {
  return _internal_has_enable_logging();
}
inline void UiResponse::clear_enable_logging() {
  enable_logging_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool UiResponse::_internal_enable_logging() const {
  return enable_logging_;
}
inline bool UiResponse::enable_logging() const {
  // @@protoc_insertion_point(field_get:amun.UiResponse.enable_logging)
  return _internal_enable_logging();
}
inline void UiResponse::_internal_set_enable_logging(bool value) {
  _has_bits_[0] |= 0x00000100u;
  enable_logging_ = value;
}
inline void UiResponse::set_enable_logging(bool value) {
  _internal_set_enable_logging(value);
  // @@protoc_insertion_point(field_set:amun.UiResponse.enable_logging)
}

// optional .amun.LoggingInfo logging_info = 2;
inline bool UiResponse::_internal_has_logging_info() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || logging_info_ != nullptr);
  return value;
}
inline bool UiResponse::has_logging_info() const {
  return _internal_has_logging_info();
}
inline void UiResponse::clear_logging_info() {
  if (logging_info_ != nullptr) logging_info_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::amun::LoggingInfo& UiResponse::_internal_logging_info() const {
  const ::amun::LoggingInfo* p = logging_info_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::LoggingInfo*>(
      &::amun::_LoggingInfo_default_instance_);
}
inline const ::amun::LoggingInfo& UiResponse::logging_info() const {
  // @@protoc_insertion_point(field_get:amun.UiResponse.logging_info)
  return _internal_logging_info();
}
inline void UiResponse::unsafe_arena_set_allocated_logging_info(
    ::amun::LoggingInfo* logging_info) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(logging_info_);
  }
  logging_info_ = logging_info;
  if (logging_info) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.UiResponse.logging_info)
}
inline ::amun::LoggingInfo* UiResponse::release_logging_info() {
  auto temp = unsafe_arena_release_logging_info();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::LoggingInfo* UiResponse::unsafe_arena_release_logging_info() {
  // @@protoc_insertion_point(field_release:amun.UiResponse.logging_info)
  _has_bits_[0] &= ~0x00000008u;
  ::amun::LoggingInfo* temp = logging_info_;
  logging_info_ = nullptr;
  return temp;
}
inline ::amun::LoggingInfo* UiResponse::_internal_mutable_logging_info() {
  _has_bits_[0] |= 0x00000008u;
  if (logging_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::LoggingInfo>(GetArena());
    logging_info_ = p;
  }
  return logging_info_;
}
inline ::amun::LoggingInfo* UiResponse::mutable_logging_info() {
  // @@protoc_insertion_point(field_mutable:amun.UiResponse.logging_info)
  return _internal_mutable_logging_info();
}
inline void UiResponse::set_allocated_logging_info(::amun::LoggingInfo* logging_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete logging_info_;
  }
  if (logging_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(logging_info);
    if (message_arena != submessage_arena) {
      logging_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, logging_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  logging_info_ = logging_info;
  // @@protoc_insertion_point(field_set_allocated:amun.UiResponse.logging_info)
}

// repeated .amun.Status logger_status = 3;
inline int UiResponse::_internal_logger_status_size() const {
  return logger_status_.size();
}
inline int UiResponse::logger_status_size() const {
  return _internal_logger_status_size();
}
inline void UiResponse::clear_logger_status() {
  logger_status_.Clear();
}
inline ::amun::Status* UiResponse::mutable_logger_status(int index) {
  // @@protoc_insertion_point(field_mutable:amun.UiResponse.logger_status)
  return logger_status_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::amun::Status >*
UiResponse::mutable_logger_status() {
  // @@protoc_insertion_point(field_mutable_list:amun.UiResponse.logger_status)
  return &logger_status_;
}
inline const ::amun::Status& UiResponse::_internal_logger_status(int index) const {
  return logger_status_.Get(index);
}
inline const ::amun::Status& UiResponse::logger_status(int index) const {
  // @@protoc_insertion_point(field_get:amun.UiResponse.logger_status)
  return _internal_logger_status(index);
}
inline ::amun::Status* UiResponse::_internal_add_logger_status() {
  return logger_status_.Add();
}
inline ::amun::Status* UiResponse::add_logger_status() {
  // @@protoc_insertion_point(field_add:amun.UiResponse.logger_status)
  return _internal_add_logger_status();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::amun::Status >&
UiResponse::logger_status() const {
  // @@protoc_insertion_point(field_list:amun.UiResponse.logger_status)
  return logger_status_;
}

// optional bool playback_burst_end = 4;
inline bool UiResponse::_internal_has_playback_burst_end() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool UiResponse::has_playback_burst_end() const {
  return _internal_has_playback_burst_end();
}
inline void UiResponse::clear_playback_burst_end() {
  playback_burst_end_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool UiResponse::_internal_playback_burst_end() const {
  return playback_burst_end_;
}
inline bool UiResponse::playback_burst_end() const {
  // @@protoc_insertion_point(field_get:amun.UiResponse.playback_burst_end)
  return _internal_playback_burst_end();
}
inline void UiResponse::_internal_set_playback_burst_end(bool value) {
  _has_bits_[0] |= 0x00000200u;
  playback_burst_end_ = value;
}
inline void UiResponse::set_playback_burst_end(bool value) {
  _internal_set_playback_burst_end(value);
  // @@protoc_insertion_point(field_set:amun.UiResponse.playback_burst_end)
}

// optional bool playback_paused = 5;
inline bool UiResponse::_internal_has_playback_paused() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool UiResponse::has_playback_paused() const {
  return _internal_has_playback_paused();
}
inline void UiResponse::clear_playback_paused() {
  playback_paused_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool UiResponse::_internal_playback_paused() const {
  return playback_paused_;
}
inline bool UiResponse::playback_paused() const {
  // @@protoc_insertion_point(field_get:amun.UiResponse.playback_paused)
  return _internal_playback_paused();
}
inline void UiResponse::_internal_set_playback_paused(bool value) {
  _has_bits_[0] |= 0x00000400u;
  playback_paused_ = value;
}
inline void UiResponse::set_playback_paused(bool value) {
  _internal_set_playback_paused(value);
  // @@protoc_insertion_point(field_set:amun.UiResponse.playback_paused)
}

// optional .amun.LogPlaybackInfo log_info = 6;
inline bool UiResponse::_internal_has_log_info() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || log_info_ != nullptr);
  return value;
}
inline bool UiResponse::has_log_info() const {
  return _internal_has_log_info();
}
inline void UiResponse::clear_log_info() {
  if (log_info_ != nullptr) log_info_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::amun::LogPlaybackInfo& UiResponse::_internal_log_info() const {
  const ::amun::LogPlaybackInfo* p = log_info_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::LogPlaybackInfo*>(
      &::amun::_LogPlaybackInfo_default_instance_);
}
inline const ::amun::LogPlaybackInfo& UiResponse::log_info() const {
  // @@protoc_insertion_point(field_get:amun.UiResponse.log_info)
  return _internal_log_info();
}
inline void UiResponse::unsafe_arena_set_allocated_log_info(
    ::amun::LogPlaybackInfo* log_info) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(log_info_);
  }
  log_info_ = log_info;
  if (log_info) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.UiResponse.log_info)
}
inline ::amun::LogPlaybackInfo* UiResponse::release_log_info() {
  auto temp = unsafe_arena_release_log_info();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::LogPlaybackInfo* UiResponse::unsafe_arena_release_log_info() {
  // @@protoc_insertion_point(field_release:amun.UiResponse.log_info)
  _has_bits_[0] &= ~0x00000010u;
  ::amun::LogPlaybackInfo* temp = log_info_;
  log_info_ = nullptr;
  return temp;
}
inline ::amun::LogPlaybackInfo* UiResponse::_internal_mutable_log_info() {
  _has_bits_[0] |= 0x00000010u;
  if (log_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::LogPlaybackInfo>(GetArena());
    log_info_ = p;
  }
  return log_info_;
}
inline ::amun::LogPlaybackInfo* UiResponse::mutable_log_info() {
  // @@protoc_insertion_point(field_mutable:amun.UiResponse.log_info)
  return _internal_mutable_log_info();
}
inline void UiResponse::set_allocated_log_info(::amun::LogPlaybackInfo* log_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete log_info_;
  }
  if (log_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(log_info);
    if (message_arena != submessage_arena) {
      log_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, log_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  log_info_ = log_info;
  // @@protoc_insertion_point(field_set_allocated:amun.UiResponse.log_info)
}

// optional int64 frame_number = 7;
inline bool UiResponse::_internal_has_frame_number() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool UiResponse::has_frame_number() const {
  return _internal_has_frame_number();
}
inline void UiResponse::clear_frame_number() {
  frame_number_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 UiResponse::_internal_frame_number() const {
  return frame_number_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 UiResponse::frame_number() const {
  // @@protoc_insertion_point(field_get:amun.UiResponse.frame_number)
  return _internal_frame_number();
}
inline void UiResponse::_internal_set_frame_number(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000080u;
  frame_number_ = value;
}
inline void UiResponse::set_frame_number(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_frame_number(value);
  // @@protoc_insertion_point(field_set:amun.UiResponse.frame_number)
}

// optional bool force_ra_horus = 8;
inline bool UiResponse::_internal_has_force_ra_horus() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool UiResponse::has_force_ra_horus() const {
  return _internal_has_force_ra_horus();
}
inline void UiResponse::clear_force_ra_horus() {
  force_ra_horus_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool UiResponse::_internal_force_ra_horus() const {
  return force_ra_horus_;
}
inline bool UiResponse::force_ra_horus() const {
  // @@protoc_insertion_point(field_get:amun.UiResponse.force_ra_horus)
  return _internal_force_ra_horus();
}
inline void UiResponse::_internal_set_force_ra_horus(bool value) {
  _has_bits_[0] |= 0x00000800u;
  force_ra_horus_ = value;
}
inline void UiResponse::set_force_ra_horus(bool value) {
  _internal_set_force_ra_horus(value);
  // @@protoc_insertion_point(field_set:amun.UiResponse.force_ra_horus)
}

// optional .amun.LogfileOpenInfo log_open = 9;
inline bool UiResponse::_internal_has_log_open() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || log_open_ != nullptr);
  return value;
}
inline bool UiResponse::has_log_open() const {
  return _internal_has_log_open();
}
inline void UiResponse::clear_log_open() {
  if (log_open_ != nullptr) log_open_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::amun::LogfileOpenInfo& UiResponse::_internal_log_open() const {
  const ::amun::LogfileOpenInfo* p = log_open_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::LogfileOpenInfo*>(
      &::amun::_LogfileOpenInfo_default_instance_);
}
inline const ::amun::LogfileOpenInfo& UiResponse::log_open() const {
  // @@protoc_insertion_point(field_get:amun.UiResponse.log_open)
  return _internal_log_open();
}
inline void UiResponse::unsafe_arena_set_allocated_log_open(
    ::amun::LogfileOpenInfo* log_open) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(log_open_);
  }
  log_open_ = log_open;
  if (log_open) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.UiResponse.log_open)
}
inline ::amun::LogfileOpenInfo* UiResponse::release_log_open() {
  auto temp = unsafe_arena_release_log_open();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::LogfileOpenInfo* UiResponse::unsafe_arena_release_log_open() {
  // @@protoc_insertion_point(field_release:amun.UiResponse.log_open)
  _has_bits_[0] &= ~0x00000020u;
  ::amun::LogfileOpenInfo* temp = log_open_;
  log_open_ = nullptr;
  return temp;
}
inline ::amun::LogfileOpenInfo* UiResponse::_internal_mutable_log_open() {
  _has_bits_[0] |= 0x00000020u;
  if (log_open_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::LogfileOpenInfo>(GetArena());
    log_open_ = p;
  }
  return log_open_;
}
inline ::amun::LogfileOpenInfo* UiResponse::mutable_log_open() {
  // @@protoc_insertion_point(field_mutable:amun.UiResponse.log_open)
  return _internal_mutable_log_open();
}
inline void UiResponse::set_allocated_log_open(::amun::LogfileOpenInfo* log_open) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete log_open_;
  }
  if (log_open) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(log_open);
    if (message_arena != submessage_arena) {
      log_open = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, log_open, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  log_open_ = log_open;
  // @@protoc_insertion_point(field_set_allocated:amun.UiResponse.log_open)
}

// optional string export_visionlog_error = 10;
inline bool UiResponse::_internal_has_export_visionlog_error() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UiResponse::has_export_visionlog_error() const {
  return _internal_has_export_visionlog_error();
}
inline void UiResponse::clear_export_visionlog_error() {
  export_visionlog_error_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UiResponse::export_visionlog_error() const {
  // @@protoc_insertion_point(field_get:amun.UiResponse.export_visionlog_error)
  return _internal_export_visionlog_error();
}
inline void UiResponse::set_export_visionlog_error(const std::string& value) {
  _internal_set_export_visionlog_error(value);
  // @@protoc_insertion_point(field_set:amun.UiResponse.export_visionlog_error)
}
inline std::string* UiResponse::mutable_export_visionlog_error() {
  // @@protoc_insertion_point(field_mutable:amun.UiResponse.export_visionlog_error)
  return _internal_mutable_export_visionlog_error();
}
inline const std::string& UiResponse::_internal_export_visionlog_error() const {
  return export_visionlog_error_.Get();
}
inline void UiResponse::_internal_set_export_visionlog_error(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  export_visionlog_error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UiResponse::set_export_visionlog_error(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  export_visionlog_error_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:amun.UiResponse.export_visionlog_error)
}
inline void UiResponse::set_export_visionlog_error(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  export_visionlog_error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:amun.UiResponse.export_visionlog_error)
}
inline void UiResponse::set_export_visionlog_error(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  export_visionlog_error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:amun.UiResponse.export_visionlog_error)
}
inline std::string* UiResponse::_internal_mutable_export_visionlog_error() {
  _has_bits_[0] |= 0x00000001u;
  return export_visionlog_error_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UiResponse::release_export_visionlog_error() {
  // @@protoc_insertion_point(field_release:amun.UiResponse.export_visionlog_error)
  if (!_internal_has_export_visionlog_error()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return export_visionlog_error_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UiResponse::set_allocated_export_visionlog_error(std::string* export_visionlog_error) {
  if (export_visionlog_error != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  export_visionlog_error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), export_visionlog_error,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:amun.UiResponse.export_visionlog_error)
}
inline std::string* UiResponse::unsafe_arena_release_export_visionlog_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:amun.UiResponse.export_visionlog_error)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return export_visionlog_error_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void UiResponse::unsafe_arena_set_allocated_export_visionlog_error(
    std::string* export_visionlog_error) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (export_visionlog_error != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  export_visionlog_error_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      export_visionlog_error, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.UiResponse.export_visionlog_error)
}

// optional string requested_log_uid = 11;
inline bool UiResponse::_internal_has_requested_log_uid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UiResponse::has_requested_log_uid() const {
  return _internal_has_requested_log_uid();
}
inline void UiResponse::clear_requested_log_uid() {
  requested_log_uid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& UiResponse::requested_log_uid() const {
  // @@protoc_insertion_point(field_get:amun.UiResponse.requested_log_uid)
  return _internal_requested_log_uid();
}
inline void UiResponse::set_requested_log_uid(const std::string& value) {
  _internal_set_requested_log_uid(value);
  // @@protoc_insertion_point(field_set:amun.UiResponse.requested_log_uid)
}
inline std::string* UiResponse::mutable_requested_log_uid() {
  // @@protoc_insertion_point(field_mutable:amun.UiResponse.requested_log_uid)
  return _internal_mutable_requested_log_uid();
}
inline const std::string& UiResponse::_internal_requested_log_uid() const {
  return requested_log_uid_.Get();
}
inline void UiResponse::_internal_set_requested_log_uid(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  requested_log_uid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UiResponse::set_requested_log_uid(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  requested_log_uid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:amun.UiResponse.requested_log_uid)
}
inline void UiResponse::set_requested_log_uid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  requested_log_uid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:amun.UiResponse.requested_log_uid)
}
inline void UiResponse::set_requested_log_uid(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  requested_log_uid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:amun.UiResponse.requested_log_uid)
}
inline std::string* UiResponse::_internal_mutable_requested_log_uid() {
  _has_bits_[0] |= 0x00000002u;
  return requested_log_uid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UiResponse::release_requested_log_uid() {
  // @@protoc_insertion_point(field_release:amun.UiResponse.requested_log_uid)
  if (!_internal_has_requested_log_uid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return requested_log_uid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UiResponse::set_allocated_requested_log_uid(std::string* requested_log_uid) {
  if (requested_log_uid != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  requested_log_uid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), requested_log_uid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:amun.UiResponse.requested_log_uid)
}
inline std::string* UiResponse::unsafe_arena_release_requested_log_uid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:amun.UiResponse.requested_log_uid)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return requested_log_uid_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void UiResponse::unsafe_arena_set_allocated_requested_log_uid(
    std::string* requested_log_uid) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (requested_log_uid != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  requested_log_uid_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      requested_log_uid, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.UiResponse.requested_log_uid)
}

// optional .logfile.LogOffer log_offers = 12;
inline bool UiResponse::_internal_has_log_offers() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || log_offers_ != nullptr);
  return value;
}
inline bool UiResponse::has_log_offers() const {
  return _internal_has_log_offers();
}
inline const ::logfile::LogOffer& UiResponse::_internal_log_offers() const {
  const ::logfile::LogOffer* p = log_offers_;
  return p != nullptr ? *p : *reinterpret_cast<const ::logfile::LogOffer*>(
      &::logfile::_LogOffer_default_instance_);
}
inline const ::logfile::LogOffer& UiResponse::log_offers() const {
  // @@protoc_insertion_point(field_get:amun.UiResponse.log_offers)
  return _internal_log_offers();
}
inline void UiResponse::unsafe_arena_set_allocated_log_offers(
    ::logfile::LogOffer* log_offers) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(log_offers_);
  }
  log_offers_ = log_offers;
  if (log_offers) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.UiResponse.log_offers)
}
inline ::logfile::LogOffer* UiResponse::release_log_offers() {
  auto temp = unsafe_arena_release_log_offers();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::logfile::LogOffer* UiResponse::unsafe_arena_release_log_offers() {
  // @@protoc_insertion_point(field_release:amun.UiResponse.log_offers)
  _has_bits_[0] &= ~0x00000040u;
  ::logfile::LogOffer* temp = log_offers_;
  log_offers_ = nullptr;
  return temp;
}
inline ::logfile::LogOffer* UiResponse::_internal_mutable_log_offers() {
  _has_bits_[0] |= 0x00000040u;
  if (log_offers_ == nullptr) {
    auto* p = CreateMaybeMessage<::logfile::LogOffer>(GetArena());
    log_offers_ = p;
  }
  return log_offers_;
}
inline ::logfile::LogOffer* UiResponse::mutable_log_offers() {
  // @@protoc_insertion_point(field_mutable:amun.UiResponse.log_offers)
  return _internal_mutable_log_offers();
}
inline void UiResponse::set_allocated_log_offers(::logfile::LogOffer* log_offers) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(log_offers_);
  }
  if (log_offers) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(log_offers)->GetArena();
    if (message_arena != submessage_arena) {
      log_offers = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, log_offers, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  log_offers_ = log_offers;
  // @@protoc_insertion_point(field_set_allocated:amun.UiResponse.log_offers)
}

// optional string log_uid_parser_error = 13;
inline bool UiResponse::_internal_has_log_uid_parser_error() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UiResponse::has_log_uid_parser_error() const {
  return _internal_has_log_uid_parser_error();
}
inline void UiResponse::clear_log_uid_parser_error() {
  log_uid_parser_error_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& UiResponse::log_uid_parser_error() const {
  // @@protoc_insertion_point(field_get:amun.UiResponse.log_uid_parser_error)
  return _internal_log_uid_parser_error();
}
inline void UiResponse::set_log_uid_parser_error(const std::string& value) {
  _internal_set_log_uid_parser_error(value);
  // @@protoc_insertion_point(field_set:amun.UiResponse.log_uid_parser_error)
}
inline std::string* UiResponse::mutable_log_uid_parser_error() {
  // @@protoc_insertion_point(field_mutable:amun.UiResponse.log_uid_parser_error)
  return _internal_mutable_log_uid_parser_error();
}
inline const std::string& UiResponse::_internal_log_uid_parser_error() const {
  return log_uid_parser_error_.Get();
}
inline void UiResponse::_internal_set_log_uid_parser_error(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  log_uid_parser_error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void UiResponse::set_log_uid_parser_error(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  log_uid_parser_error_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:amun.UiResponse.log_uid_parser_error)
}
inline void UiResponse::set_log_uid_parser_error(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  log_uid_parser_error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:amun.UiResponse.log_uid_parser_error)
}
inline void UiResponse::set_log_uid_parser_error(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  log_uid_parser_error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:amun.UiResponse.log_uid_parser_error)
}
inline std::string* UiResponse::_internal_mutable_log_uid_parser_error() {
  _has_bits_[0] |= 0x00000004u;
  return log_uid_parser_error_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* UiResponse::release_log_uid_parser_error() {
  // @@protoc_insertion_point(field_release:amun.UiResponse.log_uid_parser_error)
  if (!_internal_has_log_uid_parser_error()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return log_uid_parser_error_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void UiResponse::set_allocated_log_uid_parser_error(std::string* log_uid_parser_error) {
  if (log_uid_parser_error != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  log_uid_parser_error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), log_uid_parser_error,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:amun.UiResponse.log_uid_parser_error)
}
inline std::string* UiResponse::unsafe_arena_release_log_uid_parser_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:amun.UiResponse.log_uid_parser_error)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000004u;
  return log_uid_parser_error_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void UiResponse::unsafe_arena_set_allocated_log_uid_parser_error(
    std::string* log_uid_parser_error) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (log_uid_parser_error != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  log_uid_parser_error_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      log_uid_parser_error, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.UiResponse.log_uid_parser_error)
}

// -------------------------------------------------------------------

// LoggingInfo

// required bool is_logging = 1;
inline bool LoggingInfo::_internal_has_is_logging() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LoggingInfo::has_is_logging() const {
  return _internal_has_is_logging();
}
inline void LoggingInfo::clear_is_logging() {
  is_logging_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool LoggingInfo::_internal_is_logging() const {
  return is_logging_;
}
inline bool LoggingInfo::is_logging() const {
  // @@protoc_insertion_point(field_get:amun.LoggingInfo.is_logging)
  return _internal_is_logging();
}
inline void LoggingInfo::_internal_set_is_logging(bool value) {
  _has_bits_[0] |= 0x00000001u;
  is_logging_ = value;
}
inline void LoggingInfo::set_is_logging(bool value) {
  _internal_set_is_logging(value);
  // @@protoc_insertion_point(field_set:amun.LoggingInfo.is_logging)
}

// required bool is_replay_logger = 2;
inline bool LoggingInfo::_internal_has_is_replay_logger() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LoggingInfo::has_is_replay_logger() const {
  return _internal_has_is_replay_logger();
}
inline void LoggingInfo::clear_is_replay_logger() {
  is_replay_logger_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool LoggingInfo::_internal_is_replay_logger() const {
  return is_replay_logger_;
}
inline bool LoggingInfo::is_replay_logger() const {
  // @@protoc_insertion_point(field_get:amun.LoggingInfo.is_replay_logger)
  return _internal_is_replay_logger();
}
inline void LoggingInfo::_internal_set_is_replay_logger(bool value) {
  _has_bits_[0] |= 0x00000002u;
  is_replay_logger_ = value;
}
inline void LoggingInfo::set_is_replay_logger(bool value) {
  _internal_set_is_replay_logger(value);
  // @@protoc_insertion_point(field_set:amun.LoggingInfo.is_replay_logger)
}

// -------------------------------------------------------------------

// LogPlaybackInfo

// required int64 start_time = 1;
inline bool LogPlaybackInfo::_internal_has_start_time() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LogPlaybackInfo::has_start_time() const {
  return _internal_has_start_time();
}
inline void LogPlaybackInfo::clear_start_time() {
  start_time_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LogPlaybackInfo::_internal_start_time() const {
  return start_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LogPlaybackInfo::start_time() const {
  // @@protoc_insertion_point(field_get:amun.LogPlaybackInfo.start_time)
  return _internal_start_time();
}
inline void LogPlaybackInfo::_internal_set_start_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  start_time_ = value;
}
inline void LogPlaybackInfo::set_start_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:amun.LogPlaybackInfo.start_time)
}

// required int64 duration = 2;
inline bool LogPlaybackInfo::_internal_has_duration() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LogPlaybackInfo::has_duration() const {
  return _internal_has_duration();
}
inline void LogPlaybackInfo::clear_duration() {
  duration_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LogPlaybackInfo::_internal_duration() const {
  return duration_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LogPlaybackInfo::duration() const {
  // @@protoc_insertion_point(field_get:amun.LogPlaybackInfo.duration)
  return _internal_duration();
}
inline void LogPlaybackInfo::_internal_set_duration(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  duration_ = value;
}
inline void LogPlaybackInfo::set_duration(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:amun.LogPlaybackInfo.duration)
}

// required int64 packet_count = 3;
inline bool LogPlaybackInfo::_internal_has_packet_count() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LogPlaybackInfo::has_packet_count() const {
  return _internal_has_packet_count();
}
inline void LogPlaybackInfo::clear_packet_count() {
  packet_count_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LogPlaybackInfo::_internal_packet_count() const {
  return packet_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LogPlaybackInfo::packet_count() const {
  // @@protoc_insertion_point(field_get:amun.LogPlaybackInfo.packet_count)
  return _internal_packet_count();
}
inline void LogPlaybackInfo::_internal_set_packet_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  packet_count_ = value;
}
inline void LogPlaybackInfo::set_packet_count(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_packet_count(value);
  // @@protoc_insertion_point(field_set:amun.LogPlaybackInfo.packet_count)
}

// -------------------------------------------------------------------

// LogfileOpenInfo

// required bool success = 1;
inline bool LogfileOpenInfo::_internal_has_success() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LogfileOpenInfo::has_success() const {
  return _internal_has_success();
}
inline void LogfileOpenInfo::clear_success() {
  success_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool LogfileOpenInfo::_internal_success() const {
  return success_;
}
inline bool LogfileOpenInfo::success() const {
  // @@protoc_insertion_point(field_get:amun.LogfileOpenInfo.success)
  return _internal_success();
}
inline void LogfileOpenInfo::_internal_set_success(bool value) {
  _has_bits_[0] |= 0x00000002u;
  success_ = value;
}
inline void LogfileOpenInfo::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:amun.LogfileOpenInfo.success)
}

// required string filename = 2;
inline bool LogfileOpenInfo::_internal_has_filename() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LogfileOpenInfo::has_filename() const {
  return _internal_has_filename();
}
inline void LogfileOpenInfo::clear_filename() {
  filename_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LogfileOpenInfo::filename() const {
  // @@protoc_insertion_point(field_get:amun.LogfileOpenInfo.filename)
  return _internal_filename();
}
inline void LogfileOpenInfo::set_filename(const std::string& value) {
  _internal_set_filename(value);
  // @@protoc_insertion_point(field_set:amun.LogfileOpenInfo.filename)
}
inline std::string* LogfileOpenInfo::mutable_filename() {
  // @@protoc_insertion_point(field_mutable:amun.LogfileOpenInfo.filename)
  return _internal_mutable_filename();
}
inline const std::string& LogfileOpenInfo::_internal_filename() const {
  return filename_.Get();
}
inline void LogfileOpenInfo::_internal_set_filename(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  filename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void LogfileOpenInfo::set_filename(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  filename_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:amun.LogfileOpenInfo.filename)
}
inline void LogfileOpenInfo::set_filename(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  filename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:amun.LogfileOpenInfo.filename)
}
inline void LogfileOpenInfo::set_filename(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  filename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:amun.LogfileOpenInfo.filename)
}
inline std::string* LogfileOpenInfo::_internal_mutable_filename() {
  _has_bits_[0] |= 0x00000001u;
  return filename_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* LogfileOpenInfo::release_filename() {
  // @@protoc_insertion_point(field_release:amun.LogfileOpenInfo.filename)
  if (!_internal_has_filename()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return filename_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LogfileOpenInfo::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  filename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filename,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:amun.LogfileOpenInfo.filename)
}
inline std::string* LogfileOpenInfo::unsafe_arena_release_filename() {
  // @@protoc_insertion_point(field_unsafe_arena_release:amun.LogfileOpenInfo.filename)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return filename_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void LogfileOpenInfo::unsafe_arena_set_allocated_filename(
    std::string* filename) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (filename != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  filename_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      filename, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.LogfileOpenInfo.filename)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace amun

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::amun::StatusStrategy_STATE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::amun::StatusStrategy_STATE>() {
  return ::amun::StatusStrategy_STATE_descriptor();
}
template <> struct is_proto_enum< ::amun::GitInfo_Kind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::amun::GitInfo_Kind>() {
  return ::amun::GitInfo_Kind_descriptor();
}
template <> struct is_proto_enum< ::amun::StatusStrategyWrapper_StrategyType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::amun::StatusStrategyWrapper_StrategyType>() {
  return ::amun::StatusStrategyWrapper_StrategyType_descriptor();
}
template <> struct is_proto_enum< ::amun::StatusGameController_GameControllerState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::amun::StatusGameController_GameControllerState>() {
  return ::amun::StatusGameController_GameControllerState_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_status_2eproto
