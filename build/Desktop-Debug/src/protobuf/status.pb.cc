// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: status.proto

#include "status.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_debug_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<6> scc_info_DebugValues_debug_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_gamestate_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<4> scc_info_GameState_gamestate_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_status_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_GitInfo_status_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_status_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_LogPlaybackInfo_status_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_status_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_LogfileOpenInfo_status_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_status_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_LoggingInfo_status_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_status_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_OptionStatus_status_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_status_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_PortBindError_status_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_status_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<18> scc_info_Status_status_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_status_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_StatusAmun_status_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_status_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_StatusGameController_status_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_status_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_StatusStrategy_status_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_status_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_StatusStrategyWrapper_status_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_status_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_StatusTransceiver_status_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_status_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_StrategyOption_status_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_status_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Timing_status_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_userinput_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_UserInput_userinput_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_logfile_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_LogOffer_logfile_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_logfile_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Uid_logfile_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_robot_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_RadioCommand_robot_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_robot_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Team_robot_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_world_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Geometry_world_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_world_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<7> scc_info_State_world_2eproto;
namespace amun {
class StrategyOptionDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<StrategyOption> _instance;
} _StrategyOption_default_instance_;
class StatusStrategyDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<StatusStrategy> _instance;
} _StatusStrategy_default_instance_;
class GitInfoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<GitInfo> _instance;
} _GitInfo_default_instance_;
class StatusStrategyWrapperDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<StatusStrategyWrapper> _instance;
} _StatusStrategyWrapper_default_instance_;
class TimingDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Timing> _instance;
} _Timing_default_instance_;
class StatusTransceiverDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<StatusTransceiver> _instance;
} _StatusTransceiver_default_instance_;
class PortBindErrorDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<PortBindError> _instance;
} _PortBindError_default_instance_;
class OptionStatusDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<OptionStatus> _instance;
} _OptionStatus_default_instance_;
class StatusGameControllerDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<StatusGameController> _instance;
} _StatusGameController_default_instance_;
class StatusAmunDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<StatusAmun> _instance;
} _StatusAmun_default_instance_;
class StatusDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Status> _instance;
} _Status_default_instance_;
class UiResponseDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UiResponse> _instance;
} _UiResponse_default_instance_;
class LoggingInfoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<LoggingInfo> _instance;
} _LoggingInfo_default_instance_;
class LogPlaybackInfoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<LogPlaybackInfo> _instance;
} _LogPlaybackInfo_default_instance_;
class LogfileOpenInfoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<LogfileOpenInfo> _instance;
} _LogfileOpenInfo_default_instance_;
}  // namespace amun
static void InitDefaultsscc_info_GitInfo_status_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::amun::_GitInfo_default_instance_;
    new (ptr) ::amun::GitInfo();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::amun::GitInfo::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_GitInfo_status_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_GitInfo_status_2eproto}, {}};

static void InitDefaultsscc_info_LogPlaybackInfo_status_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::amun::_LogPlaybackInfo_default_instance_;
    new (ptr) ::amun::LogPlaybackInfo();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::amun::LogPlaybackInfo::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_LogPlaybackInfo_status_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_LogPlaybackInfo_status_2eproto}, {}};

static void InitDefaultsscc_info_LogfileOpenInfo_status_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::amun::_LogfileOpenInfo_default_instance_;
    new (ptr) ::amun::LogfileOpenInfo();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::amun::LogfileOpenInfo::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_LogfileOpenInfo_status_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_LogfileOpenInfo_status_2eproto}, {}};

static void InitDefaultsscc_info_LoggingInfo_status_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::amun::_LoggingInfo_default_instance_;
    new (ptr) ::amun::LoggingInfo();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::amun::LoggingInfo::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_LoggingInfo_status_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_LoggingInfo_status_2eproto}, {}};

static void InitDefaultsscc_info_OptionStatus_status_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::amun::_OptionStatus_default_instance_;
    new (ptr) ::amun::OptionStatus();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::amun::OptionStatus::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_OptionStatus_status_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_OptionStatus_status_2eproto}, {}};

static void InitDefaultsscc_info_PortBindError_status_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::amun::_PortBindError_default_instance_;
    new (ptr) ::amun::PortBindError();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::amun::PortBindError::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_PortBindError_status_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_PortBindError_status_2eproto}, {}};

static void InitDefaultsscc_info_Status_status_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::amun::_Status_default_instance_;
    new (ptr) ::amun::Status();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  {
    void* ptr = &::amun::_UiResponse_default_instance_;
    new (ptr) ::amun::UiResponse();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::amun::Status::InitAsDefaultInstance();
  ::amun::UiResponse::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<18> scc_info_Status_status_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 18, 0, InitDefaultsscc_info_Status_status_2eproto}, {
      &scc_info_GameState_gamestate_2eproto.base,
      &scc_info_State_world_2eproto.base,
      &scc_info_Geometry_world_2eproto.base,
      &scc_info_Team_robot_2eproto.base,
      &scc_info_StatusStrategy_status_2eproto.base,
      &scc_info_DebugValues_debug_2eproto.base,
      &scc_info_Timing_status_2eproto.base,
      &scc_info_RadioCommand_robot_2eproto.base,
      &scc_info_StatusTransceiver_status_2eproto.base,
      &scc_info_UserInput_userinput_2eproto.base,
      &scc_info_StatusAmun_status_2eproto.base,
      &scc_info_Uid_logfile_2eproto.base,
      &scc_info_StatusStrategyWrapper_status_2eproto.base,
      &scc_info_GitInfo_status_2eproto.base,
      &scc_info_LoggingInfo_status_2eproto.base,
      &scc_info_LogPlaybackInfo_status_2eproto.base,
      &scc_info_LogfileOpenInfo_status_2eproto.base,
      &scc_info_LogOffer_logfile_2eproto.base,}};

static void InitDefaultsscc_info_StatusAmun_status_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::amun::_StatusAmun_default_instance_;
    new (ptr) ::amun::StatusAmun();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::amun::StatusAmun::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_StatusAmun_status_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 3, 0, InitDefaultsscc_info_StatusAmun_status_2eproto}, {
      &scc_info_PortBindError_status_2eproto.base,
      &scc_info_OptionStatus_status_2eproto.base,
      &scc_info_StatusGameController_status_2eproto.base,}};

static void InitDefaultsscc_info_StatusGameController_status_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::amun::_StatusGameController_default_instance_;
    new (ptr) ::amun::StatusGameController();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::amun::StatusGameController::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_StatusGameController_status_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_StatusGameController_status_2eproto}, {}};

static void InitDefaultsscc_info_StatusStrategy_status_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::amun::_StatusStrategy_default_instance_;
    new (ptr) ::amun::StatusStrategy();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::amun::StatusStrategy::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_StatusStrategy_status_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_StatusStrategy_status_2eproto}, {
      &scc_info_StrategyOption_status_2eproto.base,}};

static void InitDefaultsscc_info_StatusStrategyWrapper_status_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::amun::_StatusStrategyWrapper_default_instance_;
    new (ptr) ::amun::StatusStrategyWrapper();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::amun::StatusStrategyWrapper::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_StatusStrategyWrapper_status_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_StatusStrategyWrapper_status_2eproto}, {
      &scc_info_StatusStrategy_status_2eproto.base,}};

static void InitDefaultsscc_info_StatusTransceiver_status_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::amun::_StatusTransceiver_default_instance_;
    new (ptr) ::amun::StatusTransceiver();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::amun::StatusTransceiver::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_StatusTransceiver_status_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_StatusTransceiver_status_2eproto}, {}};

static void InitDefaultsscc_info_StrategyOption_status_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::amun::_StrategyOption_default_instance_;
    new (ptr) ::amun::StrategyOption();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::amun::StrategyOption::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_StrategyOption_status_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_StrategyOption_status_2eproto}, {}};

static void InitDefaultsscc_info_Timing_status_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::amun::_Timing_default_instance_;
    new (ptr) ::amun::Timing();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::amun::Timing::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Timing_status_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_Timing_status_2eproto}, {}};

static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_status_2eproto[15];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_status_2eproto[4];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_status_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_status_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::amun::StrategyOption, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::amun::StrategyOption, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::amun::StrategyOption, name_),
  PROTOBUF_FIELD_OFFSET(::amun::StrategyOption, default_value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::amun::StatusStrategy, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::amun::StatusStrategy, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::amun::StatusStrategy, state_),
  PROTOBUF_FIELD_OFFSET(::amun::StatusStrategy, filename_),
  PROTOBUF_FIELD_OFFSET(::amun::StatusStrategy, name_),
  PROTOBUF_FIELD_OFFSET(::amun::StatusStrategy, current_entry_point_),
  PROTOBUF_FIELD_OFFSET(::amun::StatusStrategy, entry_point_),
  PROTOBUF_FIELD_OFFSET(::amun::StatusStrategy, has_debugger_),
  PROTOBUF_FIELD_OFFSET(::amun::StatusStrategy, options_),
  4,
  0,
  1,
  2,
  ~0u,
  3,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::amun::GitInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::amun::GitInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::amun::GitInfo, kind_),
  PROTOBUF_FIELD_OFFSET(::amun::GitInfo, hash_),
  PROTOBUF_FIELD_OFFSET(::amun::GitInfo, diff_),
  PROTOBUF_FIELD_OFFSET(::amun::GitInfo, min_hash_),
  PROTOBUF_FIELD_OFFSET(::amun::GitInfo, error_),
  4,
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::amun::StatusStrategyWrapper, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::amun::StatusStrategyWrapper, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::amun::StatusStrategyWrapper, type_),
  PROTOBUF_FIELD_OFFSET(::amun::StatusStrategyWrapper, status_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::amun::Timing, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::amun::Timing, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::amun::Timing, blue_total_),
  PROTOBUF_FIELD_OFFSET(::amun::Timing, blue_path_),
  PROTOBUF_FIELD_OFFSET(::amun::Timing, yellow_total_),
  PROTOBUF_FIELD_OFFSET(::amun::Timing, yellow_path_),
  PROTOBUF_FIELD_OFFSET(::amun::Timing, autoref_total_),
  PROTOBUF_FIELD_OFFSET(::amun::Timing, tracking_),
  PROTOBUF_FIELD_OFFSET(::amun::Timing, controller_),
  PROTOBUF_FIELD_OFFSET(::amun::Timing, transceiver_),
  PROTOBUF_FIELD_OFFSET(::amun::Timing, transceiver_rtt_),
  PROTOBUF_FIELD_OFFSET(::amun::Timing, simulator_),
  0,
  1,
  2,
  3,
  9,
  4,
  7,
  5,
  8,
  6,
  PROTOBUF_FIELD_OFFSET(::amun::StatusTransceiver, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::amun::StatusTransceiver, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::amun::StatusTransceiver, active_),
  PROTOBUF_FIELD_OFFSET(::amun::StatusTransceiver, error_),
  PROTOBUF_FIELD_OFFSET(::amun::StatusTransceiver, dropped_usb_packets_),
  PROTOBUF_FIELD_OFFSET(::amun::StatusTransceiver, dropped_commands_),
  1,
  0,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::amun::PortBindError, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::amun::PortBindError, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::amun::PortBindError, port_),
  0,
  PROTOBUF_FIELD_OFFSET(::amun::OptionStatus, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::amun::OptionStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::amun::OptionStatus, name_),
  PROTOBUF_FIELD_OFFSET(::amun::OptionStatus, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::amun::StatusGameController, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::amun::StatusGameController, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::amun::StatusGameController, current_state_),
  0,
  PROTOBUF_FIELD_OFFSET(::amun::StatusAmun, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::amun::StatusAmun, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::amun::StatusAmun, port_bind_error_),
  PROTOBUF_FIELD_OFFSET(::amun::StatusAmun, options_),
  PROTOBUF_FIELD_OFFSET(::amun::StatusAmun, game_controller_),
  0,
  ~0u,
  1,
  PROTOBUF_FIELD_OFFSET(::amun::Status, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::amun::Status, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::amun::Status, time_),
  PROTOBUF_FIELD_OFFSET(::amun::Status, game_state_),
  PROTOBUF_FIELD_OFFSET(::amun::Status, world_state_),
  PROTOBUF_FIELD_OFFSET(::amun::Status, geometry_),
  PROTOBUF_FIELD_OFFSET(::amun::Status, team_blue_),
  PROTOBUF_FIELD_OFFSET(::amun::Status, team_yellow_),
  PROTOBUF_FIELD_OFFSET(::amun::Status, strategy_blue_),
  PROTOBUF_FIELD_OFFSET(::amun::Status, strategy_yellow_),
  PROTOBUF_FIELD_OFFSET(::amun::Status, strategy_autoref_),
  PROTOBUF_FIELD_OFFSET(::amun::Status, debug_),
  PROTOBUF_FIELD_OFFSET(::amun::Status, timing_),
  PROTOBUF_FIELD_OFFSET(::amun::Status, radio_command_),
  PROTOBUF_FIELD_OFFSET(::amun::Status, transceiver_),
  PROTOBUF_FIELD_OFFSET(::amun::Status, user_input_blue_),
  PROTOBUF_FIELD_OFFSET(::amun::Status, user_input_yellow_),
  PROTOBUF_FIELD_OFFSET(::amun::Status, amun_state_),
  PROTOBUF_FIELD_OFFSET(::amun::Status, timer_scaling_),
  PROTOBUF_FIELD_OFFSET(::amun::Status, blue_running_),
  PROTOBUF_FIELD_OFFSET(::amun::Status, yellow_running_),
  PROTOBUF_FIELD_OFFSET(::amun::Status, autoref_running_),
  PROTOBUF_FIELD_OFFSET(::amun::Status, execution_state_),
  PROTOBUF_FIELD_OFFSET(::amun::Status, execution_game_state_),
  PROTOBUF_FIELD_OFFSET(::amun::Status, execution_user_input_),
  PROTOBUF_FIELD_OFFSET(::amun::Status, log_id_),
  PROTOBUF_FIELD_OFFSET(::amun::Status, original_frame_number_),
  PROTOBUF_FIELD_OFFSET(::amun::Status, status_strategy_),
  PROTOBUF_FIELD_OFFSET(::amun::Status, pure_ui_response_),
  PROTOBUF_FIELD_OFFSET(::amun::Status, git_info_),
  19,
  8,
  0,
  1,
  2,
  3,
  4,
  5,
  11,
  ~0u,
  6,
  ~0u,
  7,
  9,
  10,
  12,
  20,
  21,
  22,
  23,
  13,
  14,
  15,
  16,
  24,
  17,
  18,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::amun::UiResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::amun::UiResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::amun::UiResponse, enable_logging_),
  PROTOBUF_FIELD_OFFSET(::amun::UiResponse, logging_info_),
  PROTOBUF_FIELD_OFFSET(::amun::UiResponse, logger_status_),
  PROTOBUF_FIELD_OFFSET(::amun::UiResponse, playback_burst_end_),
  PROTOBUF_FIELD_OFFSET(::amun::UiResponse, playback_paused_),
  PROTOBUF_FIELD_OFFSET(::amun::UiResponse, log_info_),
  PROTOBUF_FIELD_OFFSET(::amun::UiResponse, frame_number_),
  PROTOBUF_FIELD_OFFSET(::amun::UiResponse, force_ra_horus_),
  PROTOBUF_FIELD_OFFSET(::amun::UiResponse, log_open_),
  PROTOBUF_FIELD_OFFSET(::amun::UiResponse, export_visionlog_error_),
  PROTOBUF_FIELD_OFFSET(::amun::UiResponse, requested_log_uid_),
  PROTOBUF_FIELD_OFFSET(::amun::UiResponse, log_offers_),
  PROTOBUF_FIELD_OFFSET(::amun::UiResponse, log_uid_parser_error_),
  8,
  3,
  ~0u,
  9,
  10,
  4,
  7,
  11,
  5,
  0,
  1,
  6,
  2,
  PROTOBUF_FIELD_OFFSET(::amun::LoggingInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::amun::LoggingInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::amun::LoggingInfo, is_logging_),
  PROTOBUF_FIELD_OFFSET(::amun::LoggingInfo, is_replay_logger_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::amun::LogPlaybackInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::amun::LogPlaybackInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::amun::LogPlaybackInfo, start_time_),
  PROTOBUF_FIELD_OFFSET(::amun::LogPlaybackInfo, duration_),
  PROTOBUF_FIELD_OFFSET(::amun::LogPlaybackInfo, packet_count_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::amun::LogfileOpenInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::amun::LogfileOpenInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::amun::LogfileOpenInfo, success_),
  PROTOBUF_FIELD_OFFSET(::amun::LogfileOpenInfo, filename_),
  1,
  0,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 7, sizeof(::amun::StrategyOption)},
  { 9, 21, sizeof(::amun::StatusStrategy)},
  { 28, 38, sizeof(::amun::GitInfo)},
  { 43, 50, sizeof(::amun::StatusStrategyWrapper)},
  { 52, 67, sizeof(::amun::Timing)},
  { 77, 86, sizeof(::amun::StatusTransceiver)},
  { 90, 96, sizeof(::amun::PortBindError)},
  { 97, 104, sizeof(::amun::OptionStatus)},
  { 106, 112, sizeof(::amun::StatusGameController)},
  { 113, 121, sizeof(::amun::StatusAmun)},
  { 124, 157, sizeof(::amun::Status)},
  { 185, 203, sizeof(::amun::UiResponse)},
  { 216, 223, sizeof(::amun::LoggingInfo)},
  { 225, 233, sizeof(::amun::LogPlaybackInfo)},
  { 236, 243, sizeof(::amun::LogfileOpenInfo)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::amun::_StrategyOption_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::amun::_StatusStrategy_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::amun::_GitInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::amun::_StatusStrategyWrapper_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::amun::_Timing_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::amun::_StatusTransceiver_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::amun::_PortBindError_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::amun::_OptionStatus_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::amun::_StatusGameController_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::amun::_StatusAmun_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::amun::_Status_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::amun::_UiResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::amun::_LoggingInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::amun::_LogPlaybackInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::amun::_LogfileOpenInfo_default_instance_),
};

const char descriptor_table_protodef_status_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\014status.proto\022\004amun\032\013debug.proto\032\017games"
  "tate.proto\032\013robot.proto\032\013world.proto\032\017us"
  "erinput.proto\032\rlogfile.proto\"5\n\016Strategy"
  "Option\022\014\n\004name\030\001 \002(\t\022\025\n\rdefault_value\030\002 "
  "\001(\010\"\207\002\n\016StatusStrategy\022)\n\005state\030\001 \002(\0162\032."
  "amun.StatusStrategy.STATE\022\020\n\010filename\030\002 "
  "\001(\t\022\014\n\004name\030\003 \001(\t\022\033\n\023current_entry_point"
  "\030\004 \001(\t\022\023\n\013entry_point\030\005 \003(\t\022\024\n\014has_debug"
  "ger\030\007 \001(\010\022%\n\007options\030\010 \003(\0132\024.amun.Strate"
  "gyOption\";\n\005STATE\022\n\n\006CLOSED\020\001\022\013\n\007RUNNING"
  "\020\003\022\n\n\006FAILED\020\004\022\r\n\tCOMPILING\020\005\"\247\001\n\007GitInf"
  "o\022 \n\004kind\030\001 \002(\0162\022.amun.GitInfo.Kind\022\014\n\004h"
  "ash\030\002 \002(\t\022\014\n\004diff\030\003 \002(\t\022\020\n\010min_hash\030\004 \002("
  "\t\022\r\n\005error\030\005 \002(\t\"=\n\004Kind\022\010\n\004BLUE\020\001\022\n\n\006YE"
  "LLOW\020\002\022\013\n\007AUTOREF\020\003\022\006\n\002RA\020\004\022\n\n\006CONFIG\020\005\""
  "\314\001\n\025StatusStrategyWrapper\0226\n\004type\030\001 \002(\0162"
  "(.amun.StatusStrategyWrapper.StrategyTyp"
  "e\022$\n\006status\030\002 \002(\0132\024.amun.StatusStrategy\""
  "U\n\014StrategyType\022\010\n\004BLUE\020\001\022\n\n\006YELLOW\020\002\022\013\n"
  "\007AUTOREF\020\003\022\017\n\013REPLAY_BLUE\020\004\022\021\n\rREPLAY_YE"
  "LLOW\020\005\"\330\001\n\006Timing\022\022\n\nblue_total\030\001 \001(\002\022\021\n"
  "\tblue_path\030\002 \001(\002\022\024\n\014yellow_total\030\003 \001(\002\022\023"
  "\n\013yellow_path\030\004 \001(\002\022\025\n\rautoref_total\030\n \001"
  "(\002\022\020\n\010tracking\030\005 \001(\002\022\022\n\ncontroller\030\010 \001(\002"
  "\022\023\n\013transceiver\030\006 \001(\002\022\027\n\017transceiver_rtt"
  "\030\t \001(\002\022\021\n\tsimulator\030\007 \001(\002\"i\n\021StatusTrans"
  "ceiver\022\016\n\006active\030\001 \002(\010\022\r\n\005error\030\002 \001(\t\022\033\n"
  "\023dropped_usb_packets\030\003 \001(\005\022\030\n\020dropped_co"
  "mmands\030\004 \001(\005\"\035\n\rPortBindError\022\014\n\004port\030\001 "
  "\002(\r\"+\n\014OptionStatus\022\014\n\004name\030\002 \002(\t\022\r\n\005val"
  "ue\030\003 \002(\010\"\275\001\n\024StatusGameController\022E\n\rcur"
  "rent_state\030\001 \001(\0162..amun.StatusGameContro"
  "ller.GameControllerState\"^\n\023GameControll"
  "erState\022\013\n\007STOPPED\020\001\022\014\n\010STARTING\020\002\022\013\n\007RU"
  "NNING\020\003\022\013\n\007CRASHED\020\004\022\022\n\016NOT_RESPONDING\020\005"
  "\"\224\001\n\nStatusAmun\022,\n\017port_bind_error\030\001 \001(\013"
  "2\023.amun.PortBindError\022#\n\007options\030\002 \003(\0132\022"
  ".amun.OptionStatus\0223\n\017game_controller\030\003 "
  "\001(\0132\032.amun.StatusGameController\"\210\010\n\006Stat"
  "us\022\014\n\004time\030\001 \002(\003\022#\n\ngame_state\030\017 \001(\0132\017.a"
  "mun.GameState\022!\n\013world_state\030\003 \001(\0132\014.wor"
  "ld.State\022!\n\010geometry\030\004 \001(\0132\017.world.Geome"
  "try\022\036\n\tteam_blue\030\005 \001(\0132\013.robot.Team\022 \n\013t"
  "eam_yellow\030\006 \001(\0132\013.robot.Team\022+\n\rstrateg"
  "y_blue\030\007 \001(\0132\024.amun.StatusStrategy\022-\n\017st"
  "rategy_yellow\030\010 \001(\0132\024.amun.StatusStrateg"
  "y\022.\n\020strategy_autoref\030\022 \001(\0132\024.amun.Statu"
  "sStrategy\022 \n\005debug\030\n \003(\0132\021.amun.DebugVal"
  "ues\022\034\n\006timing\030\013 \001(\0132\014.amun.Timing\022*\n\rrad"
  "io_command\030\014 \003(\0132\023.robot.RadioCommand\022,\n"
  "\013transceiver\030\r \001(\0132\027.amun.StatusTranscei"
  "ver\022(\n\017user_input_blue\030\020 \001(\0132\017.amun.User"
  "Input\022*\n\021user_input_yellow\030\021 \001(\0132\017.amun."
  "UserInput\022$\n\namun_state\030\023 \001(\0132\020.amun.Sta"
  "tusAmun\022\025\n\rtimer_scaling\030\024 \001(\002\022\024\n\014blue_r"
  "unning\030\025 \001(\010\022\026\n\016yellow_running\030\026 \001(\010\022\027\n\017"
  "autoref_running\030\032 \001(\010\022%\n\017execution_state"
  "\030\027 \001(\0132\014.world.State\022-\n\024execution_game_s"
  "tate\030\030 \001(\0132\017.amun.GameState\022-\n\024execution"
  "_user_input\030\031 \001(\0132\017.amun.UserInput\022\034\n\006lo"
  "g_id\030\033 \001(\0132\014.logfile.Uid\022\035\n\025original_fra"
  "me_number\030\034 \001(\004\0224\n\017status_strategy\030\035 \001(\013"
  "2\033.amun.StatusStrategyWrapper\022*\n\020pure_ui"
  "_response\030\036 \001(\0132\020.amun.UiResponse\022\037\n\010git"
  "_info\030\037 \003(\0132\r.amun.GitInfo\"\247\003\n\nUiRespons"
  "e\022\026\n\016enable_logging\030\001 \001(\010\022\'\n\014logging_inf"
  "o\030\002 \001(\0132\021.amun.LoggingInfo\022#\n\rlogger_sta"
  "tus\030\003 \003(\0132\014.amun.Status\022\032\n\022playback_burs"
  "t_end\030\004 \001(\010\022\027\n\017playback_paused\030\005 \001(\010\022\'\n\010"
  "log_info\030\006 \001(\0132\025.amun.LogPlaybackInfo\022\024\n"
  "\014frame_number\030\007 \001(\003\022\026\n\016force_ra_horus\030\010 "
  "\001(\010\022\'\n\010log_open\030\t \001(\0132\025.amun.LogfileOpen"
  "Info\022\036\n\026export_visionlog_error\030\n \001(\t\022\031\n\021"
  "requested_log_uid\030\013 \001(\t\022%\n\nlog_offers\030\014 "
  "\001(\0132\021.logfile.LogOffer\022\034\n\024log_uid_parser"
  "_error\030\r \001(\t\";\n\013LoggingInfo\022\022\n\nis_loggin"
  "g\030\001 \002(\010\022\030\n\020is_replay_logger\030\002 \002(\010\"M\n\017Log"
  "PlaybackInfo\022\022\n\nstart_time\030\001 \002(\003\022\020\n\010dura"
  "tion\030\002 \002(\003\022\024\n\014packet_count\030\003 \002(\003\"4\n\017Logf"
  "ileOpenInfo\022\017\n\007success\030\001 \002(\010\022\020\n\010filename"
  "\030\002 \002(\tB\003\370\001\001"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_status_2eproto_deps[6] = {
  &::descriptor_table_debug_2eproto,
  &::descriptor_table_gamestate_2eproto,
  &::descriptor_table_logfile_2eproto,
  &::descriptor_table_robot_2eproto,
  &::descriptor_table_userinput_2eproto,
  &::descriptor_table_world_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase*const descriptor_table_status_2eproto_sccs[14] = {
  &scc_info_GitInfo_status_2eproto.base,
  &scc_info_LogPlaybackInfo_status_2eproto.base,
  &scc_info_LogfileOpenInfo_status_2eproto.base,
  &scc_info_LoggingInfo_status_2eproto.base,
  &scc_info_OptionStatus_status_2eproto.base,
  &scc_info_PortBindError_status_2eproto.base,
  &scc_info_Status_status_2eproto.base,
  &scc_info_StatusAmun_status_2eproto.base,
  &scc_info_StatusGameController_status_2eproto.base,
  &scc_info_StatusStrategy_status_2eproto.base,
  &scc_info_StatusStrategyWrapper_status_2eproto.base,
  &scc_info_StatusTransceiver_status_2eproto.base,
  &scc_info_StrategyOption_status_2eproto.base,
  &scc_info_Timing_status_2eproto.base,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_status_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_status_2eproto = {
  false, false, descriptor_table_protodef_status_2eproto, "status.proto", 3211,
  &descriptor_table_status_2eproto_once, descriptor_table_status_2eproto_sccs, descriptor_table_status_2eproto_deps, 14, 6,
  schemas, file_default_instances, TableStruct_status_2eproto::offsets,
  file_level_metadata_status_2eproto, 15, file_level_enum_descriptors_status_2eproto, file_level_service_descriptors_status_2eproto,
};

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_status_2eproto = (static_cast<void>(::PROTOBUF_NAMESPACE_ID::internal::AddDescriptors(&descriptor_table_status_2eproto)), true);
namespace amun {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StatusStrategy_STATE_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_status_2eproto);
  return file_level_enum_descriptors_status_2eproto[0];
}
bool StatusStrategy_STATE_IsValid(int value) {
  switch (value) {
    case 1:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr StatusStrategy_STATE StatusStrategy::CLOSED;
constexpr StatusStrategy_STATE StatusStrategy::RUNNING;
constexpr StatusStrategy_STATE StatusStrategy::FAILED;
constexpr StatusStrategy_STATE StatusStrategy::COMPILING;
constexpr StatusStrategy_STATE StatusStrategy::STATE_MIN;
constexpr StatusStrategy_STATE StatusStrategy::STATE_MAX;
constexpr int StatusStrategy::STATE_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GitInfo_Kind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_status_2eproto);
  return file_level_enum_descriptors_status_2eproto[1];
}
bool GitInfo_Kind_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr GitInfo_Kind GitInfo::BLUE;
constexpr GitInfo_Kind GitInfo::YELLOW;
constexpr GitInfo_Kind GitInfo::AUTOREF;
constexpr GitInfo_Kind GitInfo::RA;
constexpr GitInfo_Kind GitInfo::CONFIG;
constexpr GitInfo_Kind GitInfo::Kind_MIN;
constexpr GitInfo_Kind GitInfo::Kind_MAX;
constexpr int GitInfo::Kind_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StatusStrategyWrapper_StrategyType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_status_2eproto);
  return file_level_enum_descriptors_status_2eproto[2];
}
bool StatusStrategyWrapper_StrategyType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr StatusStrategyWrapper_StrategyType StatusStrategyWrapper::BLUE;
constexpr StatusStrategyWrapper_StrategyType StatusStrategyWrapper::YELLOW;
constexpr StatusStrategyWrapper_StrategyType StatusStrategyWrapper::AUTOREF;
constexpr StatusStrategyWrapper_StrategyType StatusStrategyWrapper::REPLAY_BLUE;
constexpr StatusStrategyWrapper_StrategyType StatusStrategyWrapper::REPLAY_YELLOW;
constexpr StatusStrategyWrapper_StrategyType StatusStrategyWrapper::StrategyType_MIN;
constexpr StatusStrategyWrapper_StrategyType StatusStrategyWrapper::StrategyType_MAX;
constexpr int StatusStrategyWrapper::StrategyType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* StatusGameController_GameControllerState_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_status_2eproto);
  return file_level_enum_descriptors_status_2eproto[3];
}
bool StatusGameController_GameControllerState_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr StatusGameController_GameControllerState StatusGameController::STOPPED;
constexpr StatusGameController_GameControllerState StatusGameController::STARTING;
constexpr StatusGameController_GameControllerState StatusGameController::RUNNING;
constexpr StatusGameController_GameControllerState StatusGameController::CRASHED;
constexpr StatusGameController_GameControllerState StatusGameController::NOT_RESPONDING;
constexpr StatusGameController_GameControllerState StatusGameController::GameControllerState_MIN;
constexpr StatusGameController_GameControllerState StatusGameController::GameControllerState_MAX;
constexpr int StatusGameController::GameControllerState_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)

// ===================================================================

void StrategyOption::InitAsDefaultInstance() {
}
class StrategyOption::_Internal {
 public:
  using HasBits = decltype(std::declval<StrategyOption>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_default_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

StrategyOption::StrategyOption(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:amun.StrategyOption)
}
StrategyOption::StrategyOption(const StrategyOption& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_name()) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_name(),
      GetArena());
  }
  default_value_ = from.default_value_;
  // @@protoc_insertion_point(copy_constructor:amun.StrategyOption)
}

void StrategyOption::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_StrategyOption_status_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  default_value_ = false;
}

StrategyOption::~StrategyOption() {
  // @@protoc_insertion_point(destructor:amun.StrategyOption)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void StrategyOption::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void StrategyOption::ArenaDtor(void* object) {
  StrategyOption* _this = reinterpret_cast< StrategyOption* >(object);
  (void)_this;
}
void StrategyOption::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StrategyOption::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const StrategyOption& StrategyOption::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_StrategyOption_status_2eproto.base);
  return *internal_default_instance();
}


void StrategyOption::Clear() {
// @@protoc_insertion_point(message_clear_start:amun.StrategyOption)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    name_.ClearNonDefaultToEmpty();
  }
  default_value_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StrategyOption::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "amun.StrategyOption.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool default_value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_default_value(&has_bits);
          default_value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* StrategyOption::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:amun.StrategyOption)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "amun.StrategyOption.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional bool default_value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_default_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:amun.StrategyOption)
  return target;
}

size_t StrategyOption::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:amun.StrategyOption)
  size_t total_size = 0;

  // required string name = 1;
  if (_internal_has_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool default_value = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StrategyOption::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:amun.StrategyOption)
  GOOGLE_DCHECK_NE(&from, this);
  const StrategyOption* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<StrategyOption>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:amun.StrategyOption)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:amun.StrategyOption)
    MergeFrom(*source);
  }
}

void StrategyOption::MergeFrom(const StrategyOption& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:amun.StrategyOption)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      default_value_ = from.default_value_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void StrategyOption::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:amun.StrategyOption)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StrategyOption::CopyFrom(const StrategyOption& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:amun.StrategyOption)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StrategyOption::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void StrategyOption::InternalSwap(StrategyOption* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(default_value_, other->default_value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StrategyOption::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void StatusStrategy::InitAsDefaultInstance() {
}
class StatusStrategy::_Internal {
 public:
  using HasBits = decltype(std::declval<StatusStrategy>()._has_bits_);
  static void set_has_state(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_filename(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_current_entry_point(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_has_debugger(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000010) ^ 0x00000010) != 0;
  }
};

StatusStrategy::StatusStrategy(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  entry_point_(arena),
  options_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:amun.StatusStrategy)
}
StatusStrategy::StatusStrategy(const StatusStrategy& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      entry_point_(from.entry_point_),
      options_(from.options_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  filename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_filename()) {
    filename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_filename(),
      GetArena());
  }
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_name()) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_name(),
      GetArena());
  }
  current_entry_point_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_current_entry_point()) {
    current_entry_point_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_current_entry_point(),
      GetArena());
  }
  ::memcpy(&has_debugger_, &from.has_debugger_,
    static_cast<size_t>(reinterpret_cast<char*>(&state_) -
    reinterpret_cast<char*>(&has_debugger_)) + sizeof(state_));
  // @@protoc_insertion_point(copy_constructor:amun.StatusStrategy)
}

void StatusStrategy::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_StatusStrategy_status_2eproto.base);
  filename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  current_entry_point_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  has_debugger_ = false;
  state_ = 1;
}

StatusStrategy::~StatusStrategy() {
  // @@protoc_insertion_point(destructor:amun.StatusStrategy)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void StatusStrategy::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  filename_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  current_entry_point_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void StatusStrategy::ArenaDtor(void* object) {
  StatusStrategy* _this = reinterpret_cast< StatusStrategy* >(object);
  (void)_this;
}
void StatusStrategy::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StatusStrategy::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const StatusStrategy& StatusStrategy::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_StatusStrategy_status_2eproto.base);
  return *internal_default_instance();
}


void StatusStrategy::Clear() {
// @@protoc_insertion_point(message_clear_start:amun.StatusStrategy)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  entry_point_.Clear();
  options_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      filename_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      current_entry_point_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    has_debugger_ = false;
    state_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatusStrategy::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .amun.StatusStrategy.STATE state = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::amun::StatusStrategy_STATE_IsValid(val))) {
            _internal_set_state(static_cast<::amun::StatusStrategy_STATE>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional string filename = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_filename();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "amun.StatusStrategy.filename");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "amun.StatusStrategy.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string current_entry_point = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_current_entry_point();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "amun.StatusStrategy.current_entry_point");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated string entry_point = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_entry_point();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            #ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "amun.StatusStrategy.entry_point");
            #endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else goto handle_unusual;
        continue;
      // optional bool has_debugger = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_has_debugger(&has_bits);
          has_debugger_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .amun.StrategyOption options = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_options(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* StatusStrategy::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:amun.StatusStrategy)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .amun.StatusStrategy.STATE state = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_state(), target);
  }

  // optional string filename = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_filename().data(), static_cast<int>(this->_internal_filename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "amun.StatusStrategy.filename");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_filename(), target);
  }

  // optional string name = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "amun.StatusStrategy.name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_name(), target);
  }

  // optional string current_entry_point = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_current_entry_point().data(), static_cast<int>(this->_internal_current_entry_point().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "amun.StatusStrategy.current_entry_point");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_current_entry_point(), target);
  }

  // repeated string entry_point = 5;
  for (int i = 0, n = this->_internal_entry_point_size(); i < n; i++) {
    const auto& s = this->_internal_entry_point(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "amun.StatusStrategy.entry_point");
    target = stream->WriteString(5, s, target);
  }

  // optional bool has_debugger = 7;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->_internal_has_debugger(), target);
  }

  // repeated .amun.StrategyOption options = 8;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_options_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, this->_internal_options(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:amun.StatusStrategy)
  return target;
}

size_t StatusStrategy::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:amun.StatusStrategy)
  size_t total_size = 0;

  // required .amun.StatusStrategy.STATE state = 1;
  if (_internal_has_state()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_state());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string entry_point = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(entry_point_.size());
  for (int i = 0, n = entry_point_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      entry_point_.Get(i));
  }

  // repeated .amun.StrategyOption options = 8;
  total_size += 1UL * this->_internal_options_size();
  for (const auto& msg : this->options_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string filename = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_filename());
    }

    // optional string name = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string current_entry_point = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_current_entry_point());
    }

    // optional bool has_debugger = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StatusStrategy::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:amun.StatusStrategy)
  GOOGLE_DCHECK_NE(&from, this);
  const StatusStrategy* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<StatusStrategy>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:amun.StatusStrategy)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:amun.StatusStrategy)
    MergeFrom(*source);
  }
}

void StatusStrategy::MergeFrom(const StatusStrategy& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:amun.StatusStrategy)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  entry_point_.MergeFrom(from.entry_point_);
  options_.MergeFrom(from.options_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_filename(from._internal_filename());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_current_entry_point(from._internal_current_entry_point());
    }
    if (cached_has_bits & 0x00000008u) {
      has_debugger_ = from.has_debugger_;
    }
    if (cached_has_bits & 0x00000010u) {
      state_ = from.state_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void StatusStrategy::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:amun.StatusStrategy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StatusStrategy::CopyFrom(const StatusStrategy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:amun.StatusStrategy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatusStrategy::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(options_)) return false;
  return true;
}

void StatusStrategy::InternalSwap(StatusStrategy* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  entry_point_.InternalSwap(&other->entry_point_);
  options_.InternalSwap(&other->options_);
  filename_.Swap(&other->filename_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  current_entry_point_.Swap(&other->current_entry_point_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(has_debugger_, other->has_debugger_);
  swap(state_, other->state_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StatusStrategy::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void GitInfo::InitAsDefaultInstance() {
}
class GitInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<GitInfo>()._has_bits_);
  static void set_has_kind(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_diff(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_min_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

GitInfo::GitInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:amun.GitInfo)
}
GitInfo::GitInfo(const GitInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_hash()) {
    hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_hash(),
      GetArena());
  }
  diff_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_diff()) {
    diff_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_diff(),
      GetArena());
  }
  min_hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_min_hash()) {
    min_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_min_hash(),
      GetArena());
  }
  error_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_error()) {
    error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_error(),
      GetArena());
  }
  kind_ = from.kind_;
  // @@protoc_insertion_point(copy_constructor:amun.GitInfo)
}

void GitInfo::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_GitInfo_status_2eproto.base);
  hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  diff_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  min_hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  error_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  kind_ = 1;
}

GitInfo::~GitInfo() {
  // @@protoc_insertion_point(destructor:amun.GitInfo)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void GitInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  hash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  diff_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  min_hash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  error_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void GitInfo::ArenaDtor(void* object) {
  GitInfo* _this = reinterpret_cast< GitInfo* >(object);
  (void)_this;
}
void GitInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GitInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const GitInfo& GitInfo::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_GitInfo_status_2eproto.base);
  return *internal_default_instance();
}


void GitInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:amun.GitInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      hash_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      diff_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      min_hash_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      error_.ClearNonDefaultToEmpty();
    }
    kind_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GitInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .amun.GitInfo.Kind kind = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::amun::GitInfo_Kind_IsValid(val))) {
            _internal_set_kind(static_cast<::amun::GitInfo_Kind>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // required string hash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_hash();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "amun.GitInfo.hash");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string diff = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_diff();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "amun.GitInfo.diff");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string min_hash = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_min_hash();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "amun.GitInfo.min_hash");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string error = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_error();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "amun.GitInfo.error");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* GitInfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:amun.GitInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .amun.GitInfo.Kind kind = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_kind(), target);
  }

  // required string hash = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_hash().data(), static_cast<int>(this->_internal_hash().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "amun.GitInfo.hash");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_hash(), target);
  }

  // required string diff = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_diff().data(), static_cast<int>(this->_internal_diff().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "amun.GitInfo.diff");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_diff(), target);
  }

  // required string min_hash = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_min_hash().data(), static_cast<int>(this->_internal_min_hash().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "amun.GitInfo.min_hash");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_min_hash(), target);
  }

  // required string error = 5;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_error().data(), static_cast<int>(this->_internal_error().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "amun.GitInfo.error");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_error(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:amun.GitInfo)
  return target;
}

size_t GitInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:amun.GitInfo)
  size_t total_size = 0;

  if (_internal_has_hash()) {
    // required string hash = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_hash());
  }

  if (_internal_has_diff()) {
    // required string diff = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_diff());
  }

  if (_internal_has_min_hash()) {
    // required string min_hash = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_min_hash());
  }

  if (_internal_has_error()) {
    // required string error = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_error());
  }

  if (_internal_has_kind()) {
    // required .amun.GitInfo.Kind kind = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_kind());
  }

  return total_size;
}
size_t GitInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:amun.GitInfo)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required string hash = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_hash());

    // required string diff = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_diff());

    // required string min_hash = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_min_hash());

    // required string error = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_error());

    // required .amun.GitInfo.Kind kind = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_kind());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GitInfo::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:amun.GitInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const GitInfo* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<GitInfo>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:amun.GitInfo)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:amun.GitInfo)
    MergeFrom(*source);
  }
}

void GitInfo::MergeFrom(const GitInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:amun.GitInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_hash(from._internal_hash());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_diff(from._internal_diff());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_min_hash(from._internal_min_hash());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_error(from._internal_error());
    }
    if (cached_has_bits & 0x00000010u) {
      kind_ = from.kind_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void GitInfo::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:amun.GitInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GitInfo::CopyFrom(const GitInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:amun.GitInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GitInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void GitInfo::InternalSwap(GitInfo* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  hash_.Swap(&other->hash_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  diff_.Swap(&other->diff_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  min_hash_.Swap(&other->min_hash_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  error_.Swap(&other->error_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(kind_, other->kind_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GitInfo::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void StatusStrategyWrapper::InitAsDefaultInstance() {
  ::amun::_StatusStrategyWrapper_default_instance_._instance.get_mutable()->status_ = const_cast< ::amun::StatusStrategy*>(
      ::amun::StatusStrategy::internal_default_instance());
}
class StatusStrategyWrapper::_Internal {
 public:
  using HasBits = decltype(std::declval<StatusStrategyWrapper>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::amun::StatusStrategy& status(const StatusStrategyWrapper* msg);
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::amun::StatusStrategy&
StatusStrategyWrapper::_Internal::status(const StatusStrategyWrapper* msg) {
  return *msg->status_;
}
StatusStrategyWrapper::StatusStrategyWrapper(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:amun.StatusStrategyWrapper)
}
StatusStrategyWrapper::StatusStrategyWrapper(const StatusStrategyWrapper& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_status()) {
    status_ = new ::amun::StatusStrategy(*from.status_);
  } else {
    status_ = nullptr;
  }
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:amun.StatusStrategyWrapper)
}

void StatusStrategyWrapper::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_StatusStrategyWrapper_status_2eproto.base);
  status_ = nullptr;
  type_ = 1;
}

StatusStrategyWrapper::~StatusStrategyWrapper() {
  // @@protoc_insertion_point(destructor:amun.StatusStrategyWrapper)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void StatusStrategyWrapper::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete status_;
}

void StatusStrategyWrapper::ArenaDtor(void* object) {
  StatusStrategyWrapper* _this = reinterpret_cast< StatusStrategyWrapper* >(object);
  (void)_this;
}
void StatusStrategyWrapper::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StatusStrategyWrapper::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const StatusStrategyWrapper& StatusStrategyWrapper::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_StatusStrategyWrapper_status_2eproto.base);
  return *internal_default_instance();
}


void StatusStrategyWrapper::Clear() {
// @@protoc_insertion_point(message_clear_start:amun.StatusStrategyWrapper)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(status_ != nullptr);
      status_->Clear();
    }
    type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatusStrategyWrapper::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .amun.StatusStrategyWrapper.StrategyType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::amun::StatusStrategyWrapper_StrategyType_IsValid(val))) {
            _internal_set_type(static_cast<::amun::StatusStrategyWrapper_StrategyType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // required .amun.StatusStrategy status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_status(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* StatusStrategyWrapper::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:amun.StatusStrategyWrapper)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .amun.StatusStrategyWrapper.StrategyType type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // required .amun.StatusStrategy status = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::status(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:amun.StatusStrategyWrapper)
  return target;
}

size_t StatusStrategyWrapper::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:amun.StatusStrategyWrapper)
  size_t total_size = 0;

  if (_internal_has_status()) {
    // required .amun.StatusStrategy status = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *status_);
  }

  if (_internal_has_type()) {
    // required .amun.StatusStrategyWrapper.StrategyType type = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
  }

  return total_size;
}
size_t StatusStrategyWrapper::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:amun.StatusStrategyWrapper)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .amun.StatusStrategy status = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *status_);

    // required .amun.StatusStrategyWrapper.StrategyType type = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StatusStrategyWrapper::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:amun.StatusStrategyWrapper)
  GOOGLE_DCHECK_NE(&from, this);
  const StatusStrategyWrapper* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<StatusStrategyWrapper>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:amun.StatusStrategyWrapper)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:amun.StatusStrategyWrapper)
    MergeFrom(*source);
  }
}

void StatusStrategyWrapper::MergeFrom(const StatusStrategyWrapper& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:amun.StatusStrategyWrapper)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_status()->::amun::StatusStrategy::MergeFrom(from._internal_status());
    }
    if (cached_has_bits & 0x00000002u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void StatusStrategyWrapper::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:amun.StatusStrategyWrapper)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StatusStrategyWrapper::CopyFrom(const StatusStrategyWrapper& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:amun.StatusStrategyWrapper)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatusStrategyWrapper::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_status()) {
    if (!status_->IsInitialized()) return false;
  }
  return true;
}

void StatusStrategyWrapper::InternalSwap(StatusStrategyWrapper* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(status_, other->status_);
  swap(type_, other->type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StatusStrategyWrapper::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Timing::InitAsDefaultInstance() {
}
class Timing::_Internal {
 public:
  using HasBits = decltype(std::declval<Timing>()._has_bits_);
  static void set_has_blue_total(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_blue_path(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_yellow_total(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_yellow_path(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_autoref_total(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_tracking(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_controller(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_transceiver(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_transceiver_rtt(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_simulator(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

Timing::Timing(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:amun.Timing)
}
Timing::Timing(const Timing& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&blue_total_, &from.blue_total_,
    static_cast<size_t>(reinterpret_cast<char*>(&autoref_total_) -
    reinterpret_cast<char*>(&blue_total_)) + sizeof(autoref_total_));
  // @@protoc_insertion_point(copy_constructor:amun.Timing)
}

void Timing::SharedCtor() {
  ::memset(&blue_total_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&autoref_total_) -
      reinterpret_cast<char*>(&blue_total_)) + sizeof(autoref_total_));
}

Timing::~Timing() {
  // @@protoc_insertion_point(destructor:amun.Timing)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Timing::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void Timing::ArenaDtor(void* object) {
  Timing* _this = reinterpret_cast< Timing* >(object);
  (void)_this;
}
void Timing::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Timing::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Timing& Timing::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Timing_status_2eproto.base);
  return *internal_default_instance();
}


void Timing::Clear() {
// @@protoc_insertion_point(message_clear_start:amun.Timing)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&blue_total_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&controller_) -
        reinterpret_cast<char*>(&blue_total_)) + sizeof(controller_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&transceiver_rtt_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&autoref_total_) -
        reinterpret_cast<char*>(&transceiver_rtt_)) + sizeof(autoref_total_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Timing::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional float blue_total = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_blue_total(&has_bits);
          blue_total_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float blue_path = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_blue_path(&has_bits);
          blue_path_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float yellow_total = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_yellow_total(&has_bits);
          yellow_total_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float yellow_path = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_yellow_path(&has_bits);
          yellow_path_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float tracking = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          _Internal::set_has_tracking(&has_bits);
          tracking_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float transceiver = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 53)) {
          _Internal::set_has_transceiver(&has_bits);
          transceiver_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float simulator = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 61)) {
          _Internal::set_has_simulator(&has_bits);
          simulator_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float controller = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 69)) {
          _Internal::set_has_controller(&has_bits);
          controller_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float transceiver_rtt = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 77)) {
          _Internal::set_has_transceiver_rtt(&has_bits);
          transceiver_rtt_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float autoref_total = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 85)) {
          _Internal::set_has_autoref_total(&has_bits);
          autoref_total_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Timing::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:amun.Timing)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float blue_total = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_blue_total(), target);
  }

  // optional float blue_path = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_blue_path(), target);
  }

  // optional float yellow_total = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_yellow_total(), target);
  }

  // optional float yellow_path = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_yellow_path(), target);
  }

  // optional float tracking = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_tracking(), target);
  }

  // optional float transceiver = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(6, this->_internal_transceiver(), target);
  }

  // optional float simulator = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(7, this->_internal_simulator(), target);
  }

  // optional float controller = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(8, this->_internal_controller(), target);
  }

  // optional float transceiver_rtt = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(9, this->_internal_transceiver_rtt(), target);
  }

  // optional float autoref_total = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(10, this->_internal_autoref_total(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:amun.Timing)
  return target;
}

size_t Timing::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:amun.Timing)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional float blue_total = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float blue_path = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float yellow_total = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float yellow_path = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float tracking = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float transceiver = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float simulator = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional float controller = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional float transceiver_rtt = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional float autoref_total = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Timing::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:amun.Timing)
  GOOGLE_DCHECK_NE(&from, this);
  const Timing* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Timing>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:amun.Timing)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:amun.Timing)
    MergeFrom(*source);
  }
}

void Timing::MergeFrom(const Timing& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:amun.Timing)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      blue_total_ = from.blue_total_;
    }
    if (cached_has_bits & 0x00000002u) {
      blue_path_ = from.blue_path_;
    }
    if (cached_has_bits & 0x00000004u) {
      yellow_total_ = from.yellow_total_;
    }
    if (cached_has_bits & 0x00000008u) {
      yellow_path_ = from.yellow_path_;
    }
    if (cached_has_bits & 0x00000010u) {
      tracking_ = from.tracking_;
    }
    if (cached_has_bits & 0x00000020u) {
      transceiver_ = from.transceiver_;
    }
    if (cached_has_bits & 0x00000040u) {
      simulator_ = from.simulator_;
    }
    if (cached_has_bits & 0x00000080u) {
      controller_ = from.controller_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      transceiver_rtt_ = from.transceiver_rtt_;
    }
    if (cached_has_bits & 0x00000200u) {
      autoref_total_ = from.autoref_total_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Timing::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:amun.Timing)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Timing::CopyFrom(const Timing& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:amun.Timing)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Timing::IsInitialized() const {
  return true;
}

void Timing::InternalSwap(Timing* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Timing, autoref_total_)
      + sizeof(Timing::autoref_total_)
      - PROTOBUF_FIELD_OFFSET(Timing, blue_total_)>(
          reinterpret_cast<char*>(&blue_total_),
          reinterpret_cast<char*>(&other->blue_total_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Timing::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void StatusTransceiver::InitAsDefaultInstance() {
}
class StatusTransceiver::_Internal {
 public:
  using HasBits = decltype(std::declval<StatusTransceiver>()._has_bits_);
  static void set_has_active(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_dropped_usb_packets(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_dropped_commands(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

StatusTransceiver::StatusTransceiver(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:amun.StatusTransceiver)
}
StatusTransceiver::StatusTransceiver(const StatusTransceiver& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  error_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_error()) {
    error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_error(),
      GetArena());
  }
  ::memcpy(&active_, &from.active_,
    static_cast<size_t>(reinterpret_cast<char*>(&dropped_commands_) -
    reinterpret_cast<char*>(&active_)) + sizeof(dropped_commands_));
  // @@protoc_insertion_point(copy_constructor:amun.StatusTransceiver)
}

void StatusTransceiver::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_StatusTransceiver_status_2eproto.base);
  error_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&active_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&dropped_commands_) -
      reinterpret_cast<char*>(&active_)) + sizeof(dropped_commands_));
}

StatusTransceiver::~StatusTransceiver() {
  // @@protoc_insertion_point(destructor:amun.StatusTransceiver)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void StatusTransceiver::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  error_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void StatusTransceiver::ArenaDtor(void* object) {
  StatusTransceiver* _this = reinterpret_cast< StatusTransceiver* >(object);
  (void)_this;
}
void StatusTransceiver::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StatusTransceiver::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const StatusTransceiver& StatusTransceiver::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_StatusTransceiver_status_2eproto.base);
  return *internal_default_instance();
}


void StatusTransceiver::Clear() {
// @@protoc_insertion_point(message_clear_start:amun.StatusTransceiver)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    error_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&active_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&dropped_commands_) -
        reinterpret_cast<char*>(&active_)) + sizeof(dropped_commands_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatusTransceiver::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bool active = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_active(&has_bits);
          active_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string error = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_error();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "amun.StatusTransceiver.error");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 dropped_usb_packets = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_dropped_usb_packets(&has_bits);
          dropped_usb_packets_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 dropped_commands = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_dropped_commands(&has_bits);
          dropped_commands_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* StatusTransceiver::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:amun.StatusTransceiver)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bool active = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_active(), target);
  }

  // optional string error = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_error().data(), static_cast<int>(this->_internal_error().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "amun.StatusTransceiver.error");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_error(), target);
  }

  // optional int32 dropped_usb_packets = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_dropped_usb_packets(), target);
  }

  // optional int32 dropped_commands = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_dropped_commands(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:amun.StatusTransceiver)
  return target;
}

size_t StatusTransceiver::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:amun.StatusTransceiver)
  size_t total_size = 0;

  // required bool active = 1;
  if (_internal_has_active()) {
    total_size += 1 + 1;
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string error = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_error());
  }

  if (cached_has_bits & 0x0000000cu) {
    // optional int32 dropped_usb_packets = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_dropped_usb_packets());
    }

    // optional int32 dropped_commands = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_dropped_commands());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StatusTransceiver::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:amun.StatusTransceiver)
  GOOGLE_DCHECK_NE(&from, this);
  const StatusTransceiver* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<StatusTransceiver>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:amun.StatusTransceiver)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:amun.StatusTransceiver)
    MergeFrom(*source);
  }
}

void StatusTransceiver::MergeFrom(const StatusTransceiver& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:amun.StatusTransceiver)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_error(from._internal_error());
    }
    if (cached_has_bits & 0x00000002u) {
      active_ = from.active_;
    }
    if (cached_has_bits & 0x00000004u) {
      dropped_usb_packets_ = from.dropped_usb_packets_;
    }
    if (cached_has_bits & 0x00000008u) {
      dropped_commands_ = from.dropped_commands_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void StatusTransceiver::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:amun.StatusTransceiver)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StatusTransceiver::CopyFrom(const StatusTransceiver& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:amun.StatusTransceiver)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatusTransceiver::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void StatusTransceiver::InternalSwap(StatusTransceiver* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  error_.Swap(&other->error_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StatusTransceiver, dropped_commands_)
      + sizeof(StatusTransceiver::dropped_commands_)
      - PROTOBUF_FIELD_OFFSET(StatusTransceiver, active_)>(
          reinterpret_cast<char*>(&active_),
          reinterpret_cast<char*>(&other->active_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StatusTransceiver::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void PortBindError::InitAsDefaultInstance() {
}
class PortBindError::_Internal {
 public:
  using HasBits = decltype(std::declval<PortBindError>()._has_bits_);
  static void set_has_port(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

PortBindError::PortBindError(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:amun.PortBindError)
}
PortBindError::PortBindError(const PortBindError& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  port_ = from.port_;
  // @@protoc_insertion_point(copy_constructor:amun.PortBindError)
}

void PortBindError::SharedCtor() {
  port_ = 0u;
}

PortBindError::~PortBindError() {
  // @@protoc_insertion_point(destructor:amun.PortBindError)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void PortBindError::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void PortBindError::ArenaDtor(void* object) {
  PortBindError* _this = reinterpret_cast< PortBindError* >(object);
  (void)_this;
}
void PortBindError::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PortBindError::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const PortBindError& PortBindError::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_PortBindError_status_2eproto.base);
  return *internal_default_instance();
}


void PortBindError::Clear() {
// @@protoc_insertion_point(message_clear_start:amun.PortBindError)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  port_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PortBindError::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint32 port = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_port(&has_bits);
          port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* PortBindError::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:amun.PortBindError)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 port = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_port(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:amun.PortBindError)
  return target;
}

size_t PortBindError::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:amun.PortBindError)
  size_t total_size = 0;

  // required uint32 port = 1;
  if (_internal_has_port()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_port());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PortBindError::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:amun.PortBindError)
  GOOGLE_DCHECK_NE(&from, this);
  const PortBindError* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<PortBindError>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:amun.PortBindError)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:amun.PortBindError)
    MergeFrom(*source);
  }
}

void PortBindError::MergeFrom(const PortBindError& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:amun.PortBindError)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_port()) {
    _internal_set_port(from._internal_port());
  }
}

void PortBindError::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:amun.PortBindError)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PortBindError::CopyFrom(const PortBindError& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:amun.PortBindError)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PortBindError::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void PortBindError::InternalSwap(PortBindError* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(port_, other->port_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PortBindError::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void OptionStatus::InitAsDefaultInstance() {
}
class OptionStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<OptionStatus>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

OptionStatus::OptionStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:amun.OptionStatus)
}
OptionStatus::OptionStatus(const OptionStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_name()) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_name(),
      GetArena());
  }
  value_ = from.value_;
  // @@protoc_insertion_point(copy_constructor:amun.OptionStatus)
}

void OptionStatus::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_OptionStatus_status_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  value_ = false;
}

OptionStatus::~OptionStatus() {
  // @@protoc_insertion_point(destructor:amun.OptionStatus)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void OptionStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void OptionStatus::ArenaDtor(void* object) {
  OptionStatus* _this = reinterpret_cast< OptionStatus* >(object);
  (void)_this;
}
void OptionStatus::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void OptionStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const OptionStatus& OptionStatus::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_OptionStatus_status_2eproto.base);
  return *internal_default_instance();
}


void OptionStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:amun.OptionStatus)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    name_.ClearNonDefaultToEmpty();
  }
  value_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OptionStatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "amun.OptionStatus.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bool value = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_value(&has_bits);
          value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* OptionStatus::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:amun.OptionStatus)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "amun.OptionStatus.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // required bool value = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:amun.OptionStatus)
  return target;
}

size_t OptionStatus::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:amun.OptionStatus)
  size_t total_size = 0;

  if (_internal_has_name()) {
    // required string name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  if (_internal_has_value()) {
    // required bool value = 3;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t OptionStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:amun.OptionStatus)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());

    // required bool value = 3;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OptionStatus::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:amun.OptionStatus)
  GOOGLE_DCHECK_NE(&from, this);
  const OptionStatus* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<OptionStatus>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:amun.OptionStatus)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:amun.OptionStatus)
    MergeFrom(*source);
  }
}

void OptionStatus::MergeFrom(const OptionStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:amun.OptionStatus)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      value_ = from.value_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void OptionStatus::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:amun.OptionStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void OptionStatus::CopyFrom(const OptionStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:amun.OptionStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OptionStatus::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void OptionStatus::InternalSwap(OptionStatus* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(value_, other->value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata OptionStatus::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void StatusGameController::InitAsDefaultInstance() {
}
class StatusGameController::_Internal {
 public:
  using HasBits = decltype(std::declval<StatusGameController>()._has_bits_);
  static void set_has_current_state(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

StatusGameController::StatusGameController(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:amun.StatusGameController)
}
StatusGameController::StatusGameController(const StatusGameController& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  current_state_ = from.current_state_;
  // @@protoc_insertion_point(copy_constructor:amun.StatusGameController)
}

void StatusGameController::SharedCtor() {
  current_state_ = 1;
}

StatusGameController::~StatusGameController() {
  // @@protoc_insertion_point(destructor:amun.StatusGameController)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void StatusGameController::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void StatusGameController::ArenaDtor(void* object) {
  StatusGameController* _this = reinterpret_cast< StatusGameController* >(object);
  (void)_this;
}
void StatusGameController::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StatusGameController::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const StatusGameController& StatusGameController::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_StatusGameController_status_2eproto.base);
  return *internal_default_instance();
}


void StatusGameController::Clear() {
// @@protoc_insertion_point(message_clear_start:amun.StatusGameController)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  current_state_ = 1;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatusGameController::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .amun.StatusGameController.GameControllerState current_state = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::amun::StatusGameController_GameControllerState_IsValid(val))) {
            _internal_set_current_state(static_cast<::amun::StatusGameController_GameControllerState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* StatusGameController::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:amun.StatusGameController)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .amun.StatusGameController.GameControllerState current_state = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_current_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:amun.StatusGameController)
  return target;
}

size_t StatusGameController::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:amun.StatusGameController)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .amun.StatusGameController.GameControllerState current_state = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_current_state());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StatusGameController::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:amun.StatusGameController)
  GOOGLE_DCHECK_NE(&from, this);
  const StatusGameController* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<StatusGameController>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:amun.StatusGameController)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:amun.StatusGameController)
    MergeFrom(*source);
  }
}

void StatusGameController::MergeFrom(const StatusGameController& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:amun.StatusGameController)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_current_state()) {
    _internal_set_current_state(from._internal_current_state());
  }
}

void StatusGameController::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:amun.StatusGameController)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StatusGameController::CopyFrom(const StatusGameController& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:amun.StatusGameController)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatusGameController::IsInitialized() const {
  return true;
}

void StatusGameController::InternalSwap(StatusGameController* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(current_state_, other->current_state_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StatusGameController::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void StatusAmun::InitAsDefaultInstance() {
  ::amun::_StatusAmun_default_instance_._instance.get_mutable()->port_bind_error_ = const_cast< ::amun::PortBindError*>(
      ::amun::PortBindError::internal_default_instance());
  ::amun::_StatusAmun_default_instance_._instance.get_mutable()->game_controller_ = const_cast< ::amun::StatusGameController*>(
      ::amun::StatusGameController::internal_default_instance());
}
class StatusAmun::_Internal {
 public:
  using HasBits = decltype(std::declval<StatusAmun>()._has_bits_);
  static const ::amun::PortBindError& port_bind_error(const StatusAmun* msg);
  static void set_has_port_bind_error(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::amun::StatusGameController& game_controller(const StatusAmun* msg);
  static void set_has_game_controller(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::amun::PortBindError&
StatusAmun::_Internal::port_bind_error(const StatusAmun* msg) {
  return *msg->port_bind_error_;
}
const ::amun::StatusGameController&
StatusAmun::_Internal::game_controller(const StatusAmun* msg) {
  return *msg->game_controller_;
}
StatusAmun::StatusAmun(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  options_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:amun.StatusAmun)
}
StatusAmun::StatusAmun(const StatusAmun& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      options_(from.options_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_port_bind_error()) {
    port_bind_error_ = new ::amun::PortBindError(*from.port_bind_error_);
  } else {
    port_bind_error_ = nullptr;
  }
  if (from._internal_has_game_controller()) {
    game_controller_ = new ::amun::StatusGameController(*from.game_controller_);
  } else {
    game_controller_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:amun.StatusAmun)
}

void StatusAmun::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_StatusAmun_status_2eproto.base);
  ::memset(&port_bind_error_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&game_controller_) -
      reinterpret_cast<char*>(&port_bind_error_)) + sizeof(game_controller_));
}

StatusAmun::~StatusAmun() {
  // @@protoc_insertion_point(destructor:amun.StatusAmun)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void StatusAmun::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete port_bind_error_;
  if (this != internal_default_instance()) delete game_controller_;
}

void StatusAmun::ArenaDtor(void* object) {
  StatusAmun* _this = reinterpret_cast< StatusAmun* >(object);
  (void)_this;
}
void StatusAmun::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StatusAmun::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const StatusAmun& StatusAmun::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_StatusAmun_status_2eproto.base);
  return *internal_default_instance();
}


void StatusAmun::Clear() {
// @@protoc_insertion_point(message_clear_start:amun.StatusAmun)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  options_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(port_bind_error_ != nullptr);
      port_bind_error_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(game_controller_ != nullptr);
      game_controller_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatusAmun::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .amun.PortBindError port_bind_error = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_port_bind_error(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .amun.OptionStatus options = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_options(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else goto handle_unusual;
        continue;
      // optional .amun.StatusGameController game_controller = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_game_controller(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* StatusAmun::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:amun.StatusAmun)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .amun.PortBindError port_bind_error = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::port_bind_error(this), target, stream);
  }

  // repeated .amun.OptionStatus options = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_options_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_options(i), target, stream);
  }

  // optional .amun.StatusGameController game_controller = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::game_controller(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:amun.StatusAmun)
  return target;
}

size_t StatusAmun::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:amun.StatusAmun)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .amun.OptionStatus options = 2;
  total_size += 1UL * this->_internal_options_size();
  for (const auto& msg : this->options_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .amun.PortBindError port_bind_error = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *port_bind_error_);
    }

    // optional .amun.StatusGameController game_controller = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *game_controller_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StatusAmun::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:amun.StatusAmun)
  GOOGLE_DCHECK_NE(&from, this);
  const StatusAmun* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<StatusAmun>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:amun.StatusAmun)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:amun.StatusAmun)
    MergeFrom(*source);
  }
}

void StatusAmun::MergeFrom(const StatusAmun& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:amun.StatusAmun)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  options_.MergeFrom(from.options_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_port_bind_error()->::amun::PortBindError::MergeFrom(from._internal_port_bind_error());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_game_controller()->::amun::StatusGameController::MergeFrom(from._internal_game_controller());
    }
  }
}

void StatusAmun::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:amun.StatusAmun)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StatusAmun::CopyFrom(const StatusAmun& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:amun.StatusAmun)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatusAmun::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(options_)) return false;
  if (_internal_has_port_bind_error()) {
    if (!port_bind_error_->IsInitialized()) return false;
  }
  return true;
}

void StatusAmun::InternalSwap(StatusAmun* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  options_.InternalSwap(&other->options_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StatusAmun, game_controller_)
      + sizeof(StatusAmun::game_controller_)
      - PROTOBUF_FIELD_OFFSET(StatusAmun, port_bind_error_)>(
          reinterpret_cast<char*>(&port_bind_error_),
          reinterpret_cast<char*>(&other->port_bind_error_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StatusAmun::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Status::InitAsDefaultInstance() {
  ::amun::_Status_default_instance_._instance.get_mutable()->game_state_ = const_cast< ::amun::GameState*>(
      ::amun::GameState::internal_default_instance());
  ::amun::_Status_default_instance_._instance.get_mutable()->world_state_ = const_cast< ::world::State*>(
      ::world::State::internal_default_instance());
  ::amun::_Status_default_instance_._instance.get_mutable()->geometry_ = const_cast< ::world::Geometry*>(
      ::world::Geometry::internal_default_instance());
  ::amun::_Status_default_instance_._instance.get_mutable()->team_blue_ = const_cast< ::robot::Team*>(
      ::robot::Team::internal_default_instance());
  ::amun::_Status_default_instance_._instance.get_mutable()->team_yellow_ = const_cast< ::robot::Team*>(
      ::robot::Team::internal_default_instance());
  ::amun::_Status_default_instance_._instance.get_mutable()->strategy_blue_ = const_cast< ::amun::StatusStrategy*>(
      ::amun::StatusStrategy::internal_default_instance());
  ::amun::_Status_default_instance_._instance.get_mutable()->strategy_yellow_ = const_cast< ::amun::StatusStrategy*>(
      ::amun::StatusStrategy::internal_default_instance());
  ::amun::_Status_default_instance_._instance.get_mutable()->strategy_autoref_ = const_cast< ::amun::StatusStrategy*>(
      ::amun::StatusStrategy::internal_default_instance());
  ::amun::_Status_default_instance_._instance.get_mutable()->timing_ = const_cast< ::amun::Timing*>(
      ::amun::Timing::internal_default_instance());
  ::amun::_Status_default_instance_._instance.get_mutable()->transceiver_ = const_cast< ::amun::StatusTransceiver*>(
      ::amun::StatusTransceiver::internal_default_instance());
  ::amun::_Status_default_instance_._instance.get_mutable()->user_input_blue_ = const_cast< ::amun::UserInput*>(
      ::amun::UserInput::internal_default_instance());
  ::amun::_Status_default_instance_._instance.get_mutable()->user_input_yellow_ = const_cast< ::amun::UserInput*>(
      ::amun::UserInput::internal_default_instance());
  ::amun::_Status_default_instance_._instance.get_mutable()->amun_state_ = const_cast< ::amun::StatusAmun*>(
      ::amun::StatusAmun::internal_default_instance());
  ::amun::_Status_default_instance_._instance.get_mutable()->execution_state_ = const_cast< ::world::State*>(
      ::world::State::internal_default_instance());
  ::amun::_Status_default_instance_._instance.get_mutable()->execution_game_state_ = const_cast< ::amun::GameState*>(
      ::amun::GameState::internal_default_instance());
  ::amun::_Status_default_instance_._instance.get_mutable()->execution_user_input_ = const_cast< ::amun::UserInput*>(
      ::amun::UserInput::internal_default_instance());
  ::amun::_Status_default_instance_._instance.get_mutable()->log_id_ = const_cast< ::logfile::Uid*>(
      ::logfile::Uid::internal_default_instance());
  ::amun::_Status_default_instance_._instance.get_mutable()->status_strategy_ = const_cast< ::amun::StatusStrategyWrapper*>(
      ::amun::StatusStrategyWrapper::internal_default_instance());
  ::amun::_Status_default_instance_._instance.get_mutable()->pure_ui_response_ = const_cast< ::amun::UiResponse*>(
      ::amun::UiResponse::internal_default_instance());
}
class Status::_Internal {
 public:
  using HasBits = decltype(std::declval<Status>()._has_bits_);
  static void set_has_time(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static const ::amun::GameState& game_state(const Status* msg);
  static void set_has_game_state(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::world::State& world_state(const Status* msg);
  static void set_has_world_state(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::world::Geometry& geometry(const Status* msg);
  static void set_has_geometry(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::robot::Team& team_blue(const Status* msg);
  static void set_has_team_blue(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::robot::Team& team_yellow(const Status* msg);
  static void set_has_team_yellow(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::amun::StatusStrategy& strategy_blue(const Status* msg);
  static void set_has_strategy_blue(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::amun::StatusStrategy& strategy_yellow(const Status* msg);
  static void set_has_strategy_yellow(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::amun::StatusStrategy& strategy_autoref(const Status* msg);
  static void set_has_strategy_autoref(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::amun::Timing& timing(const Status* msg);
  static void set_has_timing(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::amun::StatusTransceiver& transceiver(const Status* msg);
  static void set_has_transceiver(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::amun::UserInput& user_input_blue(const Status* msg);
  static void set_has_user_input_blue(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::amun::UserInput& user_input_yellow(const Status* msg);
  static void set_has_user_input_yellow(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::amun::StatusAmun& amun_state(const Status* msg);
  static void set_has_amun_state(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_timer_scaling(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_blue_running(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_yellow_running(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_autoref_running(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static const ::world::State& execution_state(const Status* msg);
  static void set_has_execution_state(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static const ::amun::GameState& execution_game_state(const Status* msg);
  static void set_has_execution_game_state(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static const ::amun::UserInput& execution_user_input(const Status* msg);
  static void set_has_execution_user_input(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static const ::logfile::Uid& log_id(const Status* msg);
  static void set_has_log_id(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_original_frame_number(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static const ::amun::StatusStrategyWrapper& status_strategy(const Status* msg);
  static void set_has_status_strategy(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static const ::amun::UiResponse& pure_ui_response(const Status* msg);
  static void set_has_pure_ui_response(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00080000) ^ 0x00080000) != 0;
  }
};

const ::amun::GameState&
Status::_Internal::game_state(const Status* msg) {
  return *msg->game_state_;
}
const ::world::State&
Status::_Internal::world_state(const Status* msg) {
  return *msg->world_state_;
}
const ::world::Geometry&
Status::_Internal::geometry(const Status* msg) {
  return *msg->geometry_;
}
const ::robot::Team&
Status::_Internal::team_blue(const Status* msg) {
  return *msg->team_blue_;
}
const ::robot::Team&
Status::_Internal::team_yellow(const Status* msg) {
  return *msg->team_yellow_;
}
const ::amun::StatusStrategy&
Status::_Internal::strategy_blue(const Status* msg) {
  return *msg->strategy_blue_;
}
const ::amun::StatusStrategy&
Status::_Internal::strategy_yellow(const Status* msg) {
  return *msg->strategy_yellow_;
}
const ::amun::StatusStrategy&
Status::_Internal::strategy_autoref(const Status* msg) {
  return *msg->strategy_autoref_;
}
const ::amun::Timing&
Status::_Internal::timing(const Status* msg) {
  return *msg->timing_;
}
const ::amun::StatusTransceiver&
Status::_Internal::transceiver(const Status* msg) {
  return *msg->transceiver_;
}
const ::amun::UserInput&
Status::_Internal::user_input_blue(const Status* msg) {
  return *msg->user_input_blue_;
}
const ::amun::UserInput&
Status::_Internal::user_input_yellow(const Status* msg) {
  return *msg->user_input_yellow_;
}
const ::amun::StatusAmun&
Status::_Internal::amun_state(const Status* msg) {
  return *msg->amun_state_;
}
const ::world::State&
Status::_Internal::execution_state(const Status* msg) {
  return *msg->execution_state_;
}
const ::amun::GameState&
Status::_Internal::execution_game_state(const Status* msg) {
  return *msg->execution_game_state_;
}
const ::amun::UserInput&
Status::_Internal::execution_user_input(const Status* msg) {
  return *msg->execution_user_input_;
}
const ::logfile::Uid&
Status::_Internal::log_id(const Status* msg) {
  return *msg->log_id_;
}
const ::amun::StatusStrategyWrapper&
Status::_Internal::status_strategy(const Status* msg) {
  return *msg->status_strategy_;
}
const ::amun::UiResponse&
Status::_Internal::pure_ui_response(const Status* msg) {
  return *msg->pure_ui_response_;
}
void Status::clear_game_state() {
  if (game_state_ != nullptr) game_state_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
void Status::clear_world_state() {
  if (world_state_ != nullptr) world_state_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void Status::clear_geometry() {
  if (geometry_ != nullptr) geometry_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
void Status::clear_team_blue() {
  if (team_blue_ != nullptr) team_blue_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
void Status::clear_team_yellow() {
  if (team_yellow_ != nullptr) team_yellow_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
void Status::clear_debug() {
  debug_.Clear();
}
void Status::clear_radio_command() {
  radio_command_.Clear();
}
void Status::clear_user_input_blue() {
  if (user_input_blue_ != nullptr) user_input_blue_->Clear();
  _has_bits_[0] &= ~0x00000200u;
}
void Status::clear_user_input_yellow() {
  if (user_input_yellow_ != nullptr) user_input_yellow_->Clear();
  _has_bits_[0] &= ~0x00000400u;
}
void Status::clear_execution_state() {
  if (execution_state_ != nullptr) execution_state_->Clear();
  _has_bits_[0] &= ~0x00002000u;
}
void Status::clear_execution_game_state() {
  if (execution_game_state_ != nullptr) execution_game_state_->Clear();
  _has_bits_[0] &= ~0x00004000u;
}
void Status::clear_execution_user_input() {
  if (execution_user_input_ != nullptr) execution_user_input_->Clear();
  _has_bits_[0] &= ~0x00008000u;
}
void Status::clear_log_id() {
  if (log_id_ != nullptr) log_id_->Clear();
  _has_bits_[0] &= ~0x00010000u;
}
Status::Status(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  debug_(arena),
  radio_command_(arena),
  git_info_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:amun.Status)
}
Status::Status(const Status& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      debug_(from.debug_),
      radio_command_(from.radio_command_),
      git_info_(from.git_info_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_world_state()) {
    world_state_ = new ::world::State(*from.world_state_);
  } else {
    world_state_ = nullptr;
  }
  if (from._internal_has_geometry()) {
    geometry_ = new ::world::Geometry(*from.geometry_);
  } else {
    geometry_ = nullptr;
  }
  if (from._internal_has_team_blue()) {
    team_blue_ = new ::robot::Team(*from.team_blue_);
  } else {
    team_blue_ = nullptr;
  }
  if (from._internal_has_team_yellow()) {
    team_yellow_ = new ::robot::Team(*from.team_yellow_);
  } else {
    team_yellow_ = nullptr;
  }
  if (from._internal_has_strategy_blue()) {
    strategy_blue_ = new ::amun::StatusStrategy(*from.strategy_blue_);
  } else {
    strategy_blue_ = nullptr;
  }
  if (from._internal_has_strategy_yellow()) {
    strategy_yellow_ = new ::amun::StatusStrategy(*from.strategy_yellow_);
  } else {
    strategy_yellow_ = nullptr;
  }
  if (from._internal_has_timing()) {
    timing_ = new ::amun::Timing(*from.timing_);
  } else {
    timing_ = nullptr;
  }
  if (from._internal_has_transceiver()) {
    transceiver_ = new ::amun::StatusTransceiver(*from.transceiver_);
  } else {
    transceiver_ = nullptr;
  }
  if (from._internal_has_game_state()) {
    game_state_ = new ::amun::GameState(*from.game_state_);
  } else {
    game_state_ = nullptr;
  }
  if (from._internal_has_user_input_blue()) {
    user_input_blue_ = new ::amun::UserInput(*from.user_input_blue_);
  } else {
    user_input_blue_ = nullptr;
  }
  if (from._internal_has_user_input_yellow()) {
    user_input_yellow_ = new ::amun::UserInput(*from.user_input_yellow_);
  } else {
    user_input_yellow_ = nullptr;
  }
  if (from._internal_has_strategy_autoref()) {
    strategy_autoref_ = new ::amun::StatusStrategy(*from.strategy_autoref_);
  } else {
    strategy_autoref_ = nullptr;
  }
  if (from._internal_has_amun_state()) {
    amun_state_ = new ::amun::StatusAmun(*from.amun_state_);
  } else {
    amun_state_ = nullptr;
  }
  if (from._internal_has_execution_state()) {
    execution_state_ = new ::world::State(*from.execution_state_);
  } else {
    execution_state_ = nullptr;
  }
  if (from._internal_has_execution_game_state()) {
    execution_game_state_ = new ::amun::GameState(*from.execution_game_state_);
  } else {
    execution_game_state_ = nullptr;
  }
  if (from._internal_has_execution_user_input()) {
    execution_user_input_ = new ::amun::UserInput(*from.execution_user_input_);
  } else {
    execution_user_input_ = nullptr;
  }
  if (from._internal_has_log_id()) {
    log_id_ = new ::logfile::Uid(*from.log_id_);
  } else {
    log_id_ = nullptr;
  }
  if (from._internal_has_status_strategy()) {
    status_strategy_ = new ::amun::StatusStrategyWrapper(*from.status_strategy_);
  } else {
    status_strategy_ = nullptr;
  }
  if (from._internal_has_pure_ui_response()) {
    pure_ui_response_ = new ::amun::UiResponse(*from.pure_ui_response_);
  } else {
    pure_ui_response_ = nullptr;
  }
  ::memcpy(&time_, &from.time_,
    static_cast<size_t>(reinterpret_cast<char*>(&original_frame_number_) -
    reinterpret_cast<char*>(&time_)) + sizeof(original_frame_number_));
  // @@protoc_insertion_point(copy_constructor:amun.Status)
}

void Status::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Status_status_2eproto.base);
  ::memset(&world_state_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&original_frame_number_) -
      reinterpret_cast<char*>(&world_state_)) + sizeof(original_frame_number_));
}

Status::~Status() {
  // @@protoc_insertion_point(destructor:amun.Status)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Status::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete world_state_;
  if (this != internal_default_instance()) delete geometry_;
  if (this != internal_default_instance()) delete team_blue_;
  if (this != internal_default_instance()) delete team_yellow_;
  if (this != internal_default_instance()) delete strategy_blue_;
  if (this != internal_default_instance()) delete strategy_yellow_;
  if (this != internal_default_instance()) delete timing_;
  if (this != internal_default_instance()) delete transceiver_;
  if (this != internal_default_instance()) delete game_state_;
  if (this != internal_default_instance()) delete user_input_blue_;
  if (this != internal_default_instance()) delete user_input_yellow_;
  if (this != internal_default_instance()) delete strategy_autoref_;
  if (this != internal_default_instance()) delete amun_state_;
  if (this != internal_default_instance()) delete execution_state_;
  if (this != internal_default_instance()) delete execution_game_state_;
  if (this != internal_default_instance()) delete execution_user_input_;
  if (this != internal_default_instance()) delete log_id_;
  if (this != internal_default_instance()) delete status_strategy_;
  if (this != internal_default_instance()) delete pure_ui_response_;
}

void Status::ArenaDtor(void* object) {
  Status* _this = reinterpret_cast< Status* >(object);
  (void)_this;
}
void Status::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Status::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Status& Status::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Status_status_2eproto.base);
  return *internal_default_instance();
}


void Status::Clear() {
// @@protoc_insertion_point(message_clear_start:amun.Status)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  debug_.Clear();
  radio_command_.Clear();
  git_info_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(world_state_ != nullptr);
      world_state_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(geometry_ != nullptr);
      geometry_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(team_blue_ != nullptr);
      team_blue_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(team_yellow_ != nullptr);
      team_yellow_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(strategy_blue_ != nullptr);
      strategy_blue_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(strategy_yellow_ != nullptr);
      strategy_yellow_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(timing_ != nullptr);
      timing_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(transceiver_ != nullptr);
      transceiver_->Clear();
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(game_state_ != nullptr);
      game_state_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(user_input_blue_ != nullptr);
      user_input_blue_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(user_input_yellow_ != nullptr);
      user_input_yellow_->Clear();
    }
    if (cached_has_bits & 0x00000800u) {
      GOOGLE_DCHECK(strategy_autoref_ != nullptr);
      strategy_autoref_->Clear();
    }
    if (cached_has_bits & 0x00001000u) {
      GOOGLE_DCHECK(amun_state_ != nullptr);
      amun_state_->Clear();
    }
    if (cached_has_bits & 0x00002000u) {
      GOOGLE_DCHECK(execution_state_ != nullptr);
      execution_state_->Clear();
    }
    if (cached_has_bits & 0x00004000u) {
      GOOGLE_DCHECK(execution_game_state_ != nullptr);
      execution_game_state_->Clear();
    }
    if (cached_has_bits & 0x00008000u) {
      GOOGLE_DCHECK(execution_user_input_ != nullptr);
      execution_user_input_->Clear();
    }
  }
  if (cached_has_bits & 0x00070000u) {
    if (cached_has_bits & 0x00010000u) {
      GOOGLE_DCHECK(log_id_ != nullptr);
      log_id_->Clear();
    }
    if (cached_has_bits & 0x00020000u) {
      GOOGLE_DCHECK(status_strategy_ != nullptr);
      status_strategy_->Clear();
    }
    if (cached_has_bits & 0x00040000u) {
      GOOGLE_DCHECK(pure_ui_response_ != nullptr);
      pure_ui_response_->Clear();
    }
  }
  if (cached_has_bits & 0x00f80000u) {
    ::memset(&time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&autoref_running_) -
        reinterpret_cast<char*>(&time_)) + sizeof(autoref_running_));
  }
  original_frame_number_ = PROTOBUF_ULONGLONG(0);
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Status::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required int64 time = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_time(&has_bits);
          time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .world.State world_state = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_world_state(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .world.Geometry geometry = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_geometry(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .robot.Team team_blue = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_team_blue(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .robot.Team team_yellow = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_team_yellow(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .amun.StatusStrategy strategy_blue = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_strategy_blue(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .amun.StatusStrategy strategy_yellow = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_strategy_yellow(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .amun.DebugValues debug = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_debug(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else goto handle_unusual;
        continue;
      // optional .amun.Timing timing = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_timing(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .robot.RadioCommand radio_command = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 98)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_radio_command(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<98>(ptr));
        } else goto handle_unusual;
        continue;
      // optional .amun.StatusTransceiver transceiver = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_transceiver(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .amun.GameState game_state = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_game_state(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .amun.UserInput user_input_blue = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_user_input_blue(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .amun.UserInput user_input_yellow = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_user_input_yellow(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .amun.StatusStrategy strategy_autoref = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_strategy_autoref(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .amun.StatusAmun amun_state = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_amun_state(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float timer_scaling = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 165)) {
          _Internal::set_has_timer_scaling(&has_bits);
          timer_scaling_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional bool blue_running = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 168)) {
          _Internal::set_has_blue_running(&has_bits);
          blue_running_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool yellow_running = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 176)) {
          _Internal::set_has_yellow_running(&has_bits);
          yellow_running_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .world.State execution_state = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 186)) {
          ptr = ctx->ParseMessage(_internal_mutable_execution_state(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .amun.GameState execution_game_state = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 194)) {
          ptr = ctx->ParseMessage(_internal_mutable_execution_game_state(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .amun.UserInput execution_user_input = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_execution_user_input(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool autoref_running = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 208)) {
          _Internal::set_has_autoref_running(&has_bits);
          autoref_running_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .logfile.Uid log_id = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 218)) {
          ptr = ctx->ParseMessage(_internal_mutable_log_id(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 original_frame_number = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 224)) {
          _Internal::set_has_original_frame_number(&has_bits);
          original_frame_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .amun.StatusStrategyWrapper status_strategy = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 234)) {
          ptr = ctx->ParseMessage(_internal_mutable_status_strategy(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .amun.UiResponse pure_ui_response = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 242)) {
          ptr = ctx->ParseMessage(_internal_mutable_pure_ui_response(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .amun.GitInfo git_info = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 250)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_git_info(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<250>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Status::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:amun.Status)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 time = 1;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_time(), target);
  }

  // optional .world.State world_state = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::world_state(this), target, stream);
  }

  // optional .world.Geometry geometry = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::geometry(this), target, stream);
  }

  // optional .robot.Team team_blue = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::team_blue(this), target, stream);
  }

  // optional .robot.Team team_yellow = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::team_yellow(this), target, stream);
  }

  // optional .amun.StatusStrategy strategy_blue = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::strategy_blue(this), target, stream);
  }

  // optional .amun.StatusStrategy strategy_yellow = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        8, _Internal::strategy_yellow(this), target, stream);
  }

  // repeated .amun.DebugValues debug = 10;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_debug_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, this->_internal_debug(i), target, stream);
  }

  // optional .amun.Timing timing = 11;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        11, _Internal::timing(this), target, stream);
  }

  // repeated .robot.RadioCommand radio_command = 12;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_radio_command_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, this->_internal_radio_command(i), target, stream);
  }

  // optional .amun.StatusTransceiver transceiver = 13;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        13, _Internal::transceiver(this), target, stream);
  }

  // optional .amun.GameState game_state = 15;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        15, _Internal::game_state(this), target, stream);
  }

  // optional .amun.UserInput user_input_blue = 16;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        16, _Internal::user_input_blue(this), target, stream);
  }

  // optional .amun.UserInput user_input_yellow = 17;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        17, _Internal::user_input_yellow(this), target, stream);
  }

  // optional .amun.StatusStrategy strategy_autoref = 18;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        18, _Internal::strategy_autoref(this), target, stream);
  }

  // optional .amun.StatusAmun amun_state = 19;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        19, _Internal::amun_state(this), target, stream);
  }

  // optional float timer_scaling = 20;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(20, this->_internal_timer_scaling(), target);
  }

  // optional bool blue_running = 21;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(21, this->_internal_blue_running(), target);
  }

  // optional bool yellow_running = 22;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(22, this->_internal_yellow_running(), target);
  }

  // optional .world.State execution_state = 23;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        23, _Internal::execution_state(this), target, stream);
  }

  // optional .amun.GameState execution_game_state = 24;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        24, _Internal::execution_game_state(this), target, stream);
  }

  // optional .amun.UserInput execution_user_input = 25;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        25, _Internal::execution_user_input(this), target, stream);
  }

  // optional bool autoref_running = 26;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(26, this->_internal_autoref_running(), target);
  }

  // optional .logfile.Uid log_id = 27;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        27, _Internal::log_id(this), target, stream);
  }

  // optional uint64 original_frame_number = 28;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(28, this->_internal_original_frame_number(), target);
  }

  // optional .amun.StatusStrategyWrapper status_strategy = 29;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        29, _Internal::status_strategy(this), target, stream);
  }

  // optional .amun.UiResponse pure_ui_response = 30;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        30, _Internal::pure_ui_response(this), target, stream);
  }

  // repeated .amun.GitInfo git_info = 31;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_git_info_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(31, this->_internal_git_info(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:amun.Status)
  return target;
}

size_t Status::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:amun.Status)
  size_t total_size = 0;

  // required int64 time = 1;
  if (_internal_has_time()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
        this->_internal_time());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .amun.DebugValues debug = 10;
  total_size += 1UL * this->_internal_debug_size();
  for (const auto& msg : this->debug_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .robot.RadioCommand radio_command = 12;
  total_size += 1UL * this->_internal_radio_command_size();
  for (const auto& msg : this->radio_command_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .amun.GitInfo git_info = 31;
  total_size += 2UL * this->_internal_git_info_size();
  for (const auto& msg : this->git_info_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .world.State world_state = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *world_state_);
    }

    // optional .world.Geometry geometry = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *geometry_);
    }

    // optional .robot.Team team_blue = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *team_blue_);
    }

    // optional .robot.Team team_yellow = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *team_yellow_);
    }

    // optional .amun.StatusStrategy strategy_blue = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *strategy_blue_);
    }

    // optional .amun.StatusStrategy strategy_yellow = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *strategy_yellow_);
    }

    // optional .amun.Timing timing = 11;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *timing_);
    }

    // optional .amun.StatusTransceiver transceiver = 13;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *transceiver_);
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional .amun.GameState game_state = 15;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *game_state_);
    }

    // optional .amun.UserInput user_input_blue = 16;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *user_input_blue_);
    }

    // optional .amun.UserInput user_input_yellow = 17;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *user_input_yellow_);
    }

    // optional .amun.StatusStrategy strategy_autoref = 18;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *strategy_autoref_);
    }

    // optional .amun.StatusAmun amun_state = 19;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *amun_state_);
    }

    // optional .world.State execution_state = 23;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *execution_state_);
    }

    // optional .amun.GameState execution_game_state = 24;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *execution_game_state_);
    }

    // optional .amun.UserInput execution_user_input = 25;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *execution_user_input_);
    }

  }
  if (cached_has_bits & 0x00070000u) {
    // optional .logfile.Uid log_id = 27;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *log_id_);
    }

    // optional .amun.StatusStrategyWrapper status_strategy = 29;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *status_strategy_);
    }

    // optional .amun.UiResponse pure_ui_response = 30;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *pure_ui_response_);
    }

  }
  if (cached_has_bits & 0x00f00000u) {
    // optional float timer_scaling = 20;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 + 4;
    }

    // optional bool blue_running = 21;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 + 1;
    }

    // optional bool yellow_running = 22;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 + 1;
    }

    // optional bool autoref_running = 26;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 + 1;
    }

  }
  // optional uint64 original_frame_number = 28;
  if (cached_has_bits & 0x01000000u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->_internal_original_frame_number());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Status::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:amun.Status)
  GOOGLE_DCHECK_NE(&from, this);
  const Status* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Status>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:amun.Status)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:amun.Status)
    MergeFrom(*source);
  }
}

void Status::MergeFrom(const Status& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:amun.Status)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  debug_.MergeFrom(from.debug_);
  radio_command_.MergeFrom(from.radio_command_);
  git_info_.MergeFrom(from.git_info_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_world_state()->::world::State::MergeFrom(from._internal_world_state());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_geometry()->::world::Geometry::MergeFrom(from._internal_geometry());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_team_blue()->::robot::Team::MergeFrom(from._internal_team_blue());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_team_yellow()->::robot::Team::MergeFrom(from._internal_team_yellow());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_strategy_blue()->::amun::StatusStrategy::MergeFrom(from._internal_strategy_blue());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_strategy_yellow()->::amun::StatusStrategy::MergeFrom(from._internal_strategy_yellow());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_timing()->::amun::Timing::MergeFrom(from._internal_timing());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_mutable_transceiver()->::amun::StatusTransceiver::MergeFrom(from._internal_transceiver());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _internal_mutable_game_state()->::amun::GameState::MergeFrom(from._internal_game_state());
    }
    if (cached_has_bits & 0x00000200u) {
      _internal_mutable_user_input_blue()->::amun::UserInput::MergeFrom(from._internal_user_input_blue());
    }
    if (cached_has_bits & 0x00000400u) {
      _internal_mutable_user_input_yellow()->::amun::UserInput::MergeFrom(from._internal_user_input_yellow());
    }
    if (cached_has_bits & 0x00000800u) {
      _internal_mutable_strategy_autoref()->::amun::StatusStrategy::MergeFrom(from._internal_strategy_autoref());
    }
    if (cached_has_bits & 0x00001000u) {
      _internal_mutable_amun_state()->::amun::StatusAmun::MergeFrom(from._internal_amun_state());
    }
    if (cached_has_bits & 0x00002000u) {
      _internal_mutable_execution_state()->::world::State::MergeFrom(from._internal_execution_state());
    }
    if (cached_has_bits & 0x00004000u) {
      _internal_mutable_execution_game_state()->::amun::GameState::MergeFrom(from._internal_execution_game_state());
    }
    if (cached_has_bits & 0x00008000u) {
      _internal_mutable_execution_user_input()->::amun::UserInput::MergeFrom(from._internal_execution_user_input());
    }
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      _internal_mutable_log_id()->::logfile::Uid::MergeFrom(from._internal_log_id());
    }
    if (cached_has_bits & 0x00020000u) {
      _internal_mutable_status_strategy()->::amun::StatusStrategyWrapper::MergeFrom(from._internal_status_strategy());
    }
    if (cached_has_bits & 0x00040000u) {
      _internal_mutable_pure_ui_response()->::amun::UiResponse::MergeFrom(from._internal_pure_ui_response());
    }
    if (cached_has_bits & 0x00080000u) {
      time_ = from.time_;
    }
    if (cached_has_bits & 0x00100000u) {
      timer_scaling_ = from.timer_scaling_;
    }
    if (cached_has_bits & 0x00200000u) {
      blue_running_ = from.blue_running_;
    }
    if (cached_has_bits & 0x00400000u) {
      yellow_running_ = from.yellow_running_;
    }
    if (cached_has_bits & 0x00800000u) {
      autoref_running_ = from.autoref_running_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x01000000u) {
    _internal_set_original_frame_number(from._internal_original_frame_number());
  }
}

void Status::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:amun.Status)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Status::CopyFrom(const Status& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:amun.Status)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Status::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(debug_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(radio_command_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(git_info_)) return false;
  if (_internal_has_world_state()) {
    if (!world_state_->IsInitialized()) return false;
  }
  if (_internal_has_geometry()) {
    if (!geometry_->IsInitialized()) return false;
  }
  if (_internal_has_team_blue()) {
    if (!team_blue_->IsInitialized()) return false;
  }
  if (_internal_has_team_yellow()) {
    if (!team_yellow_->IsInitialized()) return false;
  }
  if (_internal_has_strategy_blue()) {
    if (!strategy_blue_->IsInitialized()) return false;
  }
  if (_internal_has_strategy_yellow()) {
    if (!strategy_yellow_->IsInitialized()) return false;
  }
  if (_internal_has_transceiver()) {
    if (!transceiver_->IsInitialized()) return false;
  }
  if (_internal_has_game_state()) {
    if (!game_state_->IsInitialized()) return false;
  }
  if (_internal_has_user_input_blue()) {
    if (!user_input_blue_->IsInitialized()) return false;
  }
  if (_internal_has_user_input_yellow()) {
    if (!user_input_yellow_->IsInitialized()) return false;
  }
  if (_internal_has_strategy_autoref()) {
    if (!strategy_autoref_->IsInitialized()) return false;
  }
  if (_internal_has_amun_state()) {
    if (!amun_state_->IsInitialized()) return false;
  }
  if (_internal_has_execution_state()) {
    if (!execution_state_->IsInitialized()) return false;
  }
  if (_internal_has_execution_game_state()) {
    if (!execution_game_state_->IsInitialized()) return false;
  }
  if (_internal_has_execution_user_input()) {
    if (!execution_user_input_->IsInitialized()) return false;
  }
  if (_internal_has_log_id()) {
    if (!log_id_->IsInitialized()) return false;
  }
  if (_internal_has_status_strategy()) {
    if (!status_strategy_->IsInitialized()) return false;
  }
  if (_internal_has_pure_ui_response()) {
    if (!pure_ui_response_->IsInitialized()) return false;
  }
  return true;
}

void Status::InternalSwap(Status* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  debug_.InternalSwap(&other->debug_);
  radio_command_.InternalSwap(&other->radio_command_);
  git_info_.InternalSwap(&other->git_info_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Status, original_frame_number_)
      + sizeof(Status::original_frame_number_)
      - PROTOBUF_FIELD_OFFSET(Status, world_state_)>(
          reinterpret_cast<char*>(&world_state_),
          reinterpret_cast<char*>(&other->world_state_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Status::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void UiResponse::InitAsDefaultInstance() {
  ::amun::_UiResponse_default_instance_._instance.get_mutable()->logging_info_ = const_cast< ::amun::LoggingInfo*>(
      ::amun::LoggingInfo::internal_default_instance());
  ::amun::_UiResponse_default_instance_._instance.get_mutable()->log_info_ = const_cast< ::amun::LogPlaybackInfo*>(
      ::amun::LogPlaybackInfo::internal_default_instance());
  ::amun::_UiResponse_default_instance_._instance.get_mutable()->log_open_ = const_cast< ::amun::LogfileOpenInfo*>(
      ::amun::LogfileOpenInfo::internal_default_instance());
  ::amun::_UiResponse_default_instance_._instance.get_mutable()->log_offers_ = const_cast< ::logfile::LogOffer*>(
      ::logfile::LogOffer::internal_default_instance());
}
class UiResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<UiResponse>()._has_bits_);
  static void set_has_enable_logging(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::amun::LoggingInfo& logging_info(const UiResponse* msg);
  static void set_has_logging_info(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_playback_burst_end(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_playback_paused(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::amun::LogPlaybackInfo& log_info(const UiResponse* msg);
  static void set_has_log_info(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_frame_number(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_force_ra_horus(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::amun::LogfileOpenInfo& log_open(const UiResponse* msg);
  static void set_has_log_open(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_export_visionlog_error(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_requested_log_uid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::logfile::LogOffer& log_offers(const UiResponse* msg);
  static void set_has_log_offers(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_log_uid_parser_error(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::amun::LoggingInfo&
UiResponse::_Internal::logging_info(const UiResponse* msg) {
  return *msg->logging_info_;
}
const ::amun::LogPlaybackInfo&
UiResponse::_Internal::log_info(const UiResponse* msg) {
  return *msg->log_info_;
}
const ::amun::LogfileOpenInfo&
UiResponse::_Internal::log_open(const UiResponse* msg) {
  return *msg->log_open_;
}
const ::logfile::LogOffer&
UiResponse::_Internal::log_offers(const UiResponse* msg) {
  return *msg->log_offers_;
}
void UiResponse::clear_log_offers() {
  if (log_offers_ != nullptr) log_offers_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
UiResponse::UiResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  logger_status_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:amun.UiResponse)
}
UiResponse::UiResponse(const UiResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      logger_status_(from.logger_status_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  export_visionlog_error_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_export_visionlog_error()) {
    export_visionlog_error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_export_visionlog_error(),
      GetArena());
  }
  requested_log_uid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_requested_log_uid()) {
    requested_log_uid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_requested_log_uid(),
      GetArena());
  }
  log_uid_parser_error_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_log_uid_parser_error()) {
    log_uid_parser_error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_log_uid_parser_error(),
      GetArena());
  }
  if (from._internal_has_logging_info()) {
    logging_info_ = new ::amun::LoggingInfo(*from.logging_info_);
  } else {
    logging_info_ = nullptr;
  }
  if (from._internal_has_log_info()) {
    log_info_ = new ::amun::LogPlaybackInfo(*from.log_info_);
  } else {
    log_info_ = nullptr;
  }
  if (from._internal_has_log_open()) {
    log_open_ = new ::amun::LogfileOpenInfo(*from.log_open_);
  } else {
    log_open_ = nullptr;
  }
  if (from._internal_has_log_offers()) {
    log_offers_ = new ::logfile::LogOffer(*from.log_offers_);
  } else {
    log_offers_ = nullptr;
  }
  ::memcpy(&frame_number_, &from.frame_number_,
    static_cast<size_t>(reinterpret_cast<char*>(&force_ra_horus_) -
    reinterpret_cast<char*>(&frame_number_)) + sizeof(force_ra_horus_));
  // @@protoc_insertion_point(copy_constructor:amun.UiResponse)
}

void UiResponse::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Status_status_2eproto.base);
  export_visionlog_error_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  requested_log_uid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  log_uid_parser_error_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&logging_info_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&force_ra_horus_) -
      reinterpret_cast<char*>(&logging_info_)) + sizeof(force_ra_horus_));
}

UiResponse::~UiResponse() {
  // @@protoc_insertion_point(destructor:amun.UiResponse)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void UiResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  export_visionlog_error_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  requested_log_uid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  log_uid_parser_error_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete logging_info_;
  if (this != internal_default_instance()) delete log_info_;
  if (this != internal_default_instance()) delete log_open_;
  if (this != internal_default_instance()) delete log_offers_;
}

void UiResponse::ArenaDtor(void* object) {
  UiResponse* _this = reinterpret_cast< UiResponse* >(object);
  (void)_this;
}
void UiResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void UiResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UiResponse& UiResponse::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Status_status_2eproto.base);
  return *internal_default_instance();
}


void UiResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:amun.UiResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  logger_status_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      export_visionlog_error_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      requested_log_uid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      log_uid_parser_error_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(logging_info_ != nullptr);
      logging_info_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(log_info_ != nullptr);
      log_info_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(log_open_ != nullptr);
      log_open_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(log_offers_ != nullptr);
      log_offers_->Clear();
    }
  }
  frame_number_ = PROTOBUF_LONGLONG(0);
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&enable_logging_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&force_ra_horus_) -
        reinterpret_cast<char*>(&enable_logging_)) + sizeof(force_ra_horus_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UiResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional bool enable_logging = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_enable_logging(&has_bits);
          enable_logging_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .amun.LoggingInfo logging_info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_logging_info(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .amun.Status logger_status = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_logger_status(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else goto handle_unusual;
        continue;
      // optional bool playback_burst_end = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_playback_burst_end(&has_bits);
          playback_burst_end_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool playback_paused = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_playback_paused(&has_bits);
          playback_paused_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .amun.LogPlaybackInfo log_info = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_log_info(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int64 frame_number = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_frame_number(&has_bits);
          frame_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool force_ra_horus = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_force_ra_horus(&has_bits);
          force_ra_horus_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .amun.LogfileOpenInfo log_open = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_log_open(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string export_visionlog_error = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          auto str = _internal_mutable_export_visionlog_error();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "amun.UiResponse.export_visionlog_error");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string requested_log_uid = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          auto str = _internal_mutable_requested_log_uid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "amun.UiResponse.requested_log_uid");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .logfile.LogOffer log_offers = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_log_offers(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string log_uid_parser_error = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 106)) {
          auto str = _internal_mutable_log_uid_parser_error();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "amun.UiResponse.log_uid_parser_error");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* UiResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:amun.UiResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool enable_logging = 1;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_enable_logging(), target);
  }

  // optional .amun.LoggingInfo logging_info = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::logging_info(this), target, stream);
  }

  // repeated .amun.Status logger_status = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_logger_status_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_logger_status(i), target, stream);
  }

  // optional bool playback_burst_end = 4;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_playback_burst_end(), target);
  }

  // optional bool playback_paused = 5;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_playback_paused(), target);
  }

  // optional .amun.LogPlaybackInfo log_info = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::log_info(this), target, stream);
  }

  // optional int64 frame_number = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(7, this->_internal_frame_number(), target);
  }

  // optional bool force_ra_horus = 8;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->_internal_force_ra_horus(), target);
  }

  // optional .amun.LogfileOpenInfo log_open = 9;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        9, _Internal::log_open(this), target, stream);
  }

  // optional string export_visionlog_error = 10;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_export_visionlog_error().data(), static_cast<int>(this->_internal_export_visionlog_error().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "amun.UiResponse.export_visionlog_error");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_export_visionlog_error(), target);
  }

  // optional string requested_log_uid = 11;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_requested_log_uid().data(), static_cast<int>(this->_internal_requested_log_uid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "amun.UiResponse.requested_log_uid");
    target = stream->WriteStringMaybeAliased(
        11, this->_internal_requested_log_uid(), target);
  }

  // optional .logfile.LogOffer log_offers = 12;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        12, _Internal::log_offers(this), target, stream);
  }

  // optional string log_uid_parser_error = 13;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_log_uid_parser_error().data(), static_cast<int>(this->_internal_log_uid_parser_error().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "amun.UiResponse.log_uid_parser_error");
    target = stream->WriteStringMaybeAliased(
        13, this->_internal_log_uid_parser_error(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:amun.UiResponse)
  return target;
}

size_t UiResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:amun.UiResponse)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .amun.Status logger_status = 3;
  total_size += 1UL * this->_internal_logger_status_size();
  for (const auto& msg : this->logger_status_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string export_visionlog_error = 10;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_export_visionlog_error());
    }

    // optional string requested_log_uid = 11;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_requested_log_uid());
    }

    // optional string log_uid_parser_error = 13;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_log_uid_parser_error());
    }

    // optional .amun.LoggingInfo logging_info = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *logging_info_);
    }

    // optional .amun.LogPlaybackInfo log_info = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *log_info_);
    }

    // optional .amun.LogfileOpenInfo log_open = 9;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *log_open_);
    }

    // optional .logfile.LogOffer log_offers = 12;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *log_offers_);
    }

    // optional int64 frame_number = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
          this->_internal_frame_number());
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional bool enable_logging = 1;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool playback_burst_end = 4;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool playback_paused = 5;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional bool force_ra_horus = 8;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UiResponse::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:amun.UiResponse)
  GOOGLE_DCHECK_NE(&from, this);
  const UiResponse* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<UiResponse>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:amun.UiResponse)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:amun.UiResponse)
    MergeFrom(*source);
  }
}

void UiResponse::MergeFrom(const UiResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:amun.UiResponse)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  logger_status_.MergeFrom(from.logger_status_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_export_visionlog_error(from._internal_export_visionlog_error());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_requested_log_uid(from._internal_requested_log_uid());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_log_uid_parser_error(from._internal_log_uid_parser_error());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_logging_info()->::amun::LoggingInfo::MergeFrom(from._internal_logging_info());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_log_info()->::amun::LogPlaybackInfo::MergeFrom(from._internal_log_info());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_log_open()->::amun::LogfileOpenInfo::MergeFrom(from._internal_log_open());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_log_offers()->::logfile::LogOffer::MergeFrom(from._internal_log_offers());
    }
    if (cached_has_bits & 0x00000080u) {
      frame_number_ = from.frame_number_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      enable_logging_ = from.enable_logging_;
    }
    if (cached_has_bits & 0x00000200u) {
      playback_burst_end_ = from.playback_burst_end_;
    }
    if (cached_has_bits & 0x00000400u) {
      playback_paused_ = from.playback_paused_;
    }
    if (cached_has_bits & 0x00000800u) {
      force_ra_horus_ = from.force_ra_horus_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void UiResponse::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:amun.UiResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UiResponse::CopyFrom(const UiResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:amun.UiResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UiResponse::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(logger_status_)) return false;
  if (_internal_has_logging_info()) {
    if (!logging_info_->IsInitialized()) return false;
  }
  if (_internal_has_log_info()) {
    if (!log_info_->IsInitialized()) return false;
  }
  if (_internal_has_log_open()) {
    if (!log_open_->IsInitialized()) return false;
  }
  if (_internal_has_log_offers()) {
    if (!log_offers_->IsInitialized()) return false;
  }
  return true;
}

void UiResponse::InternalSwap(UiResponse* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  logger_status_.InternalSwap(&other->logger_status_);
  export_visionlog_error_.Swap(&other->export_visionlog_error_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  requested_log_uid_.Swap(&other->requested_log_uid_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  log_uid_parser_error_.Swap(&other->log_uid_parser_error_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UiResponse, force_ra_horus_)
      + sizeof(UiResponse::force_ra_horus_)
      - PROTOBUF_FIELD_OFFSET(UiResponse, logging_info_)>(
          reinterpret_cast<char*>(&logging_info_),
          reinterpret_cast<char*>(&other->logging_info_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UiResponse::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void LoggingInfo::InitAsDefaultInstance() {
}
class LoggingInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<LoggingInfo>()._has_bits_);
  static void set_has_is_logging(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_is_replay_logger(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

LoggingInfo::LoggingInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:amun.LoggingInfo)
}
LoggingInfo::LoggingInfo(const LoggingInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&is_logging_, &from.is_logging_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_replay_logger_) -
    reinterpret_cast<char*>(&is_logging_)) + sizeof(is_replay_logger_));
  // @@protoc_insertion_point(copy_constructor:amun.LoggingInfo)
}

void LoggingInfo::SharedCtor() {
  ::memset(&is_logging_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&is_replay_logger_) -
      reinterpret_cast<char*>(&is_logging_)) + sizeof(is_replay_logger_));
}

LoggingInfo::~LoggingInfo() {
  // @@protoc_insertion_point(destructor:amun.LoggingInfo)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void LoggingInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void LoggingInfo::ArenaDtor(void* object) {
  LoggingInfo* _this = reinterpret_cast< LoggingInfo* >(object);
  (void)_this;
}
void LoggingInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LoggingInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const LoggingInfo& LoggingInfo::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_LoggingInfo_status_2eproto.base);
  return *internal_default_instance();
}


void LoggingInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:amun.LoggingInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&is_logging_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&is_replay_logger_) -
      reinterpret_cast<char*>(&is_logging_)) + sizeof(is_replay_logger_));
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LoggingInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bool is_logging = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_is_logging(&has_bits);
          is_logging_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bool is_replay_logger = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_is_replay_logger(&has_bits);
          is_replay_logger_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* LoggingInfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:amun.LoggingInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bool is_logging = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_is_logging(), target);
  }

  // required bool is_replay_logger = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_is_replay_logger(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:amun.LoggingInfo)
  return target;
}

size_t LoggingInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:amun.LoggingInfo)
  size_t total_size = 0;

  if (_internal_has_is_logging()) {
    // required bool is_logging = 1;
    total_size += 1 + 1;
  }

  if (_internal_has_is_replay_logger()) {
    // required bool is_replay_logger = 2;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t LoggingInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:amun.LoggingInfo)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required bool is_logging = 1;
    total_size += 1 + 1;

    // required bool is_replay_logger = 2;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LoggingInfo::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:amun.LoggingInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const LoggingInfo* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<LoggingInfo>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:amun.LoggingInfo)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:amun.LoggingInfo)
    MergeFrom(*source);
  }
}

void LoggingInfo::MergeFrom(const LoggingInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:amun.LoggingInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      is_logging_ = from.is_logging_;
    }
    if (cached_has_bits & 0x00000002u) {
      is_replay_logger_ = from.is_replay_logger_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void LoggingInfo::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:amun.LoggingInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LoggingInfo::CopyFrom(const LoggingInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:amun.LoggingInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoggingInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void LoggingInfo::InternalSwap(LoggingInfo* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LoggingInfo, is_replay_logger_)
      + sizeof(LoggingInfo::is_replay_logger_)
      - PROTOBUF_FIELD_OFFSET(LoggingInfo, is_logging_)>(
          reinterpret_cast<char*>(&is_logging_),
          reinterpret_cast<char*>(&other->is_logging_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LoggingInfo::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void LogPlaybackInfo::InitAsDefaultInstance() {
}
class LogPlaybackInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<LogPlaybackInfo>()._has_bits_);
  static void set_has_start_time(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_packet_count(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

LogPlaybackInfo::LogPlaybackInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:amun.LogPlaybackInfo)
}
LogPlaybackInfo::LogPlaybackInfo(const LogPlaybackInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&start_time_, &from.start_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&packet_count_) -
    reinterpret_cast<char*>(&start_time_)) + sizeof(packet_count_));
  // @@protoc_insertion_point(copy_constructor:amun.LogPlaybackInfo)
}

void LogPlaybackInfo::SharedCtor() {
  ::memset(&start_time_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&packet_count_) -
      reinterpret_cast<char*>(&start_time_)) + sizeof(packet_count_));
}

LogPlaybackInfo::~LogPlaybackInfo() {
  // @@protoc_insertion_point(destructor:amun.LogPlaybackInfo)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void LogPlaybackInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void LogPlaybackInfo::ArenaDtor(void* object) {
  LogPlaybackInfo* _this = reinterpret_cast< LogPlaybackInfo* >(object);
  (void)_this;
}
void LogPlaybackInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LogPlaybackInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const LogPlaybackInfo& LogPlaybackInfo::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_LogPlaybackInfo_status_2eproto.base);
  return *internal_default_instance();
}


void LogPlaybackInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:amun.LogPlaybackInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&start_time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&packet_count_) -
        reinterpret_cast<char*>(&start_time_)) + sizeof(packet_count_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LogPlaybackInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required int64 start_time = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_start_time(&has_bits);
          start_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required int64 duration = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_duration(&has_bits);
          duration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required int64 packet_count = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_packet_count(&has_bits);
          packet_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* LogPlaybackInfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:amun.LogPlaybackInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int64 start_time = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(1, this->_internal_start_time(), target);
  }

  // required int64 duration = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_duration(), target);
  }

  // required int64 packet_count = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(3, this->_internal_packet_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:amun.LogPlaybackInfo)
  return target;
}

size_t LogPlaybackInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:amun.LogPlaybackInfo)
  size_t total_size = 0;

  if (_internal_has_start_time()) {
    // required int64 start_time = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
        this->_internal_start_time());
  }

  if (_internal_has_duration()) {
    // required int64 duration = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
        this->_internal_duration());
  }

  if (_internal_has_packet_count()) {
    // required int64 packet_count = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
        this->_internal_packet_count());
  }

  return total_size;
}
size_t LogPlaybackInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:amun.LogPlaybackInfo)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required int64 start_time = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
        this->_internal_start_time());

    // required int64 duration = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
        this->_internal_duration());

    // required int64 packet_count = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64Size(
        this->_internal_packet_count());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LogPlaybackInfo::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:amun.LogPlaybackInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const LogPlaybackInfo* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<LogPlaybackInfo>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:amun.LogPlaybackInfo)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:amun.LogPlaybackInfo)
    MergeFrom(*source);
  }
}

void LogPlaybackInfo::MergeFrom(const LogPlaybackInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:amun.LogPlaybackInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      start_time_ = from.start_time_;
    }
    if (cached_has_bits & 0x00000002u) {
      duration_ = from.duration_;
    }
    if (cached_has_bits & 0x00000004u) {
      packet_count_ = from.packet_count_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void LogPlaybackInfo::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:amun.LogPlaybackInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LogPlaybackInfo::CopyFrom(const LogPlaybackInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:amun.LogPlaybackInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogPlaybackInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void LogPlaybackInfo::InternalSwap(LogPlaybackInfo* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LogPlaybackInfo, packet_count_)
      + sizeof(LogPlaybackInfo::packet_count_)
      - PROTOBUF_FIELD_OFFSET(LogPlaybackInfo, start_time_)>(
          reinterpret_cast<char*>(&start_time_),
          reinterpret_cast<char*>(&other->start_time_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LogPlaybackInfo::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void LogfileOpenInfo::InitAsDefaultInstance() {
}
class LogfileOpenInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<LogfileOpenInfo>()._has_bits_);
  static void set_has_success(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_filename(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

LogfileOpenInfo::LogfileOpenInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:amun.LogfileOpenInfo)
}
LogfileOpenInfo::LogfileOpenInfo(const LogfileOpenInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  filename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_filename()) {
    filename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_filename(),
      GetArena());
  }
  success_ = from.success_;
  // @@protoc_insertion_point(copy_constructor:amun.LogfileOpenInfo)
}

void LogfileOpenInfo::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_LogfileOpenInfo_status_2eproto.base);
  filename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  success_ = false;
}

LogfileOpenInfo::~LogfileOpenInfo() {
  // @@protoc_insertion_point(destructor:amun.LogfileOpenInfo)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void LogfileOpenInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  filename_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void LogfileOpenInfo::ArenaDtor(void* object) {
  LogfileOpenInfo* _this = reinterpret_cast< LogfileOpenInfo* >(object);
  (void)_this;
}
void LogfileOpenInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LogfileOpenInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const LogfileOpenInfo& LogfileOpenInfo::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_LogfileOpenInfo_status_2eproto.base);
  return *internal_default_instance();
}


void LogfileOpenInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:amun.LogfileOpenInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    filename_.ClearNonDefaultToEmpty();
  }
  success_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LogfileOpenInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bool success = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_success(&has_bits);
          success_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string filename = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_filename();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "amun.LogfileOpenInfo.filename");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* LogfileOpenInfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:amun.LogfileOpenInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bool success = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_success(), target);
  }

  // required string filename = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_filename().data(), static_cast<int>(this->_internal_filename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "amun.LogfileOpenInfo.filename");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_filename(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:amun.LogfileOpenInfo)
  return target;
}

size_t LogfileOpenInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:amun.LogfileOpenInfo)
  size_t total_size = 0;

  if (_internal_has_filename()) {
    // required string filename = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_filename());
  }

  if (_internal_has_success()) {
    // required bool success = 1;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t LogfileOpenInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:amun.LogfileOpenInfo)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string filename = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_filename());

    // required bool success = 1;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LogfileOpenInfo::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:amun.LogfileOpenInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const LogfileOpenInfo* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<LogfileOpenInfo>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:amun.LogfileOpenInfo)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:amun.LogfileOpenInfo)
    MergeFrom(*source);
  }
}

void LogfileOpenInfo::MergeFrom(const LogfileOpenInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:amun.LogfileOpenInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_filename(from._internal_filename());
    }
    if (cached_has_bits & 0x00000002u) {
      success_ = from.success_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void LogfileOpenInfo::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:amun.LogfileOpenInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LogfileOpenInfo::CopyFrom(const LogfileOpenInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:amun.LogfileOpenInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LogfileOpenInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void LogfileOpenInfo::InternalSwap(LogfileOpenInfo* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  filename_.Swap(&other->filename_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(success_, other->success_);
}

::PROTOBUF_NAMESPACE_ID::Metadata LogfileOpenInfo::GetMetadata() const {
  return GetMetadataStatic();
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace amun
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::amun::StrategyOption* Arena::CreateMaybeMessage< ::amun::StrategyOption >(Arena* arena) {
  return Arena::CreateMessageInternal< ::amun::StrategyOption >(arena);
}
template<> PROTOBUF_NOINLINE ::amun::StatusStrategy* Arena::CreateMaybeMessage< ::amun::StatusStrategy >(Arena* arena) {
  return Arena::CreateMessageInternal< ::amun::StatusStrategy >(arena);
}
template<> PROTOBUF_NOINLINE ::amun::GitInfo* Arena::CreateMaybeMessage< ::amun::GitInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::amun::GitInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::amun::StatusStrategyWrapper* Arena::CreateMaybeMessage< ::amun::StatusStrategyWrapper >(Arena* arena) {
  return Arena::CreateMessageInternal< ::amun::StatusStrategyWrapper >(arena);
}
template<> PROTOBUF_NOINLINE ::amun::Timing* Arena::CreateMaybeMessage< ::amun::Timing >(Arena* arena) {
  return Arena::CreateMessageInternal< ::amun::Timing >(arena);
}
template<> PROTOBUF_NOINLINE ::amun::StatusTransceiver* Arena::CreateMaybeMessage< ::amun::StatusTransceiver >(Arena* arena) {
  return Arena::CreateMessageInternal< ::amun::StatusTransceiver >(arena);
}
template<> PROTOBUF_NOINLINE ::amun::PortBindError* Arena::CreateMaybeMessage< ::amun::PortBindError >(Arena* arena) {
  return Arena::CreateMessageInternal< ::amun::PortBindError >(arena);
}
template<> PROTOBUF_NOINLINE ::amun::OptionStatus* Arena::CreateMaybeMessage< ::amun::OptionStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::amun::OptionStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::amun::StatusGameController* Arena::CreateMaybeMessage< ::amun::StatusGameController >(Arena* arena) {
  return Arena::CreateMessageInternal< ::amun::StatusGameController >(arena);
}
template<> PROTOBUF_NOINLINE ::amun::StatusAmun* Arena::CreateMaybeMessage< ::amun::StatusAmun >(Arena* arena) {
  return Arena::CreateMessageInternal< ::amun::StatusAmun >(arena);
}
template<> PROTOBUF_NOINLINE ::amun::Status* Arena::CreateMaybeMessage< ::amun::Status >(Arena* arena) {
  return Arena::CreateMessageInternal< ::amun::Status >(arena);
}
template<> PROTOBUF_NOINLINE ::amun::UiResponse* Arena::CreateMaybeMessage< ::amun::UiResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::amun::UiResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::amun::LoggingInfo* Arena::CreateMaybeMessage< ::amun::LoggingInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::amun::LoggingInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::amun::LogPlaybackInfo* Arena::CreateMaybeMessage< ::amun::LogPlaybackInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::amun::LogPlaybackInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::amun::LogfileOpenInfo* Arena::CreateMaybeMessage< ::amun::LogfileOpenInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::amun::LogfileOpenInfo >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
