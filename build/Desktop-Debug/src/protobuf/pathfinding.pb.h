// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pathfinding.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_pathfinding_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_pathfinding_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_pathfinding_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_pathfinding_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[17]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_pathfinding_2eproto;
namespace pathfinding {
class CircleObstacle;
class CircleObstacleDefaultTypeInternal;
extern CircleObstacleDefaultTypeInternal _CircleObstacle_default_instance_;
class FriendlyRobotObstacle;
class FriendlyRobotObstacleDefaultTypeInternal;
extern FriendlyRobotObstacleDefaultTypeInternal _FriendlyRobotObstacle_default_instance_;
class LineObstacle;
class LineObstacleDefaultTypeInternal;
extern LineObstacleDefaultTypeInternal _LineObstacle_default_instance_;
class MovingCircleObstacle;
class MovingCircleObstacleDefaultTypeInternal;
extern MovingCircleObstacleDefaultTypeInternal _MovingCircleObstacle_default_instance_;
class MovingLineObstacle;
class MovingLineObstacleDefaultTypeInternal;
extern MovingLineObstacleDefaultTypeInternal _MovingLineObstacle_default_instance_;
class Obstacle;
class ObstacleDefaultTypeInternal;
extern ObstacleDefaultTypeInternal _Obstacle_default_instance_;
class OpponentRobotObstacle;
class OpponentRobotObstacleDefaultTypeInternal;
extern OpponentRobotObstacleDefaultTypeInternal _OpponentRobotObstacle_default_instance_;
class PathFindingTask;
class PathFindingTaskDefaultTypeInternal;
extern PathFindingTaskDefaultTypeInternal _PathFindingTask_default_instance_;
class RectObstacle;
class RectObstacleDefaultTypeInternal;
extern RectObstacleDefaultTypeInternal _RectObstacle_default_instance_;
class StandardSamplerPoint;
class StandardSamplerPointDefaultTypeInternal;
extern StandardSamplerPointDefaultTypeInternal _StandardSamplerPoint_default_instance_;
class StandardSamplerPrecomputation;
class StandardSamplerPrecomputationDefaultTypeInternal;
extern StandardSamplerPrecomputationDefaultTypeInternal _StandardSamplerPrecomputation_default_instance_;
class StandardSamplerPrecomputationSegment;
class StandardSamplerPrecomputationSegmentDefaultTypeInternal;
extern StandardSamplerPrecomputationSegmentDefaultTypeInternal _StandardSamplerPrecomputationSegment_default_instance_;
class TrajectoryInput;
class TrajectoryInputDefaultTypeInternal;
extern TrajectoryInputDefaultTypeInternal _TrajectoryInput_default_instance_;
class TrajectoryPoint;
class TrajectoryPointDefaultTypeInternal;
extern TrajectoryPointDefaultTypeInternal _TrajectoryPoint_default_instance_;
class TriangleObstacle;
class TriangleObstacleDefaultTypeInternal;
extern TriangleObstacleDefaultTypeInternal _TriangleObstacle_default_instance_;
class Vector;
class VectorDefaultTypeInternal;
extern VectorDefaultTypeInternal _Vector_default_instance_;
class WorldState;
class WorldStateDefaultTypeInternal;
extern WorldStateDefaultTypeInternal _WorldState_default_instance_;
}  // namespace pathfinding
PROTOBUF_NAMESPACE_OPEN
template<> ::pathfinding::CircleObstacle* Arena::CreateMaybeMessage<::pathfinding::CircleObstacle>(Arena*);
template<> ::pathfinding::FriendlyRobotObstacle* Arena::CreateMaybeMessage<::pathfinding::FriendlyRobotObstacle>(Arena*);
template<> ::pathfinding::LineObstacle* Arena::CreateMaybeMessage<::pathfinding::LineObstacle>(Arena*);
template<> ::pathfinding::MovingCircleObstacle* Arena::CreateMaybeMessage<::pathfinding::MovingCircleObstacle>(Arena*);
template<> ::pathfinding::MovingLineObstacle* Arena::CreateMaybeMessage<::pathfinding::MovingLineObstacle>(Arena*);
template<> ::pathfinding::Obstacle* Arena::CreateMaybeMessage<::pathfinding::Obstacle>(Arena*);
template<> ::pathfinding::OpponentRobotObstacle* Arena::CreateMaybeMessage<::pathfinding::OpponentRobotObstacle>(Arena*);
template<> ::pathfinding::PathFindingTask* Arena::CreateMaybeMessage<::pathfinding::PathFindingTask>(Arena*);
template<> ::pathfinding::RectObstacle* Arena::CreateMaybeMessage<::pathfinding::RectObstacle>(Arena*);
template<> ::pathfinding::StandardSamplerPoint* Arena::CreateMaybeMessage<::pathfinding::StandardSamplerPoint>(Arena*);
template<> ::pathfinding::StandardSamplerPrecomputation* Arena::CreateMaybeMessage<::pathfinding::StandardSamplerPrecomputation>(Arena*);
template<> ::pathfinding::StandardSamplerPrecomputationSegment* Arena::CreateMaybeMessage<::pathfinding::StandardSamplerPrecomputationSegment>(Arena*);
template<> ::pathfinding::TrajectoryInput* Arena::CreateMaybeMessage<::pathfinding::TrajectoryInput>(Arena*);
template<> ::pathfinding::TrajectoryPoint* Arena::CreateMaybeMessage<::pathfinding::TrajectoryPoint>(Arena*);
template<> ::pathfinding::TriangleObstacle* Arena::CreateMaybeMessage<::pathfinding::TriangleObstacle>(Arena*);
template<> ::pathfinding::Vector* Arena::CreateMaybeMessage<::pathfinding::Vector>(Arena*);
template<> ::pathfinding::WorldState* Arena::CreateMaybeMessage<::pathfinding::WorldState>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace pathfinding {

enum InputSourceType : int {
  None = 0,
  AllSamplers = 1,
  StandardSampler = 2,
  EndInObstacleSampler = 3,
  EscapeObstacleSampler = 4
};
bool InputSourceType_IsValid(int value);
constexpr InputSourceType InputSourceType_MIN = None;
constexpr InputSourceType InputSourceType_MAX = EscapeObstacleSampler;
constexpr int InputSourceType_ARRAYSIZE = InputSourceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* InputSourceType_descriptor();
template<typename T>
inline const std::string& InputSourceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, InputSourceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function InputSourceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    InputSourceType_descriptor(), enum_t_value);
}
inline bool InputSourceType_Parse(
    const std::string& name, InputSourceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<InputSourceType>(
    InputSourceType_descriptor(), name, value);
}
// ===================================================================

class Vector PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pathfinding.Vector) */ {
 public:
  inline Vector() : Vector(nullptr) {};
  virtual ~Vector();

  Vector(const Vector& from);
  Vector(Vector&& from) noexcept
    : Vector() {
    *this = ::std::move(from);
  }

  inline Vector& operator=(const Vector& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector& operator=(Vector&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Vector& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vector* internal_default_instance() {
    return reinterpret_cast<const Vector*>(
               &_Vector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Vector& a, Vector& b) {
    a.Swap(&b);
  }
  inline void Swap(Vector* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vector* New() const final {
    return CreateMaybeMessage<Vector>(nullptr);
  }

  Vector* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vector>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Vector& from);
  void MergeFrom(const Vector& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pathfinding.Vector";
  }
  protected:
  explicit Vector(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pathfinding_2eproto);
    return ::descriptor_table_pathfinding_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // optional float x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // optional float y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // @@protoc_insertion_point(class_scope:pathfinding.Vector)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float x_;
  float y_;
  friend struct ::TableStruct_pathfinding_2eproto;
};
// -------------------------------------------------------------------

class CircleObstacle PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pathfinding.CircleObstacle) */ {
 public:
  inline CircleObstacle() : CircleObstacle(nullptr) {};
  virtual ~CircleObstacle();

  CircleObstacle(const CircleObstacle& from);
  CircleObstacle(CircleObstacle&& from) noexcept
    : CircleObstacle() {
    *this = ::std::move(from);
  }

  inline CircleObstacle& operator=(const CircleObstacle& from) {
    CopyFrom(from);
    return *this;
  }
  inline CircleObstacle& operator=(CircleObstacle&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CircleObstacle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CircleObstacle* internal_default_instance() {
    return reinterpret_cast<const CircleObstacle*>(
               &_CircleObstacle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CircleObstacle& a, CircleObstacle& b) {
    a.Swap(&b);
  }
  inline void Swap(CircleObstacle* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CircleObstacle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CircleObstacle* New() const final {
    return CreateMaybeMessage<CircleObstacle>(nullptr);
  }

  CircleObstacle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CircleObstacle>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CircleObstacle& from);
  void MergeFrom(const CircleObstacle& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CircleObstacle* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pathfinding.CircleObstacle";
  }
  protected:
  explicit CircleObstacle(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pathfinding_2eproto);
    return ::descriptor_table_pathfinding_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCenterFieldNumber = 1,
  };
  // optional .pathfinding.Vector center = 1;
  bool has_center() const;
  private:
  bool _internal_has_center() const;
  public:
  void clear_center();
  const ::pathfinding::Vector& center() const;
  ::pathfinding::Vector* release_center();
  ::pathfinding::Vector* mutable_center();
  void set_allocated_center(::pathfinding::Vector* center);
  private:
  const ::pathfinding::Vector& _internal_center() const;
  ::pathfinding::Vector* _internal_mutable_center();
  public:
  void unsafe_arena_set_allocated_center(
      ::pathfinding::Vector* center);
  ::pathfinding::Vector* unsafe_arena_release_center();

  // @@protoc_insertion_point(class_scope:pathfinding.CircleObstacle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::pathfinding::Vector* center_;
  friend struct ::TableStruct_pathfinding_2eproto;
};
// -------------------------------------------------------------------

class RectObstacle PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pathfinding.RectObstacle) */ {
 public:
  inline RectObstacle() : RectObstacle(nullptr) {};
  virtual ~RectObstacle();

  RectObstacle(const RectObstacle& from);
  RectObstacle(RectObstacle&& from) noexcept
    : RectObstacle() {
    *this = ::std::move(from);
  }

  inline RectObstacle& operator=(const RectObstacle& from) {
    CopyFrom(from);
    return *this;
  }
  inline RectObstacle& operator=(RectObstacle&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RectObstacle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RectObstacle* internal_default_instance() {
    return reinterpret_cast<const RectObstacle*>(
               &_RectObstacle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RectObstacle& a, RectObstacle& b) {
    a.Swap(&b);
  }
  inline void Swap(RectObstacle* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RectObstacle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RectObstacle* New() const final {
    return CreateMaybeMessage<RectObstacle>(nullptr);
  }

  RectObstacle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RectObstacle>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RectObstacle& from);
  void MergeFrom(const RectObstacle& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RectObstacle* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pathfinding.RectObstacle";
  }
  protected:
  explicit RectObstacle(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pathfinding_2eproto);
    return ::descriptor_table_pathfinding_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBottomLeftFieldNumber = 1,
    kTopRightFieldNumber = 2,
  };
  // optional .pathfinding.Vector bottom_left = 1;
  bool has_bottom_left() const;
  private:
  bool _internal_has_bottom_left() const;
  public:
  void clear_bottom_left();
  const ::pathfinding::Vector& bottom_left() const;
  ::pathfinding::Vector* release_bottom_left();
  ::pathfinding::Vector* mutable_bottom_left();
  void set_allocated_bottom_left(::pathfinding::Vector* bottom_left);
  private:
  const ::pathfinding::Vector& _internal_bottom_left() const;
  ::pathfinding::Vector* _internal_mutable_bottom_left();
  public:
  void unsafe_arena_set_allocated_bottom_left(
      ::pathfinding::Vector* bottom_left);
  ::pathfinding::Vector* unsafe_arena_release_bottom_left();

  // optional .pathfinding.Vector top_right = 2;
  bool has_top_right() const;
  private:
  bool _internal_has_top_right() const;
  public:
  void clear_top_right();
  const ::pathfinding::Vector& top_right() const;
  ::pathfinding::Vector* release_top_right();
  ::pathfinding::Vector* mutable_top_right();
  void set_allocated_top_right(::pathfinding::Vector* top_right);
  private:
  const ::pathfinding::Vector& _internal_top_right() const;
  ::pathfinding::Vector* _internal_mutable_top_right();
  public:
  void unsafe_arena_set_allocated_top_right(
      ::pathfinding::Vector* top_right);
  ::pathfinding::Vector* unsafe_arena_release_top_right();

  // @@protoc_insertion_point(class_scope:pathfinding.RectObstacle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::pathfinding::Vector* bottom_left_;
  ::pathfinding::Vector* top_right_;
  friend struct ::TableStruct_pathfinding_2eproto;
};
// -------------------------------------------------------------------

class TriangleObstacle PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pathfinding.TriangleObstacle) */ {
 public:
  inline TriangleObstacle() : TriangleObstacle(nullptr) {};
  virtual ~TriangleObstacle();

  TriangleObstacle(const TriangleObstacle& from);
  TriangleObstacle(TriangleObstacle&& from) noexcept
    : TriangleObstacle() {
    *this = ::std::move(from);
  }

  inline TriangleObstacle& operator=(const TriangleObstacle& from) {
    CopyFrom(from);
    return *this;
  }
  inline TriangleObstacle& operator=(TriangleObstacle&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TriangleObstacle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TriangleObstacle* internal_default_instance() {
    return reinterpret_cast<const TriangleObstacle*>(
               &_TriangleObstacle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TriangleObstacle& a, TriangleObstacle& b) {
    a.Swap(&b);
  }
  inline void Swap(TriangleObstacle* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TriangleObstacle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TriangleObstacle* New() const final {
    return CreateMaybeMessage<TriangleObstacle>(nullptr);
  }

  TriangleObstacle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TriangleObstacle>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TriangleObstacle& from);
  void MergeFrom(const TriangleObstacle& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TriangleObstacle* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pathfinding.TriangleObstacle";
  }
  protected:
  explicit TriangleObstacle(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pathfinding_2eproto);
    return ::descriptor_table_pathfinding_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kP1FieldNumber = 1,
    kP2FieldNumber = 2,
    kP3FieldNumber = 3,
  };
  // optional .pathfinding.Vector p1 = 1;
  bool has_p1() const;
  private:
  bool _internal_has_p1() const;
  public:
  void clear_p1();
  const ::pathfinding::Vector& p1() const;
  ::pathfinding::Vector* release_p1();
  ::pathfinding::Vector* mutable_p1();
  void set_allocated_p1(::pathfinding::Vector* p1);
  private:
  const ::pathfinding::Vector& _internal_p1() const;
  ::pathfinding::Vector* _internal_mutable_p1();
  public:
  void unsafe_arena_set_allocated_p1(
      ::pathfinding::Vector* p1);
  ::pathfinding::Vector* unsafe_arena_release_p1();

  // optional .pathfinding.Vector p2 = 2;
  bool has_p2() const;
  private:
  bool _internal_has_p2() const;
  public:
  void clear_p2();
  const ::pathfinding::Vector& p2() const;
  ::pathfinding::Vector* release_p2();
  ::pathfinding::Vector* mutable_p2();
  void set_allocated_p2(::pathfinding::Vector* p2);
  private:
  const ::pathfinding::Vector& _internal_p2() const;
  ::pathfinding::Vector* _internal_mutable_p2();
  public:
  void unsafe_arena_set_allocated_p2(
      ::pathfinding::Vector* p2);
  ::pathfinding::Vector* unsafe_arena_release_p2();

  // optional .pathfinding.Vector p3 = 3;
  bool has_p3() const;
  private:
  bool _internal_has_p3() const;
  public:
  void clear_p3();
  const ::pathfinding::Vector& p3() const;
  ::pathfinding::Vector* release_p3();
  ::pathfinding::Vector* mutable_p3();
  void set_allocated_p3(::pathfinding::Vector* p3);
  private:
  const ::pathfinding::Vector& _internal_p3() const;
  ::pathfinding::Vector* _internal_mutable_p3();
  public:
  void unsafe_arena_set_allocated_p3(
      ::pathfinding::Vector* p3);
  ::pathfinding::Vector* unsafe_arena_release_p3();

  // @@protoc_insertion_point(class_scope:pathfinding.TriangleObstacle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::pathfinding::Vector* p1_;
  ::pathfinding::Vector* p2_;
  ::pathfinding::Vector* p3_;
  friend struct ::TableStruct_pathfinding_2eproto;
};
// -------------------------------------------------------------------

class LineObstacle PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pathfinding.LineObstacle) */ {
 public:
  inline LineObstacle() : LineObstacle(nullptr) {};
  virtual ~LineObstacle();

  LineObstacle(const LineObstacle& from);
  LineObstacle(LineObstacle&& from) noexcept
    : LineObstacle() {
    *this = ::std::move(from);
  }

  inline LineObstacle& operator=(const LineObstacle& from) {
    CopyFrom(from);
    return *this;
  }
  inline LineObstacle& operator=(LineObstacle&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LineObstacle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LineObstacle* internal_default_instance() {
    return reinterpret_cast<const LineObstacle*>(
               &_LineObstacle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LineObstacle& a, LineObstacle& b) {
    a.Swap(&b);
  }
  inline void Swap(LineObstacle* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LineObstacle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LineObstacle* New() const final {
    return CreateMaybeMessage<LineObstacle>(nullptr);
  }

  LineObstacle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LineObstacle>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LineObstacle& from);
  void MergeFrom(const LineObstacle& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LineObstacle* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pathfinding.LineObstacle";
  }
  protected:
  explicit LineObstacle(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pathfinding_2eproto);
    return ::descriptor_table_pathfinding_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartFieldNumber = 1,
    kEndFieldNumber = 2,
  };
  // optional .pathfinding.Vector start = 1;
  bool has_start() const;
  private:
  bool _internal_has_start() const;
  public:
  void clear_start();
  const ::pathfinding::Vector& start() const;
  ::pathfinding::Vector* release_start();
  ::pathfinding::Vector* mutable_start();
  void set_allocated_start(::pathfinding::Vector* start);
  private:
  const ::pathfinding::Vector& _internal_start() const;
  ::pathfinding::Vector* _internal_mutable_start();
  public:
  void unsafe_arena_set_allocated_start(
      ::pathfinding::Vector* start);
  ::pathfinding::Vector* unsafe_arena_release_start();

  // optional .pathfinding.Vector end = 2;
  bool has_end() const;
  private:
  bool _internal_has_end() const;
  public:
  void clear_end();
  const ::pathfinding::Vector& end() const;
  ::pathfinding::Vector* release_end();
  ::pathfinding::Vector* mutable_end();
  void set_allocated_end(::pathfinding::Vector* end);
  private:
  const ::pathfinding::Vector& _internal_end() const;
  ::pathfinding::Vector* _internal_mutable_end();
  public:
  void unsafe_arena_set_allocated_end(
      ::pathfinding::Vector* end);
  ::pathfinding::Vector* unsafe_arena_release_end();

  // @@protoc_insertion_point(class_scope:pathfinding.LineObstacle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::pathfinding::Vector* start_;
  ::pathfinding::Vector* end_;
  friend struct ::TableStruct_pathfinding_2eproto;
};
// -------------------------------------------------------------------

class MovingCircleObstacle PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pathfinding.MovingCircleObstacle) */ {
 public:
  inline MovingCircleObstacle() : MovingCircleObstacle(nullptr) {};
  virtual ~MovingCircleObstacle();

  MovingCircleObstacle(const MovingCircleObstacle& from);
  MovingCircleObstacle(MovingCircleObstacle&& from) noexcept
    : MovingCircleObstacle() {
    *this = ::std::move(from);
  }

  inline MovingCircleObstacle& operator=(const MovingCircleObstacle& from) {
    CopyFrom(from);
    return *this;
  }
  inline MovingCircleObstacle& operator=(MovingCircleObstacle&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MovingCircleObstacle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MovingCircleObstacle* internal_default_instance() {
    return reinterpret_cast<const MovingCircleObstacle*>(
               &_MovingCircleObstacle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MovingCircleObstacle& a, MovingCircleObstacle& b) {
    a.Swap(&b);
  }
  inline void Swap(MovingCircleObstacle* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MovingCircleObstacle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MovingCircleObstacle* New() const final {
    return CreateMaybeMessage<MovingCircleObstacle>(nullptr);
  }

  MovingCircleObstacle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MovingCircleObstacle>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MovingCircleObstacle& from);
  void MergeFrom(const MovingCircleObstacle& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MovingCircleObstacle* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pathfinding.MovingCircleObstacle";
  }
  protected:
  explicit MovingCircleObstacle(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pathfinding_2eproto);
    return ::descriptor_table_pathfinding_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartPosFieldNumber = 1,
    kSpeedFieldNumber = 2,
    kAccFieldNumber = 3,
    kStartTimeFieldNumber = 4,
    kEndTimeFieldNumber = 5,
  };
  // optional .pathfinding.Vector start_pos = 1;
  bool has_start_pos() const;
  private:
  bool _internal_has_start_pos() const;
  public:
  void clear_start_pos();
  const ::pathfinding::Vector& start_pos() const;
  ::pathfinding::Vector* release_start_pos();
  ::pathfinding::Vector* mutable_start_pos();
  void set_allocated_start_pos(::pathfinding::Vector* start_pos);
  private:
  const ::pathfinding::Vector& _internal_start_pos() const;
  ::pathfinding::Vector* _internal_mutable_start_pos();
  public:
  void unsafe_arena_set_allocated_start_pos(
      ::pathfinding::Vector* start_pos);
  ::pathfinding::Vector* unsafe_arena_release_start_pos();

  // optional .pathfinding.Vector speed = 2;
  bool has_speed() const;
  private:
  bool _internal_has_speed() const;
  public:
  void clear_speed();
  const ::pathfinding::Vector& speed() const;
  ::pathfinding::Vector* release_speed();
  ::pathfinding::Vector* mutable_speed();
  void set_allocated_speed(::pathfinding::Vector* speed);
  private:
  const ::pathfinding::Vector& _internal_speed() const;
  ::pathfinding::Vector* _internal_mutable_speed();
  public:
  void unsafe_arena_set_allocated_speed(
      ::pathfinding::Vector* speed);
  ::pathfinding::Vector* unsafe_arena_release_speed();

  // optional .pathfinding.Vector acc = 3;
  bool has_acc() const;
  private:
  bool _internal_has_acc() const;
  public:
  void clear_acc();
  const ::pathfinding::Vector& acc() const;
  ::pathfinding::Vector* release_acc();
  ::pathfinding::Vector* mutable_acc();
  void set_allocated_acc(::pathfinding::Vector* acc);
  private:
  const ::pathfinding::Vector& _internal_acc() const;
  ::pathfinding::Vector* _internal_mutable_acc();
  public:
  void unsafe_arena_set_allocated_acc(
      ::pathfinding::Vector* acc);
  ::pathfinding::Vector* unsafe_arena_release_acc();

  // optional float start_time = 4;
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  float start_time() const;
  void set_start_time(float value);
  private:
  float _internal_start_time() const;
  void _internal_set_start_time(float value);
  public:

  // optional float end_time = 5;
  bool has_end_time() const;
  private:
  bool _internal_has_end_time() const;
  public:
  void clear_end_time();
  float end_time() const;
  void set_end_time(float value);
  private:
  float _internal_end_time() const;
  void _internal_set_end_time(float value);
  public:

  // @@protoc_insertion_point(class_scope:pathfinding.MovingCircleObstacle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::pathfinding::Vector* start_pos_;
  ::pathfinding::Vector* speed_;
  ::pathfinding::Vector* acc_;
  float start_time_;
  float end_time_;
  friend struct ::TableStruct_pathfinding_2eproto;
};
// -------------------------------------------------------------------

class MovingLineObstacle PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pathfinding.MovingLineObstacle) */ {
 public:
  inline MovingLineObstacle() : MovingLineObstacle(nullptr) {};
  virtual ~MovingLineObstacle();

  MovingLineObstacle(const MovingLineObstacle& from);
  MovingLineObstacle(MovingLineObstacle&& from) noexcept
    : MovingLineObstacle() {
    *this = ::std::move(from);
  }

  inline MovingLineObstacle& operator=(const MovingLineObstacle& from) {
    CopyFrom(from);
    return *this;
  }
  inline MovingLineObstacle& operator=(MovingLineObstacle&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MovingLineObstacle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MovingLineObstacle* internal_default_instance() {
    return reinterpret_cast<const MovingLineObstacle*>(
               &_MovingLineObstacle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(MovingLineObstacle& a, MovingLineObstacle& b) {
    a.Swap(&b);
  }
  inline void Swap(MovingLineObstacle* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MovingLineObstacle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MovingLineObstacle* New() const final {
    return CreateMaybeMessage<MovingLineObstacle>(nullptr);
  }

  MovingLineObstacle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MovingLineObstacle>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MovingLineObstacle& from);
  void MergeFrom(const MovingLineObstacle& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MovingLineObstacle* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pathfinding.MovingLineObstacle";
  }
  protected:
  explicit MovingLineObstacle(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pathfinding_2eproto);
    return ::descriptor_table_pathfinding_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartPos1FieldNumber = 1,
    kSpeed1FieldNumber = 2,
    kAcc1FieldNumber = 3,
    kStartPos2FieldNumber = 4,
    kSpeed2FieldNumber = 5,
    kAcc2FieldNumber = 6,
    kStartTimeFieldNumber = 7,
    kEndTimeFieldNumber = 8,
  };
  // optional .pathfinding.Vector start_pos1 = 1;
  bool has_start_pos1() const;
  private:
  bool _internal_has_start_pos1() const;
  public:
  void clear_start_pos1();
  const ::pathfinding::Vector& start_pos1() const;
  ::pathfinding::Vector* release_start_pos1();
  ::pathfinding::Vector* mutable_start_pos1();
  void set_allocated_start_pos1(::pathfinding::Vector* start_pos1);
  private:
  const ::pathfinding::Vector& _internal_start_pos1() const;
  ::pathfinding::Vector* _internal_mutable_start_pos1();
  public:
  void unsafe_arena_set_allocated_start_pos1(
      ::pathfinding::Vector* start_pos1);
  ::pathfinding::Vector* unsafe_arena_release_start_pos1();

  // optional .pathfinding.Vector speed1 = 2;
  bool has_speed1() const;
  private:
  bool _internal_has_speed1() const;
  public:
  void clear_speed1();
  const ::pathfinding::Vector& speed1() const;
  ::pathfinding::Vector* release_speed1();
  ::pathfinding::Vector* mutable_speed1();
  void set_allocated_speed1(::pathfinding::Vector* speed1);
  private:
  const ::pathfinding::Vector& _internal_speed1() const;
  ::pathfinding::Vector* _internal_mutable_speed1();
  public:
  void unsafe_arena_set_allocated_speed1(
      ::pathfinding::Vector* speed1);
  ::pathfinding::Vector* unsafe_arena_release_speed1();

  // optional .pathfinding.Vector acc1 = 3;
  bool has_acc1() const;
  private:
  bool _internal_has_acc1() const;
  public:
  void clear_acc1();
  const ::pathfinding::Vector& acc1() const;
  ::pathfinding::Vector* release_acc1();
  ::pathfinding::Vector* mutable_acc1();
  void set_allocated_acc1(::pathfinding::Vector* acc1);
  private:
  const ::pathfinding::Vector& _internal_acc1() const;
  ::pathfinding::Vector* _internal_mutable_acc1();
  public:
  void unsafe_arena_set_allocated_acc1(
      ::pathfinding::Vector* acc1);
  ::pathfinding::Vector* unsafe_arena_release_acc1();

  // optional .pathfinding.Vector start_pos2 = 4;
  bool has_start_pos2() const;
  private:
  bool _internal_has_start_pos2() const;
  public:
  void clear_start_pos2();
  const ::pathfinding::Vector& start_pos2() const;
  ::pathfinding::Vector* release_start_pos2();
  ::pathfinding::Vector* mutable_start_pos2();
  void set_allocated_start_pos2(::pathfinding::Vector* start_pos2);
  private:
  const ::pathfinding::Vector& _internal_start_pos2() const;
  ::pathfinding::Vector* _internal_mutable_start_pos2();
  public:
  void unsafe_arena_set_allocated_start_pos2(
      ::pathfinding::Vector* start_pos2);
  ::pathfinding::Vector* unsafe_arena_release_start_pos2();

  // optional .pathfinding.Vector speed2 = 5;
  bool has_speed2() const;
  private:
  bool _internal_has_speed2() const;
  public:
  void clear_speed2();
  const ::pathfinding::Vector& speed2() const;
  ::pathfinding::Vector* release_speed2();
  ::pathfinding::Vector* mutable_speed2();
  void set_allocated_speed2(::pathfinding::Vector* speed2);
  private:
  const ::pathfinding::Vector& _internal_speed2() const;
  ::pathfinding::Vector* _internal_mutable_speed2();
  public:
  void unsafe_arena_set_allocated_speed2(
      ::pathfinding::Vector* speed2);
  ::pathfinding::Vector* unsafe_arena_release_speed2();

  // optional .pathfinding.Vector acc2 = 6;
  bool has_acc2() const;
  private:
  bool _internal_has_acc2() const;
  public:
  void clear_acc2();
  const ::pathfinding::Vector& acc2() const;
  ::pathfinding::Vector* release_acc2();
  ::pathfinding::Vector* mutable_acc2();
  void set_allocated_acc2(::pathfinding::Vector* acc2);
  private:
  const ::pathfinding::Vector& _internal_acc2() const;
  ::pathfinding::Vector* _internal_mutable_acc2();
  public:
  void unsafe_arena_set_allocated_acc2(
      ::pathfinding::Vector* acc2);
  ::pathfinding::Vector* unsafe_arena_release_acc2();

  // optional float start_time = 7;
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  float start_time() const;
  void set_start_time(float value);
  private:
  float _internal_start_time() const;
  void _internal_set_start_time(float value);
  public:

  // optional float end_time = 8;
  bool has_end_time() const;
  private:
  bool _internal_has_end_time() const;
  public:
  void clear_end_time();
  float end_time() const;
  void set_end_time(float value);
  private:
  float _internal_end_time() const;
  void _internal_set_end_time(float value);
  public:

  // @@protoc_insertion_point(class_scope:pathfinding.MovingLineObstacle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::pathfinding::Vector* start_pos1_;
  ::pathfinding::Vector* speed1_;
  ::pathfinding::Vector* acc1_;
  ::pathfinding::Vector* start_pos2_;
  ::pathfinding::Vector* speed2_;
  ::pathfinding::Vector* acc2_;
  float start_time_;
  float end_time_;
  friend struct ::TableStruct_pathfinding_2eproto;
};
// -------------------------------------------------------------------

class TrajectoryPoint PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pathfinding.TrajectoryPoint) */ {
 public:
  inline TrajectoryPoint() : TrajectoryPoint(nullptr) {};
  virtual ~TrajectoryPoint();

  TrajectoryPoint(const TrajectoryPoint& from);
  TrajectoryPoint(TrajectoryPoint&& from) noexcept
    : TrajectoryPoint() {
    *this = ::std::move(from);
  }

  inline TrajectoryPoint& operator=(const TrajectoryPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrajectoryPoint& operator=(TrajectoryPoint&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TrajectoryPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrajectoryPoint* internal_default_instance() {
    return reinterpret_cast<const TrajectoryPoint*>(
               &_TrajectoryPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TrajectoryPoint& a, TrajectoryPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(TrajectoryPoint* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrajectoryPoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TrajectoryPoint* New() const final {
    return CreateMaybeMessage<TrajectoryPoint>(nullptr);
  }

  TrajectoryPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TrajectoryPoint>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TrajectoryPoint& from);
  void MergeFrom(const TrajectoryPoint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrajectoryPoint* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pathfinding.TrajectoryPoint";
  }
  protected:
  explicit TrajectoryPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pathfinding_2eproto);
    return ::descriptor_table_pathfinding_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosFieldNumber = 1,
    kSpeedFieldNumber = 2,
    kTimeFieldNumber = 3,
  };
  // optional .pathfinding.Vector pos = 1;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::pathfinding::Vector& pos() const;
  ::pathfinding::Vector* release_pos();
  ::pathfinding::Vector* mutable_pos();
  void set_allocated_pos(::pathfinding::Vector* pos);
  private:
  const ::pathfinding::Vector& _internal_pos() const;
  ::pathfinding::Vector* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::pathfinding::Vector* pos);
  ::pathfinding::Vector* unsafe_arena_release_pos();

  // optional .pathfinding.Vector speed = 2;
  bool has_speed() const;
  private:
  bool _internal_has_speed() const;
  public:
  void clear_speed();
  const ::pathfinding::Vector& speed() const;
  ::pathfinding::Vector* release_speed();
  ::pathfinding::Vector* mutable_speed();
  void set_allocated_speed(::pathfinding::Vector* speed);
  private:
  const ::pathfinding::Vector& _internal_speed() const;
  ::pathfinding::Vector* _internal_mutable_speed();
  public:
  void unsafe_arena_set_allocated_speed(
      ::pathfinding::Vector* speed);
  ::pathfinding::Vector* unsafe_arena_release_speed();

  // optional float time = 3;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  float time() const;
  void set_time(float value);
  private:
  float _internal_time() const;
  void _internal_set_time(float value);
  public:

  // @@protoc_insertion_point(class_scope:pathfinding.TrajectoryPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::pathfinding::Vector* pos_;
  ::pathfinding::Vector* speed_;
  float time_;
  friend struct ::TableStruct_pathfinding_2eproto;
};
// -------------------------------------------------------------------

class FriendlyRobotObstacle PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pathfinding.FriendlyRobotObstacle) */ {
 public:
  inline FriendlyRobotObstacle() : FriendlyRobotObstacle(nullptr) {};
  virtual ~FriendlyRobotObstacle();

  FriendlyRobotObstacle(const FriendlyRobotObstacle& from);
  FriendlyRobotObstacle(FriendlyRobotObstacle&& from) noexcept
    : FriendlyRobotObstacle() {
    *this = ::std::move(from);
  }

  inline FriendlyRobotObstacle& operator=(const FriendlyRobotObstacle& from) {
    CopyFrom(from);
    return *this;
  }
  inline FriendlyRobotObstacle& operator=(FriendlyRobotObstacle&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FriendlyRobotObstacle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FriendlyRobotObstacle* internal_default_instance() {
    return reinterpret_cast<const FriendlyRobotObstacle*>(
               &_FriendlyRobotObstacle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(FriendlyRobotObstacle& a, FriendlyRobotObstacle& b) {
    a.Swap(&b);
  }
  inline void Swap(FriendlyRobotObstacle* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FriendlyRobotObstacle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FriendlyRobotObstacle* New() const final {
    return CreateMaybeMessage<FriendlyRobotObstacle>(nullptr);
  }

  FriendlyRobotObstacle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FriendlyRobotObstacle>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FriendlyRobotObstacle& from);
  void MergeFrom(const FriendlyRobotObstacle& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FriendlyRobotObstacle* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pathfinding.FriendlyRobotObstacle";
  }
  protected:
  explicit FriendlyRobotObstacle(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pathfinding_2eproto);
    return ::descriptor_table_pathfinding_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotTrajectoryFieldNumber = 1,
  };
  // repeated .pathfinding.TrajectoryPoint robot_trajectory = 1;
  int robot_trajectory_size() const;
  private:
  int _internal_robot_trajectory_size() const;
  public:
  void clear_robot_trajectory();
  ::pathfinding::TrajectoryPoint* mutable_robot_trajectory(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pathfinding::TrajectoryPoint >*
      mutable_robot_trajectory();
  private:
  const ::pathfinding::TrajectoryPoint& _internal_robot_trajectory(int index) const;
  ::pathfinding::TrajectoryPoint* _internal_add_robot_trajectory();
  public:
  const ::pathfinding::TrajectoryPoint& robot_trajectory(int index) const;
  ::pathfinding::TrajectoryPoint* add_robot_trajectory();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pathfinding::TrajectoryPoint >&
      robot_trajectory() const;

  // @@protoc_insertion_point(class_scope:pathfinding.FriendlyRobotObstacle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pathfinding::TrajectoryPoint > robot_trajectory_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pathfinding_2eproto;
};
// -------------------------------------------------------------------

class OpponentRobotObstacle PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pathfinding.OpponentRobotObstacle) */ {
 public:
  inline OpponentRobotObstacle() : OpponentRobotObstacle(nullptr) {};
  virtual ~OpponentRobotObstacle();

  OpponentRobotObstacle(const OpponentRobotObstacle& from);
  OpponentRobotObstacle(OpponentRobotObstacle&& from) noexcept
    : OpponentRobotObstacle() {
    *this = ::std::move(from);
  }

  inline OpponentRobotObstacle& operator=(const OpponentRobotObstacle& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpponentRobotObstacle& operator=(OpponentRobotObstacle&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OpponentRobotObstacle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OpponentRobotObstacle* internal_default_instance() {
    return reinterpret_cast<const OpponentRobotObstacle*>(
               &_OpponentRobotObstacle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(OpponentRobotObstacle& a, OpponentRobotObstacle& b) {
    a.Swap(&b);
  }
  inline void Swap(OpponentRobotObstacle* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpponentRobotObstacle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OpponentRobotObstacle* New() const final {
    return CreateMaybeMessage<OpponentRobotObstacle>(nullptr);
  }

  OpponentRobotObstacle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OpponentRobotObstacle>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OpponentRobotObstacle& from);
  void MergeFrom(const OpponentRobotObstacle& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpponentRobotObstacle* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pathfinding.OpponentRobotObstacle";
  }
  protected:
  explicit OpponentRobotObstacle(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pathfinding_2eproto);
    return ::descriptor_table_pathfinding_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartPosFieldNumber = 1,
    kSpeedFieldNumber = 2,
  };
  // optional .pathfinding.Vector start_pos = 1;
  bool has_start_pos() const;
  private:
  bool _internal_has_start_pos() const;
  public:
  void clear_start_pos();
  const ::pathfinding::Vector& start_pos() const;
  ::pathfinding::Vector* release_start_pos();
  ::pathfinding::Vector* mutable_start_pos();
  void set_allocated_start_pos(::pathfinding::Vector* start_pos);
  private:
  const ::pathfinding::Vector& _internal_start_pos() const;
  ::pathfinding::Vector* _internal_mutable_start_pos();
  public:
  void unsafe_arena_set_allocated_start_pos(
      ::pathfinding::Vector* start_pos);
  ::pathfinding::Vector* unsafe_arena_release_start_pos();

  // optional .pathfinding.Vector speed = 2;
  bool has_speed() const;
  private:
  bool _internal_has_speed() const;
  public:
  void clear_speed();
  const ::pathfinding::Vector& speed() const;
  ::pathfinding::Vector* release_speed();
  ::pathfinding::Vector* mutable_speed();
  void set_allocated_speed(::pathfinding::Vector* speed);
  private:
  const ::pathfinding::Vector& _internal_speed() const;
  ::pathfinding::Vector* _internal_mutable_speed();
  public:
  void unsafe_arena_set_allocated_speed(
      ::pathfinding::Vector* speed);
  ::pathfinding::Vector* unsafe_arena_release_speed();

  // @@protoc_insertion_point(class_scope:pathfinding.OpponentRobotObstacle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::pathfinding::Vector* start_pos_;
  ::pathfinding::Vector* speed_;
  friend struct ::TableStruct_pathfinding_2eproto;
};
// -------------------------------------------------------------------

class Obstacle PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pathfinding.Obstacle) */ {
 public:
  inline Obstacle() : Obstacle(nullptr) {};
  virtual ~Obstacle();

  Obstacle(const Obstacle& from);
  Obstacle(Obstacle&& from) noexcept
    : Obstacle() {
    *this = ::std::move(from);
  }

  inline Obstacle& operator=(const Obstacle& from) {
    CopyFrom(from);
    return *this;
  }
  inline Obstacle& operator=(Obstacle&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Obstacle& default_instance();

  enum ObstacleCase {
    kCircle = 4,
    kRectangle = 5,
    kTriangle = 6,
    kLine = 7,
    kMovingCircle = 9,
    kMovingLine = 10,
    kFriendlyRobot = 11,
    kOpponentRobot = 12,
    OBSTACLE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Obstacle* internal_default_instance() {
    return reinterpret_cast<const Obstacle*>(
               &_Obstacle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Obstacle& a, Obstacle& b) {
    a.Swap(&b);
  }
  inline void Swap(Obstacle* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Obstacle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Obstacle* New() const final {
    return CreateMaybeMessage<Obstacle>(nullptr);
  }

  Obstacle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Obstacle>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Obstacle& from);
  void MergeFrom(const Obstacle& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Obstacle* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pathfinding.Obstacle";
  }
  protected:
  explicit Obstacle(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pathfinding_2eproto);
    return ::descriptor_table_pathfinding_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kPrioFieldNumber = 2,
    kRadiusFieldNumber = 3,
    kCircleFieldNumber = 4,
    kRectangleFieldNumber = 5,
    kTriangleFieldNumber = 6,
    kLineFieldNumber = 7,
    kMovingCircleFieldNumber = 9,
    kMovingLineFieldNumber = 10,
    kFriendlyRobotFieldNumber = 11,
    kOpponentRobotFieldNumber = 12,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional int32 prio = 2;
  bool has_prio() const;
  private:
  bool _internal_has_prio() const;
  public:
  void clear_prio();
  ::PROTOBUF_NAMESPACE_ID::int32 prio() const;
  void set_prio(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_prio() const;
  void _internal_set_prio(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional float radius = 3;
  bool has_radius() const;
  private:
  bool _internal_has_radius() const;
  public:
  void clear_radius();
  float radius() const;
  void set_radius(float value);
  private:
  float _internal_radius() const;
  void _internal_set_radius(float value);
  public:

  // .pathfinding.CircleObstacle circle = 4;
  bool has_circle() const;
  private:
  bool _internal_has_circle() const;
  public:
  void clear_circle();
  const ::pathfinding::CircleObstacle& circle() const;
  ::pathfinding::CircleObstacle* release_circle();
  ::pathfinding::CircleObstacle* mutable_circle();
  void set_allocated_circle(::pathfinding::CircleObstacle* circle);
  private:
  const ::pathfinding::CircleObstacle& _internal_circle() const;
  ::pathfinding::CircleObstacle* _internal_mutable_circle();
  public:
  void unsafe_arena_set_allocated_circle(
      ::pathfinding::CircleObstacle* circle);
  ::pathfinding::CircleObstacle* unsafe_arena_release_circle();

  // .pathfinding.RectObstacle rectangle = 5;
  bool has_rectangle() const;
  private:
  bool _internal_has_rectangle() const;
  public:
  void clear_rectangle();
  const ::pathfinding::RectObstacle& rectangle() const;
  ::pathfinding::RectObstacle* release_rectangle();
  ::pathfinding::RectObstacle* mutable_rectangle();
  void set_allocated_rectangle(::pathfinding::RectObstacle* rectangle);
  private:
  const ::pathfinding::RectObstacle& _internal_rectangle() const;
  ::pathfinding::RectObstacle* _internal_mutable_rectangle();
  public:
  void unsafe_arena_set_allocated_rectangle(
      ::pathfinding::RectObstacle* rectangle);
  ::pathfinding::RectObstacle* unsafe_arena_release_rectangle();

  // .pathfinding.TriangleObstacle triangle = 6;
  bool has_triangle() const;
  private:
  bool _internal_has_triangle() const;
  public:
  void clear_triangle();
  const ::pathfinding::TriangleObstacle& triangle() const;
  ::pathfinding::TriangleObstacle* release_triangle();
  ::pathfinding::TriangleObstacle* mutable_triangle();
  void set_allocated_triangle(::pathfinding::TriangleObstacle* triangle);
  private:
  const ::pathfinding::TriangleObstacle& _internal_triangle() const;
  ::pathfinding::TriangleObstacle* _internal_mutable_triangle();
  public:
  void unsafe_arena_set_allocated_triangle(
      ::pathfinding::TriangleObstacle* triangle);
  ::pathfinding::TriangleObstacle* unsafe_arena_release_triangle();

  // .pathfinding.LineObstacle line = 7;
  bool has_line() const;
  private:
  bool _internal_has_line() const;
  public:
  void clear_line();
  const ::pathfinding::LineObstacle& line() const;
  ::pathfinding::LineObstacle* release_line();
  ::pathfinding::LineObstacle* mutable_line();
  void set_allocated_line(::pathfinding::LineObstacle* line);
  private:
  const ::pathfinding::LineObstacle& _internal_line() const;
  ::pathfinding::LineObstacle* _internal_mutable_line();
  public:
  void unsafe_arena_set_allocated_line(
      ::pathfinding::LineObstacle* line);
  ::pathfinding::LineObstacle* unsafe_arena_release_line();

  // .pathfinding.MovingCircleObstacle moving_circle = 9;
  bool has_moving_circle() const;
  private:
  bool _internal_has_moving_circle() const;
  public:
  void clear_moving_circle();
  const ::pathfinding::MovingCircleObstacle& moving_circle() const;
  ::pathfinding::MovingCircleObstacle* release_moving_circle();
  ::pathfinding::MovingCircleObstacle* mutable_moving_circle();
  void set_allocated_moving_circle(::pathfinding::MovingCircleObstacle* moving_circle);
  private:
  const ::pathfinding::MovingCircleObstacle& _internal_moving_circle() const;
  ::pathfinding::MovingCircleObstacle* _internal_mutable_moving_circle();
  public:
  void unsafe_arena_set_allocated_moving_circle(
      ::pathfinding::MovingCircleObstacle* moving_circle);
  ::pathfinding::MovingCircleObstacle* unsafe_arena_release_moving_circle();

  // .pathfinding.MovingLineObstacle moving_line = 10;
  bool has_moving_line() const;
  private:
  bool _internal_has_moving_line() const;
  public:
  void clear_moving_line();
  const ::pathfinding::MovingLineObstacle& moving_line() const;
  ::pathfinding::MovingLineObstacle* release_moving_line();
  ::pathfinding::MovingLineObstacle* mutable_moving_line();
  void set_allocated_moving_line(::pathfinding::MovingLineObstacle* moving_line);
  private:
  const ::pathfinding::MovingLineObstacle& _internal_moving_line() const;
  ::pathfinding::MovingLineObstacle* _internal_mutable_moving_line();
  public:
  void unsafe_arena_set_allocated_moving_line(
      ::pathfinding::MovingLineObstacle* moving_line);
  ::pathfinding::MovingLineObstacle* unsafe_arena_release_moving_line();

  // .pathfinding.FriendlyRobotObstacle friendly_robot = 11;
  bool has_friendly_robot() const;
  private:
  bool _internal_has_friendly_robot() const;
  public:
  void clear_friendly_robot();
  const ::pathfinding::FriendlyRobotObstacle& friendly_robot() const;
  ::pathfinding::FriendlyRobotObstacle* release_friendly_robot();
  ::pathfinding::FriendlyRobotObstacle* mutable_friendly_robot();
  void set_allocated_friendly_robot(::pathfinding::FriendlyRobotObstacle* friendly_robot);
  private:
  const ::pathfinding::FriendlyRobotObstacle& _internal_friendly_robot() const;
  ::pathfinding::FriendlyRobotObstacle* _internal_mutable_friendly_robot();
  public:
  void unsafe_arena_set_allocated_friendly_robot(
      ::pathfinding::FriendlyRobotObstacle* friendly_robot);
  ::pathfinding::FriendlyRobotObstacle* unsafe_arena_release_friendly_robot();

  // .pathfinding.OpponentRobotObstacle opponent_robot = 12;
  bool has_opponent_robot() const;
  private:
  bool _internal_has_opponent_robot() const;
  public:
  void clear_opponent_robot();
  const ::pathfinding::OpponentRobotObstacle& opponent_robot() const;
  ::pathfinding::OpponentRobotObstacle* release_opponent_robot();
  ::pathfinding::OpponentRobotObstacle* mutable_opponent_robot();
  void set_allocated_opponent_robot(::pathfinding::OpponentRobotObstacle* opponent_robot);
  private:
  const ::pathfinding::OpponentRobotObstacle& _internal_opponent_robot() const;
  ::pathfinding::OpponentRobotObstacle* _internal_mutable_opponent_robot();
  public:
  void unsafe_arena_set_allocated_opponent_robot(
      ::pathfinding::OpponentRobotObstacle* opponent_robot);
  ::pathfinding::OpponentRobotObstacle* unsafe_arena_release_opponent_robot();

  void clear_obstacle();
  ObstacleCase obstacle_case() const;
  // @@protoc_insertion_point(class_scope:pathfinding.Obstacle)
 private:
  class _Internal;
  void set_has_circle();
  void set_has_rectangle();
  void set_has_triangle();
  void set_has_line();
  void set_has_moving_circle();
  void set_has_moving_line();
  void set_has_friendly_robot();
  void set_has_opponent_robot();

  inline bool has_obstacle() const;
  inline void clear_has_obstacle();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int32 prio_;
  float radius_;
  union ObstacleUnion {
    ObstacleUnion() {}
    ::pathfinding::CircleObstacle* circle_;
    ::pathfinding::RectObstacle* rectangle_;
    ::pathfinding::TriangleObstacle* triangle_;
    ::pathfinding::LineObstacle* line_;
    ::pathfinding::MovingCircleObstacle* moving_circle_;
    ::pathfinding::MovingLineObstacle* moving_line_;
    ::pathfinding::FriendlyRobotObstacle* friendly_robot_;
    ::pathfinding::OpponentRobotObstacle* opponent_robot_;
  } obstacle_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_pathfinding_2eproto;
};
// -------------------------------------------------------------------

class WorldState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pathfinding.WorldState) */ {
 public:
  inline WorldState() : WorldState(nullptr) {};
  virtual ~WorldState();

  WorldState(const WorldState& from);
  WorldState(WorldState&& from) noexcept
    : WorldState() {
    *this = ::std::move(from);
  }

  inline WorldState& operator=(const WorldState& from) {
    CopyFrom(from);
    return *this;
  }
  inline WorldState& operator=(WorldState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const WorldState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WorldState* internal_default_instance() {
    return reinterpret_cast<const WorldState*>(
               &_WorldState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(WorldState& a, WorldState& b) {
    a.Swap(&b);
  }
  inline void Swap(WorldState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WorldState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WorldState* New() const final {
    return CreateMaybeMessage<WorldState>(nullptr);
  }

  WorldState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WorldState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const WorldState& from);
  void MergeFrom(const WorldState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorldState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pathfinding.WorldState";
  }
  protected:
  explicit WorldState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pathfinding_2eproto);
    return ::descriptor_table_pathfinding_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kObstaclesFieldNumber = 1,
    kBoundaryFieldNumber = 3,
    kOutOfFieldPriorityFieldNumber = 2,
    kRadiusFieldNumber = 4,
    kRobotIdFieldNumber = 5,
  };
  // repeated .pathfinding.Obstacle obstacles = 1;
  int obstacles_size() const;
  private:
  int _internal_obstacles_size() const;
  public:
  void clear_obstacles();
  ::pathfinding::Obstacle* mutable_obstacles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pathfinding::Obstacle >*
      mutable_obstacles();
  private:
  const ::pathfinding::Obstacle& _internal_obstacles(int index) const;
  ::pathfinding::Obstacle* _internal_add_obstacles();
  public:
  const ::pathfinding::Obstacle& obstacles(int index) const;
  ::pathfinding::Obstacle* add_obstacles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pathfinding::Obstacle >&
      obstacles() const;

  // optional .pathfinding.RectObstacle boundary = 3;
  bool has_boundary() const;
  private:
  bool _internal_has_boundary() const;
  public:
  void clear_boundary();
  const ::pathfinding::RectObstacle& boundary() const;
  ::pathfinding::RectObstacle* release_boundary();
  ::pathfinding::RectObstacle* mutable_boundary();
  void set_allocated_boundary(::pathfinding::RectObstacle* boundary);
  private:
  const ::pathfinding::RectObstacle& _internal_boundary() const;
  ::pathfinding::RectObstacle* _internal_mutable_boundary();
  public:
  void unsafe_arena_set_allocated_boundary(
      ::pathfinding::RectObstacle* boundary);
  ::pathfinding::RectObstacle* unsafe_arena_release_boundary();

  // optional uint32 out_of_field_priority = 2;
  bool has_out_of_field_priority() const;
  private:
  bool _internal_has_out_of_field_priority() const;
  public:
  void clear_out_of_field_priority();
  ::PROTOBUF_NAMESPACE_ID::uint32 out_of_field_priority() const;
  void set_out_of_field_priority(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_out_of_field_priority() const;
  void _internal_set_out_of_field_priority(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional float radius = 4;
  bool has_radius() const;
  private:
  bool _internal_has_radius() const;
  public:
  void clear_radius();
  float radius() const;
  void set_radius(float value);
  private:
  float _internal_radius() const;
  void _internal_set_radius(float value);
  public:

  // optional uint32 robot_id = 5;
  bool has_robot_id() const;
  private:
  bool _internal_has_robot_id() const;
  public:
  void clear_robot_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 robot_id() const;
  void set_robot_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_robot_id() const;
  void _internal_set_robot_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:pathfinding.WorldState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pathfinding::Obstacle > obstacles_;
  ::pathfinding::RectObstacle* boundary_;
  ::PROTOBUF_NAMESPACE_ID::uint32 out_of_field_priority_;
  float radius_;
  ::PROTOBUF_NAMESPACE_ID::uint32 robot_id_;
  friend struct ::TableStruct_pathfinding_2eproto;
};
// -------------------------------------------------------------------

class TrajectoryInput PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pathfinding.TrajectoryInput) */ {
 public:
  inline TrajectoryInput() : TrajectoryInput(nullptr) {};
  virtual ~TrajectoryInput();

  TrajectoryInput(const TrajectoryInput& from);
  TrajectoryInput(TrajectoryInput&& from) noexcept
    : TrajectoryInput() {
    *this = ::std::move(from);
  }

  inline TrajectoryInput& operator=(const TrajectoryInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrajectoryInput& operator=(TrajectoryInput&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TrajectoryInput& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrajectoryInput* internal_default_instance() {
    return reinterpret_cast<const TrajectoryInput*>(
               &_TrajectoryInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(TrajectoryInput& a, TrajectoryInput& b) {
    a.Swap(&b);
  }
  inline void Swap(TrajectoryInput* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrajectoryInput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TrajectoryInput* New() const final {
    return CreateMaybeMessage<TrajectoryInput>(nullptr);
  }

  TrajectoryInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TrajectoryInput>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TrajectoryInput& from);
  void MergeFrom(const TrajectoryInput& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrajectoryInput* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pathfinding.TrajectoryInput";
  }
  protected:
  explicit TrajectoryInput(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pathfinding_2eproto);
    return ::descriptor_table_pathfinding_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kV0FieldNumber = 1,
    kV1FieldNumber = 2,
    kS0FieldNumber = 4,
    kS1FieldNumber = 5,
    kMaxSpeedFieldNumber = 6,
    kAccelerationFieldNumber = 7,
  };
  // optional .pathfinding.Vector v0 = 1;
  bool has_v0() const;
  private:
  bool _internal_has_v0() const;
  public:
  void clear_v0();
  const ::pathfinding::Vector& v0() const;
  ::pathfinding::Vector* release_v0();
  ::pathfinding::Vector* mutable_v0();
  void set_allocated_v0(::pathfinding::Vector* v0);
  private:
  const ::pathfinding::Vector& _internal_v0() const;
  ::pathfinding::Vector* _internal_mutable_v0();
  public:
  void unsafe_arena_set_allocated_v0(
      ::pathfinding::Vector* v0);
  ::pathfinding::Vector* unsafe_arena_release_v0();

  // optional .pathfinding.Vector v1 = 2;
  bool has_v1() const;
  private:
  bool _internal_has_v1() const;
  public:
  void clear_v1();
  const ::pathfinding::Vector& v1() const;
  ::pathfinding::Vector* release_v1();
  ::pathfinding::Vector* mutable_v1();
  void set_allocated_v1(::pathfinding::Vector* v1);
  private:
  const ::pathfinding::Vector& _internal_v1() const;
  ::pathfinding::Vector* _internal_mutable_v1();
  public:
  void unsafe_arena_set_allocated_v1(
      ::pathfinding::Vector* v1);
  ::pathfinding::Vector* unsafe_arena_release_v1();

  // optional .pathfinding.Vector s0 = 4;
  bool has_s0() const;
  private:
  bool _internal_has_s0() const;
  public:
  void clear_s0();
  const ::pathfinding::Vector& s0() const;
  ::pathfinding::Vector* release_s0();
  ::pathfinding::Vector* mutable_s0();
  void set_allocated_s0(::pathfinding::Vector* s0);
  private:
  const ::pathfinding::Vector& _internal_s0() const;
  ::pathfinding::Vector* _internal_mutable_s0();
  public:
  void unsafe_arena_set_allocated_s0(
      ::pathfinding::Vector* s0);
  ::pathfinding::Vector* unsafe_arena_release_s0();

  // optional .pathfinding.Vector s1 = 5;
  bool has_s1() const;
  private:
  bool _internal_has_s1() const;
  public:
  void clear_s1();
  const ::pathfinding::Vector& s1() const;
  ::pathfinding::Vector* release_s1();
  ::pathfinding::Vector* mutable_s1();
  void set_allocated_s1(::pathfinding::Vector* s1);
  private:
  const ::pathfinding::Vector& _internal_s1() const;
  ::pathfinding::Vector* _internal_mutable_s1();
  public:
  void unsafe_arena_set_allocated_s1(
      ::pathfinding::Vector* s1);
  ::pathfinding::Vector* unsafe_arena_release_s1();

  // optional float max_speed = 6;
  bool has_max_speed() const;
  private:
  bool _internal_has_max_speed() const;
  public:
  void clear_max_speed();
  float max_speed() const;
  void set_max_speed(float value);
  private:
  float _internal_max_speed() const;
  void _internal_set_max_speed(float value);
  public:

  // optional float acceleration = 7;
  bool has_acceleration() const;
  private:
  bool _internal_has_acceleration() const;
  public:
  void clear_acceleration();
  float acceleration() const;
  void set_acceleration(float value);
  private:
  float _internal_acceleration() const;
  void _internal_set_acceleration(float value);
  public:

  // @@protoc_insertion_point(class_scope:pathfinding.TrajectoryInput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::pathfinding::Vector* v0_;
  ::pathfinding::Vector* v1_;
  ::pathfinding::Vector* s0_;
  ::pathfinding::Vector* s1_;
  float max_speed_;
  float acceleration_;
  friend struct ::TableStruct_pathfinding_2eproto;
};
// -------------------------------------------------------------------

class PathFindingTask PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pathfinding.PathFindingTask) */ {
 public:
  inline PathFindingTask() : PathFindingTask(nullptr) {};
  virtual ~PathFindingTask();

  PathFindingTask(const PathFindingTask& from);
  PathFindingTask(PathFindingTask&& from) noexcept
    : PathFindingTask() {
    *this = ::std::move(from);
  }

  inline PathFindingTask& operator=(const PathFindingTask& from) {
    CopyFrom(from);
    return *this;
  }
  inline PathFindingTask& operator=(PathFindingTask&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PathFindingTask& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PathFindingTask* internal_default_instance() {
    return reinterpret_cast<const PathFindingTask*>(
               &_PathFindingTask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(PathFindingTask& a, PathFindingTask& b) {
    a.Swap(&b);
  }
  inline void Swap(PathFindingTask* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PathFindingTask* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PathFindingTask* New() const final {
    return CreateMaybeMessage<PathFindingTask>(nullptr);
  }

  PathFindingTask* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PathFindingTask>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PathFindingTask& from);
  void MergeFrom(const PathFindingTask& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PathFindingTask* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pathfinding.PathFindingTask";
  }
  protected:
  explicit PathFindingTask(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pathfinding_2eproto);
    return ::descriptor_table_pathfinding_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
    kInputFieldNumber = 2,
    kTypeFieldNumber = 3,
  };
  // optional .pathfinding.WorldState state = 1;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  const ::pathfinding::WorldState& state() const;
  ::pathfinding::WorldState* release_state();
  ::pathfinding::WorldState* mutable_state();
  void set_allocated_state(::pathfinding::WorldState* state);
  private:
  const ::pathfinding::WorldState& _internal_state() const;
  ::pathfinding::WorldState* _internal_mutable_state();
  public:
  void unsafe_arena_set_allocated_state(
      ::pathfinding::WorldState* state);
  ::pathfinding::WorldState* unsafe_arena_release_state();

  // optional .pathfinding.TrajectoryInput input = 2;
  bool has_input() const;
  private:
  bool _internal_has_input() const;
  public:
  void clear_input();
  const ::pathfinding::TrajectoryInput& input() const;
  ::pathfinding::TrajectoryInput* release_input();
  ::pathfinding::TrajectoryInput* mutable_input();
  void set_allocated_input(::pathfinding::TrajectoryInput* input);
  private:
  const ::pathfinding::TrajectoryInput& _internal_input() const;
  ::pathfinding::TrajectoryInput* _internal_mutable_input();
  public:
  void unsafe_arena_set_allocated_input(
      ::pathfinding::TrajectoryInput* input);
  ::pathfinding::TrajectoryInput* unsafe_arena_release_input();

  // optional .pathfinding.InputSourceType type = 3;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::pathfinding::InputSourceType type() const;
  void set_type(::pathfinding::InputSourceType value);
  private:
  ::pathfinding::InputSourceType _internal_type() const;
  void _internal_set_type(::pathfinding::InputSourceType value);
  public:

  // @@protoc_insertion_point(class_scope:pathfinding.PathFindingTask)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::pathfinding::WorldState* state_;
  ::pathfinding::TrajectoryInput* input_;
  int type_;
  friend struct ::TableStruct_pathfinding_2eproto;
};
// -------------------------------------------------------------------

class StandardSamplerPoint PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pathfinding.StandardSamplerPoint) */ {
 public:
  inline StandardSamplerPoint() : StandardSamplerPoint(nullptr) {};
  virtual ~StandardSamplerPoint();

  StandardSamplerPoint(const StandardSamplerPoint& from);
  StandardSamplerPoint(StandardSamplerPoint&& from) noexcept
    : StandardSamplerPoint() {
    *this = ::std::move(from);
  }

  inline StandardSamplerPoint& operator=(const StandardSamplerPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline StandardSamplerPoint& operator=(StandardSamplerPoint&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StandardSamplerPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StandardSamplerPoint* internal_default_instance() {
    return reinterpret_cast<const StandardSamplerPoint*>(
               &_StandardSamplerPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(StandardSamplerPoint& a, StandardSamplerPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(StandardSamplerPoint* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StandardSamplerPoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StandardSamplerPoint* New() const final {
    return CreateMaybeMessage<StandardSamplerPoint>(nullptr);
  }

  StandardSamplerPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StandardSamplerPoint>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StandardSamplerPoint& from);
  void MergeFrom(const StandardSamplerPoint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StandardSamplerPoint* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pathfinding.StandardSamplerPoint";
  }
  protected:
  explicit StandardSamplerPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pathfinding_2eproto);
    return ::descriptor_table_pathfinding_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeFieldNumber = 1,
    kAngleFieldNumber = 2,
    kMidSpeedXFieldNumber = 3,
    kMidSpeedYFieldNumber = 4,
  };
  // optional float time = 1;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  float time() const;
  void set_time(float value);
  private:
  float _internal_time() const;
  void _internal_set_time(float value);
  public:

  // optional float angle = 2;
  bool has_angle() const;
  private:
  bool _internal_has_angle() const;
  public:
  void clear_angle();
  float angle() const;
  void set_angle(float value);
  private:
  float _internal_angle() const;
  void _internal_set_angle(float value);
  public:

  // optional float mid_speed_x = 3;
  bool has_mid_speed_x() const;
  private:
  bool _internal_has_mid_speed_x() const;
  public:
  void clear_mid_speed_x();
  float mid_speed_x() const;
  void set_mid_speed_x(float value);
  private:
  float _internal_mid_speed_x() const;
  void _internal_set_mid_speed_x(float value);
  public:

  // optional float mid_speed_y = 4;
  bool has_mid_speed_y() const;
  private:
  bool _internal_has_mid_speed_y() const;
  public:
  void clear_mid_speed_y();
  float mid_speed_y() const;
  void set_mid_speed_y(float value);
  private:
  float _internal_mid_speed_y() const;
  void _internal_set_mid_speed_y(float value);
  public:

  // @@protoc_insertion_point(class_scope:pathfinding.StandardSamplerPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float time_;
  float angle_;
  float mid_speed_x_;
  float mid_speed_y_;
  friend struct ::TableStruct_pathfinding_2eproto;
};
// -------------------------------------------------------------------

class StandardSamplerPrecomputationSegment PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pathfinding.StandardSamplerPrecomputationSegment) */ {
 public:
  inline StandardSamplerPrecomputationSegment() : StandardSamplerPrecomputationSegment(nullptr) {};
  virtual ~StandardSamplerPrecomputationSegment();

  StandardSamplerPrecomputationSegment(const StandardSamplerPrecomputationSegment& from);
  StandardSamplerPrecomputationSegment(StandardSamplerPrecomputationSegment&& from) noexcept
    : StandardSamplerPrecomputationSegment() {
    *this = ::std::move(from);
  }

  inline StandardSamplerPrecomputationSegment& operator=(const StandardSamplerPrecomputationSegment& from) {
    CopyFrom(from);
    return *this;
  }
  inline StandardSamplerPrecomputationSegment& operator=(StandardSamplerPrecomputationSegment&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StandardSamplerPrecomputationSegment& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StandardSamplerPrecomputationSegment* internal_default_instance() {
    return reinterpret_cast<const StandardSamplerPrecomputationSegment*>(
               &_StandardSamplerPrecomputationSegment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(StandardSamplerPrecomputationSegment& a, StandardSamplerPrecomputationSegment& b) {
    a.Swap(&b);
  }
  inline void Swap(StandardSamplerPrecomputationSegment* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StandardSamplerPrecomputationSegment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StandardSamplerPrecomputationSegment* New() const final {
    return CreateMaybeMessage<StandardSamplerPrecomputationSegment>(nullptr);
  }

  StandardSamplerPrecomputationSegment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StandardSamplerPrecomputationSegment>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StandardSamplerPrecomputationSegment& from);
  void MergeFrom(const StandardSamplerPrecomputationSegment& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StandardSamplerPrecomputationSegment* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pathfinding.StandardSamplerPrecomputationSegment";
  }
  protected:
  explicit StandardSamplerPrecomputationSegment(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pathfinding_2eproto);
    return ::descriptor_table_pathfinding_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrecomputedPointsFieldNumber = 1,
    kMinDistanceFieldNumber = 2,
    kMaxDistanceFieldNumber = 3,
  };
  // repeated .pathfinding.StandardSamplerPoint precomputed_points = 1;
  int precomputed_points_size() const;
  private:
  int _internal_precomputed_points_size() const;
  public:
  void clear_precomputed_points();
  ::pathfinding::StandardSamplerPoint* mutable_precomputed_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pathfinding::StandardSamplerPoint >*
      mutable_precomputed_points();
  private:
  const ::pathfinding::StandardSamplerPoint& _internal_precomputed_points(int index) const;
  ::pathfinding::StandardSamplerPoint* _internal_add_precomputed_points();
  public:
  const ::pathfinding::StandardSamplerPoint& precomputed_points(int index) const;
  ::pathfinding::StandardSamplerPoint* add_precomputed_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pathfinding::StandardSamplerPoint >&
      precomputed_points() const;

  // optional float min_distance = 2;
  bool has_min_distance() const;
  private:
  bool _internal_has_min_distance() const;
  public:
  void clear_min_distance();
  float min_distance() const;
  void set_min_distance(float value);
  private:
  float _internal_min_distance() const;
  void _internal_set_min_distance(float value);
  public:

  // optional float max_distance = 3;
  bool has_max_distance() const;
  private:
  bool _internal_has_max_distance() const;
  public:
  void clear_max_distance();
  float max_distance() const;
  void set_max_distance(float value);
  private:
  float _internal_max_distance() const;
  void _internal_set_max_distance(float value);
  public:

  // @@protoc_insertion_point(class_scope:pathfinding.StandardSamplerPrecomputationSegment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pathfinding::StandardSamplerPoint > precomputed_points_;
  float min_distance_;
  float max_distance_;
  friend struct ::TableStruct_pathfinding_2eproto;
};
// -------------------------------------------------------------------

class StandardSamplerPrecomputation PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pathfinding.StandardSamplerPrecomputation) */ {
 public:
  inline StandardSamplerPrecomputation() : StandardSamplerPrecomputation(nullptr) {};
  virtual ~StandardSamplerPrecomputation();

  StandardSamplerPrecomputation(const StandardSamplerPrecomputation& from);
  StandardSamplerPrecomputation(StandardSamplerPrecomputation&& from) noexcept
    : StandardSamplerPrecomputation() {
    *this = ::std::move(from);
  }

  inline StandardSamplerPrecomputation& operator=(const StandardSamplerPrecomputation& from) {
    CopyFrom(from);
    return *this;
  }
  inline StandardSamplerPrecomputation& operator=(StandardSamplerPrecomputation&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StandardSamplerPrecomputation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StandardSamplerPrecomputation* internal_default_instance() {
    return reinterpret_cast<const StandardSamplerPrecomputation*>(
               &_StandardSamplerPrecomputation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(StandardSamplerPrecomputation& a, StandardSamplerPrecomputation& b) {
    a.Swap(&b);
  }
  inline void Swap(StandardSamplerPrecomputation* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StandardSamplerPrecomputation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StandardSamplerPrecomputation* New() const final {
    return CreateMaybeMessage<StandardSamplerPrecomputation>(nullptr);
  }

  StandardSamplerPrecomputation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StandardSamplerPrecomputation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StandardSamplerPrecomputation& from);
  void MergeFrom(const StandardSamplerPrecomputation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StandardSamplerPrecomputation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pathfinding.StandardSamplerPrecomputation";
  }
  protected:
  explicit StandardSamplerPrecomputation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_pathfinding_2eproto);
    return ::descriptor_table_pathfinding_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSegmentsFieldNumber = 1,
  };
  // repeated .pathfinding.StandardSamplerPrecomputationSegment segments = 1;
  int segments_size() const;
  private:
  int _internal_segments_size() const;
  public:
  void clear_segments();
  ::pathfinding::StandardSamplerPrecomputationSegment* mutable_segments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pathfinding::StandardSamplerPrecomputationSegment >*
      mutable_segments();
  private:
  const ::pathfinding::StandardSamplerPrecomputationSegment& _internal_segments(int index) const;
  ::pathfinding::StandardSamplerPrecomputationSegment* _internal_add_segments();
  public:
  const ::pathfinding::StandardSamplerPrecomputationSegment& segments(int index) const;
  ::pathfinding::StandardSamplerPrecomputationSegment* add_segments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pathfinding::StandardSamplerPrecomputationSegment >&
      segments() const;

  // @@protoc_insertion_point(class_scope:pathfinding.StandardSamplerPrecomputation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pathfinding::StandardSamplerPrecomputationSegment > segments_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pathfinding_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Vector

// optional float x = 1;
inline bool Vector::_internal_has_x() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Vector::has_x() const {
  return _internal_has_x();
}
inline void Vector::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float Vector::_internal_x() const {
  return x_;
}
inline float Vector::x() const {
  // @@protoc_insertion_point(field_get:pathfinding.Vector.x)
  return _internal_x();
}
inline void Vector::_internal_set_x(float value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
}
inline void Vector::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:pathfinding.Vector.x)
}

// optional float y = 2;
inline bool Vector::_internal_has_y() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Vector::has_y() const {
  return _internal_has_y();
}
inline void Vector::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float Vector::_internal_y() const {
  return y_;
}
inline float Vector::y() const {
  // @@protoc_insertion_point(field_get:pathfinding.Vector.y)
  return _internal_y();
}
inline void Vector::_internal_set_y(float value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
}
inline void Vector::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:pathfinding.Vector.y)
}

// -------------------------------------------------------------------

// CircleObstacle

// optional .pathfinding.Vector center = 1;
inline bool CircleObstacle::_internal_has_center() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || center_ != nullptr);
  return value;
}
inline bool CircleObstacle::has_center() const {
  return _internal_has_center();
}
inline void CircleObstacle::clear_center() {
  if (center_ != nullptr) center_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::pathfinding::Vector& CircleObstacle::_internal_center() const {
  const ::pathfinding::Vector* p = center_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pathfinding::Vector*>(
      &::pathfinding::_Vector_default_instance_);
}
inline const ::pathfinding::Vector& CircleObstacle::center() const {
  // @@protoc_insertion_point(field_get:pathfinding.CircleObstacle.center)
  return _internal_center();
}
inline void CircleObstacle::unsafe_arena_set_allocated_center(
    ::pathfinding::Vector* center) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(center_);
  }
  center_ = center;
  if (center) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pathfinding.CircleObstacle.center)
}
inline ::pathfinding::Vector* CircleObstacle::release_center() {
  auto temp = unsafe_arena_release_center();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pathfinding::Vector* CircleObstacle::unsafe_arena_release_center() {
  // @@protoc_insertion_point(field_release:pathfinding.CircleObstacle.center)
  _has_bits_[0] &= ~0x00000001u;
  ::pathfinding::Vector* temp = center_;
  center_ = nullptr;
  return temp;
}
inline ::pathfinding::Vector* CircleObstacle::_internal_mutable_center() {
  _has_bits_[0] |= 0x00000001u;
  if (center_ == nullptr) {
    auto* p = CreateMaybeMessage<::pathfinding::Vector>(GetArena());
    center_ = p;
  }
  return center_;
}
inline ::pathfinding::Vector* CircleObstacle::mutable_center() {
  // @@protoc_insertion_point(field_mutable:pathfinding.CircleObstacle.center)
  return _internal_mutable_center();
}
inline void CircleObstacle::set_allocated_center(::pathfinding::Vector* center) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete center_;
  }
  if (center) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(center);
    if (message_arena != submessage_arena) {
      center = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, center, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  center_ = center;
  // @@protoc_insertion_point(field_set_allocated:pathfinding.CircleObstacle.center)
}

// -------------------------------------------------------------------

// RectObstacle

// optional .pathfinding.Vector bottom_left = 1;
inline bool RectObstacle::_internal_has_bottom_left() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || bottom_left_ != nullptr);
  return value;
}
inline bool RectObstacle::has_bottom_left() const {
  return _internal_has_bottom_left();
}
inline void RectObstacle::clear_bottom_left() {
  if (bottom_left_ != nullptr) bottom_left_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::pathfinding::Vector& RectObstacle::_internal_bottom_left() const {
  const ::pathfinding::Vector* p = bottom_left_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pathfinding::Vector*>(
      &::pathfinding::_Vector_default_instance_);
}
inline const ::pathfinding::Vector& RectObstacle::bottom_left() const {
  // @@protoc_insertion_point(field_get:pathfinding.RectObstacle.bottom_left)
  return _internal_bottom_left();
}
inline void RectObstacle::unsafe_arena_set_allocated_bottom_left(
    ::pathfinding::Vector* bottom_left) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bottom_left_);
  }
  bottom_left_ = bottom_left;
  if (bottom_left) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pathfinding.RectObstacle.bottom_left)
}
inline ::pathfinding::Vector* RectObstacle::release_bottom_left() {
  auto temp = unsafe_arena_release_bottom_left();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pathfinding::Vector* RectObstacle::unsafe_arena_release_bottom_left() {
  // @@protoc_insertion_point(field_release:pathfinding.RectObstacle.bottom_left)
  _has_bits_[0] &= ~0x00000001u;
  ::pathfinding::Vector* temp = bottom_left_;
  bottom_left_ = nullptr;
  return temp;
}
inline ::pathfinding::Vector* RectObstacle::_internal_mutable_bottom_left() {
  _has_bits_[0] |= 0x00000001u;
  if (bottom_left_ == nullptr) {
    auto* p = CreateMaybeMessage<::pathfinding::Vector>(GetArena());
    bottom_left_ = p;
  }
  return bottom_left_;
}
inline ::pathfinding::Vector* RectObstacle::mutable_bottom_left() {
  // @@protoc_insertion_point(field_mutable:pathfinding.RectObstacle.bottom_left)
  return _internal_mutable_bottom_left();
}
inline void RectObstacle::set_allocated_bottom_left(::pathfinding::Vector* bottom_left) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete bottom_left_;
  }
  if (bottom_left) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(bottom_left);
    if (message_arena != submessage_arena) {
      bottom_left = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bottom_left, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  bottom_left_ = bottom_left;
  // @@protoc_insertion_point(field_set_allocated:pathfinding.RectObstacle.bottom_left)
}

// optional .pathfinding.Vector top_right = 2;
inline bool RectObstacle::_internal_has_top_right() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || top_right_ != nullptr);
  return value;
}
inline bool RectObstacle::has_top_right() const {
  return _internal_has_top_right();
}
inline void RectObstacle::clear_top_right() {
  if (top_right_ != nullptr) top_right_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::pathfinding::Vector& RectObstacle::_internal_top_right() const {
  const ::pathfinding::Vector* p = top_right_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pathfinding::Vector*>(
      &::pathfinding::_Vector_default_instance_);
}
inline const ::pathfinding::Vector& RectObstacle::top_right() const {
  // @@protoc_insertion_point(field_get:pathfinding.RectObstacle.top_right)
  return _internal_top_right();
}
inline void RectObstacle::unsafe_arena_set_allocated_top_right(
    ::pathfinding::Vector* top_right) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(top_right_);
  }
  top_right_ = top_right;
  if (top_right) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pathfinding.RectObstacle.top_right)
}
inline ::pathfinding::Vector* RectObstacle::release_top_right() {
  auto temp = unsafe_arena_release_top_right();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pathfinding::Vector* RectObstacle::unsafe_arena_release_top_right() {
  // @@protoc_insertion_point(field_release:pathfinding.RectObstacle.top_right)
  _has_bits_[0] &= ~0x00000002u;
  ::pathfinding::Vector* temp = top_right_;
  top_right_ = nullptr;
  return temp;
}
inline ::pathfinding::Vector* RectObstacle::_internal_mutable_top_right() {
  _has_bits_[0] |= 0x00000002u;
  if (top_right_ == nullptr) {
    auto* p = CreateMaybeMessage<::pathfinding::Vector>(GetArena());
    top_right_ = p;
  }
  return top_right_;
}
inline ::pathfinding::Vector* RectObstacle::mutable_top_right() {
  // @@protoc_insertion_point(field_mutable:pathfinding.RectObstacle.top_right)
  return _internal_mutable_top_right();
}
inline void RectObstacle::set_allocated_top_right(::pathfinding::Vector* top_right) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete top_right_;
  }
  if (top_right) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(top_right);
    if (message_arena != submessage_arena) {
      top_right = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, top_right, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  top_right_ = top_right;
  // @@protoc_insertion_point(field_set_allocated:pathfinding.RectObstacle.top_right)
}

// -------------------------------------------------------------------

// TriangleObstacle

// optional .pathfinding.Vector p1 = 1;
inline bool TriangleObstacle::_internal_has_p1() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || p1_ != nullptr);
  return value;
}
inline bool TriangleObstacle::has_p1() const {
  return _internal_has_p1();
}
inline void TriangleObstacle::clear_p1() {
  if (p1_ != nullptr) p1_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::pathfinding::Vector& TriangleObstacle::_internal_p1() const {
  const ::pathfinding::Vector* p = p1_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pathfinding::Vector*>(
      &::pathfinding::_Vector_default_instance_);
}
inline const ::pathfinding::Vector& TriangleObstacle::p1() const {
  // @@protoc_insertion_point(field_get:pathfinding.TriangleObstacle.p1)
  return _internal_p1();
}
inline void TriangleObstacle::unsafe_arena_set_allocated_p1(
    ::pathfinding::Vector* p1) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(p1_);
  }
  p1_ = p1;
  if (p1) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pathfinding.TriangleObstacle.p1)
}
inline ::pathfinding::Vector* TriangleObstacle::release_p1() {
  auto temp = unsafe_arena_release_p1();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pathfinding::Vector* TriangleObstacle::unsafe_arena_release_p1() {
  // @@protoc_insertion_point(field_release:pathfinding.TriangleObstacle.p1)
  _has_bits_[0] &= ~0x00000001u;
  ::pathfinding::Vector* temp = p1_;
  p1_ = nullptr;
  return temp;
}
inline ::pathfinding::Vector* TriangleObstacle::_internal_mutable_p1() {
  _has_bits_[0] |= 0x00000001u;
  if (p1_ == nullptr) {
    auto* p = CreateMaybeMessage<::pathfinding::Vector>(GetArena());
    p1_ = p;
  }
  return p1_;
}
inline ::pathfinding::Vector* TriangleObstacle::mutable_p1() {
  // @@protoc_insertion_point(field_mutable:pathfinding.TriangleObstacle.p1)
  return _internal_mutable_p1();
}
inline void TriangleObstacle::set_allocated_p1(::pathfinding::Vector* p1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete p1_;
  }
  if (p1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(p1);
    if (message_arena != submessage_arena) {
      p1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, p1, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  p1_ = p1;
  // @@protoc_insertion_point(field_set_allocated:pathfinding.TriangleObstacle.p1)
}

// optional .pathfinding.Vector p2 = 2;
inline bool TriangleObstacle::_internal_has_p2() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || p2_ != nullptr);
  return value;
}
inline bool TriangleObstacle::has_p2() const {
  return _internal_has_p2();
}
inline void TriangleObstacle::clear_p2() {
  if (p2_ != nullptr) p2_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::pathfinding::Vector& TriangleObstacle::_internal_p2() const {
  const ::pathfinding::Vector* p = p2_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pathfinding::Vector*>(
      &::pathfinding::_Vector_default_instance_);
}
inline const ::pathfinding::Vector& TriangleObstacle::p2() const {
  // @@protoc_insertion_point(field_get:pathfinding.TriangleObstacle.p2)
  return _internal_p2();
}
inline void TriangleObstacle::unsafe_arena_set_allocated_p2(
    ::pathfinding::Vector* p2) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(p2_);
  }
  p2_ = p2;
  if (p2) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pathfinding.TriangleObstacle.p2)
}
inline ::pathfinding::Vector* TriangleObstacle::release_p2() {
  auto temp = unsafe_arena_release_p2();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pathfinding::Vector* TriangleObstacle::unsafe_arena_release_p2() {
  // @@protoc_insertion_point(field_release:pathfinding.TriangleObstacle.p2)
  _has_bits_[0] &= ~0x00000002u;
  ::pathfinding::Vector* temp = p2_;
  p2_ = nullptr;
  return temp;
}
inline ::pathfinding::Vector* TriangleObstacle::_internal_mutable_p2() {
  _has_bits_[0] |= 0x00000002u;
  if (p2_ == nullptr) {
    auto* p = CreateMaybeMessage<::pathfinding::Vector>(GetArena());
    p2_ = p;
  }
  return p2_;
}
inline ::pathfinding::Vector* TriangleObstacle::mutable_p2() {
  // @@protoc_insertion_point(field_mutable:pathfinding.TriangleObstacle.p2)
  return _internal_mutable_p2();
}
inline void TriangleObstacle::set_allocated_p2(::pathfinding::Vector* p2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete p2_;
  }
  if (p2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(p2);
    if (message_arena != submessage_arena) {
      p2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, p2, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  p2_ = p2;
  // @@protoc_insertion_point(field_set_allocated:pathfinding.TriangleObstacle.p2)
}

// optional .pathfinding.Vector p3 = 3;
inline bool TriangleObstacle::_internal_has_p3() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || p3_ != nullptr);
  return value;
}
inline bool TriangleObstacle::has_p3() const {
  return _internal_has_p3();
}
inline void TriangleObstacle::clear_p3() {
  if (p3_ != nullptr) p3_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::pathfinding::Vector& TriangleObstacle::_internal_p3() const {
  const ::pathfinding::Vector* p = p3_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pathfinding::Vector*>(
      &::pathfinding::_Vector_default_instance_);
}
inline const ::pathfinding::Vector& TriangleObstacle::p3() const {
  // @@protoc_insertion_point(field_get:pathfinding.TriangleObstacle.p3)
  return _internal_p3();
}
inline void TriangleObstacle::unsafe_arena_set_allocated_p3(
    ::pathfinding::Vector* p3) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(p3_);
  }
  p3_ = p3;
  if (p3) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pathfinding.TriangleObstacle.p3)
}
inline ::pathfinding::Vector* TriangleObstacle::release_p3() {
  auto temp = unsafe_arena_release_p3();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pathfinding::Vector* TriangleObstacle::unsafe_arena_release_p3() {
  // @@protoc_insertion_point(field_release:pathfinding.TriangleObstacle.p3)
  _has_bits_[0] &= ~0x00000004u;
  ::pathfinding::Vector* temp = p3_;
  p3_ = nullptr;
  return temp;
}
inline ::pathfinding::Vector* TriangleObstacle::_internal_mutable_p3() {
  _has_bits_[0] |= 0x00000004u;
  if (p3_ == nullptr) {
    auto* p = CreateMaybeMessage<::pathfinding::Vector>(GetArena());
    p3_ = p;
  }
  return p3_;
}
inline ::pathfinding::Vector* TriangleObstacle::mutable_p3() {
  // @@protoc_insertion_point(field_mutable:pathfinding.TriangleObstacle.p3)
  return _internal_mutable_p3();
}
inline void TriangleObstacle::set_allocated_p3(::pathfinding::Vector* p3) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete p3_;
  }
  if (p3) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(p3);
    if (message_arena != submessage_arena) {
      p3 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, p3, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  p3_ = p3;
  // @@protoc_insertion_point(field_set_allocated:pathfinding.TriangleObstacle.p3)
}

// -------------------------------------------------------------------

// LineObstacle

// optional .pathfinding.Vector start = 1;
inline bool LineObstacle::_internal_has_start() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || start_ != nullptr);
  return value;
}
inline bool LineObstacle::has_start() const {
  return _internal_has_start();
}
inline void LineObstacle::clear_start() {
  if (start_ != nullptr) start_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::pathfinding::Vector& LineObstacle::_internal_start() const {
  const ::pathfinding::Vector* p = start_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pathfinding::Vector*>(
      &::pathfinding::_Vector_default_instance_);
}
inline const ::pathfinding::Vector& LineObstacle::start() const {
  // @@protoc_insertion_point(field_get:pathfinding.LineObstacle.start)
  return _internal_start();
}
inline void LineObstacle::unsafe_arena_set_allocated_start(
    ::pathfinding::Vector* start) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_);
  }
  start_ = start;
  if (start) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pathfinding.LineObstacle.start)
}
inline ::pathfinding::Vector* LineObstacle::release_start() {
  auto temp = unsafe_arena_release_start();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pathfinding::Vector* LineObstacle::unsafe_arena_release_start() {
  // @@protoc_insertion_point(field_release:pathfinding.LineObstacle.start)
  _has_bits_[0] &= ~0x00000001u;
  ::pathfinding::Vector* temp = start_;
  start_ = nullptr;
  return temp;
}
inline ::pathfinding::Vector* LineObstacle::_internal_mutable_start() {
  _has_bits_[0] |= 0x00000001u;
  if (start_ == nullptr) {
    auto* p = CreateMaybeMessage<::pathfinding::Vector>(GetArena());
    start_ = p;
  }
  return start_;
}
inline ::pathfinding::Vector* LineObstacle::mutable_start() {
  // @@protoc_insertion_point(field_mutable:pathfinding.LineObstacle.start)
  return _internal_mutable_start();
}
inline void LineObstacle::set_allocated_start(::pathfinding::Vector* start) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete start_;
  }
  if (start) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(start);
    if (message_arena != submessage_arena) {
      start = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  start_ = start;
  // @@protoc_insertion_point(field_set_allocated:pathfinding.LineObstacle.start)
}

// optional .pathfinding.Vector end = 2;
inline bool LineObstacle::_internal_has_end() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || end_ != nullptr);
  return value;
}
inline bool LineObstacle::has_end() const {
  return _internal_has_end();
}
inline void LineObstacle::clear_end() {
  if (end_ != nullptr) end_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::pathfinding::Vector& LineObstacle::_internal_end() const {
  const ::pathfinding::Vector* p = end_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pathfinding::Vector*>(
      &::pathfinding::_Vector_default_instance_);
}
inline const ::pathfinding::Vector& LineObstacle::end() const {
  // @@protoc_insertion_point(field_get:pathfinding.LineObstacle.end)
  return _internal_end();
}
inline void LineObstacle::unsafe_arena_set_allocated_end(
    ::pathfinding::Vector* end) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_);
  }
  end_ = end;
  if (end) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pathfinding.LineObstacle.end)
}
inline ::pathfinding::Vector* LineObstacle::release_end() {
  auto temp = unsafe_arena_release_end();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pathfinding::Vector* LineObstacle::unsafe_arena_release_end() {
  // @@protoc_insertion_point(field_release:pathfinding.LineObstacle.end)
  _has_bits_[0] &= ~0x00000002u;
  ::pathfinding::Vector* temp = end_;
  end_ = nullptr;
  return temp;
}
inline ::pathfinding::Vector* LineObstacle::_internal_mutable_end() {
  _has_bits_[0] |= 0x00000002u;
  if (end_ == nullptr) {
    auto* p = CreateMaybeMessage<::pathfinding::Vector>(GetArena());
    end_ = p;
  }
  return end_;
}
inline ::pathfinding::Vector* LineObstacle::mutable_end() {
  // @@protoc_insertion_point(field_mutable:pathfinding.LineObstacle.end)
  return _internal_mutable_end();
}
inline void LineObstacle::set_allocated_end(::pathfinding::Vector* end) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete end_;
  }
  if (end) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(end);
    if (message_arena != submessage_arena) {
      end = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  end_ = end;
  // @@protoc_insertion_point(field_set_allocated:pathfinding.LineObstacle.end)
}

// -------------------------------------------------------------------

// MovingCircleObstacle

// optional .pathfinding.Vector start_pos = 1;
inline bool MovingCircleObstacle::_internal_has_start_pos() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || start_pos_ != nullptr);
  return value;
}
inline bool MovingCircleObstacle::has_start_pos() const {
  return _internal_has_start_pos();
}
inline void MovingCircleObstacle::clear_start_pos() {
  if (start_pos_ != nullptr) start_pos_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::pathfinding::Vector& MovingCircleObstacle::_internal_start_pos() const {
  const ::pathfinding::Vector* p = start_pos_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pathfinding::Vector*>(
      &::pathfinding::_Vector_default_instance_);
}
inline const ::pathfinding::Vector& MovingCircleObstacle::start_pos() const {
  // @@protoc_insertion_point(field_get:pathfinding.MovingCircleObstacle.start_pos)
  return _internal_start_pos();
}
inline void MovingCircleObstacle::unsafe_arena_set_allocated_start_pos(
    ::pathfinding::Vector* start_pos) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_pos_);
  }
  start_pos_ = start_pos;
  if (start_pos) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pathfinding.MovingCircleObstacle.start_pos)
}
inline ::pathfinding::Vector* MovingCircleObstacle::release_start_pos() {
  auto temp = unsafe_arena_release_start_pos();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pathfinding::Vector* MovingCircleObstacle::unsafe_arena_release_start_pos() {
  // @@protoc_insertion_point(field_release:pathfinding.MovingCircleObstacle.start_pos)
  _has_bits_[0] &= ~0x00000001u;
  ::pathfinding::Vector* temp = start_pos_;
  start_pos_ = nullptr;
  return temp;
}
inline ::pathfinding::Vector* MovingCircleObstacle::_internal_mutable_start_pos() {
  _has_bits_[0] |= 0x00000001u;
  if (start_pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::pathfinding::Vector>(GetArena());
    start_pos_ = p;
  }
  return start_pos_;
}
inline ::pathfinding::Vector* MovingCircleObstacle::mutable_start_pos() {
  // @@protoc_insertion_point(field_mutable:pathfinding.MovingCircleObstacle.start_pos)
  return _internal_mutable_start_pos();
}
inline void MovingCircleObstacle::set_allocated_start_pos(::pathfinding::Vector* start_pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete start_pos_;
  }
  if (start_pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(start_pos);
    if (message_arena != submessage_arena) {
      start_pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_pos, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  start_pos_ = start_pos;
  // @@protoc_insertion_point(field_set_allocated:pathfinding.MovingCircleObstacle.start_pos)
}

// optional .pathfinding.Vector speed = 2;
inline bool MovingCircleObstacle::_internal_has_speed() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || speed_ != nullptr);
  return value;
}
inline bool MovingCircleObstacle::has_speed() const {
  return _internal_has_speed();
}
inline void MovingCircleObstacle::clear_speed() {
  if (speed_ != nullptr) speed_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::pathfinding::Vector& MovingCircleObstacle::_internal_speed() const {
  const ::pathfinding::Vector* p = speed_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pathfinding::Vector*>(
      &::pathfinding::_Vector_default_instance_);
}
inline const ::pathfinding::Vector& MovingCircleObstacle::speed() const {
  // @@protoc_insertion_point(field_get:pathfinding.MovingCircleObstacle.speed)
  return _internal_speed();
}
inline void MovingCircleObstacle::unsafe_arena_set_allocated_speed(
    ::pathfinding::Vector* speed) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(speed_);
  }
  speed_ = speed;
  if (speed) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pathfinding.MovingCircleObstacle.speed)
}
inline ::pathfinding::Vector* MovingCircleObstacle::release_speed() {
  auto temp = unsafe_arena_release_speed();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pathfinding::Vector* MovingCircleObstacle::unsafe_arena_release_speed() {
  // @@protoc_insertion_point(field_release:pathfinding.MovingCircleObstacle.speed)
  _has_bits_[0] &= ~0x00000002u;
  ::pathfinding::Vector* temp = speed_;
  speed_ = nullptr;
  return temp;
}
inline ::pathfinding::Vector* MovingCircleObstacle::_internal_mutable_speed() {
  _has_bits_[0] |= 0x00000002u;
  if (speed_ == nullptr) {
    auto* p = CreateMaybeMessage<::pathfinding::Vector>(GetArena());
    speed_ = p;
  }
  return speed_;
}
inline ::pathfinding::Vector* MovingCircleObstacle::mutable_speed() {
  // @@protoc_insertion_point(field_mutable:pathfinding.MovingCircleObstacle.speed)
  return _internal_mutable_speed();
}
inline void MovingCircleObstacle::set_allocated_speed(::pathfinding::Vector* speed) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete speed_;
  }
  if (speed) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(speed);
    if (message_arena != submessage_arena) {
      speed = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, speed, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  speed_ = speed;
  // @@protoc_insertion_point(field_set_allocated:pathfinding.MovingCircleObstacle.speed)
}

// optional .pathfinding.Vector acc = 3;
inline bool MovingCircleObstacle::_internal_has_acc() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || acc_ != nullptr);
  return value;
}
inline bool MovingCircleObstacle::has_acc() const {
  return _internal_has_acc();
}
inline void MovingCircleObstacle::clear_acc() {
  if (acc_ != nullptr) acc_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::pathfinding::Vector& MovingCircleObstacle::_internal_acc() const {
  const ::pathfinding::Vector* p = acc_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pathfinding::Vector*>(
      &::pathfinding::_Vector_default_instance_);
}
inline const ::pathfinding::Vector& MovingCircleObstacle::acc() const {
  // @@protoc_insertion_point(field_get:pathfinding.MovingCircleObstacle.acc)
  return _internal_acc();
}
inline void MovingCircleObstacle::unsafe_arena_set_allocated_acc(
    ::pathfinding::Vector* acc) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(acc_);
  }
  acc_ = acc;
  if (acc) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pathfinding.MovingCircleObstacle.acc)
}
inline ::pathfinding::Vector* MovingCircleObstacle::release_acc() {
  auto temp = unsafe_arena_release_acc();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pathfinding::Vector* MovingCircleObstacle::unsafe_arena_release_acc() {
  // @@protoc_insertion_point(field_release:pathfinding.MovingCircleObstacle.acc)
  _has_bits_[0] &= ~0x00000004u;
  ::pathfinding::Vector* temp = acc_;
  acc_ = nullptr;
  return temp;
}
inline ::pathfinding::Vector* MovingCircleObstacle::_internal_mutable_acc() {
  _has_bits_[0] |= 0x00000004u;
  if (acc_ == nullptr) {
    auto* p = CreateMaybeMessage<::pathfinding::Vector>(GetArena());
    acc_ = p;
  }
  return acc_;
}
inline ::pathfinding::Vector* MovingCircleObstacle::mutable_acc() {
  // @@protoc_insertion_point(field_mutable:pathfinding.MovingCircleObstacle.acc)
  return _internal_mutable_acc();
}
inline void MovingCircleObstacle::set_allocated_acc(::pathfinding::Vector* acc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete acc_;
  }
  if (acc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(acc);
    if (message_arena != submessage_arena) {
      acc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, acc, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  acc_ = acc;
  // @@protoc_insertion_point(field_set_allocated:pathfinding.MovingCircleObstacle.acc)
}

// optional float start_time = 4;
inline bool MovingCircleObstacle::_internal_has_start_time() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MovingCircleObstacle::has_start_time() const {
  return _internal_has_start_time();
}
inline void MovingCircleObstacle::clear_start_time() {
  start_time_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float MovingCircleObstacle::_internal_start_time() const {
  return start_time_;
}
inline float MovingCircleObstacle::start_time() const {
  // @@protoc_insertion_point(field_get:pathfinding.MovingCircleObstacle.start_time)
  return _internal_start_time();
}
inline void MovingCircleObstacle::_internal_set_start_time(float value) {
  _has_bits_[0] |= 0x00000008u;
  start_time_ = value;
}
inline void MovingCircleObstacle::set_start_time(float value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:pathfinding.MovingCircleObstacle.start_time)
}

// optional float end_time = 5;
inline bool MovingCircleObstacle::_internal_has_end_time() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MovingCircleObstacle::has_end_time() const {
  return _internal_has_end_time();
}
inline void MovingCircleObstacle::clear_end_time() {
  end_time_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float MovingCircleObstacle::_internal_end_time() const {
  return end_time_;
}
inline float MovingCircleObstacle::end_time() const {
  // @@protoc_insertion_point(field_get:pathfinding.MovingCircleObstacle.end_time)
  return _internal_end_time();
}
inline void MovingCircleObstacle::_internal_set_end_time(float value) {
  _has_bits_[0] |= 0x00000010u;
  end_time_ = value;
}
inline void MovingCircleObstacle::set_end_time(float value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:pathfinding.MovingCircleObstacle.end_time)
}

// -------------------------------------------------------------------

// MovingLineObstacle

// optional .pathfinding.Vector start_pos1 = 1;
inline bool MovingLineObstacle::_internal_has_start_pos1() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || start_pos1_ != nullptr);
  return value;
}
inline bool MovingLineObstacle::has_start_pos1() const {
  return _internal_has_start_pos1();
}
inline void MovingLineObstacle::clear_start_pos1() {
  if (start_pos1_ != nullptr) start_pos1_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::pathfinding::Vector& MovingLineObstacle::_internal_start_pos1() const {
  const ::pathfinding::Vector* p = start_pos1_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pathfinding::Vector*>(
      &::pathfinding::_Vector_default_instance_);
}
inline const ::pathfinding::Vector& MovingLineObstacle::start_pos1() const {
  // @@protoc_insertion_point(field_get:pathfinding.MovingLineObstacle.start_pos1)
  return _internal_start_pos1();
}
inline void MovingLineObstacle::unsafe_arena_set_allocated_start_pos1(
    ::pathfinding::Vector* start_pos1) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_pos1_);
  }
  start_pos1_ = start_pos1;
  if (start_pos1) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pathfinding.MovingLineObstacle.start_pos1)
}
inline ::pathfinding::Vector* MovingLineObstacle::release_start_pos1() {
  auto temp = unsafe_arena_release_start_pos1();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pathfinding::Vector* MovingLineObstacle::unsafe_arena_release_start_pos1() {
  // @@protoc_insertion_point(field_release:pathfinding.MovingLineObstacle.start_pos1)
  _has_bits_[0] &= ~0x00000001u;
  ::pathfinding::Vector* temp = start_pos1_;
  start_pos1_ = nullptr;
  return temp;
}
inline ::pathfinding::Vector* MovingLineObstacle::_internal_mutable_start_pos1() {
  _has_bits_[0] |= 0x00000001u;
  if (start_pos1_ == nullptr) {
    auto* p = CreateMaybeMessage<::pathfinding::Vector>(GetArena());
    start_pos1_ = p;
  }
  return start_pos1_;
}
inline ::pathfinding::Vector* MovingLineObstacle::mutable_start_pos1() {
  // @@protoc_insertion_point(field_mutable:pathfinding.MovingLineObstacle.start_pos1)
  return _internal_mutable_start_pos1();
}
inline void MovingLineObstacle::set_allocated_start_pos1(::pathfinding::Vector* start_pos1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete start_pos1_;
  }
  if (start_pos1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(start_pos1);
    if (message_arena != submessage_arena) {
      start_pos1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_pos1, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  start_pos1_ = start_pos1;
  // @@protoc_insertion_point(field_set_allocated:pathfinding.MovingLineObstacle.start_pos1)
}

// optional .pathfinding.Vector speed1 = 2;
inline bool MovingLineObstacle::_internal_has_speed1() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || speed1_ != nullptr);
  return value;
}
inline bool MovingLineObstacle::has_speed1() const {
  return _internal_has_speed1();
}
inline void MovingLineObstacle::clear_speed1() {
  if (speed1_ != nullptr) speed1_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::pathfinding::Vector& MovingLineObstacle::_internal_speed1() const {
  const ::pathfinding::Vector* p = speed1_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pathfinding::Vector*>(
      &::pathfinding::_Vector_default_instance_);
}
inline const ::pathfinding::Vector& MovingLineObstacle::speed1() const {
  // @@protoc_insertion_point(field_get:pathfinding.MovingLineObstacle.speed1)
  return _internal_speed1();
}
inline void MovingLineObstacle::unsafe_arena_set_allocated_speed1(
    ::pathfinding::Vector* speed1) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(speed1_);
  }
  speed1_ = speed1;
  if (speed1) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pathfinding.MovingLineObstacle.speed1)
}
inline ::pathfinding::Vector* MovingLineObstacle::release_speed1() {
  auto temp = unsafe_arena_release_speed1();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pathfinding::Vector* MovingLineObstacle::unsafe_arena_release_speed1() {
  // @@protoc_insertion_point(field_release:pathfinding.MovingLineObstacle.speed1)
  _has_bits_[0] &= ~0x00000002u;
  ::pathfinding::Vector* temp = speed1_;
  speed1_ = nullptr;
  return temp;
}
inline ::pathfinding::Vector* MovingLineObstacle::_internal_mutable_speed1() {
  _has_bits_[0] |= 0x00000002u;
  if (speed1_ == nullptr) {
    auto* p = CreateMaybeMessage<::pathfinding::Vector>(GetArena());
    speed1_ = p;
  }
  return speed1_;
}
inline ::pathfinding::Vector* MovingLineObstacle::mutable_speed1() {
  // @@protoc_insertion_point(field_mutable:pathfinding.MovingLineObstacle.speed1)
  return _internal_mutable_speed1();
}
inline void MovingLineObstacle::set_allocated_speed1(::pathfinding::Vector* speed1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete speed1_;
  }
  if (speed1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(speed1);
    if (message_arena != submessage_arena) {
      speed1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, speed1, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  speed1_ = speed1;
  // @@protoc_insertion_point(field_set_allocated:pathfinding.MovingLineObstacle.speed1)
}

// optional .pathfinding.Vector acc1 = 3;
inline bool MovingLineObstacle::_internal_has_acc1() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || acc1_ != nullptr);
  return value;
}
inline bool MovingLineObstacle::has_acc1() const {
  return _internal_has_acc1();
}
inline void MovingLineObstacle::clear_acc1() {
  if (acc1_ != nullptr) acc1_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::pathfinding::Vector& MovingLineObstacle::_internal_acc1() const {
  const ::pathfinding::Vector* p = acc1_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pathfinding::Vector*>(
      &::pathfinding::_Vector_default_instance_);
}
inline const ::pathfinding::Vector& MovingLineObstacle::acc1() const {
  // @@protoc_insertion_point(field_get:pathfinding.MovingLineObstacle.acc1)
  return _internal_acc1();
}
inline void MovingLineObstacle::unsafe_arena_set_allocated_acc1(
    ::pathfinding::Vector* acc1) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(acc1_);
  }
  acc1_ = acc1;
  if (acc1) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pathfinding.MovingLineObstacle.acc1)
}
inline ::pathfinding::Vector* MovingLineObstacle::release_acc1() {
  auto temp = unsafe_arena_release_acc1();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pathfinding::Vector* MovingLineObstacle::unsafe_arena_release_acc1() {
  // @@protoc_insertion_point(field_release:pathfinding.MovingLineObstacle.acc1)
  _has_bits_[0] &= ~0x00000004u;
  ::pathfinding::Vector* temp = acc1_;
  acc1_ = nullptr;
  return temp;
}
inline ::pathfinding::Vector* MovingLineObstacle::_internal_mutable_acc1() {
  _has_bits_[0] |= 0x00000004u;
  if (acc1_ == nullptr) {
    auto* p = CreateMaybeMessage<::pathfinding::Vector>(GetArena());
    acc1_ = p;
  }
  return acc1_;
}
inline ::pathfinding::Vector* MovingLineObstacle::mutable_acc1() {
  // @@protoc_insertion_point(field_mutable:pathfinding.MovingLineObstacle.acc1)
  return _internal_mutable_acc1();
}
inline void MovingLineObstacle::set_allocated_acc1(::pathfinding::Vector* acc1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete acc1_;
  }
  if (acc1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(acc1);
    if (message_arena != submessage_arena) {
      acc1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, acc1, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  acc1_ = acc1;
  // @@protoc_insertion_point(field_set_allocated:pathfinding.MovingLineObstacle.acc1)
}

// optional .pathfinding.Vector start_pos2 = 4;
inline bool MovingLineObstacle::_internal_has_start_pos2() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || start_pos2_ != nullptr);
  return value;
}
inline bool MovingLineObstacle::has_start_pos2() const {
  return _internal_has_start_pos2();
}
inline void MovingLineObstacle::clear_start_pos2() {
  if (start_pos2_ != nullptr) start_pos2_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::pathfinding::Vector& MovingLineObstacle::_internal_start_pos2() const {
  const ::pathfinding::Vector* p = start_pos2_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pathfinding::Vector*>(
      &::pathfinding::_Vector_default_instance_);
}
inline const ::pathfinding::Vector& MovingLineObstacle::start_pos2() const {
  // @@protoc_insertion_point(field_get:pathfinding.MovingLineObstacle.start_pos2)
  return _internal_start_pos2();
}
inline void MovingLineObstacle::unsafe_arena_set_allocated_start_pos2(
    ::pathfinding::Vector* start_pos2) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_pos2_);
  }
  start_pos2_ = start_pos2;
  if (start_pos2) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pathfinding.MovingLineObstacle.start_pos2)
}
inline ::pathfinding::Vector* MovingLineObstacle::release_start_pos2() {
  auto temp = unsafe_arena_release_start_pos2();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pathfinding::Vector* MovingLineObstacle::unsafe_arena_release_start_pos2() {
  // @@protoc_insertion_point(field_release:pathfinding.MovingLineObstacle.start_pos2)
  _has_bits_[0] &= ~0x00000008u;
  ::pathfinding::Vector* temp = start_pos2_;
  start_pos2_ = nullptr;
  return temp;
}
inline ::pathfinding::Vector* MovingLineObstacle::_internal_mutable_start_pos2() {
  _has_bits_[0] |= 0x00000008u;
  if (start_pos2_ == nullptr) {
    auto* p = CreateMaybeMessage<::pathfinding::Vector>(GetArena());
    start_pos2_ = p;
  }
  return start_pos2_;
}
inline ::pathfinding::Vector* MovingLineObstacle::mutable_start_pos2() {
  // @@protoc_insertion_point(field_mutable:pathfinding.MovingLineObstacle.start_pos2)
  return _internal_mutable_start_pos2();
}
inline void MovingLineObstacle::set_allocated_start_pos2(::pathfinding::Vector* start_pos2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete start_pos2_;
  }
  if (start_pos2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(start_pos2);
    if (message_arena != submessage_arena) {
      start_pos2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_pos2, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  start_pos2_ = start_pos2;
  // @@protoc_insertion_point(field_set_allocated:pathfinding.MovingLineObstacle.start_pos2)
}

// optional .pathfinding.Vector speed2 = 5;
inline bool MovingLineObstacle::_internal_has_speed2() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || speed2_ != nullptr);
  return value;
}
inline bool MovingLineObstacle::has_speed2() const {
  return _internal_has_speed2();
}
inline void MovingLineObstacle::clear_speed2() {
  if (speed2_ != nullptr) speed2_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::pathfinding::Vector& MovingLineObstacle::_internal_speed2() const {
  const ::pathfinding::Vector* p = speed2_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pathfinding::Vector*>(
      &::pathfinding::_Vector_default_instance_);
}
inline const ::pathfinding::Vector& MovingLineObstacle::speed2() const {
  // @@protoc_insertion_point(field_get:pathfinding.MovingLineObstacle.speed2)
  return _internal_speed2();
}
inline void MovingLineObstacle::unsafe_arena_set_allocated_speed2(
    ::pathfinding::Vector* speed2) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(speed2_);
  }
  speed2_ = speed2;
  if (speed2) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pathfinding.MovingLineObstacle.speed2)
}
inline ::pathfinding::Vector* MovingLineObstacle::release_speed2() {
  auto temp = unsafe_arena_release_speed2();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pathfinding::Vector* MovingLineObstacle::unsafe_arena_release_speed2() {
  // @@protoc_insertion_point(field_release:pathfinding.MovingLineObstacle.speed2)
  _has_bits_[0] &= ~0x00000010u;
  ::pathfinding::Vector* temp = speed2_;
  speed2_ = nullptr;
  return temp;
}
inline ::pathfinding::Vector* MovingLineObstacle::_internal_mutable_speed2() {
  _has_bits_[0] |= 0x00000010u;
  if (speed2_ == nullptr) {
    auto* p = CreateMaybeMessage<::pathfinding::Vector>(GetArena());
    speed2_ = p;
  }
  return speed2_;
}
inline ::pathfinding::Vector* MovingLineObstacle::mutable_speed2() {
  // @@protoc_insertion_point(field_mutable:pathfinding.MovingLineObstacle.speed2)
  return _internal_mutable_speed2();
}
inline void MovingLineObstacle::set_allocated_speed2(::pathfinding::Vector* speed2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete speed2_;
  }
  if (speed2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(speed2);
    if (message_arena != submessage_arena) {
      speed2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, speed2, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  speed2_ = speed2;
  // @@protoc_insertion_point(field_set_allocated:pathfinding.MovingLineObstacle.speed2)
}

// optional .pathfinding.Vector acc2 = 6;
inline bool MovingLineObstacle::_internal_has_acc2() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || acc2_ != nullptr);
  return value;
}
inline bool MovingLineObstacle::has_acc2() const {
  return _internal_has_acc2();
}
inline void MovingLineObstacle::clear_acc2() {
  if (acc2_ != nullptr) acc2_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::pathfinding::Vector& MovingLineObstacle::_internal_acc2() const {
  const ::pathfinding::Vector* p = acc2_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pathfinding::Vector*>(
      &::pathfinding::_Vector_default_instance_);
}
inline const ::pathfinding::Vector& MovingLineObstacle::acc2() const {
  // @@protoc_insertion_point(field_get:pathfinding.MovingLineObstacle.acc2)
  return _internal_acc2();
}
inline void MovingLineObstacle::unsafe_arena_set_allocated_acc2(
    ::pathfinding::Vector* acc2) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(acc2_);
  }
  acc2_ = acc2;
  if (acc2) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pathfinding.MovingLineObstacle.acc2)
}
inline ::pathfinding::Vector* MovingLineObstacle::release_acc2() {
  auto temp = unsafe_arena_release_acc2();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pathfinding::Vector* MovingLineObstacle::unsafe_arena_release_acc2() {
  // @@protoc_insertion_point(field_release:pathfinding.MovingLineObstacle.acc2)
  _has_bits_[0] &= ~0x00000020u;
  ::pathfinding::Vector* temp = acc2_;
  acc2_ = nullptr;
  return temp;
}
inline ::pathfinding::Vector* MovingLineObstacle::_internal_mutable_acc2() {
  _has_bits_[0] |= 0x00000020u;
  if (acc2_ == nullptr) {
    auto* p = CreateMaybeMessage<::pathfinding::Vector>(GetArena());
    acc2_ = p;
  }
  return acc2_;
}
inline ::pathfinding::Vector* MovingLineObstacle::mutable_acc2() {
  // @@protoc_insertion_point(field_mutable:pathfinding.MovingLineObstacle.acc2)
  return _internal_mutable_acc2();
}
inline void MovingLineObstacle::set_allocated_acc2(::pathfinding::Vector* acc2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete acc2_;
  }
  if (acc2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(acc2);
    if (message_arena != submessage_arena) {
      acc2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, acc2, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  acc2_ = acc2;
  // @@protoc_insertion_point(field_set_allocated:pathfinding.MovingLineObstacle.acc2)
}

// optional float start_time = 7;
inline bool MovingLineObstacle::_internal_has_start_time() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool MovingLineObstacle::has_start_time() const {
  return _internal_has_start_time();
}
inline void MovingLineObstacle::clear_start_time() {
  start_time_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline float MovingLineObstacle::_internal_start_time() const {
  return start_time_;
}
inline float MovingLineObstacle::start_time() const {
  // @@protoc_insertion_point(field_get:pathfinding.MovingLineObstacle.start_time)
  return _internal_start_time();
}
inline void MovingLineObstacle::_internal_set_start_time(float value) {
  _has_bits_[0] |= 0x00000040u;
  start_time_ = value;
}
inline void MovingLineObstacle::set_start_time(float value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:pathfinding.MovingLineObstacle.start_time)
}

// optional float end_time = 8;
inline bool MovingLineObstacle::_internal_has_end_time() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool MovingLineObstacle::has_end_time() const {
  return _internal_has_end_time();
}
inline void MovingLineObstacle::clear_end_time() {
  end_time_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline float MovingLineObstacle::_internal_end_time() const {
  return end_time_;
}
inline float MovingLineObstacle::end_time() const {
  // @@protoc_insertion_point(field_get:pathfinding.MovingLineObstacle.end_time)
  return _internal_end_time();
}
inline void MovingLineObstacle::_internal_set_end_time(float value) {
  _has_bits_[0] |= 0x00000080u;
  end_time_ = value;
}
inline void MovingLineObstacle::set_end_time(float value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:pathfinding.MovingLineObstacle.end_time)
}

// -------------------------------------------------------------------

// TrajectoryPoint

// optional .pathfinding.Vector pos = 1;
inline bool TrajectoryPoint::_internal_has_pos() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || pos_ != nullptr);
  return value;
}
inline bool TrajectoryPoint::has_pos() const {
  return _internal_has_pos();
}
inline void TrajectoryPoint::clear_pos() {
  if (pos_ != nullptr) pos_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::pathfinding::Vector& TrajectoryPoint::_internal_pos() const {
  const ::pathfinding::Vector* p = pos_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pathfinding::Vector*>(
      &::pathfinding::_Vector_default_instance_);
}
inline const ::pathfinding::Vector& TrajectoryPoint::pos() const {
  // @@protoc_insertion_point(field_get:pathfinding.TrajectoryPoint.pos)
  return _internal_pos();
}
inline void TrajectoryPoint::unsafe_arena_set_allocated_pos(
    ::pathfinding::Vector* pos) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pos_);
  }
  pos_ = pos;
  if (pos) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pathfinding.TrajectoryPoint.pos)
}
inline ::pathfinding::Vector* TrajectoryPoint::release_pos() {
  auto temp = unsafe_arena_release_pos();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pathfinding::Vector* TrajectoryPoint::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:pathfinding.TrajectoryPoint.pos)
  _has_bits_[0] &= ~0x00000001u;
  ::pathfinding::Vector* temp = pos_;
  pos_ = nullptr;
  return temp;
}
inline ::pathfinding::Vector* TrajectoryPoint::_internal_mutable_pos() {
  _has_bits_[0] |= 0x00000001u;
  if (pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::pathfinding::Vector>(GetArena());
    pos_ = p;
  }
  return pos_;
}
inline ::pathfinding::Vector* TrajectoryPoint::mutable_pos() {
  // @@protoc_insertion_point(field_mutable:pathfinding.TrajectoryPoint.pos)
  return _internal_mutable_pos();
}
inline void TrajectoryPoint::set_allocated_pos(::pathfinding::Vector* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:pathfinding.TrajectoryPoint.pos)
}

// optional .pathfinding.Vector speed = 2;
inline bool TrajectoryPoint::_internal_has_speed() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || speed_ != nullptr);
  return value;
}
inline bool TrajectoryPoint::has_speed() const {
  return _internal_has_speed();
}
inline void TrajectoryPoint::clear_speed() {
  if (speed_ != nullptr) speed_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::pathfinding::Vector& TrajectoryPoint::_internal_speed() const {
  const ::pathfinding::Vector* p = speed_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pathfinding::Vector*>(
      &::pathfinding::_Vector_default_instance_);
}
inline const ::pathfinding::Vector& TrajectoryPoint::speed() const {
  // @@protoc_insertion_point(field_get:pathfinding.TrajectoryPoint.speed)
  return _internal_speed();
}
inline void TrajectoryPoint::unsafe_arena_set_allocated_speed(
    ::pathfinding::Vector* speed) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(speed_);
  }
  speed_ = speed;
  if (speed) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pathfinding.TrajectoryPoint.speed)
}
inline ::pathfinding::Vector* TrajectoryPoint::release_speed() {
  auto temp = unsafe_arena_release_speed();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pathfinding::Vector* TrajectoryPoint::unsafe_arena_release_speed() {
  // @@protoc_insertion_point(field_release:pathfinding.TrajectoryPoint.speed)
  _has_bits_[0] &= ~0x00000002u;
  ::pathfinding::Vector* temp = speed_;
  speed_ = nullptr;
  return temp;
}
inline ::pathfinding::Vector* TrajectoryPoint::_internal_mutable_speed() {
  _has_bits_[0] |= 0x00000002u;
  if (speed_ == nullptr) {
    auto* p = CreateMaybeMessage<::pathfinding::Vector>(GetArena());
    speed_ = p;
  }
  return speed_;
}
inline ::pathfinding::Vector* TrajectoryPoint::mutable_speed() {
  // @@protoc_insertion_point(field_mutable:pathfinding.TrajectoryPoint.speed)
  return _internal_mutable_speed();
}
inline void TrajectoryPoint::set_allocated_speed(::pathfinding::Vector* speed) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete speed_;
  }
  if (speed) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(speed);
    if (message_arena != submessage_arena) {
      speed = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, speed, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  speed_ = speed;
  // @@protoc_insertion_point(field_set_allocated:pathfinding.TrajectoryPoint.speed)
}

// optional float time = 3;
inline bool TrajectoryPoint::_internal_has_time() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TrajectoryPoint::has_time() const {
  return _internal_has_time();
}
inline void TrajectoryPoint::clear_time() {
  time_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float TrajectoryPoint::_internal_time() const {
  return time_;
}
inline float TrajectoryPoint::time() const {
  // @@protoc_insertion_point(field_get:pathfinding.TrajectoryPoint.time)
  return _internal_time();
}
inline void TrajectoryPoint::_internal_set_time(float value) {
  _has_bits_[0] |= 0x00000004u;
  time_ = value;
}
inline void TrajectoryPoint::set_time(float value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:pathfinding.TrajectoryPoint.time)
}

// -------------------------------------------------------------------

// FriendlyRobotObstacle

// repeated .pathfinding.TrajectoryPoint robot_trajectory = 1;
inline int FriendlyRobotObstacle::_internal_robot_trajectory_size() const {
  return robot_trajectory_.size();
}
inline int FriendlyRobotObstacle::robot_trajectory_size() const {
  return _internal_robot_trajectory_size();
}
inline void FriendlyRobotObstacle::clear_robot_trajectory() {
  robot_trajectory_.Clear();
}
inline ::pathfinding::TrajectoryPoint* FriendlyRobotObstacle::mutable_robot_trajectory(int index) {
  // @@protoc_insertion_point(field_mutable:pathfinding.FriendlyRobotObstacle.robot_trajectory)
  return robot_trajectory_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pathfinding::TrajectoryPoint >*
FriendlyRobotObstacle::mutable_robot_trajectory() {
  // @@protoc_insertion_point(field_mutable_list:pathfinding.FriendlyRobotObstacle.robot_trajectory)
  return &robot_trajectory_;
}
inline const ::pathfinding::TrajectoryPoint& FriendlyRobotObstacle::_internal_robot_trajectory(int index) const {
  return robot_trajectory_.Get(index);
}
inline const ::pathfinding::TrajectoryPoint& FriendlyRobotObstacle::robot_trajectory(int index) const {
  // @@protoc_insertion_point(field_get:pathfinding.FriendlyRobotObstacle.robot_trajectory)
  return _internal_robot_trajectory(index);
}
inline ::pathfinding::TrajectoryPoint* FriendlyRobotObstacle::_internal_add_robot_trajectory() {
  return robot_trajectory_.Add();
}
inline ::pathfinding::TrajectoryPoint* FriendlyRobotObstacle::add_robot_trajectory() {
  // @@protoc_insertion_point(field_add:pathfinding.FriendlyRobotObstacle.robot_trajectory)
  return _internal_add_robot_trajectory();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pathfinding::TrajectoryPoint >&
FriendlyRobotObstacle::robot_trajectory() const {
  // @@protoc_insertion_point(field_list:pathfinding.FriendlyRobotObstacle.robot_trajectory)
  return robot_trajectory_;
}

// -------------------------------------------------------------------

// OpponentRobotObstacle

// optional .pathfinding.Vector start_pos = 1;
inline bool OpponentRobotObstacle::_internal_has_start_pos() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || start_pos_ != nullptr);
  return value;
}
inline bool OpponentRobotObstacle::has_start_pos() const {
  return _internal_has_start_pos();
}
inline void OpponentRobotObstacle::clear_start_pos() {
  if (start_pos_ != nullptr) start_pos_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::pathfinding::Vector& OpponentRobotObstacle::_internal_start_pos() const {
  const ::pathfinding::Vector* p = start_pos_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pathfinding::Vector*>(
      &::pathfinding::_Vector_default_instance_);
}
inline const ::pathfinding::Vector& OpponentRobotObstacle::start_pos() const {
  // @@protoc_insertion_point(field_get:pathfinding.OpponentRobotObstacle.start_pos)
  return _internal_start_pos();
}
inline void OpponentRobotObstacle::unsafe_arena_set_allocated_start_pos(
    ::pathfinding::Vector* start_pos) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_pos_);
  }
  start_pos_ = start_pos;
  if (start_pos) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pathfinding.OpponentRobotObstacle.start_pos)
}
inline ::pathfinding::Vector* OpponentRobotObstacle::release_start_pos() {
  auto temp = unsafe_arena_release_start_pos();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pathfinding::Vector* OpponentRobotObstacle::unsafe_arena_release_start_pos() {
  // @@protoc_insertion_point(field_release:pathfinding.OpponentRobotObstacle.start_pos)
  _has_bits_[0] &= ~0x00000001u;
  ::pathfinding::Vector* temp = start_pos_;
  start_pos_ = nullptr;
  return temp;
}
inline ::pathfinding::Vector* OpponentRobotObstacle::_internal_mutable_start_pos() {
  _has_bits_[0] |= 0x00000001u;
  if (start_pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::pathfinding::Vector>(GetArena());
    start_pos_ = p;
  }
  return start_pos_;
}
inline ::pathfinding::Vector* OpponentRobotObstacle::mutable_start_pos() {
  // @@protoc_insertion_point(field_mutable:pathfinding.OpponentRobotObstacle.start_pos)
  return _internal_mutable_start_pos();
}
inline void OpponentRobotObstacle::set_allocated_start_pos(::pathfinding::Vector* start_pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete start_pos_;
  }
  if (start_pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(start_pos);
    if (message_arena != submessage_arena) {
      start_pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_pos, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  start_pos_ = start_pos;
  // @@protoc_insertion_point(field_set_allocated:pathfinding.OpponentRobotObstacle.start_pos)
}

// optional .pathfinding.Vector speed = 2;
inline bool OpponentRobotObstacle::_internal_has_speed() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || speed_ != nullptr);
  return value;
}
inline bool OpponentRobotObstacle::has_speed() const {
  return _internal_has_speed();
}
inline void OpponentRobotObstacle::clear_speed() {
  if (speed_ != nullptr) speed_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::pathfinding::Vector& OpponentRobotObstacle::_internal_speed() const {
  const ::pathfinding::Vector* p = speed_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pathfinding::Vector*>(
      &::pathfinding::_Vector_default_instance_);
}
inline const ::pathfinding::Vector& OpponentRobotObstacle::speed() const {
  // @@protoc_insertion_point(field_get:pathfinding.OpponentRobotObstacle.speed)
  return _internal_speed();
}
inline void OpponentRobotObstacle::unsafe_arena_set_allocated_speed(
    ::pathfinding::Vector* speed) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(speed_);
  }
  speed_ = speed;
  if (speed) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pathfinding.OpponentRobotObstacle.speed)
}
inline ::pathfinding::Vector* OpponentRobotObstacle::release_speed() {
  auto temp = unsafe_arena_release_speed();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pathfinding::Vector* OpponentRobotObstacle::unsafe_arena_release_speed() {
  // @@protoc_insertion_point(field_release:pathfinding.OpponentRobotObstacle.speed)
  _has_bits_[0] &= ~0x00000002u;
  ::pathfinding::Vector* temp = speed_;
  speed_ = nullptr;
  return temp;
}
inline ::pathfinding::Vector* OpponentRobotObstacle::_internal_mutable_speed() {
  _has_bits_[0] |= 0x00000002u;
  if (speed_ == nullptr) {
    auto* p = CreateMaybeMessage<::pathfinding::Vector>(GetArena());
    speed_ = p;
  }
  return speed_;
}
inline ::pathfinding::Vector* OpponentRobotObstacle::mutable_speed() {
  // @@protoc_insertion_point(field_mutable:pathfinding.OpponentRobotObstacle.speed)
  return _internal_mutable_speed();
}
inline void OpponentRobotObstacle::set_allocated_speed(::pathfinding::Vector* speed) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete speed_;
  }
  if (speed) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(speed);
    if (message_arena != submessage_arena) {
      speed = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, speed, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  speed_ = speed;
  // @@protoc_insertion_point(field_set_allocated:pathfinding.OpponentRobotObstacle.speed)
}

// -------------------------------------------------------------------

// Obstacle

// optional string name = 1;
inline bool Obstacle::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Obstacle::has_name() const {
  return _internal_has_name();
}
inline void Obstacle::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Obstacle::name() const {
  // @@protoc_insertion_point(field_get:pathfinding.Obstacle.name)
  return _internal_name();
}
inline void Obstacle::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:pathfinding.Obstacle.name)
}
inline std::string* Obstacle::mutable_name() {
  // @@protoc_insertion_point(field_mutable:pathfinding.Obstacle.name)
  return _internal_mutable_name();
}
inline const std::string& Obstacle::_internal_name() const {
  return name_.Get();
}
inline void Obstacle::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Obstacle::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pathfinding.Obstacle.name)
}
inline void Obstacle::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:pathfinding.Obstacle.name)
}
inline void Obstacle::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pathfinding.Obstacle.name)
}
inline std::string* Obstacle::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Obstacle::release_name() {
  // @@protoc_insertion_point(field_release:pathfinding.Obstacle.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Obstacle::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pathfinding.Obstacle.name)
}
inline std::string* Obstacle::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pathfinding.Obstacle.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Obstacle::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pathfinding.Obstacle.name)
}

// optional int32 prio = 2;
inline bool Obstacle::_internal_has_prio() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Obstacle::has_prio() const {
  return _internal_has_prio();
}
inline void Obstacle::clear_prio() {
  prio_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Obstacle::_internal_prio() const {
  return prio_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Obstacle::prio() const {
  // @@protoc_insertion_point(field_get:pathfinding.Obstacle.prio)
  return _internal_prio();
}
inline void Obstacle::_internal_set_prio(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  prio_ = value;
}
inline void Obstacle::set_prio(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_prio(value);
  // @@protoc_insertion_point(field_set:pathfinding.Obstacle.prio)
}

// optional float radius = 3;
inline bool Obstacle::_internal_has_radius() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Obstacle::has_radius() const {
  return _internal_has_radius();
}
inline void Obstacle::clear_radius() {
  radius_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float Obstacle::_internal_radius() const {
  return radius_;
}
inline float Obstacle::radius() const {
  // @@protoc_insertion_point(field_get:pathfinding.Obstacle.radius)
  return _internal_radius();
}
inline void Obstacle::_internal_set_radius(float value) {
  _has_bits_[0] |= 0x00000004u;
  radius_ = value;
}
inline void Obstacle::set_radius(float value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:pathfinding.Obstacle.radius)
}

// .pathfinding.CircleObstacle circle = 4;
inline bool Obstacle::_internal_has_circle() const {
  return obstacle_case() == kCircle;
}
inline bool Obstacle::has_circle() const {
  return _internal_has_circle();
}
inline void Obstacle::set_has_circle() {
  _oneof_case_[0] = kCircle;
}
inline void Obstacle::clear_circle() {
  if (_internal_has_circle()) {
    if (GetArena() == nullptr) {
      delete obstacle_.circle_;
    }
    clear_has_obstacle();
  }
}
inline ::pathfinding::CircleObstacle* Obstacle::release_circle() {
  // @@protoc_insertion_point(field_release:pathfinding.Obstacle.circle)
  if (_internal_has_circle()) {
    clear_has_obstacle();
      ::pathfinding::CircleObstacle* temp = obstacle_.circle_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    obstacle_.circle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pathfinding::CircleObstacle& Obstacle::_internal_circle() const {
  return _internal_has_circle()
      ? *obstacle_.circle_
      : *reinterpret_cast< ::pathfinding::CircleObstacle*>(&::pathfinding::_CircleObstacle_default_instance_);
}
inline const ::pathfinding::CircleObstacle& Obstacle::circle() const {
  // @@protoc_insertion_point(field_get:pathfinding.Obstacle.circle)
  return _internal_circle();
}
inline ::pathfinding::CircleObstacle* Obstacle::unsafe_arena_release_circle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pathfinding.Obstacle.circle)
  if (_internal_has_circle()) {
    clear_has_obstacle();
    ::pathfinding::CircleObstacle* temp = obstacle_.circle_;
    obstacle_.circle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Obstacle::unsafe_arena_set_allocated_circle(::pathfinding::CircleObstacle* circle) {
  clear_obstacle();
  if (circle) {
    set_has_circle();
    obstacle_.circle_ = circle;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pathfinding.Obstacle.circle)
}
inline ::pathfinding::CircleObstacle* Obstacle::_internal_mutable_circle() {
  if (!_internal_has_circle()) {
    clear_obstacle();
    set_has_circle();
    obstacle_.circle_ = CreateMaybeMessage< ::pathfinding::CircleObstacle >(GetArena());
  }
  return obstacle_.circle_;
}
inline ::pathfinding::CircleObstacle* Obstacle::mutable_circle() {
  // @@protoc_insertion_point(field_mutable:pathfinding.Obstacle.circle)
  return _internal_mutable_circle();
}

// .pathfinding.RectObstacle rectangle = 5;
inline bool Obstacle::_internal_has_rectangle() const {
  return obstacle_case() == kRectangle;
}
inline bool Obstacle::has_rectangle() const {
  return _internal_has_rectangle();
}
inline void Obstacle::set_has_rectangle() {
  _oneof_case_[0] = kRectangle;
}
inline void Obstacle::clear_rectangle() {
  if (_internal_has_rectangle()) {
    if (GetArena() == nullptr) {
      delete obstacle_.rectangle_;
    }
    clear_has_obstacle();
  }
}
inline ::pathfinding::RectObstacle* Obstacle::release_rectangle() {
  // @@protoc_insertion_point(field_release:pathfinding.Obstacle.rectangle)
  if (_internal_has_rectangle()) {
    clear_has_obstacle();
      ::pathfinding::RectObstacle* temp = obstacle_.rectangle_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    obstacle_.rectangle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pathfinding::RectObstacle& Obstacle::_internal_rectangle() const {
  return _internal_has_rectangle()
      ? *obstacle_.rectangle_
      : *reinterpret_cast< ::pathfinding::RectObstacle*>(&::pathfinding::_RectObstacle_default_instance_);
}
inline const ::pathfinding::RectObstacle& Obstacle::rectangle() const {
  // @@protoc_insertion_point(field_get:pathfinding.Obstacle.rectangle)
  return _internal_rectangle();
}
inline ::pathfinding::RectObstacle* Obstacle::unsafe_arena_release_rectangle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pathfinding.Obstacle.rectangle)
  if (_internal_has_rectangle()) {
    clear_has_obstacle();
    ::pathfinding::RectObstacle* temp = obstacle_.rectangle_;
    obstacle_.rectangle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Obstacle::unsafe_arena_set_allocated_rectangle(::pathfinding::RectObstacle* rectangle) {
  clear_obstacle();
  if (rectangle) {
    set_has_rectangle();
    obstacle_.rectangle_ = rectangle;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pathfinding.Obstacle.rectangle)
}
inline ::pathfinding::RectObstacle* Obstacle::_internal_mutable_rectangle() {
  if (!_internal_has_rectangle()) {
    clear_obstacle();
    set_has_rectangle();
    obstacle_.rectangle_ = CreateMaybeMessage< ::pathfinding::RectObstacle >(GetArena());
  }
  return obstacle_.rectangle_;
}
inline ::pathfinding::RectObstacle* Obstacle::mutable_rectangle() {
  // @@protoc_insertion_point(field_mutable:pathfinding.Obstacle.rectangle)
  return _internal_mutable_rectangle();
}

// .pathfinding.TriangleObstacle triangle = 6;
inline bool Obstacle::_internal_has_triangle() const {
  return obstacle_case() == kTriangle;
}
inline bool Obstacle::has_triangle() const {
  return _internal_has_triangle();
}
inline void Obstacle::set_has_triangle() {
  _oneof_case_[0] = kTriangle;
}
inline void Obstacle::clear_triangle() {
  if (_internal_has_triangle()) {
    if (GetArena() == nullptr) {
      delete obstacle_.triangle_;
    }
    clear_has_obstacle();
  }
}
inline ::pathfinding::TriangleObstacle* Obstacle::release_triangle() {
  // @@protoc_insertion_point(field_release:pathfinding.Obstacle.triangle)
  if (_internal_has_triangle()) {
    clear_has_obstacle();
      ::pathfinding::TriangleObstacle* temp = obstacle_.triangle_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    obstacle_.triangle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pathfinding::TriangleObstacle& Obstacle::_internal_triangle() const {
  return _internal_has_triangle()
      ? *obstacle_.triangle_
      : *reinterpret_cast< ::pathfinding::TriangleObstacle*>(&::pathfinding::_TriangleObstacle_default_instance_);
}
inline const ::pathfinding::TriangleObstacle& Obstacle::triangle() const {
  // @@protoc_insertion_point(field_get:pathfinding.Obstacle.triangle)
  return _internal_triangle();
}
inline ::pathfinding::TriangleObstacle* Obstacle::unsafe_arena_release_triangle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pathfinding.Obstacle.triangle)
  if (_internal_has_triangle()) {
    clear_has_obstacle();
    ::pathfinding::TriangleObstacle* temp = obstacle_.triangle_;
    obstacle_.triangle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Obstacle::unsafe_arena_set_allocated_triangle(::pathfinding::TriangleObstacle* triangle) {
  clear_obstacle();
  if (triangle) {
    set_has_triangle();
    obstacle_.triangle_ = triangle;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pathfinding.Obstacle.triangle)
}
inline ::pathfinding::TriangleObstacle* Obstacle::_internal_mutable_triangle() {
  if (!_internal_has_triangle()) {
    clear_obstacle();
    set_has_triangle();
    obstacle_.triangle_ = CreateMaybeMessage< ::pathfinding::TriangleObstacle >(GetArena());
  }
  return obstacle_.triangle_;
}
inline ::pathfinding::TriangleObstacle* Obstacle::mutable_triangle() {
  // @@protoc_insertion_point(field_mutable:pathfinding.Obstacle.triangle)
  return _internal_mutable_triangle();
}

// .pathfinding.LineObstacle line = 7;
inline bool Obstacle::_internal_has_line() const {
  return obstacle_case() == kLine;
}
inline bool Obstacle::has_line() const {
  return _internal_has_line();
}
inline void Obstacle::set_has_line() {
  _oneof_case_[0] = kLine;
}
inline void Obstacle::clear_line() {
  if (_internal_has_line()) {
    if (GetArena() == nullptr) {
      delete obstacle_.line_;
    }
    clear_has_obstacle();
  }
}
inline ::pathfinding::LineObstacle* Obstacle::release_line() {
  // @@protoc_insertion_point(field_release:pathfinding.Obstacle.line)
  if (_internal_has_line()) {
    clear_has_obstacle();
      ::pathfinding::LineObstacle* temp = obstacle_.line_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    obstacle_.line_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pathfinding::LineObstacle& Obstacle::_internal_line() const {
  return _internal_has_line()
      ? *obstacle_.line_
      : *reinterpret_cast< ::pathfinding::LineObstacle*>(&::pathfinding::_LineObstacle_default_instance_);
}
inline const ::pathfinding::LineObstacle& Obstacle::line() const {
  // @@protoc_insertion_point(field_get:pathfinding.Obstacle.line)
  return _internal_line();
}
inline ::pathfinding::LineObstacle* Obstacle::unsafe_arena_release_line() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pathfinding.Obstacle.line)
  if (_internal_has_line()) {
    clear_has_obstacle();
    ::pathfinding::LineObstacle* temp = obstacle_.line_;
    obstacle_.line_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Obstacle::unsafe_arena_set_allocated_line(::pathfinding::LineObstacle* line) {
  clear_obstacle();
  if (line) {
    set_has_line();
    obstacle_.line_ = line;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pathfinding.Obstacle.line)
}
inline ::pathfinding::LineObstacle* Obstacle::_internal_mutable_line() {
  if (!_internal_has_line()) {
    clear_obstacle();
    set_has_line();
    obstacle_.line_ = CreateMaybeMessage< ::pathfinding::LineObstacle >(GetArena());
  }
  return obstacle_.line_;
}
inline ::pathfinding::LineObstacle* Obstacle::mutable_line() {
  // @@protoc_insertion_point(field_mutable:pathfinding.Obstacle.line)
  return _internal_mutable_line();
}

// .pathfinding.MovingCircleObstacle moving_circle = 9;
inline bool Obstacle::_internal_has_moving_circle() const {
  return obstacle_case() == kMovingCircle;
}
inline bool Obstacle::has_moving_circle() const {
  return _internal_has_moving_circle();
}
inline void Obstacle::set_has_moving_circle() {
  _oneof_case_[0] = kMovingCircle;
}
inline void Obstacle::clear_moving_circle() {
  if (_internal_has_moving_circle()) {
    if (GetArena() == nullptr) {
      delete obstacle_.moving_circle_;
    }
    clear_has_obstacle();
  }
}
inline ::pathfinding::MovingCircleObstacle* Obstacle::release_moving_circle() {
  // @@protoc_insertion_point(field_release:pathfinding.Obstacle.moving_circle)
  if (_internal_has_moving_circle()) {
    clear_has_obstacle();
      ::pathfinding::MovingCircleObstacle* temp = obstacle_.moving_circle_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    obstacle_.moving_circle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pathfinding::MovingCircleObstacle& Obstacle::_internal_moving_circle() const {
  return _internal_has_moving_circle()
      ? *obstacle_.moving_circle_
      : *reinterpret_cast< ::pathfinding::MovingCircleObstacle*>(&::pathfinding::_MovingCircleObstacle_default_instance_);
}
inline const ::pathfinding::MovingCircleObstacle& Obstacle::moving_circle() const {
  // @@protoc_insertion_point(field_get:pathfinding.Obstacle.moving_circle)
  return _internal_moving_circle();
}
inline ::pathfinding::MovingCircleObstacle* Obstacle::unsafe_arena_release_moving_circle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pathfinding.Obstacle.moving_circle)
  if (_internal_has_moving_circle()) {
    clear_has_obstacle();
    ::pathfinding::MovingCircleObstacle* temp = obstacle_.moving_circle_;
    obstacle_.moving_circle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Obstacle::unsafe_arena_set_allocated_moving_circle(::pathfinding::MovingCircleObstacle* moving_circle) {
  clear_obstacle();
  if (moving_circle) {
    set_has_moving_circle();
    obstacle_.moving_circle_ = moving_circle;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pathfinding.Obstacle.moving_circle)
}
inline ::pathfinding::MovingCircleObstacle* Obstacle::_internal_mutable_moving_circle() {
  if (!_internal_has_moving_circle()) {
    clear_obstacle();
    set_has_moving_circle();
    obstacle_.moving_circle_ = CreateMaybeMessage< ::pathfinding::MovingCircleObstacle >(GetArena());
  }
  return obstacle_.moving_circle_;
}
inline ::pathfinding::MovingCircleObstacle* Obstacle::mutable_moving_circle() {
  // @@protoc_insertion_point(field_mutable:pathfinding.Obstacle.moving_circle)
  return _internal_mutable_moving_circle();
}

// .pathfinding.MovingLineObstacle moving_line = 10;
inline bool Obstacle::_internal_has_moving_line() const {
  return obstacle_case() == kMovingLine;
}
inline bool Obstacle::has_moving_line() const {
  return _internal_has_moving_line();
}
inline void Obstacle::set_has_moving_line() {
  _oneof_case_[0] = kMovingLine;
}
inline void Obstacle::clear_moving_line() {
  if (_internal_has_moving_line()) {
    if (GetArena() == nullptr) {
      delete obstacle_.moving_line_;
    }
    clear_has_obstacle();
  }
}
inline ::pathfinding::MovingLineObstacle* Obstacle::release_moving_line() {
  // @@protoc_insertion_point(field_release:pathfinding.Obstacle.moving_line)
  if (_internal_has_moving_line()) {
    clear_has_obstacle();
      ::pathfinding::MovingLineObstacle* temp = obstacle_.moving_line_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    obstacle_.moving_line_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pathfinding::MovingLineObstacle& Obstacle::_internal_moving_line() const {
  return _internal_has_moving_line()
      ? *obstacle_.moving_line_
      : *reinterpret_cast< ::pathfinding::MovingLineObstacle*>(&::pathfinding::_MovingLineObstacle_default_instance_);
}
inline const ::pathfinding::MovingLineObstacle& Obstacle::moving_line() const {
  // @@protoc_insertion_point(field_get:pathfinding.Obstacle.moving_line)
  return _internal_moving_line();
}
inline ::pathfinding::MovingLineObstacle* Obstacle::unsafe_arena_release_moving_line() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pathfinding.Obstacle.moving_line)
  if (_internal_has_moving_line()) {
    clear_has_obstacle();
    ::pathfinding::MovingLineObstacle* temp = obstacle_.moving_line_;
    obstacle_.moving_line_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Obstacle::unsafe_arena_set_allocated_moving_line(::pathfinding::MovingLineObstacle* moving_line) {
  clear_obstacle();
  if (moving_line) {
    set_has_moving_line();
    obstacle_.moving_line_ = moving_line;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pathfinding.Obstacle.moving_line)
}
inline ::pathfinding::MovingLineObstacle* Obstacle::_internal_mutable_moving_line() {
  if (!_internal_has_moving_line()) {
    clear_obstacle();
    set_has_moving_line();
    obstacle_.moving_line_ = CreateMaybeMessage< ::pathfinding::MovingLineObstacle >(GetArena());
  }
  return obstacle_.moving_line_;
}
inline ::pathfinding::MovingLineObstacle* Obstacle::mutable_moving_line() {
  // @@protoc_insertion_point(field_mutable:pathfinding.Obstacle.moving_line)
  return _internal_mutable_moving_line();
}

// .pathfinding.FriendlyRobotObstacle friendly_robot = 11;
inline bool Obstacle::_internal_has_friendly_robot() const {
  return obstacle_case() == kFriendlyRobot;
}
inline bool Obstacle::has_friendly_robot() const {
  return _internal_has_friendly_robot();
}
inline void Obstacle::set_has_friendly_robot() {
  _oneof_case_[0] = kFriendlyRobot;
}
inline void Obstacle::clear_friendly_robot() {
  if (_internal_has_friendly_robot()) {
    if (GetArena() == nullptr) {
      delete obstacle_.friendly_robot_;
    }
    clear_has_obstacle();
  }
}
inline ::pathfinding::FriendlyRobotObstacle* Obstacle::release_friendly_robot() {
  // @@protoc_insertion_point(field_release:pathfinding.Obstacle.friendly_robot)
  if (_internal_has_friendly_robot()) {
    clear_has_obstacle();
      ::pathfinding::FriendlyRobotObstacle* temp = obstacle_.friendly_robot_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    obstacle_.friendly_robot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pathfinding::FriendlyRobotObstacle& Obstacle::_internal_friendly_robot() const {
  return _internal_has_friendly_robot()
      ? *obstacle_.friendly_robot_
      : *reinterpret_cast< ::pathfinding::FriendlyRobotObstacle*>(&::pathfinding::_FriendlyRobotObstacle_default_instance_);
}
inline const ::pathfinding::FriendlyRobotObstacle& Obstacle::friendly_robot() const {
  // @@protoc_insertion_point(field_get:pathfinding.Obstacle.friendly_robot)
  return _internal_friendly_robot();
}
inline ::pathfinding::FriendlyRobotObstacle* Obstacle::unsafe_arena_release_friendly_robot() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pathfinding.Obstacle.friendly_robot)
  if (_internal_has_friendly_robot()) {
    clear_has_obstacle();
    ::pathfinding::FriendlyRobotObstacle* temp = obstacle_.friendly_robot_;
    obstacle_.friendly_robot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Obstacle::unsafe_arena_set_allocated_friendly_robot(::pathfinding::FriendlyRobotObstacle* friendly_robot) {
  clear_obstacle();
  if (friendly_robot) {
    set_has_friendly_robot();
    obstacle_.friendly_robot_ = friendly_robot;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pathfinding.Obstacle.friendly_robot)
}
inline ::pathfinding::FriendlyRobotObstacle* Obstacle::_internal_mutable_friendly_robot() {
  if (!_internal_has_friendly_robot()) {
    clear_obstacle();
    set_has_friendly_robot();
    obstacle_.friendly_robot_ = CreateMaybeMessage< ::pathfinding::FriendlyRobotObstacle >(GetArena());
  }
  return obstacle_.friendly_robot_;
}
inline ::pathfinding::FriendlyRobotObstacle* Obstacle::mutable_friendly_robot() {
  // @@protoc_insertion_point(field_mutable:pathfinding.Obstacle.friendly_robot)
  return _internal_mutable_friendly_robot();
}

// .pathfinding.OpponentRobotObstacle opponent_robot = 12;
inline bool Obstacle::_internal_has_opponent_robot() const {
  return obstacle_case() == kOpponentRobot;
}
inline bool Obstacle::has_opponent_robot() const {
  return _internal_has_opponent_robot();
}
inline void Obstacle::set_has_opponent_robot() {
  _oneof_case_[0] = kOpponentRobot;
}
inline void Obstacle::clear_opponent_robot() {
  if (_internal_has_opponent_robot()) {
    if (GetArena() == nullptr) {
      delete obstacle_.opponent_robot_;
    }
    clear_has_obstacle();
  }
}
inline ::pathfinding::OpponentRobotObstacle* Obstacle::release_opponent_robot() {
  // @@protoc_insertion_point(field_release:pathfinding.Obstacle.opponent_robot)
  if (_internal_has_opponent_robot()) {
    clear_has_obstacle();
      ::pathfinding::OpponentRobotObstacle* temp = obstacle_.opponent_robot_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    obstacle_.opponent_robot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pathfinding::OpponentRobotObstacle& Obstacle::_internal_opponent_robot() const {
  return _internal_has_opponent_robot()
      ? *obstacle_.opponent_robot_
      : *reinterpret_cast< ::pathfinding::OpponentRobotObstacle*>(&::pathfinding::_OpponentRobotObstacle_default_instance_);
}
inline const ::pathfinding::OpponentRobotObstacle& Obstacle::opponent_robot() const {
  // @@protoc_insertion_point(field_get:pathfinding.Obstacle.opponent_robot)
  return _internal_opponent_robot();
}
inline ::pathfinding::OpponentRobotObstacle* Obstacle::unsafe_arena_release_opponent_robot() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pathfinding.Obstacle.opponent_robot)
  if (_internal_has_opponent_robot()) {
    clear_has_obstacle();
    ::pathfinding::OpponentRobotObstacle* temp = obstacle_.opponent_robot_;
    obstacle_.opponent_robot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Obstacle::unsafe_arena_set_allocated_opponent_robot(::pathfinding::OpponentRobotObstacle* opponent_robot) {
  clear_obstacle();
  if (opponent_robot) {
    set_has_opponent_robot();
    obstacle_.opponent_robot_ = opponent_robot;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pathfinding.Obstacle.opponent_robot)
}
inline ::pathfinding::OpponentRobotObstacle* Obstacle::_internal_mutable_opponent_robot() {
  if (!_internal_has_opponent_robot()) {
    clear_obstacle();
    set_has_opponent_robot();
    obstacle_.opponent_robot_ = CreateMaybeMessage< ::pathfinding::OpponentRobotObstacle >(GetArena());
  }
  return obstacle_.opponent_robot_;
}
inline ::pathfinding::OpponentRobotObstacle* Obstacle::mutable_opponent_robot() {
  // @@protoc_insertion_point(field_mutable:pathfinding.Obstacle.opponent_robot)
  return _internal_mutable_opponent_robot();
}

inline bool Obstacle::has_obstacle() const {
  return obstacle_case() != OBSTACLE_NOT_SET;
}
inline void Obstacle::clear_has_obstacle() {
  _oneof_case_[0] = OBSTACLE_NOT_SET;
}
inline Obstacle::ObstacleCase Obstacle::obstacle_case() const {
  return Obstacle::ObstacleCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// WorldState

// repeated .pathfinding.Obstacle obstacles = 1;
inline int WorldState::_internal_obstacles_size() const {
  return obstacles_.size();
}
inline int WorldState::obstacles_size() const {
  return _internal_obstacles_size();
}
inline void WorldState::clear_obstacles() {
  obstacles_.Clear();
}
inline ::pathfinding::Obstacle* WorldState::mutable_obstacles(int index) {
  // @@protoc_insertion_point(field_mutable:pathfinding.WorldState.obstacles)
  return obstacles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pathfinding::Obstacle >*
WorldState::mutable_obstacles() {
  // @@protoc_insertion_point(field_mutable_list:pathfinding.WorldState.obstacles)
  return &obstacles_;
}
inline const ::pathfinding::Obstacle& WorldState::_internal_obstacles(int index) const {
  return obstacles_.Get(index);
}
inline const ::pathfinding::Obstacle& WorldState::obstacles(int index) const {
  // @@protoc_insertion_point(field_get:pathfinding.WorldState.obstacles)
  return _internal_obstacles(index);
}
inline ::pathfinding::Obstacle* WorldState::_internal_add_obstacles() {
  return obstacles_.Add();
}
inline ::pathfinding::Obstacle* WorldState::add_obstacles() {
  // @@protoc_insertion_point(field_add:pathfinding.WorldState.obstacles)
  return _internal_add_obstacles();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pathfinding::Obstacle >&
WorldState::obstacles() const {
  // @@protoc_insertion_point(field_list:pathfinding.WorldState.obstacles)
  return obstacles_;
}

// optional uint32 out_of_field_priority = 2;
inline bool WorldState::_internal_has_out_of_field_priority() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool WorldState::has_out_of_field_priority() const {
  return _internal_has_out_of_field_priority();
}
inline void WorldState::clear_out_of_field_priority() {
  out_of_field_priority_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 WorldState::_internal_out_of_field_priority() const {
  return out_of_field_priority_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 WorldState::out_of_field_priority() const {
  // @@protoc_insertion_point(field_get:pathfinding.WorldState.out_of_field_priority)
  return _internal_out_of_field_priority();
}
inline void WorldState::_internal_set_out_of_field_priority(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  out_of_field_priority_ = value;
}
inline void WorldState::set_out_of_field_priority(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_out_of_field_priority(value);
  // @@protoc_insertion_point(field_set:pathfinding.WorldState.out_of_field_priority)
}

// optional .pathfinding.RectObstacle boundary = 3;
inline bool WorldState::_internal_has_boundary() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || boundary_ != nullptr);
  return value;
}
inline bool WorldState::has_boundary() const {
  return _internal_has_boundary();
}
inline void WorldState::clear_boundary() {
  if (boundary_ != nullptr) boundary_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::pathfinding::RectObstacle& WorldState::_internal_boundary() const {
  const ::pathfinding::RectObstacle* p = boundary_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pathfinding::RectObstacle*>(
      &::pathfinding::_RectObstacle_default_instance_);
}
inline const ::pathfinding::RectObstacle& WorldState::boundary() const {
  // @@protoc_insertion_point(field_get:pathfinding.WorldState.boundary)
  return _internal_boundary();
}
inline void WorldState::unsafe_arena_set_allocated_boundary(
    ::pathfinding::RectObstacle* boundary) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(boundary_);
  }
  boundary_ = boundary;
  if (boundary) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pathfinding.WorldState.boundary)
}
inline ::pathfinding::RectObstacle* WorldState::release_boundary() {
  auto temp = unsafe_arena_release_boundary();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pathfinding::RectObstacle* WorldState::unsafe_arena_release_boundary() {
  // @@protoc_insertion_point(field_release:pathfinding.WorldState.boundary)
  _has_bits_[0] &= ~0x00000001u;
  ::pathfinding::RectObstacle* temp = boundary_;
  boundary_ = nullptr;
  return temp;
}
inline ::pathfinding::RectObstacle* WorldState::_internal_mutable_boundary() {
  _has_bits_[0] |= 0x00000001u;
  if (boundary_ == nullptr) {
    auto* p = CreateMaybeMessage<::pathfinding::RectObstacle>(GetArena());
    boundary_ = p;
  }
  return boundary_;
}
inline ::pathfinding::RectObstacle* WorldState::mutable_boundary() {
  // @@protoc_insertion_point(field_mutable:pathfinding.WorldState.boundary)
  return _internal_mutable_boundary();
}
inline void WorldState::set_allocated_boundary(::pathfinding::RectObstacle* boundary) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete boundary_;
  }
  if (boundary) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(boundary);
    if (message_arena != submessage_arena) {
      boundary = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, boundary, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  boundary_ = boundary;
  // @@protoc_insertion_point(field_set_allocated:pathfinding.WorldState.boundary)
}

// optional float radius = 4;
inline bool WorldState::_internal_has_radius() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool WorldState::has_radius() const {
  return _internal_has_radius();
}
inline void WorldState::clear_radius() {
  radius_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float WorldState::_internal_radius() const {
  return radius_;
}
inline float WorldState::radius() const {
  // @@protoc_insertion_point(field_get:pathfinding.WorldState.radius)
  return _internal_radius();
}
inline void WorldState::_internal_set_radius(float value) {
  _has_bits_[0] |= 0x00000004u;
  radius_ = value;
}
inline void WorldState::set_radius(float value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:pathfinding.WorldState.radius)
}

// optional uint32 robot_id = 5;
inline bool WorldState::_internal_has_robot_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool WorldState::has_robot_id() const {
  return _internal_has_robot_id();
}
inline void WorldState::clear_robot_id() {
  robot_id_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 WorldState::_internal_robot_id() const {
  return robot_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 WorldState::robot_id() const {
  // @@protoc_insertion_point(field_get:pathfinding.WorldState.robot_id)
  return _internal_robot_id();
}
inline void WorldState::_internal_set_robot_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  robot_id_ = value;
}
inline void WorldState::set_robot_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_robot_id(value);
  // @@protoc_insertion_point(field_set:pathfinding.WorldState.robot_id)
}

// -------------------------------------------------------------------

// TrajectoryInput

// optional .pathfinding.Vector v0 = 1;
inline bool TrajectoryInput::_internal_has_v0() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || v0_ != nullptr);
  return value;
}
inline bool TrajectoryInput::has_v0() const {
  return _internal_has_v0();
}
inline void TrajectoryInput::clear_v0() {
  if (v0_ != nullptr) v0_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::pathfinding::Vector& TrajectoryInput::_internal_v0() const {
  const ::pathfinding::Vector* p = v0_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pathfinding::Vector*>(
      &::pathfinding::_Vector_default_instance_);
}
inline const ::pathfinding::Vector& TrajectoryInput::v0() const {
  // @@protoc_insertion_point(field_get:pathfinding.TrajectoryInput.v0)
  return _internal_v0();
}
inline void TrajectoryInput::unsafe_arena_set_allocated_v0(
    ::pathfinding::Vector* v0) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(v0_);
  }
  v0_ = v0;
  if (v0) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pathfinding.TrajectoryInput.v0)
}
inline ::pathfinding::Vector* TrajectoryInput::release_v0() {
  auto temp = unsafe_arena_release_v0();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pathfinding::Vector* TrajectoryInput::unsafe_arena_release_v0() {
  // @@protoc_insertion_point(field_release:pathfinding.TrajectoryInput.v0)
  _has_bits_[0] &= ~0x00000001u;
  ::pathfinding::Vector* temp = v0_;
  v0_ = nullptr;
  return temp;
}
inline ::pathfinding::Vector* TrajectoryInput::_internal_mutable_v0() {
  _has_bits_[0] |= 0x00000001u;
  if (v0_ == nullptr) {
    auto* p = CreateMaybeMessage<::pathfinding::Vector>(GetArena());
    v0_ = p;
  }
  return v0_;
}
inline ::pathfinding::Vector* TrajectoryInput::mutable_v0() {
  // @@protoc_insertion_point(field_mutable:pathfinding.TrajectoryInput.v0)
  return _internal_mutable_v0();
}
inline void TrajectoryInput::set_allocated_v0(::pathfinding::Vector* v0) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete v0_;
  }
  if (v0) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(v0);
    if (message_arena != submessage_arena) {
      v0 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, v0, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  v0_ = v0;
  // @@protoc_insertion_point(field_set_allocated:pathfinding.TrajectoryInput.v0)
}

// optional .pathfinding.Vector v1 = 2;
inline bool TrajectoryInput::_internal_has_v1() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || v1_ != nullptr);
  return value;
}
inline bool TrajectoryInput::has_v1() const {
  return _internal_has_v1();
}
inline void TrajectoryInput::clear_v1() {
  if (v1_ != nullptr) v1_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::pathfinding::Vector& TrajectoryInput::_internal_v1() const {
  const ::pathfinding::Vector* p = v1_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pathfinding::Vector*>(
      &::pathfinding::_Vector_default_instance_);
}
inline const ::pathfinding::Vector& TrajectoryInput::v1() const {
  // @@protoc_insertion_point(field_get:pathfinding.TrajectoryInput.v1)
  return _internal_v1();
}
inline void TrajectoryInput::unsafe_arena_set_allocated_v1(
    ::pathfinding::Vector* v1) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(v1_);
  }
  v1_ = v1;
  if (v1) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pathfinding.TrajectoryInput.v1)
}
inline ::pathfinding::Vector* TrajectoryInput::release_v1() {
  auto temp = unsafe_arena_release_v1();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pathfinding::Vector* TrajectoryInput::unsafe_arena_release_v1() {
  // @@protoc_insertion_point(field_release:pathfinding.TrajectoryInput.v1)
  _has_bits_[0] &= ~0x00000002u;
  ::pathfinding::Vector* temp = v1_;
  v1_ = nullptr;
  return temp;
}
inline ::pathfinding::Vector* TrajectoryInput::_internal_mutable_v1() {
  _has_bits_[0] |= 0x00000002u;
  if (v1_ == nullptr) {
    auto* p = CreateMaybeMessage<::pathfinding::Vector>(GetArena());
    v1_ = p;
  }
  return v1_;
}
inline ::pathfinding::Vector* TrajectoryInput::mutable_v1() {
  // @@protoc_insertion_point(field_mutable:pathfinding.TrajectoryInput.v1)
  return _internal_mutable_v1();
}
inline void TrajectoryInput::set_allocated_v1(::pathfinding::Vector* v1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete v1_;
  }
  if (v1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(v1);
    if (message_arena != submessage_arena) {
      v1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, v1, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  v1_ = v1;
  // @@protoc_insertion_point(field_set_allocated:pathfinding.TrajectoryInput.v1)
}

// optional .pathfinding.Vector s0 = 4;
inline bool TrajectoryInput::_internal_has_s0() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || s0_ != nullptr);
  return value;
}
inline bool TrajectoryInput::has_s0() const {
  return _internal_has_s0();
}
inline void TrajectoryInput::clear_s0() {
  if (s0_ != nullptr) s0_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::pathfinding::Vector& TrajectoryInput::_internal_s0() const {
  const ::pathfinding::Vector* p = s0_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pathfinding::Vector*>(
      &::pathfinding::_Vector_default_instance_);
}
inline const ::pathfinding::Vector& TrajectoryInput::s0() const {
  // @@protoc_insertion_point(field_get:pathfinding.TrajectoryInput.s0)
  return _internal_s0();
}
inline void TrajectoryInput::unsafe_arena_set_allocated_s0(
    ::pathfinding::Vector* s0) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(s0_);
  }
  s0_ = s0;
  if (s0) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pathfinding.TrajectoryInput.s0)
}
inline ::pathfinding::Vector* TrajectoryInput::release_s0() {
  auto temp = unsafe_arena_release_s0();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pathfinding::Vector* TrajectoryInput::unsafe_arena_release_s0() {
  // @@protoc_insertion_point(field_release:pathfinding.TrajectoryInput.s0)
  _has_bits_[0] &= ~0x00000004u;
  ::pathfinding::Vector* temp = s0_;
  s0_ = nullptr;
  return temp;
}
inline ::pathfinding::Vector* TrajectoryInput::_internal_mutable_s0() {
  _has_bits_[0] |= 0x00000004u;
  if (s0_ == nullptr) {
    auto* p = CreateMaybeMessage<::pathfinding::Vector>(GetArena());
    s0_ = p;
  }
  return s0_;
}
inline ::pathfinding::Vector* TrajectoryInput::mutable_s0() {
  // @@protoc_insertion_point(field_mutable:pathfinding.TrajectoryInput.s0)
  return _internal_mutable_s0();
}
inline void TrajectoryInput::set_allocated_s0(::pathfinding::Vector* s0) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete s0_;
  }
  if (s0) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(s0);
    if (message_arena != submessage_arena) {
      s0 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, s0, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  s0_ = s0;
  // @@protoc_insertion_point(field_set_allocated:pathfinding.TrajectoryInput.s0)
}

// optional .pathfinding.Vector s1 = 5;
inline bool TrajectoryInput::_internal_has_s1() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || s1_ != nullptr);
  return value;
}
inline bool TrajectoryInput::has_s1() const {
  return _internal_has_s1();
}
inline void TrajectoryInput::clear_s1() {
  if (s1_ != nullptr) s1_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::pathfinding::Vector& TrajectoryInput::_internal_s1() const {
  const ::pathfinding::Vector* p = s1_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pathfinding::Vector*>(
      &::pathfinding::_Vector_default_instance_);
}
inline const ::pathfinding::Vector& TrajectoryInput::s1() const {
  // @@protoc_insertion_point(field_get:pathfinding.TrajectoryInput.s1)
  return _internal_s1();
}
inline void TrajectoryInput::unsafe_arena_set_allocated_s1(
    ::pathfinding::Vector* s1) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(s1_);
  }
  s1_ = s1;
  if (s1) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pathfinding.TrajectoryInput.s1)
}
inline ::pathfinding::Vector* TrajectoryInput::release_s1() {
  auto temp = unsafe_arena_release_s1();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pathfinding::Vector* TrajectoryInput::unsafe_arena_release_s1() {
  // @@protoc_insertion_point(field_release:pathfinding.TrajectoryInput.s1)
  _has_bits_[0] &= ~0x00000008u;
  ::pathfinding::Vector* temp = s1_;
  s1_ = nullptr;
  return temp;
}
inline ::pathfinding::Vector* TrajectoryInput::_internal_mutable_s1() {
  _has_bits_[0] |= 0x00000008u;
  if (s1_ == nullptr) {
    auto* p = CreateMaybeMessage<::pathfinding::Vector>(GetArena());
    s1_ = p;
  }
  return s1_;
}
inline ::pathfinding::Vector* TrajectoryInput::mutable_s1() {
  // @@protoc_insertion_point(field_mutable:pathfinding.TrajectoryInput.s1)
  return _internal_mutable_s1();
}
inline void TrajectoryInput::set_allocated_s1(::pathfinding::Vector* s1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete s1_;
  }
  if (s1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(s1);
    if (message_arena != submessage_arena) {
      s1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, s1, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  s1_ = s1;
  // @@protoc_insertion_point(field_set_allocated:pathfinding.TrajectoryInput.s1)
}

// optional float max_speed = 6;
inline bool TrajectoryInput::_internal_has_max_speed() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TrajectoryInput::has_max_speed() const {
  return _internal_has_max_speed();
}
inline void TrajectoryInput::clear_max_speed() {
  max_speed_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float TrajectoryInput::_internal_max_speed() const {
  return max_speed_;
}
inline float TrajectoryInput::max_speed() const {
  // @@protoc_insertion_point(field_get:pathfinding.TrajectoryInput.max_speed)
  return _internal_max_speed();
}
inline void TrajectoryInput::_internal_set_max_speed(float value) {
  _has_bits_[0] |= 0x00000010u;
  max_speed_ = value;
}
inline void TrajectoryInput::set_max_speed(float value) {
  _internal_set_max_speed(value);
  // @@protoc_insertion_point(field_set:pathfinding.TrajectoryInput.max_speed)
}

// optional float acceleration = 7;
inline bool TrajectoryInput::_internal_has_acceleration() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TrajectoryInput::has_acceleration() const {
  return _internal_has_acceleration();
}
inline void TrajectoryInput::clear_acceleration() {
  acceleration_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline float TrajectoryInput::_internal_acceleration() const {
  return acceleration_;
}
inline float TrajectoryInput::acceleration() const {
  // @@protoc_insertion_point(field_get:pathfinding.TrajectoryInput.acceleration)
  return _internal_acceleration();
}
inline void TrajectoryInput::_internal_set_acceleration(float value) {
  _has_bits_[0] |= 0x00000020u;
  acceleration_ = value;
}
inline void TrajectoryInput::set_acceleration(float value) {
  _internal_set_acceleration(value);
  // @@protoc_insertion_point(field_set:pathfinding.TrajectoryInput.acceleration)
}

// -------------------------------------------------------------------

// PathFindingTask

// optional .pathfinding.WorldState state = 1;
inline bool PathFindingTask::_internal_has_state() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || state_ != nullptr);
  return value;
}
inline bool PathFindingTask::has_state() const {
  return _internal_has_state();
}
inline void PathFindingTask::clear_state() {
  if (state_ != nullptr) state_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::pathfinding::WorldState& PathFindingTask::_internal_state() const {
  const ::pathfinding::WorldState* p = state_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pathfinding::WorldState*>(
      &::pathfinding::_WorldState_default_instance_);
}
inline const ::pathfinding::WorldState& PathFindingTask::state() const {
  // @@protoc_insertion_point(field_get:pathfinding.PathFindingTask.state)
  return _internal_state();
}
inline void PathFindingTask::unsafe_arena_set_allocated_state(
    ::pathfinding::WorldState* state) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(state_);
  }
  state_ = state;
  if (state) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pathfinding.PathFindingTask.state)
}
inline ::pathfinding::WorldState* PathFindingTask::release_state() {
  auto temp = unsafe_arena_release_state();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pathfinding::WorldState* PathFindingTask::unsafe_arena_release_state() {
  // @@protoc_insertion_point(field_release:pathfinding.PathFindingTask.state)
  _has_bits_[0] &= ~0x00000001u;
  ::pathfinding::WorldState* temp = state_;
  state_ = nullptr;
  return temp;
}
inline ::pathfinding::WorldState* PathFindingTask::_internal_mutable_state() {
  _has_bits_[0] |= 0x00000001u;
  if (state_ == nullptr) {
    auto* p = CreateMaybeMessage<::pathfinding::WorldState>(GetArena());
    state_ = p;
  }
  return state_;
}
inline ::pathfinding::WorldState* PathFindingTask::mutable_state() {
  // @@protoc_insertion_point(field_mutable:pathfinding.PathFindingTask.state)
  return _internal_mutable_state();
}
inline void PathFindingTask::set_allocated_state(::pathfinding::WorldState* state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete state_;
  }
  if (state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(state);
    if (message_arena != submessage_arena) {
      state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  state_ = state;
  // @@protoc_insertion_point(field_set_allocated:pathfinding.PathFindingTask.state)
}

// optional .pathfinding.TrajectoryInput input = 2;
inline bool PathFindingTask::_internal_has_input() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || input_ != nullptr);
  return value;
}
inline bool PathFindingTask::has_input() const {
  return _internal_has_input();
}
inline void PathFindingTask::clear_input() {
  if (input_ != nullptr) input_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::pathfinding::TrajectoryInput& PathFindingTask::_internal_input() const {
  const ::pathfinding::TrajectoryInput* p = input_;
  return p != nullptr ? *p : *reinterpret_cast<const ::pathfinding::TrajectoryInput*>(
      &::pathfinding::_TrajectoryInput_default_instance_);
}
inline const ::pathfinding::TrajectoryInput& PathFindingTask::input() const {
  // @@protoc_insertion_point(field_get:pathfinding.PathFindingTask.input)
  return _internal_input();
}
inline void PathFindingTask::unsafe_arena_set_allocated_input(
    ::pathfinding::TrajectoryInput* input) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(input_);
  }
  input_ = input;
  if (input) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pathfinding.PathFindingTask.input)
}
inline ::pathfinding::TrajectoryInput* PathFindingTask::release_input() {
  auto temp = unsafe_arena_release_input();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pathfinding::TrajectoryInput* PathFindingTask::unsafe_arena_release_input() {
  // @@protoc_insertion_point(field_release:pathfinding.PathFindingTask.input)
  _has_bits_[0] &= ~0x00000002u;
  ::pathfinding::TrajectoryInput* temp = input_;
  input_ = nullptr;
  return temp;
}
inline ::pathfinding::TrajectoryInput* PathFindingTask::_internal_mutable_input() {
  _has_bits_[0] |= 0x00000002u;
  if (input_ == nullptr) {
    auto* p = CreateMaybeMessage<::pathfinding::TrajectoryInput>(GetArena());
    input_ = p;
  }
  return input_;
}
inline ::pathfinding::TrajectoryInput* PathFindingTask::mutable_input() {
  // @@protoc_insertion_point(field_mutable:pathfinding.PathFindingTask.input)
  return _internal_mutable_input();
}
inline void PathFindingTask::set_allocated_input(::pathfinding::TrajectoryInput* input) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete input_;
  }
  if (input) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(input);
    if (message_arena != submessage_arena) {
      input = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, input, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  input_ = input;
  // @@protoc_insertion_point(field_set_allocated:pathfinding.PathFindingTask.input)
}

// optional .pathfinding.InputSourceType type = 3;
inline bool PathFindingTask::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PathFindingTask::has_type() const {
  return _internal_has_type();
}
inline void PathFindingTask::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::pathfinding::InputSourceType PathFindingTask::_internal_type() const {
  return static_cast< ::pathfinding::InputSourceType >(type_);
}
inline ::pathfinding::InputSourceType PathFindingTask::type() const {
  // @@protoc_insertion_point(field_get:pathfinding.PathFindingTask.type)
  return _internal_type();
}
inline void PathFindingTask::_internal_set_type(::pathfinding::InputSourceType value) {
  assert(::pathfinding::InputSourceType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  type_ = value;
}
inline void PathFindingTask::set_type(::pathfinding::InputSourceType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:pathfinding.PathFindingTask.type)
}

// -------------------------------------------------------------------

// StandardSamplerPoint

// optional float time = 1;
inline bool StandardSamplerPoint::_internal_has_time() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StandardSamplerPoint::has_time() const {
  return _internal_has_time();
}
inline void StandardSamplerPoint::clear_time() {
  time_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float StandardSamplerPoint::_internal_time() const {
  return time_;
}
inline float StandardSamplerPoint::time() const {
  // @@protoc_insertion_point(field_get:pathfinding.StandardSamplerPoint.time)
  return _internal_time();
}
inline void StandardSamplerPoint::_internal_set_time(float value) {
  _has_bits_[0] |= 0x00000001u;
  time_ = value;
}
inline void StandardSamplerPoint::set_time(float value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:pathfinding.StandardSamplerPoint.time)
}

// optional float angle = 2;
inline bool StandardSamplerPoint::_internal_has_angle() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StandardSamplerPoint::has_angle() const {
  return _internal_has_angle();
}
inline void StandardSamplerPoint::clear_angle() {
  angle_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float StandardSamplerPoint::_internal_angle() const {
  return angle_;
}
inline float StandardSamplerPoint::angle() const {
  // @@protoc_insertion_point(field_get:pathfinding.StandardSamplerPoint.angle)
  return _internal_angle();
}
inline void StandardSamplerPoint::_internal_set_angle(float value) {
  _has_bits_[0] |= 0x00000002u;
  angle_ = value;
}
inline void StandardSamplerPoint::set_angle(float value) {
  _internal_set_angle(value);
  // @@protoc_insertion_point(field_set:pathfinding.StandardSamplerPoint.angle)
}

// optional float mid_speed_x = 3;
inline bool StandardSamplerPoint::_internal_has_mid_speed_x() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StandardSamplerPoint::has_mid_speed_x() const {
  return _internal_has_mid_speed_x();
}
inline void StandardSamplerPoint::clear_mid_speed_x() {
  mid_speed_x_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float StandardSamplerPoint::_internal_mid_speed_x() const {
  return mid_speed_x_;
}
inline float StandardSamplerPoint::mid_speed_x() const {
  // @@protoc_insertion_point(field_get:pathfinding.StandardSamplerPoint.mid_speed_x)
  return _internal_mid_speed_x();
}
inline void StandardSamplerPoint::_internal_set_mid_speed_x(float value) {
  _has_bits_[0] |= 0x00000004u;
  mid_speed_x_ = value;
}
inline void StandardSamplerPoint::set_mid_speed_x(float value) {
  _internal_set_mid_speed_x(value);
  // @@protoc_insertion_point(field_set:pathfinding.StandardSamplerPoint.mid_speed_x)
}

// optional float mid_speed_y = 4;
inline bool StandardSamplerPoint::_internal_has_mid_speed_y() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool StandardSamplerPoint::has_mid_speed_y() const {
  return _internal_has_mid_speed_y();
}
inline void StandardSamplerPoint::clear_mid_speed_y() {
  mid_speed_y_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float StandardSamplerPoint::_internal_mid_speed_y() const {
  return mid_speed_y_;
}
inline float StandardSamplerPoint::mid_speed_y() const {
  // @@protoc_insertion_point(field_get:pathfinding.StandardSamplerPoint.mid_speed_y)
  return _internal_mid_speed_y();
}
inline void StandardSamplerPoint::_internal_set_mid_speed_y(float value) {
  _has_bits_[0] |= 0x00000008u;
  mid_speed_y_ = value;
}
inline void StandardSamplerPoint::set_mid_speed_y(float value) {
  _internal_set_mid_speed_y(value);
  // @@protoc_insertion_point(field_set:pathfinding.StandardSamplerPoint.mid_speed_y)
}

// -------------------------------------------------------------------

// StandardSamplerPrecomputationSegment

// repeated .pathfinding.StandardSamplerPoint precomputed_points = 1;
inline int StandardSamplerPrecomputationSegment::_internal_precomputed_points_size() const {
  return precomputed_points_.size();
}
inline int StandardSamplerPrecomputationSegment::precomputed_points_size() const {
  return _internal_precomputed_points_size();
}
inline void StandardSamplerPrecomputationSegment::clear_precomputed_points() {
  precomputed_points_.Clear();
}
inline ::pathfinding::StandardSamplerPoint* StandardSamplerPrecomputationSegment::mutable_precomputed_points(int index) {
  // @@protoc_insertion_point(field_mutable:pathfinding.StandardSamplerPrecomputationSegment.precomputed_points)
  return precomputed_points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pathfinding::StandardSamplerPoint >*
StandardSamplerPrecomputationSegment::mutable_precomputed_points() {
  // @@protoc_insertion_point(field_mutable_list:pathfinding.StandardSamplerPrecomputationSegment.precomputed_points)
  return &precomputed_points_;
}
inline const ::pathfinding::StandardSamplerPoint& StandardSamplerPrecomputationSegment::_internal_precomputed_points(int index) const {
  return precomputed_points_.Get(index);
}
inline const ::pathfinding::StandardSamplerPoint& StandardSamplerPrecomputationSegment::precomputed_points(int index) const {
  // @@protoc_insertion_point(field_get:pathfinding.StandardSamplerPrecomputationSegment.precomputed_points)
  return _internal_precomputed_points(index);
}
inline ::pathfinding::StandardSamplerPoint* StandardSamplerPrecomputationSegment::_internal_add_precomputed_points() {
  return precomputed_points_.Add();
}
inline ::pathfinding::StandardSamplerPoint* StandardSamplerPrecomputationSegment::add_precomputed_points() {
  // @@protoc_insertion_point(field_add:pathfinding.StandardSamplerPrecomputationSegment.precomputed_points)
  return _internal_add_precomputed_points();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pathfinding::StandardSamplerPoint >&
StandardSamplerPrecomputationSegment::precomputed_points() const {
  // @@protoc_insertion_point(field_list:pathfinding.StandardSamplerPrecomputationSegment.precomputed_points)
  return precomputed_points_;
}

// optional float min_distance = 2;
inline bool StandardSamplerPrecomputationSegment::_internal_has_min_distance() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StandardSamplerPrecomputationSegment::has_min_distance() const {
  return _internal_has_min_distance();
}
inline void StandardSamplerPrecomputationSegment::clear_min_distance() {
  min_distance_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float StandardSamplerPrecomputationSegment::_internal_min_distance() const {
  return min_distance_;
}
inline float StandardSamplerPrecomputationSegment::min_distance() const {
  // @@protoc_insertion_point(field_get:pathfinding.StandardSamplerPrecomputationSegment.min_distance)
  return _internal_min_distance();
}
inline void StandardSamplerPrecomputationSegment::_internal_set_min_distance(float value) {
  _has_bits_[0] |= 0x00000001u;
  min_distance_ = value;
}
inline void StandardSamplerPrecomputationSegment::set_min_distance(float value) {
  _internal_set_min_distance(value);
  // @@protoc_insertion_point(field_set:pathfinding.StandardSamplerPrecomputationSegment.min_distance)
}

// optional float max_distance = 3;
inline bool StandardSamplerPrecomputationSegment::_internal_has_max_distance() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StandardSamplerPrecomputationSegment::has_max_distance() const {
  return _internal_has_max_distance();
}
inline void StandardSamplerPrecomputationSegment::clear_max_distance() {
  max_distance_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float StandardSamplerPrecomputationSegment::_internal_max_distance() const {
  return max_distance_;
}
inline float StandardSamplerPrecomputationSegment::max_distance() const {
  // @@protoc_insertion_point(field_get:pathfinding.StandardSamplerPrecomputationSegment.max_distance)
  return _internal_max_distance();
}
inline void StandardSamplerPrecomputationSegment::_internal_set_max_distance(float value) {
  _has_bits_[0] |= 0x00000002u;
  max_distance_ = value;
}
inline void StandardSamplerPrecomputationSegment::set_max_distance(float value) {
  _internal_set_max_distance(value);
  // @@protoc_insertion_point(field_set:pathfinding.StandardSamplerPrecomputationSegment.max_distance)
}

// -------------------------------------------------------------------

// StandardSamplerPrecomputation

// repeated .pathfinding.StandardSamplerPrecomputationSegment segments = 1;
inline int StandardSamplerPrecomputation::_internal_segments_size() const {
  return segments_.size();
}
inline int StandardSamplerPrecomputation::segments_size() const {
  return _internal_segments_size();
}
inline void StandardSamplerPrecomputation::clear_segments() {
  segments_.Clear();
}
inline ::pathfinding::StandardSamplerPrecomputationSegment* StandardSamplerPrecomputation::mutable_segments(int index) {
  // @@protoc_insertion_point(field_mutable:pathfinding.StandardSamplerPrecomputation.segments)
  return segments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pathfinding::StandardSamplerPrecomputationSegment >*
StandardSamplerPrecomputation::mutable_segments() {
  // @@protoc_insertion_point(field_mutable_list:pathfinding.StandardSamplerPrecomputation.segments)
  return &segments_;
}
inline const ::pathfinding::StandardSamplerPrecomputationSegment& StandardSamplerPrecomputation::_internal_segments(int index) const {
  return segments_.Get(index);
}
inline const ::pathfinding::StandardSamplerPrecomputationSegment& StandardSamplerPrecomputation::segments(int index) const {
  // @@protoc_insertion_point(field_get:pathfinding.StandardSamplerPrecomputation.segments)
  return _internal_segments(index);
}
inline ::pathfinding::StandardSamplerPrecomputationSegment* StandardSamplerPrecomputation::_internal_add_segments() {
  return segments_.Add();
}
inline ::pathfinding::StandardSamplerPrecomputationSegment* StandardSamplerPrecomputation::add_segments() {
  // @@protoc_insertion_point(field_add:pathfinding.StandardSamplerPrecomputation.segments)
  return _internal_add_segments();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pathfinding::StandardSamplerPrecomputationSegment >&
StandardSamplerPrecomputation::segments() const {
  // @@protoc_insertion_point(field_list:pathfinding.StandardSamplerPrecomputation.segments)
  return segments_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pathfinding

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::pathfinding::InputSourceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pathfinding::InputSourceType>() {
  return ::pathfinding::InputSourceType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_pathfinding_2eproto
