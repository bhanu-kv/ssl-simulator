// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: command.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_command_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_command_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "world.pb.h"
#include "robot.pb.h"
#include "logfile.pb.h"
#include "ssl_geometry.pb.h"
#include "ssl_simulation_control.pb.h"
#include "ssl_simulation_custom_erforce_realism.pb.h"
#include "ssl_referee.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_command_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_command_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[29]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_command_2eproto;
namespace amun {
class Command;
class CommandDefaultTypeInternal;
extern CommandDefaultTypeInternal _Command_default_instance_;
class CommandAmun;
class CommandAmunDefaultTypeInternal;
extern CommandAmunDefaultTypeInternal _CommandAmun_default_instance_;
class CommandControl;
class CommandControlDefaultTypeInternal;
extern CommandControlDefaultTypeInternal _CommandControl_default_instance_;
class CommandDebuggerInput;
class CommandDebuggerInputDefaultTypeInternal;
extern CommandDebuggerInputDefaultTypeInternal _CommandDebuggerInput_default_instance_;
class CommandDebuggerInputDisable;
class CommandDebuggerInputDisableDefaultTypeInternal;
extern CommandDebuggerInputDisableDefaultTypeInternal _CommandDebuggerInputDisable_default_instance_;
class CommandDebuggerInputLine;
class CommandDebuggerInputLineDefaultTypeInternal;
extern CommandDebuggerInputLineDefaultTypeInternal _CommandDebuggerInputLine_default_instance_;
class CommandPlayback;
class CommandPlaybackDefaultTypeInternal;
extern CommandPlaybackDefaultTypeInternal _CommandPlayback_default_instance_;
class CommandRecord;
class CommandRecordDefaultTypeInternal;
extern CommandRecordDefaultTypeInternal _CommandRecord_default_instance_;
class CommandReferee;
class CommandRefereeDefaultTypeInternal;
extern CommandRefereeDefaultTypeInternal _CommandReferee_default_instance_;
class CommandReplay;
class CommandReplayDefaultTypeInternal;
extern CommandReplayDefaultTypeInternal _CommandReplay_default_instance_;
class CommandSimulator;
class CommandSimulatorDefaultTypeInternal;
extern CommandSimulatorDefaultTypeInternal _CommandSimulator_default_instance_;
class CommandStrategy;
class CommandStrategyDefaultTypeInternal;
extern CommandStrategyDefaultTypeInternal _CommandStrategy_default_instance_;
class CommandStrategyAutomaticEntrypoints;
class CommandStrategyAutomaticEntrypointsDefaultTypeInternal;
extern CommandStrategyAutomaticEntrypointsDefaultTypeInternal _CommandStrategyAutomaticEntrypoints_default_instance_;
class CommandStrategyAutomaticEntrypoints_EntrypointForStage;
class CommandStrategyAutomaticEntrypoints_EntrypointForStageDefaultTypeInternal;
extern CommandStrategyAutomaticEntrypoints_EntrypointForStageDefaultTypeInternal _CommandStrategyAutomaticEntrypoints_EntrypointForStage_default_instance_;
class CommandStrategyChangeOption;
class CommandStrategyChangeOptionDefaultTypeInternal;
extern CommandStrategyChangeOptionDefaultTypeInternal _CommandStrategyChangeOption_default_instance_;
class CommandStrategyClose;
class CommandStrategyCloseDefaultTypeInternal;
extern CommandStrategyCloseDefaultTypeInternal _CommandStrategyClose_default_instance_;
class CommandStrategyLoad;
class CommandStrategyLoadDefaultTypeInternal;
extern CommandStrategyLoadDefaultTypeInternal _CommandStrategyLoad_default_instance_;
class CommandStrategyTriggerDebugger;
class CommandStrategyTriggerDebuggerDefaultTypeInternal;
extern CommandStrategyTriggerDebuggerDefaultTypeInternal _CommandStrategyTriggerDebugger_default_instance_;
class CommandTracking;
class CommandTrackingDefaultTypeInternal;
extern CommandTrackingDefaultTypeInternal _CommandTracking_default_instance_;
class CommandTransceiver;
class CommandTransceiverDefaultTypeInternal;
extern CommandTransceiverDefaultTypeInternal _CommandTransceiver_default_instance_;
class Flag;
class FlagDefaultTypeInternal;
extern FlagDefaultTypeInternal _Flag_default_instance_;
class HostAddress;
class HostAddressDefaultTypeInternal;
extern HostAddressDefaultTypeInternal _HostAddress_default_instance_;
class PauseSimulatorCommand;
class PauseSimulatorCommandDefaultTypeInternal;
extern PauseSimulatorCommandDefaultTypeInternal _PauseSimulatorCommand_default_instance_;
class RobotMoveCommand;
class RobotMoveCommandDefaultTypeInternal;
extern RobotMoveCommandDefaultTypeInternal _RobotMoveCommand_default_instance_;
class SimulatorNetworking;
class SimulatorNetworkingDefaultTypeInternal;
extern SimulatorNetworkingDefaultTypeInternal _SimulatorNetworking_default_instance_;
class SimulatorSetup;
class SimulatorSetupDefaultTypeInternal;
extern SimulatorSetupDefaultTypeInternal _SimulatorSetup_default_instance_;
class SimulatorWorstCaseVision;
class SimulatorWorstCaseVisionDefaultTypeInternal;
extern SimulatorWorstCaseVisionDefaultTypeInternal _SimulatorWorstCaseVision_default_instance_;
class TransceiverConfiguration;
class TransceiverConfigurationDefaultTypeInternal;
extern TransceiverConfigurationDefaultTypeInternal _TransceiverConfiguration_default_instance_;
class VirtualFieldTransform;
class VirtualFieldTransformDefaultTypeInternal;
extern VirtualFieldTransformDefaultTypeInternal _VirtualFieldTransform_default_instance_;
}  // namespace amun
PROTOBUF_NAMESPACE_OPEN
template<> ::amun::Command* Arena::CreateMaybeMessage<::amun::Command>(Arena*);
template<> ::amun::CommandAmun* Arena::CreateMaybeMessage<::amun::CommandAmun>(Arena*);
template<> ::amun::CommandControl* Arena::CreateMaybeMessage<::amun::CommandControl>(Arena*);
template<> ::amun::CommandDebuggerInput* Arena::CreateMaybeMessage<::amun::CommandDebuggerInput>(Arena*);
template<> ::amun::CommandDebuggerInputDisable* Arena::CreateMaybeMessage<::amun::CommandDebuggerInputDisable>(Arena*);
template<> ::amun::CommandDebuggerInputLine* Arena::CreateMaybeMessage<::amun::CommandDebuggerInputLine>(Arena*);
template<> ::amun::CommandPlayback* Arena::CreateMaybeMessage<::amun::CommandPlayback>(Arena*);
template<> ::amun::CommandRecord* Arena::CreateMaybeMessage<::amun::CommandRecord>(Arena*);
template<> ::amun::CommandReferee* Arena::CreateMaybeMessage<::amun::CommandReferee>(Arena*);
template<> ::amun::CommandReplay* Arena::CreateMaybeMessage<::amun::CommandReplay>(Arena*);
template<> ::amun::CommandSimulator* Arena::CreateMaybeMessage<::amun::CommandSimulator>(Arena*);
template<> ::amun::CommandStrategy* Arena::CreateMaybeMessage<::amun::CommandStrategy>(Arena*);
template<> ::amun::CommandStrategyAutomaticEntrypoints* Arena::CreateMaybeMessage<::amun::CommandStrategyAutomaticEntrypoints>(Arena*);
template<> ::amun::CommandStrategyAutomaticEntrypoints_EntrypointForStage* Arena::CreateMaybeMessage<::amun::CommandStrategyAutomaticEntrypoints_EntrypointForStage>(Arena*);
template<> ::amun::CommandStrategyChangeOption* Arena::CreateMaybeMessage<::amun::CommandStrategyChangeOption>(Arena*);
template<> ::amun::CommandStrategyClose* Arena::CreateMaybeMessage<::amun::CommandStrategyClose>(Arena*);
template<> ::amun::CommandStrategyLoad* Arena::CreateMaybeMessage<::amun::CommandStrategyLoad>(Arena*);
template<> ::amun::CommandStrategyTriggerDebugger* Arena::CreateMaybeMessage<::amun::CommandStrategyTriggerDebugger>(Arena*);
template<> ::amun::CommandTracking* Arena::CreateMaybeMessage<::amun::CommandTracking>(Arena*);
template<> ::amun::CommandTransceiver* Arena::CreateMaybeMessage<::amun::CommandTransceiver>(Arena*);
template<> ::amun::Flag* Arena::CreateMaybeMessage<::amun::Flag>(Arena*);
template<> ::amun::HostAddress* Arena::CreateMaybeMessage<::amun::HostAddress>(Arena*);
template<> ::amun::PauseSimulatorCommand* Arena::CreateMaybeMessage<::amun::PauseSimulatorCommand>(Arena*);
template<> ::amun::RobotMoveCommand* Arena::CreateMaybeMessage<::amun::RobotMoveCommand>(Arena*);
template<> ::amun::SimulatorNetworking* Arena::CreateMaybeMessage<::amun::SimulatorNetworking>(Arena*);
template<> ::amun::SimulatorSetup* Arena::CreateMaybeMessage<::amun::SimulatorSetup>(Arena*);
template<> ::amun::SimulatorWorstCaseVision* Arena::CreateMaybeMessage<::amun::SimulatorWorstCaseVision>(Arena*);
template<> ::amun::TransceiverConfiguration* Arena::CreateMaybeMessage<::amun::TransceiverConfiguration>(Arena*);
template<> ::amun::VirtualFieldTransform* Arena::CreateMaybeMessage<::amun::VirtualFieldTransform>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace amun {

enum DebuggerInputTarget : int {
  DITStrategyYellow = 0,
  DITStrategyBlue = 1,
  DITAutoref = 2
};
bool DebuggerInputTarget_IsValid(int value);
constexpr DebuggerInputTarget DebuggerInputTarget_MIN = DITStrategyYellow;
constexpr DebuggerInputTarget DebuggerInputTarget_MAX = DITAutoref;
constexpr int DebuggerInputTarget_ARRAYSIZE = DebuggerInputTarget_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DebuggerInputTarget_descriptor();
template<typename T>
inline const std::string& DebuggerInputTarget_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DebuggerInputTarget>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DebuggerInputTarget_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DebuggerInputTarget_descriptor(), enum_t_value);
}
inline bool DebuggerInputTarget_Parse(
    const std::string& name, DebuggerInputTarget* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DebuggerInputTarget>(
    DebuggerInputTarget_descriptor(), name, value);
}
enum PauseSimulatorReason : int {
  Ui = 1,
  WindowFocus = 2,
  DebugBlueStrategy = 3,
  DebugYellowStrategy = 4,
  DebugAutoref = 5,
  Replay = 6,
  Horus = 7,
  Logging = 8
};
bool PauseSimulatorReason_IsValid(int value);
constexpr PauseSimulatorReason PauseSimulatorReason_MIN = Ui;
constexpr PauseSimulatorReason PauseSimulatorReason_MAX = Logging;
constexpr int PauseSimulatorReason_ARRAYSIZE = PauseSimulatorReason_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PauseSimulatorReason_descriptor();
template<typename T>
inline const std::string& PauseSimulatorReason_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PauseSimulatorReason>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PauseSimulatorReason_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PauseSimulatorReason_descriptor(), enum_t_value);
}
inline bool PauseSimulatorReason_Parse(
    const std::string& name, PauseSimulatorReason* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PauseSimulatorReason>(
    PauseSimulatorReason_descriptor(), name, value);
}
// ===================================================================

class RobotMoveCommand PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:amun.RobotMoveCommand) */ {
 public:
  inline RobotMoveCommand() : RobotMoveCommand(nullptr) {};
  virtual ~RobotMoveCommand();

  RobotMoveCommand(const RobotMoveCommand& from);
  RobotMoveCommand(RobotMoveCommand&& from) noexcept
    : RobotMoveCommand() {
    *this = ::std::move(from);
  }

  inline RobotMoveCommand& operator=(const RobotMoveCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotMoveCommand& operator=(RobotMoveCommand&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RobotMoveCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RobotMoveCommand* internal_default_instance() {
    return reinterpret_cast<const RobotMoveCommand*>(
               &_RobotMoveCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RobotMoveCommand& a, RobotMoveCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotMoveCommand* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotMoveCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RobotMoveCommand* New() const final {
    return CreateMaybeMessage<RobotMoveCommand>(nullptr);
  }

  RobotMoveCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RobotMoveCommand>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RobotMoveCommand& from);
  void MergeFrom(const RobotMoveCommand& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotMoveCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "amun.RobotMoveCommand";
  }
  protected:
  explicit RobotMoveCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_command_2eproto);
    return ::descriptor_table_command_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kPXFieldNumber = 2,
    kPYFieldNumber = 3,
  };
  // required uint32 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional float p_x = 2;
  bool has_p_x() const;
  private:
  bool _internal_has_p_x() const;
  public:
  void clear_p_x();
  float p_x() const;
  void set_p_x(float value);
  private:
  float _internal_p_x() const;
  void _internal_set_p_x(float value);
  public:

  // optional float p_y = 3;
  bool has_p_y() const;
  private:
  bool _internal_has_p_y() const;
  public:
  void clear_p_y();
  float p_y() const;
  void set_p_y(float value);
  private:
  float _internal_p_y() const;
  void _internal_set_p_y(float value);
  public:

  // @@protoc_insertion_point(class_scope:amun.RobotMoveCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  float p_x_;
  float p_y_;
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class SimulatorSetup PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:amun.SimulatorSetup) */ {
 public:
  inline SimulatorSetup() : SimulatorSetup(nullptr) {};
  virtual ~SimulatorSetup();

  SimulatorSetup(const SimulatorSetup& from);
  SimulatorSetup(SimulatorSetup&& from) noexcept
    : SimulatorSetup() {
    *this = ::std::move(from);
  }

  inline SimulatorSetup& operator=(const SimulatorSetup& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimulatorSetup& operator=(SimulatorSetup&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SimulatorSetup& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SimulatorSetup* internal_default_instance() {
    return reinterpret_cast<const SimulatorSetup*>(
               &_SimulatorSetup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SimulatorSetup& a, SimulatorSetup& b) {
    a.Swap(&b);
  }
  inline void Swap(SimulatorSetup* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SimulatorSetup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SimulatorSetup* New() const final {
    return CreateMaybeMessage<SimulatorSetup>(nullptr);
  }

  SimulatorSetup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SimulatorSetup>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SimulatorSetup& from);
  void MergeFrom(const SimulatorSetup& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimulatorSetup* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "amun.SimulatorSetup";
  }
  protected:
  explicit SimulatorSetup(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_command_2eproto);
    return ::descriptor_table_command_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCameraSetupFieldNumber = 2,
    kGeometryFieldNumber = 1,
  };
  // repeated .SSL_GeometryCameraCalibration camera_setup = 2;
  int camera_setup_size() const;
  private:
  int _internal_camera_setup_size() const;
  public:
  void clear_camera_setup();
  ::SSL_GeometryCameraCalibration* mutable_camera_setup(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SSL_GeometryCameraCalibration >*
      mutable_camera_setup();
  private:
  const ::SSL_GeometryCameraCalibration& _internal_camera_setup(int index) const;
  ::SSL_GeometryCameraCalibration* _internal_add_camera_setup();
  public:
  const ::SSL_GeometryCameraCalibration& camera_setup(int index) const;
  ::SSL_GeometryCameraCalibration* add_camera_setup();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SSL_GeometryCameraCalibration >&
      camera_setup() const;

  // required .world.Geometry geometry = 1;
  bool has_geometry() const;
  private:
  bool _internal_has_geometry() const;
  public:
  void clear_geometry();
  const ::world::Geometry& geometry() const;
  ::world::Geometry* release_geometry();
  ::world::Geometry* mutable_geometry();
  void set_allocated_geometry(::world::Geometry* geometry);
  private:
  const ::world::Geometry& _internal_geometry() const;
  ::world::Geometry* _internal_mutable_geometry();
  public:
  void unsafe_arena_set_allocated_geometry(
      ::world::Geometry* geometry);
  ::world::Geometry* unsafe_arena_release_geometry();

  // @@protoc_insertion_point(class_scope:amun.SimulatorSetup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SSL_GeometryCameraCalibration > camera_setup_;
  ::world::Geometry* geometry_;
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class SimulatorWorstCaseVision PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:amun.SimulatorWorstCaseVision) */ {
 public:
  inline SimulatorWorstCaseVision() : SimulatorWorstCaseVision(nullptr) {};
  virtual ~SimulatorWorstCaseVision();

  SimulatorWorstCaseVision(const SimulatorWorstCaseVision& from);
  SimulatorWorstCaseVision(SimulatorWorstCaseVision&& from) noexcept
    : SimulatorWorstCaseVision() {
    *this = ::std::move(from);
  }

  inline SimulatorWorstCaseVision& operator=(const SimulatorWorstCaseVision& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimulatorWorstCaseVision& operator=(SimulatorWorstCaseVision&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SimulatorWorstCaseVision& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SimulatorWorstCaseVision* internal_default_instance() {
    return reinterpret_cast<const SimulatorWorstCaseVision*>(
               &_SimulatorWorstCaseVision_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SimulatorWorstCaseVision& a, SimulatorWorstCaseVision& b) {
    a.Swap(&b);
  }
  inline void Swap(SimulatorWorstCaseVision* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SimulatorWorstCaseVision* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SimulatorWorstCaseVision* New() const final {
    return CreateMaybeMessage<SimulatorWorstCaseVision>(nullptr);
  }

  SimulatorWorstCaseVision* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SimulatorWorstCaseVision>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SimulatorWorstCaseVision& from);
  void MergeFrom(const SimulatorWorstCaseVision& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimulatorWorstCaseVision* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "amun.SimulatorWorstCaseVision";
  }
  protected:
  explicit SimulatorWorstCaseVision(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_command_2eproto);
    return ::descriptor_table_command_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinRobotDetectionTimeFieldNumber = 1,
    kMinBallDetectionTimeFieldNumber = 2,
  };
  // optional float min_robot_detection_time = 1;
  bool has_min_robot_detection_time() const;
  private:
  bool _internal_has_min_robot_detection_time() const;
  public:
  void clear_min_robot_detection_time();
  float min_robot_detection_time() const;
  void set_min_robot_detection_time(float value);
  private:
  float _internal_min_robot_detection_time() const;
  void _internal_set_min_robot_detection_time(float value);
  public:

  // optional float min_ball_detection_time = 2;
  bool has_min_ball_detection_time() const;
  private:
  bool _internal_has_min_ball_detection_time() const;
  public:
  void clear_min_ball_detection_time();
  float min_ball_detection_time() const;
  void set_min_ball_detection_time(float value);
  private:
  float _internal_min_ball_detection_time() const;
  void _internal_set_min_ball_detection_time(float value);
  public:

  // @@protoc_insertion_point(class_scope:amun.SimulatorWorstCaseVision)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float min_robot_detection_time_;
  float min_ball_detection_time_;
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class CommandSimulator PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:amun.CommandSimulator) */ {
 public:
  inline CommandSimulator() : CommandSimulator(nullptr) {};
  virtual ~CommandSimulator();

  CommandSimulator(const CommandSimulator& from);
  CommandSimulator(CommandSimulator&& from) noexcept
    : CommandSimulator() {
    *this = ::std::move(from);
  }

  inline CommandSimulator& operator=(const CommandSimulator& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandSimulator& operator=(CommandSimulator&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CommandSimulator& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommandSimulator* internal_default_instance() {
    return reinterpret_cast<const CommandSimulator*>(
               &_CommandSimulator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CommandSimulator& a, CommandSimulator& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandSimulator* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandSimulator* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandSimulator* New() const final {
    return CreateMaybeMessage<CommandSimulator>(nullptr);
  }

  CommandSimulator* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandSimulator>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CommandSimulator& from);
  void MergeFrom(const CommandSimulator& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommandSimulator* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "amun.CommandSimulator";
  }
  protected:
  explicit CommandSimulator(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_command_2eproto);
    return ::descriptor_table_command_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSimulatorSetupFieldNumber = 2,
    kVisionWorstCaseFieldNumber = 3,
    kRealismConfigFieldNumber = 4,
    kSetSimulatorStateFieldNumber = 5,
    kSslControlFieldNumber = 6,
    kEnableFieldNumber = 1,
  };
  // optional .amun.SimulatorSetup simulator_setup = 2;
  bool has_simulator_setup() const;
  private:
  bool _internal_has_simulator_setup() const;
  public:
  void clear_simulator_setup();
  const ::amun::SimulatorSetup& simulator_setup() const;
  ::amun::SimulatorSetup* release_simulator_setup();
  ::amun::SimulatorSetup* mutable_simulator_setup();
  void set_allocated_simulator_setup(::amun::SimulatorSetup* simulator_setup);
  private:
  const ::amun::SimulatorSetup& _internal_simulator_setup() const;
  ::amun::SimulatorSetup* _internal_mutable_simulator_setup();
  public:
  void unsafe_arena_set_allocated_simulator_setup(
      ::amun::SimulatorSetup* simulator_setup);
  ::amun::SimulatorSetup* unsafe_arena_release_simulator_setup();

  // optional .amun.SimulatorWorstCaseVision vision_worst_case = 3;
  bool has_vision_worst_case() const;
  private:
  bool _internal_has_vision_worst_case() const;
  public:
  void clear_vision_worst_case();
  const ::amun::SimulatorWorstCaseVision& vision_worst_case() const;
  ::amun::SimulatorWorstCaseVision* release_vision_worst_case();
  ::amun::SimulatorWorstCaseVision* mutable_vision_worst_case();
  void set_allocated_vision_worst_case(::amun::SimulatorWorstCaseVision* vision_worst_case);
  private:
  const ::amun::SimulatorWorstCaseVision& _internal_vision_worst_case() const;
  ::amun::SimulatorWorstCaseVision* _internal_mutable_vision_worst_case();
  public:
  void unsafe_arena_set_allocated_vision_worst_case(
      ::amun::SimulatorWorstCaseVision* vision_worst_case);
  ::amun::SimulatorWorstCaseVision* unsafe_arena_release_vision_worst_case();

  // optional .RealismConfigErForce realism_config = 4;
  bool has_realism_config() const;
  private:
  bool _internal_has_realism_config() const;
  public:
  void clear_realism_config();
  const ::RealismConfigErForce& realism_config() const;
  ::RealismConfigErForce* release_realism_config();
  ::RealismConfigErForce* mutable_realism_config();
  void set_allocated_realism_config(::RealismConfigErForce* realism_config);
  private:
  const ::RealismConfigErForce& _internal_realism_config() const;
  ::RealismConfigErForce* _internal_mutable_realism_config();
  public:
  void unsafe_arena_set_allocated_realism_config(
      ::RealismConfigErForce* realism_config);
  ::RealismConfigErForce* unsafe_arena_release_realism_config();

  // optional .world.SimulatorState set_simulator_state = 5;
  bool has_set_simulator_state() const;
  private:
  bool _internal_has_set_simulator_state() const;
  public:
  void clear_set_simulator_state();
  const ::world::SimulatorState& set_simulator_state() const;
  ::world::SimulatorState* release_set_simulator_state();
  ::world::SimulatorState* mutable_set_simulator_state();
  void set_allocated_set_simulator_state(::world::SimulatorState* set_simulator_state);
  private:
  const ::world::SimulatorState& _internal_set_simulator_state() const;
  ::world::SimulatorState* _internal_mutable_set_simulator_state();
  public:
  void unsafe_arena_set_allocated_set_simulator_state(
      ::world::SimulatorState* set_simulator_state);
  ::world::SimulatorState* unsafe_arena_release_set_simulator_state();

  // optional .sslsim.SimulatorControl ssl_control = 6;
  bool has_ssl_control() const;
  private:
  bool _internal_has_ssl_control() const;
  public:
  void clear_ssl_control();
  const ::sslsim::SimulatorControl& ssl_control() const;
  ::sslsim::SimulatorControl* release_ssl_control();
  ::sslsim::SimulatorControl* mutable_ssl_control();
  void set_allocated_ssl_control(::sslsim::SimulatorControl* ssl_control);
  private:
  const ::sslsim::SimulatorControl& _internal_ssl_control() const;
  ::sslsim::SimulatorControl* _internal_mutable_ssl_control();
  public:
  void unsafe_arena_set_allocated_ssl_control(
      ::sslsim::SimulatorControl* ssl_control);
  ::sslsim::SimulatorControl* unsafe_arena_release_ssl_control();

  // optional bool enable = 1;
  bool has_enable() const;
  private:
  bool _internal_has_enable() const;
  public:
  void clear_enable();
  bool enable() const;
  void set_enable(bool value);
  private:
  bool _internal_enable() const;
  void _internal_set_enable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:amun.CommandSimulator)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::amun::SimulatorSetup* simulator_setup_;
  ::amun::SimulatorWorstCaseVision* vision_worst_case_;
  ::RealismConfigErForce* realism_config_;
  ::world::SimulatorState* set_simulator_state_;
  ::sslsim::SimulatorControl* ssl_control_;
  bool enable_;
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class CommandReferee PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:amun.CommandReferee) */ {
 public:
  inline CommandReferee() : CommandReferee(nullptr) {};
  virtual ~CommandReferee();

  CommandReferee(const CommandReferee& from);
  CommandReferee(CommandReferee&& from) noexcept
    : CommandReferee() {
    *this = ::std::move(from);
  }

  inline CommandReferee& operator=(const CommandReferee& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandReferee& operator=(CommandReferee&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CommandReferee& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommandReferee* internal_default_instance() {
    return reinterpret_cast<const CommandReferee*>(
               &_CommandReferee_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CommandReferee& a, CommandReferee& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandReferee* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandReferee* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandReferee* New() const final {
    return CreateMaybeMessage<CommandReferee>(nullptr);
  }

  CommandReferee* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandReferee>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CommandReferee& from);
  void MergeFrom(const CommandReferee& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommandReferee* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "amun.CommandReferee";
  }
  protected:
  explicit CommandReferee(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_command_2eproto);
    return ::descriptor_table_command_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommandFieldNumber = 2,
    kActiveFieldNumber = 1,
    kUseInternalAutorefFieldNumber = 3,
    kUseAutomaticRobotExchangeFieldNumber = 4,
  };
  // optional bytes command = 2;
  bool has_command() const;
  private:
  bool _internal_has_command() const;
  public:
  void clear_command();
  const std::string& command() const;
  void set_command(const std::string& value);
  void set_command(std::string&& value);
  void set_command(const char* value);
  void set_command(const void* value, size_t size);
  std::string* mutable_command();
  std::string* release_command();
  void set_allocated_command(std::string* command);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_command();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_command(
      std::string* command);
  private:
  const std::string& _internal_command() const;
  void _internal_set_command(const std::string& value);
  std::string* _internal_mutable_command();
  public:

  // optional bool active = 1;
  bool has_active() const;
  private:
  bool _internal_has_active() const;
  public:
  void clear_active();
  bool active() const;
  void set_active(bool value);
  private:
  bool _internal_active() const;
  void _internal_set_active(bool value);
  public:

  // optional bool use_internal_autoref = 3;
  bool has_use_internal_autoref() const;
  private:
  bool _internal_has_use_internal_autoref() const;
  public:
  void clear_use_internal_autoref();
  bool use_internal_autoref() const;
  void set_use_internal_autoref(bool value);
  private:
  bool _internal_use_internal_autoref() const;
  void _internal_set_use_internal_autoref(bool value);
  public:

  // optional bool use_automatic_robot_exchange = 4;
  bool has_use_automatic_robot_exchange() const;
  private:
  bool _internal_has_use_automatic_robot_exchange() const;
  public:
  void clear_use_automatic_robot_exchange();
  bool use_automatic_robot_exchange() const;
  void set_use_automatic_robot_exchange(bool value);
  private:
  bool _internal_use_automatic_robot_exchange() const;
  void _internal_set_use_automatic_robot_exchange(bool value);
  public:

  // @@protoc_insertion_point(class_scope:amun.CommandReferee)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr command_;
  bool active_;
  bool use_internal_autoref_;
  bool use_automatic_robot_exchange_;
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class CommandStrategyAutomaticEntrypoints_EntrypointForStage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:amun.CommandStrategyAutomaticEntrypoints.EntrypointForStage) */ {
 public:
  inline CommandStrategyAutomaticEntrypoints_EntrypointForStage() : CommandStrategyAutomaticEntrypoints_EntrypointForStage(nullptr) {};
  virtual ~CommandStrategyAutomaticEntrypoints_EntrypointForStage();

  CommandStrategyAutomaticEntrypoints_EntrypointForStage(const CommandStrategyAutomaticEntrypoints_EntrypointForStage& from);
  CommandStrategyAutomaticEntrypoints_EntrypointForStage(CommandStrategyAutomaticEntrypoints_EntrypointForStage&& from) noexcept
    : CommandStrategyAutomaticEntrypoints_EntrypointForStage() {
    *this = ::std::move(from);
  }

  inline CommandStrategyAutomaticEntrypoints_EntrypointForStage& operator=(const CommandStrategyAutomaticEntrypoints_EntrypointForStage& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandStrategyAutomaticEntrypoints_EntrypointForStage& operator=(CommandStrategyAutomaticEntrypoints_EntrypointForStage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CommandStrategyAutomaticEntrypoints_EntrypointForStage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommandStrategyAutomaticEntrypoints_EntrypointForStage* internal_default_instance() {
    return reinterpret_cast<const CommandStrategyAutomaticEntrypoints_EntrypointForStage*>(
               &_CommandStrategyAutomaticEntrypoints_EntrypointForStage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CommandStrategyAutomaticEntrypoints_EntrypointForStage& a, CommandStrategyAutomaticEntrypoints_EntrypointForStage& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandStrategyAutomaticEntrypoints_EntrypointForStage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandStrategyAutomaticEntrypoints_EntrypointForStage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandStrategyAutomaticEntrypoints_EntrypointForStage* New() const final {
    return CreateMaybeMessage<CommandStrategyAutomaticEntrypoints_EntrypointForStage>(nullptr);
  }

  CommandStrategyAutomaticEntrypoints_EntrypointForStage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandStrategyAutomaticEntrypoints_EntrypointForStage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CommandStrategyAutomaticEntrypoints_EntrypointForStage& from);
  void MergeFrom(const CommandStrategyAutomaticEntrypoints_EntrypointForStage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommandStrategyAutomaticEntrypoints_EntrypointForStage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "amun.CommandStrategyAutomaticEntrypoints.EntrypointForStage";
  }
  protected:
  explicit CommandStrategyAutomaticEntrypoints_EntrypointForStage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_command_2eproto);
    return ::descriptor_table_command_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntryPointFieldNumber = 2,
    kStageFieldNumber = 1,
  };
  // required string entry_point = 2;
  bool has_entry_point() const;
  private:
  bool _internal_has_entry_point() const;
  public:
  void clear_entry_point();
  const std::string& entry_point() const;
  void set_entry_point(const std::string& value);
  void set_entry_point(std::string&& value);
  void set_entry_point(const char* value);
  void set_entry_point(const char* value, size_t size);
  std::string* mutable_entry_point();
  std::string* release_entry_point();
  void set_allocated_entry_point(std::string* entry_point);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_entry_point();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_entry_point(
      std::string* entry_point);
  private:
  const std::string& _internal_entry_point() const;
  void _internal_set_entry_point(const std::string& value);
  std::string* _internal_mutable_entry_point();
  public:

  // required .SSL_Referee.Stage stage = 1;
  bool has_stage() const;
  private:
  bool _internal_has_stage() const;
  public:
  void clear_stage();
  ::SSL_Referee_Stage stage() const;
  void set_stage(::SSL_Referee_Stage value);
  private:
  ::SSL_Referee_Stage _internal_stage() const;
  void _internal_set_stage(::SSL_Referee_Stage value);
  public:

  // @@protoc_insertion_point(class_scope:amun.CommandStrategyAutomaticEntrypoints.EntrypointForStage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr entry_point_;
  int stage_;
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class CommandStrategyAutomaticEntrypoints PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:amun.CommandStrategyAutomaticEntrypoints) */ {
 public:
  inline CommandStrategyAutomaticEntrypoints() : CommandStrategyAutomaticEntrypoints(nullptr) {};
  virtual ~CommandStrategyAutomaticEntrypoints();

  CommandStrategyAutomaticEntrypoints(const CommandStrategyAutomaticEntrypoints& from);
  CommandStrategyAutomaticEntrypoints(CommandStrategyAutomaticEntrypoints&& from) noexcept
    : CommandStrategyAutomaticEntrypoints() {
    *this = ::std::move(from);
  }

  inline CommandStrategyAutomaticEntrypoints& operator=(const CommandStrategyAutomaticEntrypoints& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandStrategyAutomaticEntrypoints& operator=(CommandStrategyAutomaticEntrypoints&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CommandStrategyAutomaticEntrypoints& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommandStrategyAutomaticEntrypoints* internal_default_instance() {
    return reinterpret_cast<const CommandStrategyAutomaticEntrypoints*>(
               &_CommandStrategyAutomaticEntrypoints_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CommandStrategyAutomaticEntrypoints& a, CommandStrategyAutomaticEntrypoints& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandStrategyAutomaticEntrypoints* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandStrategyAutomaticEntrypoints* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandStrategyAutomaticEntrypoints* New() const final {
    return CreateMaybeMessage<CommandStrategyAutomaticEntrypoints>(nullptr);
  }

  CommandStrategyAutomaticEntrypoints* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandStrategyAutomaticEntrypoints>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CommandStrategyAutomaticEntrypoints& from);
  void MergeFrom(const CommandStrategyAutomaticEntrypoints& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommandStrategyAutomaticEntrypoints* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "amun.CommandStrategyAutomaticEntrypoints";
  }
  protected:
  explicit CommandStrategyAutomaticEntrypoints(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_command_2eproto);
    return ::descriptor_table_command_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef CommandStrategyAutomaticEntrypoints_EntrypointForStage EntrypointForStage;

  // accessors -------------------------------------------------------

  enum : int {
    kMappingFieldNumber = 1,
  };
  // repeated .amun.CommandStrategyAutomaticEntrypoints.EntrypointForStage mapping = 1;
  int mapping_size() const;
  private:
  int _internal_mapping_size() const;
  public:
  void clear_mapping();
  ::amun::CommandStrategyAutomaticEntrypoints_EntrypointForStage* mutable_mapping(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::amun::CommandStrategyAutomaticEntrypoints_EntrypointForStage >*
      mutable_mapping();
  private:
  const ::amun::CommandStrategyAutomaticEntrypoints_EntrypointForStage& _internal_mapping(int index) const;
  ::amun::CommandStrategyAutomaticEntrypoints_EntrypointForStage* _internal_add_mapping();
  public:
  const ::amun::CommandStrategyAutomaticEntrypoints_EntrypointForStage& mapping(int index) const;
  ::amun::CommandStrategyAutomaticEntrypoints_EntrypointForStage* add_mapping();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::amun::CommandStrategyAutomaticEntrypoints_EntrypointForStage >&
      mapping() const;

  // @@protoc_insertion_point(class_scope:amun.CommandStrategyAutomaticEntrypoints)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::amun::CommandStrategyAutomaticEntrypoints_EntrypointForStage > mapping_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class CommandStrategyLoad PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:amun.CommandStrategyLoad) */ {
 public:
  inline CommandStrategyLoad() : CommandStrategyLoad(nullptr) {};
  virtual ~CommandStrategyLoad();

  CommandStrategyLoad(const CommandStrategyLoad& from);
  CommandStrategyLoad(CommandStrategyLoad&& from) noexcept
    : CommandStrategyLoad() {
    *this = ::std::move(from);
  }

  inline CommandStrategyLoad& operator=(const CommandStrategyLoad& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandStrategyLoad& operator=(CommandStrategyLoad&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CommandStrategyLoad& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommandStrategyLoad* internal_default_instance() {
    return reinterpret_cast<const CommandStrategyLoad*>(
               &_CommandStrategyLoad_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CommandStrategyLoad& a, CommandStrategyLoad& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandStrategyLoad* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandStrategyLoad* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandStrategyLoad* New() const final {
    return CreateMaybeMessage<CommandStrategyLoad>(nullptr);
  }

  CommandStrategyLoad* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandStrategyLoad>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CommandStrategyLoad& from);
  void MergeFrom(const CommandStrategyLoad& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommandStrategyLoad* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "amun.CommandStrategyLoad";
  }
  protected:
  explicit CommandStrategyLoad(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_command_2eproto);
    return ::descriptor_table_command_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilenameFieldNumber = 1,
    kEntryPointFieldNumber = 2,
  };
  // required string filename = 1;
  bool has_filename() const;
  private:
  bool _internal_has_filename() const;
  public:
  void clear_filename();
  const std::string& filename() const;
  void set_filename(const std::string& value);
  void set_filename(std::string&& value);
  void set_filename(const char* value);
  void set_filename(const char* value, size_t size);
  std::string* mutable_filename();
  std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_filename();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_filename(
      std::string* filename);
  private:
  const std::string& _internal_filename() const;
  void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // optional string entry_point = 2;
  bool has_entry_point() const;
  private:
  bool _internal_has_entry_point() const;
  public:
  void clear_entry_point();
  const std::string& entry_point() const;
  void set_entry_point(const std::string& value);
  void set_entry_point(std::string&& value);
  void set_entry_point(const char* value);
  void set_entry_point(const char* value, size_t size);
  std::string* mutable_entry_point();
  std::string* release_entry_point();
  void set_allocated_entry_point(std::string* entry_point);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_entry_point();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_entry_point(
      std::string* entry_point);
  private:
  const std::string& _internal_entry_point() const;
  void _internal_set_entry_point(const std::string& value);
  std::string* _internal_mutable_entry_point();
  public:

  // @@protoc_insertion_point(class_scope:amun.CommandStrategyLoad)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr entry_point_;
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class CommandStrategyClose PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:amun.CommandStrategyClose) */ {
 public:
  inline CommandStrategyClose() : CommandStrategyClose(nullptr) {};
  virtual ~CommandStrategyClose();

  CommandStrategyClose(const CommandStrategyClose& from);
  CommandStrategyClose(CommandStrategyClose&& from) noexcept
    : CommandStrategyClose() {
    *this = ::std::move(from);
  }

  inline CommandStrategyClose& operator=(const CommandStrategyClose& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandStrategyClose& operator=(CommandStrategyClose&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CommandStrategyClose& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommandStrategyClose* internal_default_instance() {
    return reinterpret_cast<const CommandStrategyClose*>(
               &_CommandStrategyClose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CommandStrategyClose& a, CommandStrategyClose& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandStrategyClose* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandStrategyClose* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandStrategyClose* New() const final {
    return CreateMaybeMessage<CommandStrategyClose>(nullptr);
  }

  CommandStrategyClose* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandStrategyClose>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CommandStrategyClose& from);
  void MergeFrom(const CommandStrategyClose& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommandStrategyClose* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "amun.CommandStrategyClose";
  }
  protected:
  explicit CommandStrategyClose(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_command_2eproto);
    return ::descriptor_table_command_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:amun.CommandStrategyClose)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class CommandStrategyTriggerDebugger PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:amun.CommandStrategyTriggerDebugger) */ {
 public:
  inline CommandStrategyTriggerDebugger() : CommandStrategyTriggerDebugger(nullptr) {};
  virtual ~CommandStrategyTriggerDebugger();

  CommandStrategyTriggerDebugger(const CommandStrategyTriggerDebugger& from);
  CommandStrategyTriggerDebugger(CommandStrategyTriggerDebugger&& from) noexcept
    : CommandStrategyTriggerDebugger() {
    *this = ::std::move(from);
  }

  inline CommandStrategyTriggerDebugger& operator=(const CommandStrategyTriggerDebugger& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandStrategyTriggerDebugger& operator=(CommandStrategyTriggerDebugger&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CommandStrategyTriggerDebugger& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommandStrategyTriggerDebugger* internal_default_instance() {
    return reinterpret_cast<const CommandStrategyTriggerDebugger*>(
               &_CommandStrategyTriggerDebugger_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CommandStrategyTriggerDebugger& a, CommandStrategyTriggerDebugger& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandStrategyTriggerDebugger* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandStrategyTriggerDebugger* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandStrategyTriggerDebugger* New() const final {
    return CreateMaybeMessage<CommandStrategyTriggerDebugger>(nullptr);
  }

  CommandStrategyTriggerDebugger* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandStrategyTriggerDebugger>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CommandStrategyTriggerDebugger& from);
  void MergeFrom(const CommandStrategyTriggerDebugger& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommandStrategyTriggerDebugger* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "amun.CommandStrategyTriggerDebugger";
  }
  protected:
  explicit CommandStrategyTriggerDebugger(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_command_2eproto);
    return ::descriptor_table_command_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:amun.CommandStrategyTriggerDebugger)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class CommandStrategy PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:amun.CommandStrategy) */ {
 public:
  inline CommandStrategy() : CommandStrategy(nullptr) {};
  virtual ~CommandStrategy();

  CommandStrategy(const CommandStrategy& from);
  CommandStrategy(CommandStrategy&& from) noexcept
    : CommandStrategy() {
    *this = ::std::move(from);
  }

  inline CommandStrategy& operator=(const CommandStrategy& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandStrategy& operator=(CommandStrategy&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CommandStrategy& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommandStrategy* internal_default_instance() {
    return reinterpret_cast<const CommandStrategy*>(
               &_CommandStrategy_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CommandStrategy& a, CommandStrategy& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandStrategy* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandStrategy* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandStrategy* New() const final {
    return CreateMaybeMessage<CommandStrategy>(nullptr);
  }

  CommandStrategy* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandStrategy>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CommandStrategy& from);
  void MergeFrom(const CommandStrategy& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommandStrategy* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "amun.CommandStrategy";
  }
  protected:
  explicit CommandStrategy(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_command_2eproto);
    return ::descriptor_table_command_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFinishAndSaveProfileFieldNumber = 9,
    kLoadFieldNumber = 1,
    kCloseFieldNumber = 2,
    kDebugFieldNumber = 6,
    kAutomaticEntrypointsFieldNumber = 11,
    kReloadFieldNumber = 3,
    kAutoReloadFieldNumber = 4,
    kEnableDebugFieldNumber = 5,
    kPerformanceModeFieldNumber = 7,
    kStartProfilingFieldNumber = 8,
    kTournamentModeFieldNumber = 10,
  };
  // optional string finish_and_save_profile = 9;
  bool has_finish_and_save_profile() const;
  private:
  bool _internal_has_finish_and_save_profile() const;
  public:
  void clear_finish_and_save_profile();
  const std::string& finish_and_save_profile() const;
  void set_finish_and_save_profile(const std::string& value);
  void set_finish_and_save_profile(std::string&& value);
  void set_finish_and_save_profile(const char* value);
  void set_finish_and_save_profile(const char* value, size_t size);
  std::string* mutable_finish_and_save_profile();
  std::string* release_finish_and_save_profile();
  void set_allocated_finish_and_save_profile(std::string* finish_and_save_profile);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_finish_and_save_profile();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_finish_and_save_profile(
      std::string* finish_and_save_profile);
  private:
  const std::string& _internal_finish_and_save_profile() const;
  void _internal_set_finish_and_save_profile(const std::string& value);
  std::string* _internal_mutable_finish_and_save_profile();
  public:

  // optional .amun.CommandStrategyLoad load = 1;
  bool has_load() const;
  private:
  bool _internal_has_load() const;
  public:
  void clear_load();
  const ::amun::CommandStrategyLoad& load() const;
  ::amun::CommandStrategyLoad* release_load();
  ::amun::CommandStrategyLoad* mutable_load();
  void set_allocated_load(::amun::CommandStrategyLoad* load);
  private:
  const ::amun::CommandStrategyLoad& _internal_load() const;
  ::amun::CommandStrategyLoad* _internal_mutable_load();
  public:
  void unsafe_arena_set_allocated_load(
      ::amun::CommandStrategyLoad* load);
  ::amun::CommandStrategyLoad* unsafe_arena_release_load();

  // optional .amun.CommandStrategyClose close = 2;
  bool has_close() const;
  private:
  bool _internal_has_close() const;
  public:
  void clear_close();
  const ::amun::CommandStrategyClose& close() const;
  ::amun::CommandStrategyClose* release_close();
  ::amun::CommandStrategyClose* mutable_close();
  void set_allocated_close(::amun::CommandStrategyClose* close);
  private:
  const ::amun::CommandStrategyClose& _internal_close() const;
  ::amun::CommandStrategyClose* _internal_mutable_close();
  public:
  void unsafe_arena_set_allocated_close(
      ::amun::CommandStrategyClose* close);
  ::amun::CommandStrategyClose* unsafe_arena_release_close();

  // optional .amun.CommandStrategyTriggerDebugger debug = 6;
  bool has_debug() const;
  private:
  bool _internal_has_debug() const;
  public:
  void clear_debug();
  const ::amun::CommandStrategyTriggerDebugger& debug() const;
  ::amun::CommandStrategyTriggerDebugger* release_debug();
  ::amun::CommandStrategyTriggerDebugger* mutable_debug();
  void set_allocated_debug(::amun::CommandStrategyTriggerDebugger* debug);
  private:
  const ::amun::CommandStrategyTriggerDebugger& _internal_debug() const;
  ::amun::CommandStrategyTriggerDebugger* _internal_mutable_debug();
  public:
  void unsafe_arena_set_allocated_debug(
      ::amun::CommandStrategyTriggerDebugger* debug);
  ::amun::CommandStrategyTriggerDebugger* unsafe_arena_release_debug();

  // optional .amun.CommandStrategyAutomaticEntrypoints automatic_entrypoints = 11;
  bool has_automatic_entrypoints() const;
  private:
  bool _internal_has_automatic_entrypoints() const;
  public:
  void clear_automatic_entrypoints();
  const ::amun::CommandStrategyAutomaticEntrypoints& automatic_entrypoints() const;
  ::amun::CommandStrategyAutomaticEntrypoints* release_automatic_entrypoints();
  ::amun::CommandStrategyAutomaticEntrypoints* mutable_automatic_entrypoints();
  void set_allocated_automatic_entrypoints(::amun::CommandStrategyAutomaticEntrypoints* automatic_entrypoints);
  private:
  const ::amun::CommandStrategyAutomaticEntrypoints& _internal_automatic_entrypoints() const;
  ::amun::CommandStrategyAutomaticEntrypoints* _internal_mutable_automatic_entrypoints();
  public:
  void unsafe_arena_set_allocated_automatic_entrypoints(
      ::amun::CommandStrategyAutomaticEntrypoints* automatic_entrypoints);
  ::amun::CommandStrategyAutomaticEntrypoints* unsafe_arena_release_automatic_entrypoints();

  // optional bool reload = 3;
  bool has_reload() const;
  private:
  bool _internal_has_reload() const;
  public:
  void clear_reload();
  bool reload() const;
  void set_reload(bool value);
  private:
  bool _internal_reload() const;
  void _internal_set_reload(bool value);
  public:

  // optional bool auto_reload = 4;
  bool has_auto_reload() const;
  private:
  bool _internal_has_auto_reload() const;
  public:
  void clear_auto_reload();
  bool auto_reload() const;
  void set_auto_reload(bool value);
  private:
  bool _internal_auto_reload() const;
  void _internal_set_auto_reload(bool value);
  public:

  // optional bool enable_debug = 5;
  bool has_enable_debug() const;
  private:
  bool _internal_has_enable_debug() const;
  public:
  void clear_enable_debug();
  bool enable_debug() const;
  void set_enable_debug(bool value);
  private:
  bool _internal_enable_debug() const;
  void _internal_set_enable_debug(bool value);
  public:

  // optional bool performance_mode = 7;
  bool has_performance_mode() const;
  private:
  bool _internal_has_performance_mode() const;
  public:
  void clear_performance_mode();
  bool performance_mode() const;
  void set_performance_mode(bool value);
  private:
  bool _internal_performance_mode() const;
  void _internal_set_performance_mode(bool value);
  public:

  // optional bool start_profiling = 8;
  bool has_start_profiling() const;
  private:
  bool _internal_has_start_profiling() const;
  public:
  void clear_start_profiling();
  bool start_profiling() const;
  void set_start_profiling(bool value);
  private:
  bool _internal_start_profiling() const;
  void _internal_set_start_profiling(bool value);
  public:

  // optional bool tournament_mode = 10;
  bool has_tournament_mode() const;
  private:
  bool _internal_has_tournament_mode() const;
  public:
  void clear_tournament_mode();
  bool tournament_mode() const;
  void set_tournament_mode(bool value);
  private:
  bool _internal_tournament_mode() const;
  void _internal_set_tournament_mode(bool value);
  public:

  // @@protoc_insertion_point(class_scope:amun.CommandStrategy)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr finish_and_save_profile_;
  ::amun::CommandStrategyLoad* load_;
  ::amun::CommandStrategyClose* close_;
  ::amun::CommandStrategyTriggerDebugger* debug_;
  ::amun::CommandStrategyAutomaticEntrypoints* automatic_entrypoints_;
  bool reload_;
  bool auto_reload_;
  bool enable_debug_;
  bool performance_mode_;
  bool start_profiling_;
  bool tournament_mode_;
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class CommandControl PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:amun.CommandControl) */ {
 public:
  inline CommandControl() : CommandControl(nullptr) {};
  virtual ~CommandControl();

  CommandControl(const CommandControl& from);
  CommandControl(CommandControl&& from) noexcept
    : CommandControl() {
    *this = ::std::move(from);
  }

  inline CommandControl& operator=(const CommandControl& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandControl& operator=(CommandControl&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CommandControl& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommandControl* internal_default_instance() {
    return reinterpret_cast<const CommandControl*>(
               &_CommandControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CommandControl& a, CommandControl& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandControl* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandControl* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandControl* New() const final {
    return CreateMaybeMessage<CommandControl>(nullptr);
  }

  CommandControl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandControl>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CommandControl& from);
  void MergeFrom(const CommandControl& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommandControl* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "amun.CommandControl";
  }
  protected:
  explicit CommandControl(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_command_2eproto);
    return ::descriptor_table_command_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommandsFieldNumber = 1,
  };
  // repeated .robot.RadioCommand commands = 1;
  int commands_size() const;
  private:
  int _internal_commands_size() const;
  public:
  void clear_commands();
  ::robot::RadioCommand* mutable_commands(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::RadioCommand >*
      mutable_commands();
  private:
  const ::robot::RadioCommand& _internal_commands(int index) const;
  ::robot::RadioCommand* _internal_add_commands();
  public:
  const ::robot::RadioCommand& commands(int index) const;
  ::robot::RadioCommand* add_commands();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::RadioCommand >&
      commands() const;

  // @@protoc_insertion_point(class_scope:amun.CommandControl)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::RadioCommand > commands_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class TransceiverConfiguration PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:amun.TransceiverConfiguration) */ {
 public:
  inline TransceiverConfiguration() : TransceiverConfiguration(nullptr) {};
  virtual ~TransceiverConfiguration();

  TransceiverConfiguration(const TransceiverConfiguration& from);
  TransceiverConfiguration(TransceiverConfiguration&& from) noexcept
    : TransceiverConfiguration() {
    *this = ::std::move(from);
  }

  inline TransceiverConfiguration& operator=(const TransceiverConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransceiverConfiguration& operator=(TransceiverConfiguration&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TransceiverConfiguration& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TransceiverConfiguration* internal_default_instance() {
    return reinterpret_cast<const TransceiverConfiguration*>(
               &_TransceiverConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(TransceiverConfiguration& a, TransceiverConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(TransceiverConfiguration* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransceiverConfiguration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TransceiverConfiguration* New() const final {
    return CreateMaybeMessage<TransceiverConfiguration>(nullptr);
  }

  TransceiverConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransceiverConfiguration>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TransceiverConfiguration& from);
  void MergeFrom(const TransceiverConfiguration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransceiverConfiguration* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "amun.TransceiverConfiguration";
  }
  protected:
  explicit TransceiverConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_command_2eproto);
    return ::descriptor_table_command_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelFieldNumber = 1,
  };
  // required uint32 channel = 1;
  bool has_channel() const;
  private:
  bool _internal_has_channel() const;
  public:
  void clear_channel();
  ::PROTOBUF_NAMESPACE_ID::uint32 channel() const;
  void set_channel(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_channel() const;
  void _internal_set_channel(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:amun.TransceiverConfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 channel_;
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class HostAddress PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:amun.HostAddress) */ {
 public:
  inline HostAddress() : HostAddress(nullptr) {};
  virtual ~HostAddress();

  HostAddress(const HostAddress& from);
  HostAddress(HostAddress&& from) noexcept
    : HostAddress() {
    *this = ::std::move(from);
  }

  inline HostAddress& operator=(const HostAddress& from) {
    CopyFrom(from);
    return *this;
  }
  inline HostAddress& operator=(HostAddress&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HostAddress& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HostAddress* internal_default_instance() {
    return reinterpret_cast<const HostAddress*>(
               &_HostAddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(HostAddress& a, HostAddress& b) {
    a.Swap(&b);
  }
  inline void Swap(HostAddress* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HostAddress* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HostAddress* New() const final {
    return CreateMaybeMessage<HostAddress>(nullptr);
  }

  HostAddress* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HostAddress>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HostAddress& from);
  void MergeFrom(const HostAddress& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HostAddress* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "amun.HostAddress";
  }
  protected:
  explicit HostAddress(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_command_2eproto);
    return ::descriptor_table_command_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostFieldNumber = 1,
    kPortFieldNumber = 2,
  };
  // required string host = 1;
  bool has_host() const;
  private:
  bool _internal_has_host() const;
  public:
  void clear_host();
  const std::string& host() const;
  void set_host(const std::string& value);
  void set_host(std::string&& value);
  void set_host(const char* value);
  void set_host(const char* value, size_t size);
  std::string* mutable_host();
  std::string* release_host();
  void set_allocated_host(std::string* host);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_host();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_host(
      std::string* host);
  private:
  const std::string& _internal_host() const;
  void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // required uint32 port = 2;
  bool has_port() const;
  private:
  bool _internal_has_port() const;
  public:
  void clear_port();
  ::PROTOBUF_NAMESPACE_ID::uint32 port() const;
  void set_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_port() const;
  void _internal_set_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:amun.HostAddress)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
  ::PROTOBUF_NAMESPACE_ID::uint32 port_;
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class SimulatorNetworking PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:amun.SimulatorNetworking) */ {
 public:
  inline SimulatorNetworking() : SimulatorNetworking(nullptr) {};
  virtual ~SimulatorNetworking();

  SimulatorNetworking(const SimulatorNetworking& from);
  SimulatorNetworking(SimulatorNetworking&& from) noexcept
    : SimulatorNetworking() {
    *this = ::std::move(from);
  }

  inline SimulatorNetworking& operator=(const SimulatorNetworking& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimulatorNetworking& operator=(SimulatorNetworking&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SimulatorNetworking& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SimulatorNetworking* internal_default_instance() {
    return reinterpret_cast<const SimulatorNetworking*>(
               &_SimulatorNetworking_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SimulatorNetworking& a, SimulatorNetworking& b) {
    a.Swap(&b);
  }
  inline void Swap(SimulatorNetworking* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SimulatorNetworking* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SimulatorNetworking* New() const final {
    return CreateMaybeMessage<SimulatorNetworking>(nullptr);
  }

  SimulatorNetworking* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SimulatorNetworking>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SimulatorNetworking& from);
  void MergeFrom(const SimulatorNetworking& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimulatorNetworking* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "amun.SimulatorNetworking";
  }
  protected:
  explicit SimulatorNetworking(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_command_2eproto);
    return ::descriptor_table_command_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControlSimulatorFieldNumber = 1,
    kControlBlueFieldNumber = 2,
    kControlYellowFieldNumber = 3,
    kPortBlueFieldNumber = 4,
    kPortYellowFieldNumber = 5,
  };
  // required bool control_simulator = 1;
  bool has_control_simulator() const;
  private:
  bool _internal_has_control_simulator() const;
  public:
  void clear_control_simulator();
  bool control_simulator() const;
  void set_control_simulator(bool value);
  private:
  bool _internal_control_simulator() const;
  void _internal_set_control_simulator(bool value);
  public:

  // required bool control_blue = 2;
  bool has_control_blue() const;
  private:
  bool _internal_has_control_blue() const;
  public:
  void clear_control_blue();
  bool control_blue() const;
  void set_control_blue(bool value);
  private:
  bool _internal_control_blue() const;
  void _internal_set_control_blue(bool value);
  public:

  // required bool control_yellow = 3;
  bool has_control_yellow() const;
  private:
  bool _internal_has_control_yellow() const;
  public:
  void clear_control_yellow();
  bool control_yellow() const;
  void set_control_yellow(bool value);
  private:
  bool _internal_control_yellow() const;
  void _internal_set_control_yellow(bool value);
  public:

  // required uint32 port_blue = 4;
  bool has_port_blue() const;
  private:
  bool _internal_has_port_blue() const;
  public:
  void clear_port_blue();
  ::PROTOBUF_NAMESPACE_ID::uint32 port_blue() const;
  void set_port_blue(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_port_blue() const;
  void _internal_set_port_blue(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 port_yellow = 5;
  bool has_port_yellow() const;
  private:
  bool _internal_has_port_yellow() const;
  public:
  void clear_port_yellow();
  ::PROTOBUF_NAMESPACE_ID::uint32 port_yellow() const;
  void set_port_yellow(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_port_yellow() const;
  void _internal_set_port_yellow(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:amun.SimulatorNetworking)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool control_simulator_;
  bool control_blue_;
  bool control_yellow_;
  ::PROTOBUF_NAMESPACE_ID::uint32 port_blue_;
  ::PROTOBUF_NAMESPACE_ID::uint32 port_yellow_;
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class CommandTransceiver PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:amun.CommandTransceiver) */ {
 public:
  inline CommandTransceiver() : CommandTransceiver(nullptr) {};
  virtual ~CommandTransceiver();

  CommandTransceiver(const CommandTransceiver& from);
  CommandTransceiver(CommandTransceiver&& from) noexcept
    : CommandTransceiver() {
    *this = ::std::move(from);
  }

  inline CommandTransceiver& operator=(const CommandTransceiver& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandTransceiver& operator=(CommandTransceiver&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CommandTransceiver& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommandTransceiver* internal_default_instance() {
    return reinterpret_cast<const CommandTransceiver*>(
               &_CommandTransceiver_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(CommandTransceiver& a, CommandTransceiver& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandTransceiver* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandTransceiver* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandTransceiver* New() const final {
    return CreateMaybeMessage<CommandTransceiver>(nullptr);
  }

  CommandTransceiver* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandTransceiver>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CommandTransceiver& from);
  void MergeFrom(const CommandTransceiver& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommandTransceiver* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "amun.CommandTransceiver";
  }
  protected:
  explicit CommandTransceiver(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_command_2eproto);
    return ::descriptor_table_command_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigurationFieldNumber = 3,
    kNetworkConfigurationFieldNumber = 4,
    kSimulatorConfigurationFieldNumber = 6,
    kEnableFieldNumber = 1,
    kChargeFieldNumber = 2,
    kUseNetworkFieldNumber = 5,
  };
  // optional .amun.TransceiverConfiguration configuration = 3;
  bool has_configuration() const;
  private:
  bool _internal_has_configuration() const;
  public:
  void clear_configuration();
  const ::amun::TransceiverConfiguration& configuration() const;
  ::amun::TransceiverConfiguration* release_configuration();
  ::amun::TransceiverConfiguration* mutable_configuration();
  void set_allocated_configuration(::amun::TransceiverConfiguration* configuration);
  private:
  const ::amun::TransceiverConfiguration& _internal_configuration() const;
  ::amun::TransceiverConfiguration* _internal_mutable_configuration();
  public:
  void unsafe_arena_set_allocated_configuration(
      ::amun::TransceiverConfiguration* configuration);
  ::amun::TransceiverConfiguration* unsafe_arena_release_configuration();

  // optional .amun.HostAddress network_configuration = 4;
  bool has_network_configuration() const;
  private:
  bool _internal_has_network_configuration() const;
  public:
  void clear_network_configuration();
  const ::amun::HostAddress& network_configuration() const;
  ::amun::HostAddress* release_network_configuration();
  ::amun::HostAddress* mutable_network_configuration();
  void set_allocated_network_configuration(::amun::HostAddress* network_configuration);
  private:
  const ::amun::HostAddress& _internal_network_configuration() const;
  ::amun::HostAddress* _internal_mutable_network_configuration();
  public:
  void unsafe_arena_set_allocated_network_configuration(
      ::amun::HostAddress* network_configuration);
  ::amun::HostAddress* unsafe_arena_release_network_configuration();

  // optional .amun.SimulatorNetworking simulator_configuration = 6;
  bool has_simulator_configuration() const;
  private:
  bool _internal_has_simulator_configuration() const;
  public:
  void clear_simulator_configuration();
  const ::amun::SimulatorNetworking& simulator_configuration() const;
  ::amun::SimulatorNetworking* release_simulator_configuration();
  ::amun::SimulatorNetworking* mutable_simulator_configuration();
  void set_allocated_simulator_configuration(::amun::SimulatorNetworking* simulator_configuration);
  private:
  const ::amun::SimulatorNetworking& _internal_simulator_configuration() const;
  ::amun::SimulatorNetworking* _internal_mutable_simulator_configuration();
  public:
  void unsafe_arena_set_allocated_simulator_configuration(
      ::amun::SimulatorNetworking* simulator_configuration);
  ::amun::SimulatorNetworking* unsafe_arena_release_simulator_configuration();

  // optional bool enable = 1;
  bool has_enable() const;
  private:
  bool _internal_has_enable() const;
  public:
  void clear_enable();
  bool enable() const;
  void set_enable(bool value);
  private:
  bool _internal_enable() const;
  void _internal_set_enable(bool value);
  public:

  // optional bool charge = 2;
  bool has_charge() const;
  private:
  bool _internal_has_charge() const;
  public:
  void clear_charge();
  bool charge() const;
  void set_charge(bool value);
  private:
  bool _internal_charge() const;
  void _internal_set_charge(bool value);
  public:

  // optional bool use_network = 5;
  bool has_use_network() const;
  private:
  bool _internal_has_use_network() const;
  public:
  void clear_use_network();
  bool use_network() const;
  void set_use_network(bool value);
  private:
  bool _internal_use_network() const;
  void _internal_set_use_network(bool value);
  public:

  // @@protoc_insertion_point(class_scope:amun.CommandTransceiver)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::amun::TransceiverConfiguration* configuration_;
  ::amun::HostAddress* network_configuration_;
  ::amun::SimulatorNetworking* simulator_configuration_;
  bool enable_;
  bool charge_;
  bool use_network_;
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class VirtualFieldTransform PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:amun.VirtualFieldTransform) */ {
 public:
  inline VirtualFieldTransform() : VirtualFieldTransform(nullptr) {};
  virtual ~VirtualFieldTransform();

  VirtualFieldTransform(const VirtualFieldTransform& from);
  VirtualFieldTransform(VirtualFieldTransform&& from) noexcept
    : VirtualFieldTransform() {
    *this = ::std::move(from);
  }

  inline VirtualFieldTransform& operator=(const VirtualFieldTransform& from) {
    CopyFrom(from);
    return *this;
  }
  inline VirtualFieldTransform& operator=(VirtualFieldTransform&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VirtualFieldTransform& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VirtualFieldTransform* internal_default_instance() {
    return reinterpret_cast<const VirtualFieldTransform*>(
               &_VirtualFieldTransform_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(VirtualFieldTransform& a, VirtualFieldTransform& b) {
    a.Swap(&b);
  }
  inline void Swap(VirtualFieldTransform* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VirtualFieldTransform* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VirtualFieldTransform* New() const final {
    return CreateMaybeMessage<VirtualFieldTransform>(nullptr);
  }

  VirtualFieldTransform* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VirtualFieldTransform>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VirtualFieldTransform& from);
  void MergeFrom(const VirtualFieldTransform& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VirtualFieldTransform* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "amun.VirtualFieldTransform";
  }
  protected:
  explicit VirtualFieldTransform(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_command_2eproto);
    return ::descriptor_table_command_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kA11FieldNumber = 1,
    kA12FieldNumber = 2,
    kA21FieldNumber = 3,
    kA22FieldNumber = 4,
    kOffsetXFieldNumber = 5,
    kOffsetYFieldNumber = 6,
  };
  // required float a11 = 1;
  bool has_a11() const;
  private:
  bool _internal_has_a11() const;
  public:
  void clear_a11();
  float a11() const;
  void set_a11(float value);
  private:
  float _internal_a11() const;
  void _internal_set_a11(float value);
  public:

  // required float a12 = 2;
  bool has_a12() const;
  private:
  bool _internal_has_a12() const;
  public:
  void clear_a12();
  float a12() const;
  void set_a12(float value);
  private:
  float _internal_a12() const;
  void _internal_set_a12(float value);
  public:

  // required float a21 = 3;
  bool has_a21() const;
  private:
  bool _internal_has_a21() const;
  public:
  void clear_a21();
  float a21() const;
  void set_a21(float value);
  private:
  float _internal_a21() const;
  void _internal_set_a21(float value);
  public:

  // required float a22 = 4;
  bool has_a22() const;
  private:
  bool _internal_has_a22() const;
  public:
  void clear_a22();
  float a22() const;
  void set_a22(float value);
  private:
  float _internal_a22() const;
  void _internal_set_a22(float value);
  public:

  // required float offsetX = 5;
  bool has_offsetx() const;
  private:
  bool _internal_has_offsetx() const;
  public:
  void clear_offsetx();
  float offsetx() const;
  void set_offsetx(float value);
  private:
  float _internal_offsetx() const;
  void _internal_set_offsetx(float value);
  public:

  // required float offsetY = 6;
  bool has_offsety() const;
  private:
  bool _internal_has_offsety() const;
  public:
  void clear_offsety();
  float offsety() const;
  void set_offsety(float value);
  private:
  float _internal_offsety() const;
  void _internal_set_offsety(float value);
  public:

  // @@protoc_insertion_point(class_scope:amun.VirtualFieldTransform)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float a11_;
  float a12_;
  float a21_;
  float a22_;
  float offsetx_;
  float offsety_;
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class CommandTracking PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:amun.CommandTracking) */ {
 public:
  inline CommandTracking() : CommandTracking(nullptr) {};
  virtual ~CommandTracking();

  CommandTracking(const CommandTracking& from);
  CommandTracking(CommandTracking&& from) noexcept
    : CommandTracking() {
    *this = ::std::move(from);
  }

  inline CommandTracking& operator=(const CommandTracking& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandTracking& operator=(CommandTracking&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CommandTracking& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommandTracking* internal_default_instance() {
    return reinterpret_cast<const CommandTracking*>(
               &_CommandTracking_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(CommandTracking& a, CommandTracking& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandTracking* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandTracking* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandTracking* New() const final {
    return CreateMaybeMessage<CommandTracking>(nullptr);
  }

  CommandTracking* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandTracking>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CommandTracking& from);
  void MergeFrom(const CommandTracking& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommandTracking* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "amun.CommandTracking";
  }
  protected:
  explicit CommandTracking(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_command_2eproto);
    return ::descriptor_table_command_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAoiFieldNumber = 2,
    kFieldTransformFieldNumber = 6,
    kVirtualGeometryFieldNumber = 7,
    kBallModelFieldNumber = 9,
    kSystemDelayFieldNumber = 3,
    kAoiEnabledFieldNumber = 1,
    kResetFieldNumber = 4,
    kEnableVirtualFieldFieldNumber = 5,
    kTrackingReplayEnabledFieldNumber = 8,
  };
  // optional .world.TrackingAOI aoi = 2;
  bool has_aoi() const;
  private:
  bool _internal_has_aoi() const;
  public:
  void clear_aoi();
  const ::world::TrackingAOI& aoi() const;
  ::world::TrackingAOI* release_aoi();
  ::world::TrackingAOI* mutable_aoi();
  void set_allocated_aoi(::world::TrackingAOI* aoi);
  private:
  const ::world::TrackingAOI& _internal_aoi() const;
  ::world::TrackingAOI* _internal_mutable_aoi();
  public:
  void unsafe_arena_set_allocated_aoi(
      ::world::TrackingAOI* aoi);
  ::world::TrackingAOI* unsafe_arena_release_aoi();

  // optional .amun.VirtualFieldTransform field_transform = 6;
  bool has_field_transform() const;
  private:
  bool _internal_has_field_transform() const;
  public:
  void clear_field_transform();
  const ::amun::VirtualFieldTransform& field_transform() const;
  ::amun::VirtualFieldTransform* release_field_transform();
  ::amun::VirtualFieldTransform* mutable_field_transform();
  void set_allocated_field_transform(::amun::VirtualFieldTransform* field_transform);
  private:
  const ::amun::VirtualFieldTransform& _internal_field_transform() const;
  ::amun::VirtualFieldTransform* _internal_mutable_field_transform();
  public:
  void unsafe_arena_set_allocated_field_transform(
      ::amun::VirtualFieldTransform* field_transform);
  ::amun::VirtualFieldTransform* unsafe_arena_release_field_transform();

  // optional .world.Geometry virtual_geometry = 7;
  bool has_virtual_geometry() const;
  private:
  bool _internal_has_virtual_geometry() const;
  public:
  void clear_virtual_geometry();
  const ::world::Geometry& virtual_geometry() const;
  ::world::Geometry* release_virtual_geometry();
  ::world::Geometry* mutable_virtual_geometry();
  void set_allocated_virtual_geometry(::world::Geometry* virtual_geometry);
  private:
  const ::world::Geometry& _internal_virtual_geometry() const;
  ::world::Geometry* _internal_mutable_virtual_geometry();
  public:
  void unsafe_arena_set_allocated_virtual_geometry(
      ::world::Geometry* virtual_geometry);
  ::world::Geometry* unsafe_arena_release_virtual_geometry();

  // optional .world.BallModel ball_model = 9;
  bool has_ball_model() const;
  private:
  bool _internal_has_ball_model() const;
  public:
  void clear_ball_model();
  const ::world::BallModel& ball_model() const;
  ::world::BallModel* release_ball_model();
  ::world::BallModel* mutable_ball_model();
  void set_allocated_ball_model(::world::BallModel* ball_model);
  private:
  const ::world::BallModel& _internal_ball_model() const;
  ::world::BallModel* _internal_mutable_ball_model();
  public:
  void unsafe_arena_set_allocated_ball_model(
      ::world::BallModel* ball_model);
  ::world::BallModel* unsafe_arena_release_ball_model();

  // optional int64 system_delay = 3;
  bool has_system_delay() const;
  private:
  bool _internal_has_system_delay() const;
  public:
  void clear_system_delay();
  ::PROTOBUF_NAMESPACE_ID::int64 system_delay() const;
  void set_system_delay(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_system_delay() const;
  void _internal_set_system_delay(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional bool aoi_enabled = 1;
  bool has_aoi_enabled() const;
  private:
  bool _internal_has_aoi_enabled() const;
  public:
  void clear_aoi_enabled();
  bool aoi_enabled() const;
  void set_aoi_enabled(bool value);
  private:
  bool _internal_aoi_enabled() const;
  void _internal_set_aoi_enabled(bool value);
  public:

  // optional bool reset = 4;
  bool has_reset() const;
  private:
  bool _internal_has_reset() const;
  public:
  void clear_reset();
  bool reset() const;
  void set_reset(bool value);
  private:
  bool _internal_reset() const;
  void _internal_set_reset(bool value);
  public:

  // optional bool enable_virtual_field = 5;
  bool has_enable_virtual_field() const;
  private:
  bool _internal_has_enable_virtual_field() const;
  public:
  void clear_enable_virtual_field();
  bool enable_virtual_field() const;
  void set_enable_virtual_field(bool value);
  private:
  bool _internal_enable_virtual_field() const;
  void _internal_set_enable_virtual_field(bool value);
  public:

  // optional bool tracking_replay_enabled = 8;
  bool has_tracking_replay_enabled() const;
  private:
  bool _internal_has_tracking_replay_enabled() const;
  public:
  void clear_tracking_replay_enabled();
  bool tracking_replay_enabled() const;
  void set_tracking_replay_enabled(bool value);
  private:
  bool _internal_tracking_replay_enabled() const;
  void _internal_set_tracking_replay_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:amun.CommandTracking)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::world::TrackingAOI* aoi_;
  ::amun::VirtualFieldTransform* field_transform_;
  ::world::Geometry* virtual_geometry_;
  ::world::BallModel* ball_model_;
  ::PROTOBUF_NAMESPACE_ID::int64 system_delay_;
  bool aoi_enabled_;
  bool reset_;
  bool enable_virtual_field_;
  bool tracking_replay_enabled_;
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class CommandStrategyChangeOption PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:amun.CommandStrategyChangeOption) */ {
 public:
  inline CommandStrategyChangeOption() : CommandStrategyChangeOption(nullptr) {};
  virtual ~CommandStrategyChangeOption();

  CommandStrategyChangeOption(const CommandStrategyChangeOption& from);
  CommandStrategyChangeOption(CommandStrategyChangeOption&& from) noexcept
    : CommandStrategyChangeOption() {
    *this = ::std::move(from);
  }

  inline CommandStrategyChangeOption& operator=(const CommandStrategyChangeOption& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandStrategyChangeOption& operator=(CommandStrategyChangeOption&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CommandStrategyChangeOption& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommandStrategyChangeOption* internal_default_instance() {
    return reinterpret_cast<const CommandStrategyChangeOption*>(
               &_CommandStrategyChangeOption_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(CommandStrategyChangeOption& a, CommandStrategyChangeOption& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandStrategyChangeOption* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandStrategyChangeOption* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandStrategyChangeOption* New() const final {
    return CreateMaybeMessage<CommandStrategyChangeOption>(nullptr);
  }

  CommandStrategyChangeOption* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandStrategyChangeOption>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CommandStrategyChangeOption& from);
  void MergeFrom(const CommandStrategyChangeOption& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommandStrategyChangeOption* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "amun.CommandStrategyChangeOption";
  }
  protected:
  explicit CommandStrategyChangeOption(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_command_2eproto);
    return ::descriptor_table_command_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required bool value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  bool value() const;
  void set_value(bool value);
  private:
  bool _internal_value() const;
  void _internal_set_value(bool value);
  public:

  // @@protoc_insertion_point(class_scope:amun.CommandStrategyChangeOption)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  bool value_;
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class CommandAmun PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:amun.CommandAmun) */ {
 public:
  inline CommandAmun() : CommandAmun(nullptr) {};
  virtual ~CommandAmun();

  CommandAmun(const CommandAmun& from);
  CommandAmun(CommandAmun&& from) noexcept
    : CommandAmun() {
    *this = ::std::move(from);
  }

  inline CommandAmun& operator=(const CommandAmun& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandAmun& operator=(CommandAmun&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CommandAmun& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommandAmun* internal_default_instance() {
    return reinterpret_cast<const CommandAmun*>(
               &_CommandAmun_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(CommandAmun& a, CommandAmun& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandAmun* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandAmun* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandAmun* New() const final {
    return CreateMaybeMessage<CommandAmun>(nullptr);
  }

  CommandAmun* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandAmun>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CommandAmun& from);
  void MergeFrom(const CommandAmun& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommandAmun* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "amun.CommandAmun";
  }
  protected:
  explicit CommandAmun(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_command_2eproto);
    return ::descriptor_table_command_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChangeOptionFieldNumber = 3,
    kVisionPortFieldNumber = 1,
    kRefereePortFieldNumber = 2,
    kTrackerPortFieldNumber = 4,
  };
  // optional .amun.CommandStrategyChangeOption change_option = 3;
  bool has_change_option() const;
  private:
  bool _internal_has_change_option() const;
  public:
  void clear_change_option();
  const ::amun::CommandStrategyChangeOption& change_option() const;
  ::amun::CommandStrategyChangeOption* release_change_option();
  ::amun::CommandStrategyChangeOption* mutable_change_option();
  void set_allocated_change_option(::amun::CommandStrategyChangeOption* change_option);
  private:
  const ::amun::CommandStrategyChangeOption& _internal_change_option() const;
  ::amun::CommandStrategyChangeOption* _internal_mutable_change_option();
  public:
  void unsafe_arena_set_allocated_change_option(
      ::amun::CommandStrategyChangeOption* change_option);
  ::amun::CommandStrategyChangeOption* unsafe_arena_release_change_option();

  // optional uint32 vision_port = 1;
  bool has_vision_port() const;
  private:
  bool _internal_has_vision_port() const;
  public:
  void clear_vision_port();
  ::PROTOBUF_NAMESPACE_ID::uint32 vision_port() const;
  void set_vision_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_vision_port() const;
  void _internal_set_vision_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 referee_port = 2;
  bool has_referee_port() const;
  private:
  bool _internal_has_referee_port() const;
  public:
  void clear_referee_port();
  ::PROTOBUF_NAMESPACE_ID::uint32 referee_port() const;
  void set_referee_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_referee_port() const;
  void _internal_set_referee_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 tracker_port = 4;
  bool has_tracker_port() const;
  private:
  bool _internal_has_tracker_port() const;
  public:
  void clear_tracker_port();
  ::PROTOBUF_NAMESPACE_ID::uint32 tracker_port() const;
  void set_tracker_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_tracker_port() const;
  void _internal_set_tracker_port(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:amun.CommandAmun)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::amun::CommandStrategyChangeOption* change_option_;
  ::PROTOBUF_NAMESPACE_ID::uint32 vision_port_;
  ::PROTOBUF_NAMESPACE_ID::uint32 referee_port_;
  ::PROTOBUF_NAMESPACE_ID::uint32 tracker_port_;
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class CommandDebuggerInputDisable PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:amun.CommandDebuggerInputDisable) */ {
 public:
  inline CommandDebuggerInputDisable() : CommandDebuggerInputDisable(nullptr) {};
  virtual ~CommandDebuggerInputDisable();

  CommandDebuggerInputDisable(const CommandDebuggerInputDisable& from);
  CommandDebuggerInputDisable(CommandDebuggerInputDisable&& from) noexcept
    : CommandDebuggerInputDisable() {
    *this = ::std::move(from);
  }

  inline CommandDebuggerInputDisable& operator=(const CommandDebuggerInputDisable& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandDebuggerInputDisable& operator=(CommandDebuggerInputDisable&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CommandDebuggerInputDisable& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommandDebuggerInputDisable* internal_default_instance() {
    return reinterpret_cast<const CommandDebuggerInputDisable*>(
               &_CommandDebuggerInputDisable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(CommandDebuggerInputDisable& a, CommandDebuggerInputDisable& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandDebuggerInputDisable* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandDebuggerInputDisable* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandDebuggerInputDisable* New() const final {
    return CreateMaybeMessage<CommandDebuggerInputDisable>(nullptr);
  }

  CommandDebuggerInputDisable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandDebuggerInputDisable>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CommandDebuggerInputDisable& from);
  void MergeFrom(const CommandDebuggerInputDisable& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommandDebuggerInputDisable* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "amun.CommandDebuggerInputDisable";
  }
  protected:
  explicit CommandDebuggerInputDisable(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_command_2eproto);
    return ::descriptor_table_command_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:amun.CommandDebuggerInputDisable)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class CommandDebuggerInputLine PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:amun.CommandDebuggerInputLine) */ {
 public:
  inline CommandDebuggerInputLine() : CommandDebuggerInputLine(nullptr) {};
  virtual ~CommandDebuggerInputLine();

  CommandDebuggerInputLine(const CommandDebuggerInputLine& from);
  CommandDebuggerInputLine(CommandDebuggerInputLine&& from) noexcept
    : CommandDebuggerInputLine() {
    *this = ::std::move(from);
  }

  inline CommandDebuggerInputLine& operator=(const CommandDebuggerInputLine& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandDebuggerInputLine& operator=(CommandDebuggerInputLine&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CommandDebuggerInputLine& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommandDebuggerInputLine* internal_default_instance() {
    return reinterpret_cast<const CommandDebuggerInputLine*>(
               &_CommandDebuggerInputLine_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(CommandDebuggerInputLine& a, CommandDebuggerInputLine& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandDebuggerInputLine* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandDebuggerInputLine* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandDebuggerInputLine* New() const final {
    return CreateMaybeMessage<CommandDebuggerInputLine>(nullptr);
  }

  CommandDebuggerInputLine* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandDebuggerInputLine>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CommandDebuggerInputLine& from);
  void MergeFrom(const CommandDebuggerInputLine& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommandDebuggerInputLine* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "amun.CommandDebuggerInputLine";
  }
  protected:
  explicit CommandDebuggerInputLine(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_command_2eproto);
    return ::descriptor_table_command_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLineFieldNumber = 1,
  };
  // optional string line = 1;
  bool has_line() const;
  private:
  bool _internal_has_line() const;
  public:
  void clear_line();
  const std::string& line() const;
  void set_line(const std::string& value);
  void set_line(std::string&& value);
  void set_line(const char* value);
  void set_line(const char* value, size_t size);
  std::string* mutable_line();
  std::string* release_line();
  void set_allocated_line(std::string* line);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_line();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_line(
      std::string* line);
  private:
  const std::string& _internal_line() const;
  void _internal_set_line(const std::string& value);
  std::string* _internal_mutable_line();
  public:

  // @@protoc_insertion_point(class_scope:amun.CommandDebuggerInputLine)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr line_;
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class CommandDebuggerInput PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:amun.CommandDebuggerInput) */ {
 public:
  inline CommandDebuggerInput() : CommandDebuggerInput(nullptr) {};
  virtual ~CommandDebuggerInput();

  CommandDebuggerInput(const CommandDebuggerInput& from);
  CommandDebuggerInput(CommandDebuggerInput&& from) noexcept
    : CommandDebuggerInput() {
    *this = ::std::move(from);
  }

  inline CommandDebuggerInput& operator=(const CommandDebuggerInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandDebuggerInput& operator=(CommandDebuggerInput&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CommandDebuggerInput& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommandDebuggerInput* internal_default_instance() {
    return reinterpret_cast<const CommandDebuggerInput*>(
               &_CommandDebuggerInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(CommandDebuggerInput& a, CommandDebuggerInput& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandDebuggerInput* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandDebuggerInput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandDebuggerInput* New() const final {
    return CreateMaybeMessage<CommandDebuggerInput>(nullptr);
  }

  CommandDebuggerInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandDebuggerInput>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CommandDebuggerInput& from);
  void MergeFrom(const CommandDebuggerInput& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommandDebuggerInput* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "amun.CommandDebuggerInput";
  }
  protected:
  explicit CommandDebuggerInput(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_command_2eproto);
    return ::descriptor_table_command_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDisableFieldNumber = 2,
    kQueueLineFieldNumber = 3,
    kStrategyTypeFieldNumber = 1,
  };
  // optional .amun.CommandDebuggerInputDisable disable = 2;
  bool has_disable() const;
  private:
  bool _internal_has_disable() const;
  public:
  void clear_disable();
  const ::amun::CommandDebuggerInputDisable& disable() const;
  ::amun::CommandDebuggerInputDisable* release_disable();
  ::amun::CommandDebuggerInputDisable* mutable_disable();
  void set_allocated_disable(::amun::CommandDebuggerInputDisable* disable);
  private:
  const ::amun::CommandDebuggerInputDisable& _internal_disable() const;
  ::amun::CommandDebuggerInputDisable* _internal_mutable_disable();
  public:
  void unsafe_arena_set_allocated_disable(
      ::amun::CommandDebuggerInputDisable* disable);
  ::amun::CommandDebuggerInputDisable* unsafe_arena_release_disable();

  // optional .amun.CommandDebuggerInputLine queue_line = 3;
  bool has_queue_line() const;
  private:
  bool _internal_has_queue_line() const;
  public:
  void clear_queue_line();
  const ::amun::CommandDebuggerInputLine& queue_line() const;
  ::amun::CommandDebuggerInputLine* release_queue_line();
  ::amun::CommandDebuggerInputLine* mutable_queue_line();
  void set_allocated_queue_line(::amun::CommandDebuggerInputLine* queue_line);
  private:
  const ::amun::CommandDebuggerInputLine& _internal_queue_line() const;
  ::amun::CommandDebuggerInputLine* _internal_mutable_queue_line();
  public:
  void unsafe_arena_set_allocated_queue_line(
      ::amun::CommandDebuggerInputLine* queue_line);
  ::amun::CommandDebuggerInputLine* unsafe_arena_release_queue_line();

  // required .amun.DebuggerInputTarget strategy_type = 1;
  bool has_strategy_type() const;
  private:
  bool _internal_has_strategy_type() const;
  public:
  void clear_strategy_type();
  ::amun::DebuggerInputTarget strategy_type() const;
  void set_strategy_type(::amun::DebuggerInputTarget value);
  private:
  ::amun::DebuggerInputTarget _internal_strategy_type() const;
  void _internal_set_strategy_type(::amun::DebuggerInputTarget value);
  public:

  // @@protoc_insertion_point(class_scope:amun.CommandDebuggerInput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::amun::CommandDebuggerInputDisable* disable_;
  ::amun::CommandDebuggerInputLine* queue_line_;
  int strategy_type_;
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class PauseSimulatorCommand PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:amun.PauseSimulatorCommand) */ {
 public:
  inline PauseSimulatorCommand() : PauseSimulatorCommand(nullptr) {};
  virtual ~PauseSimulatorCommand();

  PauseSimulatorCommand(const PauseSimulatorCommand& from);
  PauseSimulatorCommand(PauseSimulatorCommand&& from) noexcept
    : PauseSimulatorCommand() {
    *this = ::std::move(from);
  }

  inline PauseSimulatorCommand& operator=(const PauseSimulatorCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline PauseSimulatorCommand& operator=(PauseSimulatorCommand&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PauseSimulatorCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PauseSimulatorCommand* internal_default_instance() {
    return reinterpret_cast<const PauseSimulatorCommand*>(
               &_PauseSimulatorCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(PauseSimulatorCommand& a, PauseSimulatorCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(PauseSimulatorCommand* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PauseSimulatorCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PauseSimulatorCommand* New() const final {
    return CreateMaybeMessage<PauseSimulatorCommand>(nullptr);
  }

  PauseSimulatorCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PauseSimulatorCommand>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PauseSimulatorCommand& from);
  void MergeFrom(const PauseSimulatorCommand& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PauseSimulatorCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "amun.PauseSimulatorCommand";
  }
  protected:
  explicit PauseSimulatorCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_command_2eproto);
    return ::descriptor_table_command_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPauseFieldNumber = 2,
    kToggleFieldNumber = 3,
    kReasonFieldNumber = 1,
  };
  // optional bool pause = 2;
  bool has_pause() const;
  private:
  bool _internal_has_pause() const;
  public:
  void clear_pause();
  bool pause() const;
  void set_pause(bool value);
  private:
  bool _internal_pause() const;
  void _internal_set_pause(bool value);
  public:

  // optional bool toggle = 3;
  bool has_toggle() const;
  private:
  bool _internal_has_toggle() const;
  public:
  void clear_toggle();
  bool toggle() const;
  void set_toggle(bool value);
  private:
  bool _internal_toggle() const;
  void _internal_set_toggle(bool value);
  public:

  // required .amun.PauseSimulatorReason reason = 1;
  bool has_reason() const;
  private:
  bool _internal_has_reason() const;
  public:
  void clear_reason();
  ::amun::PauseSimulatorReason reason() const;
  void set_reason(::amun::PauseSimulatorReason value);
  private:
  ::amun::PauseSimulatorReason _internal_reason() const;
  void _internal_set_reason(::amun::PauseSimulatorReason value);
  public:

  // @@protoc_insertion_point(class_scope:amun.PauseSimulatorCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool pause_;
  bool toggle_;
  int reason_;
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class CommandReplay PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:amun.CommandReplay) */ {
 public:
  inline CommandReplay() : CommandReplay(nullptr) {};
  virtual ~CommandReplay();

  CommandReplay(const CommandReplay& from);
  CommandReplay(CommandReplay&& from) noexcept
    : CommandReplay() {
    *this = ::std::move(from);
  }

  inline CommandReplay& operator=(const CommandReplay& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandReplay& operator=(CommandReplay&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CommandReplay& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommandReplay* internal_default_instance() {
    return reinterpret_cast<const CommandReplay*>(
               &_CommandReplay_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(CommandReplay& a, CommandReplay& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandReplay* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandReplay* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandReplay* New() const final {
    return CreateMaybeMessage<CommandReplay>(nullptr);
  }

  CommandReplay* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandReplay>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CommandReplay& from);
  void MergeFrom(const CommandReplay& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommandReplay* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "amun.CommandReplay";
  }
  protected:
  explicit CommandReplay(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_command_2eproto);
    return ::descriptor_table_command_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlueStrategyFieldNumber = 3,
    kYellowStrategyFieldNumber = 5,
    kEnableFieldNumber = 1,
    kEnableBlueStrategyFieldNumber = 2,
    kEnableYellowStrategyFieldNumber = 4,
  };
  // optional .amun.CommandStrategy blue_strategy = 3;
  bool has_blue_strategy() const;
  private:
  bool _internal_has_blue_strategy() const;
  public:
  void clear_blue_strategy();
  const ::amun::CommandStrategy& blue_strategy() const;
  ::amun::CommandStrategy* release_blue_strategy();
  ::amun::CommandStrategy* mutable_blue_strategy();
  void set_allocated_blue_strategy(::amun::CommandStrategy* blue_strategy);
  private:
  const ::amun::CommandStrategy& _internal_blue_strategy() const;
  ::amun::CommandStrategy* _internal_mutable_blue_strategy();
  public:
  void unsafe_arena_set_allocated_blue_strategy(
      ::amun::CommandStrategy* blue_strategy);
  ::amun::CommandStrategy* unsafe_arena_release_blue_strategy();

  // optional .amun.CommandStrategy yellow_strategy = 5;
  bool has_yellow_strategy() const;
  private:
  bool _internal_has_yellow_strategy() const;
  public:
  void clear_yellow_strategy();
  const ::amun::CommandStrategy& yellow_strategy() const;
  ::amun::CommandStrategy* release_yellow_strategy();
  ::amun::CommandStrategy* mutable_yellow_strategy();
  void set_allocated_yellow_strategy(::amun::CommandStrategy* yellow_strategy);
  private:
  const ::amun::CommandStrategy& _internal_yellow_strategy() const;
  ::amun::CommandStrategy* _internal_mutable_yellow_strategy();
  public:
  void unsafe_arena_set_allocated_yellow_strategy(
      ::amun::CommandStrategy* yellow_strategy);
  ::amun::CommandStrategy* unsafe_arena_release_yellow_strategy();

  // optional bool enable = 1;
  bool has_enable() const;
  private:
  bool _internal_has_enable() const;
  public:
  void clear_enable();
  bool enable() const;
  void set_enable(bool value);
  private:
  bool _internal_enable() const;
  void _internal_set_enable(bool value);
  public:

  // optional bool enable_blue_strategy = 2;
  bool has_enable_blue_strategy() const;
  private:
  bool _internal_has_enable_blue_strategy() const;
  public:
  void clear_enable_blue_strategy();
  bool enable_blue_strategy() const;
  void set_enable_blue_strategy(bool value);
  private:
  bool _internal_enable_blue_strategy() const;
  void _internal_set_enable_blue_strategy(bool value);
  public:

  // optional bool enable_yellow_strategy = 4;
  bool has_enable_yellow_strategy() const;
  private:
  bool _internal_has_enable_yellow_strategy() const;
  public:
  void clear_enable_yellow_strategy();
  bool enable_yellow_strategy() const;
  void set_enable_yellow_strategy(bool value);
  private:
  bool _internal_enable_yellow_strategy() const;
  void _internal_set_enable_yellow_strategy(bool value);
  public:

  // @@protoc_insertion_point(class_scope:amun.CommandReplay)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::amun::CommandStrategy* blue_strategy_;
  ::amun::CommandStrategy* yellow_strategy_;
  bool enable_;
  bool enable_blue_strategy_;
  bool enable_yellow_strategy_;
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class Flag PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:amun.Flag) */ {
 public:
  inline Flag() : Flag(nullptr) {};
  virtual ~Flag();

  Flag(const Flag& from);
  Flag(Flag&& from) noexcept
    : Flag() {
    *this = ::std::move(from);
  }

  inline Flag& operator=(const Flag& from) {
    CopyFrom(from);
    return *this;
  }
  inline Flag& operator=(Flag&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Flag& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Flag* internal_default_instance() {
    return reinterpret_cast<const Flag*>(
               &_Flag_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(Flag& a, Flag& b) {
    a.Swap(&b);
  }
  inline void Swap(Flag* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Flag* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Flag* New() const final {
    return CreateMaybeMessage<Flag>(nullptr);
  }

  Flag* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Flag>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Flag& from);
  void MergeFrom(const Flag& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Flag* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "amun.Flag";
  }
  protected:
  explicit Flag(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_command_2eproto);
    return ::descriptor_table_command_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:amun.Flag)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class CommandPlayback PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:amun.CommandPlayback) */ {
 public:
  inline CommandPlayback() : CommandPlayback(nullptr) {};
  virtual ~CommandPlayback();

  CommandPlayback(const CommandPlayback& from);
  CommandPlayback(CommandPlayback&& from) noexcept
    : CommandPlayback() {
    *this = ::std::move(from);
  }

  inline CommandPlayback& operator=(const CommandPlayback& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandPlayback& operator=(CommandPlayback&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CommandPlayback& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommandPlayback* internal_default_instance() {
    return reinterpret_cast<const CommandPlayback*>(
               &_CommandPlayback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(CommandPlayback& a, CommandPlayback& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandPlayback* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandPlayback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandPlayback* New() const final {
    return CreateMaybeMessage<CommandPlayback>(nullptr);
  }

  CommandPlayback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandPlayback>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CommandPlayback& from);
  void MergeFrom(const CommandPlayback& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommandPlayback* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "amun.CommandPlayback";
  }
  protected:
  explicit CommandPlayback(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_command_2eproto);
    return ::descriptor_table_command_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExportVisionLogFieldNumber = 9,
    kFindLogfileFieldNumber = 11,
    kTogglePausedFieldNumber = 5,
    kLogPathFieldNumber = 7,
    kInstantReplayFieldNumber = 8,
    kGetUidFieldNumber = 10,
    kSeekTimeFieldNumber = 1,
    kSeekPacketFieldNumber = 2,
    kSeekTimeBackwardsFieldNumber = 3,
    kPlaybackSpeedFieldNumber = 4,
    kRunPlaybackFieldNumber = 6,
    kPlaybackLimitFieldNumber = 12,
  };
  // optional string export_vision_log = 9;
  bool has_export_vision_log() const;
  private:
  bool _internal_has_export_vision_log() const;
  public:
  void clear_export_vision_log();
  const std::string& export_vision_log() const;
  void set_export_vision_log(const std::string& value);
  void set_export_vision_log(std::string&& value);
  void set_export_vision_log(const char* value);
  void set_export_vision_log(const char* value, size_t size);
  std::string* mutable_export_vision_log();
  std::string* release_export_vision_log();
  void set_allocated_export_vision_log(std::string* export_vision_log);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_export_vision_log();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_export_vision_log(
      std::string* export_vision_log);
  private:
  const std::string& _internal_export_vision_log() const;
  void _internal_set_export_vision_log(const std::string& value);
  std::string* _internal_mutable_export_vision_log();
  public:

  // optional string find_logfile = 11;
  bool has_find_logfile() const;
  private:
  bool _internal_has_find_logfile() const;
  public:
  void clear_find_logfile();
  const std::string& find_logfile() const;
  void set_find_logfile(const std::string& value);
  void set_find_logfile(std::string&& value);
  void set_find_logfile(const char* value);
  void set_find_logfile(const char* value, size_t size);
  std::string* mutable_find_logfile();
  std::string* release_find_logfile();
  void set_allocated_find_logfile(std::string* find_logfile);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_find_logfile();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_find_logfile(
      std::string* find_logfile);
  private:
  const std::string& _internal_find_logfile() const;
  void _internal_set_find_logfile(const std::string& value);
  std::string* _internal_mutable_find_logfile();
  public:

  // optional .amun.Flag toggle_paused = 5;
  bool has_toggle_paused() const;
  private:
  bool _internal_has_toggle_paused() const;
  public:
  void clear_toggle_paused();
  const ::amun::Flag& toggle_paused() const;
  ::amun::Flag* release_toggle_paused();
  ::amun::Flag* mutable_toggle_paused();
  void set_allocated_toggle_paused(::amun::Flag* toggle_paused);
  private:
  const ::amun::Flag& _internal_toggle_paused() const;
  ::amun::Flag* _internal_mutable_toggle_paused();
  public:
  void unsafe_arena_set_allocated_toggle_paused(
      ::amun::Flag* toggle_paused);
  ::amun::Flag* unsafe_arena_release_toggle_paused();

  // optional .logfile.LogRequest log_path = 7;
  bool has_log_path() const;
  private:
  bool _internal_has_log_path() const;
  public:
  void clear_log_path();
  const ::logfile::LogRequest& log_path() const;
  ::logfile::LogRequest* release_log_path();
  ::logfile::LogRequest* mutable_log_path();
  void set_allocated_log_path(::logfile::LogRequest* log_path);
  private:
  const ::logfile::LogRequest& _internal_log_path() const;
  ::logfile::LogRequest* _internal_mutable_log_path();
  public:
  void unsafe_arena_set_allocated_log_path(
      ::logfile::LogRequest* log_path);
  ::logfile::LogRequest* unsafe_arena_release_log_path();

  // optional .amun.Flag instant_replay = 8;
  bool has_instant_replay() const;
  private:
  bool _internal_has_instant_replay() const;
  public:
  void clear_instant_replay();
  const ::amun::Flag& instant_replay() const;
  ::amun::Flag* release_instant_replay();
  ::amun::Flag* mutable_instant_replay();
  void set_allocated_instant_replay(::amun::Flag* instant_replay);
  private:
  const ::amun::Flag& _internal_instant_replay() const;
  ::amun::Flag* _internal_mutable_instant_replay();
  public:
  void unsafe_arena_set_allocated_instant_replay(
      ::amun::Flag* instant_replay);
  ::amun::Flag* unsafe_arena_release_instant_replay();

  // optional .amun.Flag get_uid = 10;
  bool has_get_uid() const;
  private:
  bool _internal_has_get_uid() const;
  public:
  void clear_get_uid();
  const ::amun::Flag& get_uid() const;
  ::amun::Flag* release_get_uid();
  ::amun::Flag* mutable_get_uid();
  void set_allocated_get_uid(::amun::Flag* get_uid);
  private:
  const ::amun::Flag& _internal_get_uid() const;
  ::amun::Flag* _internal_mutable_get_uid();
  public:
  void unsafe_arena_set_allocated_get_uid(
      ::amun::Flag* get_uid);
  ::amun::Flag* unsafe_arena_release_get_uid();

  // optional int32 seek_time = 1;
  bool has_seek_time() const;
  private:
  bool _internal_has_seek_time() const;
  public:
  void clear_seek_time();
  ::PROTOBUF_NAMESPACE_ID::int32 seek_time() const;
  void set_seek_time(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_seek_time() const;
  void _internal_set_seek_time(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 seek_packet = 2;
  bool has_seek_packet() const;
  private:
  bool _internal_has_seek_packet() const;
  public:
  void clear_seek_packet();
  ::PROTOBUF_NAMESPACE_ID::int32 seek_packet() const;
  void set_seek_packet(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_seek_packet() const;
  void _internal_set_seek_packet(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 seek_time_backwards = 3;
  bool has_seek_time_backwards() const;
  private:
  bool _internal_has_seek_time_backwards() const;
  public:
  void clear_seek_time_backwards();
  ::PROTOBUF_NAMESPACE_ID::int32 seek_time_backwards() const;
  void set_seek_time_backwards(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_seek_time_backwards() const;
  void _internal_set_seek_time_backwards(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 playback_speed = 4;
  bool has_playback_speed() const;
  private:
  bool _internal_has_playback_speed() const;
  public:
  void clear_playback_speed();
  ::PROTOBUF_NAMESPACE_ID::int32 playback_speed() const;
  void set_playback_speed(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_playback_speed() const;
  void _internal_set_playback_speed(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional bool run_playback = 6;
  bool has_run_playback() const;
  private:
  bool _internal_has_run_playback() const;
  public:
  void clear_run_playback();
  bool run_playback() const;
  void set_run_playback(bool value);
  private:
  bool _internal_run_playback() const;
  void _internal_set_run_playback(bool value);
  public:

  // optional int32 playback_limit = 12;
  bool has_playback_limit() const;
  private:
  bool _internal_has_playback_limit() const;
  public:
  void clear_playback_limit();
  ::PROTOBUF_NAMESPACE_ID::int32 playback_limit() const;
  void set_playback_limit(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_playback_limit() const;
  void _internal_set_playback_limit(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:amun.CommandPlayback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr export_vision_log_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr find_logfile_;
  ::amun::Flag* toggle_paused_;
  ::logfile::LogRequest* log_path_;
  ::amun::Flag* instant_replay_;
  ::amun::Flag* get_uid_;
  ::PROTOBUF_NAMESPACE_ID::int32 seek_time_;
  ::PROTOBUF_NAMESPACE_ID::int32 seek_packet_;
  ::PROTOBUF_NAMESPACE_ID::int32 seek_time_backwards_;
  ::PROTOBUF_NAMESPACE_ID::int32 playback_speed_;
  bool run_playback_;
  ::PROTOBUF_NAMESPACE_ID::int32 playback_limit_;
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class CommandRecord PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:amun.CommandRecord) */ {
 public:
  inline CommandRecord() : CommandRecord(nullptr) {};
  virtual ~CommandRecord();

  CommandRecord(const CommandRecord& from);
  CommandRecord(CommandRecord&& from) noexcept
    : CommandRecord() {
    *this = ::std::move(from);
  }

  inline CommandRecord& operator=(const CommandRecord& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommandRecord& operator=(CommandRecord&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CommandRecord& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CommandRecord* internal_default_instance() {
    return reinterpret_cast<const CommandRecord*>(
               &_CommandRecord_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(CommandRecord& a, CommandRecord& b) {
    a.Swap(&b);
  }
  inline void Swap(CommandRecord* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommandRecord* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CommandRecord* New() const final {
    return CreateMaybeMessage<CommandRecord>(nullptr);
  }

  CommandRecord* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CommandRecord>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CommandRecord& from);
  void MergeFrom(const CommandRecord& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommandRecord* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "amun.CommandRecord";
  }
  protected:
  explicit CommandRecord(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_command_2eproto);
    return ::descriptor_table_command_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOverwriteRecordFilenameFieldNumber = 6,
    kSaveBacklogFieldNumber = 2,
    kUseLogfileLocationFieldNumber = 1,
    kRunLoggingFieldNumber = 3,
    kForReplayFieldNumber = 4,
    kRequestBacklogFieldNumber = 5,
  };
  // optional string overwrite_record_filename = 6;
  bool has_overwrite_record_filename() const;
  private:
  bool _internal_has_overwrite_record_filename() const;
  public:
  void clear_overwrite_record_filename();
  const std::string& overwrite_record_filename() const;
  void set_overwrite_record_filename(const std::string& value);
  void set_overwrite_record_filename(std::string&& value);
  void set_overwrite_record_filename(const char* value);
  void set_overwrite_record_filename(const char* value, size_t size);
  std::string* mutable_overwrite_record_filename();
  std::string* release_overwrite_record_filename();
  void set_allocated_overwrite_record_filename(std::string* overwrite_record_filename);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_overwrite_record_filename();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_overwrite_record_filename(
      std::string* overwrite_record_filename);
  private:
  const std::string& _internal_overwrite_record_filename() const;
  void _internal_set_overwrite_record_filename(const std::string& value);
  std::string* _internal_mutable_overwrite_record_filename();
  public:

  // optional .amun.Flag save_backlog = 2;
  bool has_save_backlog() const;
  private:
  bool _internal_has_save_backlog() const;
  public:
  void clear_save_backlog();
  const ::amun::Flag& save_backlog() const;
  ::amun::Flag* release_save_backlog();
  ::amun::Flag* mutable_save_backlog();
  void set_allocated_save_backlog(::amun::Flag* save_backlog);
  private:
  const ::amun::Flag& _internal_save_backlog() const;
  ::amun::Flag* _internal_mutable_save_backlog();
  public:
  void unsafe_arena_set_allocated_save_backlog(
      ::amun::Flag* save_backlog);
  ::amun::Flag* unsafe_arena_release_save_backlog();

  // optional bool use_logfile_location = 1;
  bool has_use_logfile_location() const;
  private:
  bool _internal_has_use_logfile_location() const;
  public:
  void clear_use_logfile_location();
  bool use_logfile_location() const;
  void set_use_logfile_location(bool value);
  private:
  bool _internal_use_logfile_location() const;
  void _internal_set_use_logfile_location(bool value);
  public:

  // optional bool run_logging = 3;
  bool has_run_logging() const;
  private:
  bool _internal_has_run_logging() const;
  public:
  void clear_run_logging();
  bool run_logging() const;
  void set_run_logging(bool value);
  private:
  bool _internal_run_logging() const;
  void _internal_set_run_logging(bool value);
  public:

  // optional bool for_replay = 4;
  bool has_for_replay() const;
  private:
  bool _internal_has_for_replay() const;
  public:
  void clear_for_replay();
  bool for_replay() const;
  void set_for_replay(bool value);
  private:
  bool _internal_for_replay() const;
  void _internal_set_for_replay(bool value);
  public:

  // optional int32 request_backlog = 5;
  bool has_request_backlog() const;
  private:
  bool _internal_has_request_backlog() const;
  public:
  void clear_request_backlog();
  ::PROTOBUF_NAMESPACE_ID::int32 request_backlog() const;
  void set_request_backlog(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_request_backlog() const;
  void _internal_set_request_backlog(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:amun.CommandRecord)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr overwrite_record_filename_;
  ::amun::Flag* save_backlog_;
  bool use_logfile_location_;
  bool run_logging_;
  bool for_replay_;
  ::PROTOBUF_NAMESPACE_ID::int32 request_backlog_;
  friend struct ::TableStruct_command_2eproto;
};
// -------------------------------------------------------------------

class Command PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:amun.Command) */ {
 public:
  inline Command() : Command(nullptr) {};
  virtual ~Command();

  Command(const Command& from);
  Command(Command&& from) noexcept
    : Command() {
    *this = ::std::move(from);
  }

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }
  inline Command& operator=(Command&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Command& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Command* internal_default_instance() {
    return reinterpret_cast<const Command*>(
               &_Command_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(Command& a, Command& b) {
    a.Swap(&b);
  }
  inline void Swap(Command* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Command* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Command* New() const final {
    return CreateMaybeMessage<Command>(nullptr);
  }

  Command* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Command>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Command* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "amun.Command";
  }
  protected:
  explicit Command(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_command_2eproto);
    return ::descriptor_table_command_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotMoveBlueFieldNumber = 14,
    kRobotMoveYellowFieldNumber = 15,
    kSimulatorFieldNumber = 1,
    kRefereeFieldNumber = 2,
    kSetTeamBlueFieldNumber = 3,
    kSetTeamYellowFieldNumber = 4,
    kStrategyBlueFieldNumber = 5,
    kStrategyYellowFieldNumber = 6,
    kStrategyAutorefFieldNumber = 7,
    kControlFieldNumber = 8,
    kTransceiverFieldNumber = 9,
    kTrackingFieldNumber = 11,
    kAmunFieldNumber = 12,
    kMixedTeamDestinationFieldNumber = 13,
    kDebuggerInputFieldNumber = 16,
    kPauseSimulatorFieldNumber = 17,
    kReplayFieldNumber = 18,
    kPlaybackFieldNumber = 19,
    kRecordFieldNumber = 20,
  };
  // repeated .amun.RobotMoveCommand robot_move_blue = 14;
  int robot_move_blue_size() const;
  private:
  int _internal_robot_move_blue_size() const;
  public:
  void clear_robot_move_blue();
  ::amun::RobotMoveCommand* mutable_robot_move_blue(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::amun::RobotMoveCommand >*
      mutable_robot_move_blue();
  private:
  const ::amun::RobotMoveCommand& _internal_robot_move_blue(int index) const;
  ::amun::RobotMoveCommand* _internal_add_robot_move_blue();
  public:
  const ::amun::RobotMoveCommand& robot_move_blue(int index) const;
  ::amun::RobotMoveCommand* add_robot_move_blue();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::amun::RobotMoveCommand >&
      robot_move_blue() const;

  // repeated .amun.RobotMoveCommand robot_move_yellow = 15;
  int robot_move_yellow_size() const;
  private:
  int _internal_robot_move_yellow_size() const;
  public:
  void clear_robot_move_yellow();
  ::amun::RobotMoveCommand* mutable_robot_move_yellow(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::amun::RobotMoveCommand >*
      mutable_robot_move_yellow();
  private:
  const ::amun::RobotMoveCommand& _internal_robot_move_yellow(int index) const;
  ::amun::RobotMoveCommand* _internal_add_robot_move_yellow();
  public:
  const ::amun::RobotMoveCommand& robot_move_yellow(int index) const;
  ::amun::RobotMoveCommand* add_robot_move_yellow();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::amun::RobotMoveCommand >&
      robot_move_yellow() const;

  // optional .amun.CommandSimulator simulator = 1;
  bool has_simulator() const;
  private:
  bool _internal_has_simulator() const;
  public:
  void clear_simulator();
  const ::amun::CommandSimulator& simulator() const;
  ::amun::CommandSimulator* release_simulator();
  ::amun::CommandSimulator* mutable_simulator();
  void set_allocated_simulator(::amun::CommandSimulator* simulator);
  private:
  const ::amun::CommandSimulator& _internal_simulator() const;
  ::amun::CommandSimulator* _internal_mutable_simulator();
  public:
  void unsafe_arena_set_allocated_simulator(
      ::amun::CommandSimulator* simulator);
  ::amun::CommandSimulator* unsafe_arena_release_simulator();

  // optional .amun.CommandReferee referee = 2;
  bool has_referee() const;
  private:
  bool _internal_has_referee() const;
  public:
  void clear_referee();
  const ::amun::CommandReferee& referee() const;
  ::amun::CommandReferee* release_referee();
  ::amun::CommandReferee* mutable_referee();
  void set_allocated_referee(::amun::CommandReferee* referee);
  private:
  const ::amun::CommandReferee& _internal_referee() const;
  ::amun::CommandReferee* _internal_mutable_referee();
  public:
  void unsafe_arena_set_allocated_referee(
      ::amun::CommandReferee* referee);
  ::amun::CommandReferee* unsafe_arena_release_referee();

  // optional .robot.Team set_team_blue = 3;
  bool has_set_team_blue() const;
  private:
  bool _internal_has_set_team_blue() const;
  public:
  void clear_set_team_blue();
  const ::robot::Team& set_team_blue() const;
  ::robot::Team* release_set_team_blue();
  ::robot::Team* mutable_set_team_blue();
  void set_allocated_set_team_blue(::robot::Team* set_team_blue);
  private:
  const ::robot::Team& _internal_set_team_blue() const;
  ::robot::Team* _internal_mutable_set_team_blue();
  public:
  void unsafe_arena_set_allocated_set_team_blue(
      ::robot::Team* set_team_blue);
  ::robot::Team* unsafe_arena_release_set_team_blue();

  // optional .robot.Team set_team_yellow = 4;
  bool has_set_team_yellow() const;
  private:
  bool _internal_has_set_team_yellow() const;
  public:
  void clear_set_team_yellow();
  const ::robot::Team& set_team_yellow() const;
  ::robot::Team* release_set_team_yellow();
  ::robot::Team* mutable_set_team_yellow();
  void set_allocated_set_team_yellow(::robot::Team* set_team_yellow);
  private:
  const ::robot::Team& _internal_set_team_yellow() const;
  ::robot::Team* _internal_mutable_set_team_yellow();
  public:
  void unsafe_arena_set_allocated_set_team_yellow(
      ::robot::Team* set_team_yellow);
  ::robot::Team* unsafe_arena_release_set_team_yellow();

  // optional .amun.CommandStrategy strategy_blue = 5;
  bool has_strategy_blue() const;
  private:
  bool _internal_has_strategy_blue() const;
  public:
  void clear_strategy_blue();
  const ::amun::CommandStrategy& strategy_blue() const;
  ::amun::CommandStrategy* release_strategy_blue();
  ::amun::CommandStrategy* mutable_strategy_blue();
  void set_allocated_strategy_blue(::amun::CommandStrategy* strategy_blue);
  private:
  const ::amun::CommandStrategy& _internal_strategy_blue() const;
  ::amun::CommandStrategy* _internal_mutable_strategy_blue();
  public:
  void unsafe_arena_set_allocated_strategy_blue(
      ::amun::CommandStrategy* strategy_blue);
  ::amun::CommandStrategy* unsafe_arena_release_strategy_blue();

  // optional .amun.CommandStrategy strategy_yellow = 6;
  bool has_strategy_yellow() const;
  private:
  bool _internal_has_strategy_yellow() const;
  public:
  void clear_strategy_yellow();
  const ::amun::CommandStrategy& strategy_yellow() const;
  ::amun::CommandStrategy* release_strategy_yellow();
  ::amun::CommandStrategy* mutable_strategy_yellow();
  void set_allocated_strategy_yellow(::amun::CommandStrategy* strategy_yellow);
  private:
  const ::amun::CommandStrategy& _internal_strategy_yellow() const;
  ::amun::CommandStrategy* _internal_mutable_strategy_yellow();
  public:
  void unsafe_arena_set_allocated_strategy_yellow(
      ::amun::CommandStrategy* strategy_yellow);
  ::amun::CommandStrategy* unsafe_arena_release_strategy_yellow();

  // optional .amun.CommandStrategy strategy_autoref = 7;
  bool has_strategy_autoref() const;
  private:
  bool _internal_has_strategy_autoref() const;
  public:
  void clear_strategy_autoref();
  const ::amun::CommandStrategy& strategy_autoref() const;
  ::amun::CommandStrategy* release_strategy_autoref();
  ::amun::CommandStrategy* mutable_strategy_autoref();
  void set_allocated_strategy_autoref(::amun::CommandStrategy* strategy_autoref);
  private:
  const ::amun::CommandStrategy& _internal_strategy_autoref() const;
  ::amun::CommandStrategy* _internal_mutable_strategy_autoref();
  public:
  void unsafe_arena_set_allocated_strategy_autoref(
      ::amun::CommandStrategy* strategy_autoref);
  ::amun::CommandStrategy* unsafe_arena_release_strategy_autoref();

  // optional .amun.CommandControl control = 8;
  bool has_control() const;
  private:
  bool _internal_has_control() const;
  public:
  void clear_control();
  const ::amun::CommandControl& control() const;
  ::amun::CommandControl* release_control();
  ::amun::CommandControl* mutable_control();
  void set_allocated_control(::amun::CommandControl* control);
  private:
  const ::amun::CommandControl& _internal_control() const;
  ::amun::CommandControl* _internal_mutable_control();
  public:
  void unsafe_arena_set_allocated_control(
      ::amun::CommandControl* control);
  ::amun::CommandControl* unsafe_arena_release_control();

  // optional .amun.CommandTransceiver transceiver = 9;
  bool has_transceiver() const;
  private:
  bool _internal_has_transceiver() const;
  public:
  void clear_transceiver();
  const ::amun::CommandTransceiver& transceiver() const;
  ::amun::CommandTransceiver* release_transceiver();
  ::amun::CommandTransceiver* mutable_transceiver();
  void set_allocated_transceiver(::amun::CommandTransceiver* transceiver);
  private:
  const ::amun::CommandTransceiver& _internal_transceiver() const;
  ::amun::CommandTransceiver* _internal_mutable_transceiver();
  public:
  void unsafe_arena_set_allocated_transceiver(
      ::amun::CommandTransceiver* transceiver);
  ::amun::CommandTransceiver* unsafe_arena_release_transceiver();

  // optional .amun.CommandTracking tracking = 11;
  bool has_tracking() const;
  private:
  bool _internal_has_tracking() const;
  public:
  void clear_tracking();
  const ::amun::CommandTracking& tracking() const;
  ::amun::CommandTracking* release_tracking();
  ::amun::CommandTracking* mutable_tracking();
  void set_allocated_tracking(::amun::CommandTracking* tracking);
  private:
  const ::amun::CommandTracking& _internal_tracking() const;
  ::amun::CommandTracking* _internal_mutable_tracking();
  public:
  void unsafe_arena_set_allocated_tracking(
      ::amun::CommandTracking* tracking);
  ::amun::CommandTracking* unsafe_arena_release_tracking();

  // optional .amun.CommandAmun amun = 12;
  bool has_amun() const;
  private:
  bool _internal_has_amun() const;
  public:
  void clear_amun();
  const ::amun::CommandAmun& amun() const;
  ::amun::CommandAmun* release_amun();
  ::amun::CommandAmun* mutable_amun();
  void set_allocated_amun(::amun::CommandAmun* amun);
  private:
  const ::amun::CommandAmun& _internal_amun() const;
  ::amun::CommandAmun* _internal_mutable_amun();
  public:
  void unsafe_arena_set_allocated_amun(
      ::amun::CommandAmun* amun);
  ::amun::CommandAmun* unsafe_arena_release_amun();

  // optional .amun.HostAddress mixed_team_destination = 13;
  bool has_mixed_team_destination() const;
  private:
  bool _internal_has_mixed_team_destination() const;
  public:
  void clear_mixed_team_destination();
  const ::amun::HostAddress& mixed_team_destination() const;
  ::amun::HostAddress* release_mixed_team_destination();
  ::amun::HostAddress* mutable_mixed_team_destination();
  void set_allocated_mixed_team_destination(::amun::HostAddress* mixed_team_destination);
  private:
  const ::amun::HostAddress& _internal_mixed_team_destination() const;
  ::amun::HostAddress* _internal_mutable_mixed_team_destination();
  public:
  void unsafe_arena_set_allocated_mixed_team_destination(
      ::amun::HostAddress* mixed_team_destination);
  ::amun::HostAddress* unsafe_arena_release_mixed_team_destination();

  // optional .amun.CommandDebuggerInput debugger_input = 16;
  bool has_debugger_input() const;
  private:
  bool _internal_has_debugger_input() const;
  public:
  void clear_debugger_input();
  const ::amun::CommandDebuggerInput& debugger_input() const;
  ::amun::CommandDebuggerInput* release_debugger_input();
  ::amun::CommandDebuggerInput* mutable_debugger_input();
  void set_allocated_debugger_input(::amun::CommandDebuggerInput* debugger_input);
  private:
  const ::amun::CommandDebuggerInput& _internal_debugger_input() const;
  ::amun::CommandDebuggerInput* _internal_mutable_debugger_input();
  public:
  void unsafe_arena_set_allocated_debugger_input(
      ::amun::CommandDebuggerInput* debugger_input);
  ::amun::CommandDebuggerInput* unsafe_arena_release_debugger_input();

  // optional .amun.PauseSimulatorCommand pause_simulator = 17;
  bool has_pause_simulator() const;
  private:
  bool _internal_has_pause_simulator() const;
  public:
  void clear_pause_simulator();
  const ::amun::PauseSimulatorCommand& pause_simulator() const;
  ::amun::PauseSimulatorCommand* release_pause_simulator();
  ::amun::PauseSimulatorCommand* mutable_pause_simulator();
  void set_allocated_pause_simulator(::amun::PauseSimulatorCommand* pause_simulator);
  private:
  const ::amun::PauseSimulatorCommand& _internal_pause_simulator() const;
  ::amun::PauseSimulatorCommand* _internal_mutable_pause_simulator();
  public:
  void unsafe_arena_set_allocated_pause_simulator(
      ::amun::PauseSimulatorCommand* pause_simulator);
  ::amun::PauseSimulatorCommand* unsafe_arena_release_pause_simulator();

  // optional .amun.CommandReplay replay = 18;
  bool has_replay() const;
  private:
  bool _internal_has_replay() const;
  public:
  void clear_replay();
  const ::amun::CommandReplay& replay() const;
  ::amun::CommandReplay* release_replay();
  ::amun::CommandReplay* mutable_replay();
  void set_allocated_replay(::amun::CommandReplay* replay);
  private:
  const ::amun::CommandReplay& _internal_replay() const;
  ::amun::CommandReplay* _internal_mutable_replay();
  public:
  void unsafe_arena_set_allocated_replay(
      ::amun::CommandReplay* replay);
  ::amun::CommandReplay* unsafe_arena_release_replay();

  // optional .amun.CommandPlayback playback = 19;
  bool has_playback() const;
  private:
  bool _internal_has_playback() const;
  public:
  void clear_playback();
  const ::amun::CommandPlayback& playback() const;
  ::amun::CommandPlayback* release_playback();
  ::amun::CommandPlayback* mutable_playback();
  void set_allocated_playback(::amun::CommandPlayback* playback);
  private:
  const ::amun::CommandPlayback& _internal_playback() const;
  ::amun::CommandPlayback* _internal_mutable_playback();
  public:
  void unsafe_arena_set_allocated_playback(
      ::amun::CommandPlayback* playback);
  ::amun::CommandPlayback* unsafe_arena_release_playback();

  // optional .amun.CommandRecord record = 20;
  bool has_record() const;
  private:
  bool _internal_has_record() const;
  public:
  void clear_record();
  const ::amun::CommandRecord& record() const;
  ::amun::CommandRecord* release_record();
  ::amun::CommandRecord* mutable_record();
  void set_allocated_record(::amun::CommandRecord* record);
  private:
  const ::amun::CommandRecord& _internal_record() const;
  ::amun::CommandRecord* _internal_mutable_record();
  public:
  void unsafe_arena_set_allocated_record(
      ::amun::CommandRecord* record);
  ::amun::CommandRecord* unsafe_arena_release_record();

  // @@protoc_insertion_point(class_scope:amun.Command)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::amun::RobotMoveCommand > robot_move_blue_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::amun::RobotMoveCommand > robot_move_yellow_;
  ::amun::CommandSimulator* simulator_;
  ::amun::CommandReferee* referee_;
  ::robot::Team* set_team_blue_;
  ::robot::Team* set_team_yellow_;
  ::amun::CommandStrategy* strategy_blue_;
  ::amun::CommandStrategy* strategy_yellow_;
  ::amun::CommandStrategy* strategy_autoref_;
  ::amun::CommandControl* control_;
  ::amun::CommandTransceiver* transceiver_;
  ::amun::CommandTracking* tracking_;
  ::amun::CommandAmun* amun_;
  ::amun::HostAddress* mixed_team_destination_;
  ::amun::CommandDebuggerInput* debugger_input_;
  ::amun::PauseSimulatorCommand* pause_simulator_;
  ::amun::CommandReplay* replay_;
  ::amun::CommandPlayback* playback_;
  ::amun::CommandRecord* record_;
  friend struct ::TableStruct_command_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RobotMoveCommand

// required uint32 id = 1;
inline bool RobotMoveCommand::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RobotMoveCommand::has_id() const {
  return _internal_has_id();
}
inline void RobotMoveCommand::clear_id() {
  id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RobotMoveCommand::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RobotMoveCommand::id() const {
  // @@protoc_insertion_point(field_get:amun.RobotMoveCommand.id)
  return _internal_id();
}
inline void RobotMoveCommand::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  id_ = value;
}
inline void RobotMoveCommand::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:amun.RobotMoveCommand.id)
}

// optional float p_x = 2;
inline bool RobotMoveCommand::_internal_has_p_x() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RobotMoveCommand::has_p_x() const {
  return _internal_has_p_x();
}
inline void RobotMoveCommand::clear_p_x() {
  p_x_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float RobotMoveCommand::_internal_p_x() const {
  return p_x_;
}
inline float RobotMoveCommand::p_x() const {
  // @@protoc_insertion_point(field_get:amun.RobotMoveCommand.p_x)
  return _internal_p_x();
}
inline void RobotMoveCommand::_internal_set_p_x(float value) {
  _has_bits_[0] |= 0x00000002u;
  p_x_ = value;
}
inline void RobotMoveCommand::set_p_x(float value) {
  _internal_set_p_x(value);
  // @@protoc_insertion_point(field_set:amun.RobotMoveCommand.p_x)
}

// optional float p_y = 3;
inline bool RobotMoveCommand::_internal_has_p_y() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RobotMoveCommand::has_p_y() const {
  return _internal_has_p_y();
}
inline void RobotMoveCommand::clear_p_y() {
  p_y_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float RobotMoveCommand::_internal_p_y() const {
  return p_y_;
}
inline float RobotMoveCommand::p_y() const {
  // @@protoc_insertion_point(field_get:amun.RobotMoveCommand.p_y)
  return _internal_p_y();
}
inline void RobotMoveCommand::_internal_set_p_y(float value) {
  _has_bits_[0] |= 0x00000004u;
  p_y_ = value;
}
inline void RobotMoveCommand::set_p_y(float value) {
  _internal_set_p_y(value);
  // @@protoc_insertion_point(field_set:amun.RobotMoveCommand.p_y)
}

// -------------------------------------------------------------------

// SimulatorSetup

// required .world.Geometry geometry = 1;
inline bool SimulatorSetup::_internal_has_geometry() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || geometry_ != nullptr);
  return value;
}
inline bool SimulatorSetup::has_geometry() const {
  return _internal_has_geometry();
}
inline const ::world::Geometry& SimulatorSetup::_internal_geometry() const {
  const ::world::Geometry* p = geometry_;
  return p != nullptr ? *p : *reinterpret_cast<const ::world::Geometry*>(
      &::world::_Geometry_default_instance_);
}
inline const ::world::Geometry& SimulatorSetup::geometry() const {
  // @@protoc_insertion_point(field_get:amun.SimulatorSetup.geometry)
  return _internal_geometry();
}
inline void SimulatorSetup::unsafe_arena_set_allocated_geometry(
    ::world::Geometry* geometry) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(geometry_);
  }
  geometry_ = geometry;
  if (geometry) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.SimulatorSetup.geometry)
}
inline ::world::Geometry* SimulatorSetup::release_geometry() {
  auto temp = unsafe_arena_release_geometry();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::world::Geometry* SimulatorSetup::unsafe_arena_release_geometry() {
  // @@protoc_insertion_point(field_release:amun.SimulatorSetup.geometry)
  _has_bits_[0] &= ~0x00000001u;
  ::world::Geometry* temp = geometry_;
  geometry_ = nullptr;
  return temp;
}
inline ::world::Geometry* SimulatorSetup::_internal_mutable_geometry() {
  _has_bits_[0] |= 0x00000001u;
  if (geometry_ == nullptr) {
    auto* p = CreateMaybeMessage<::world::Geometry>(GetArena());
    geometry_ = p;
  }
  return geometry_;
}
inline ::world::Geometry* SimulatorSetup::mutable_geometry() {
  // @@protoc_insertion_point(field_mutable:amun.SimulatorSetup.geometry)
  return _internal_mutable_geometry();
}
inline void SimulatorSetup::set_allocated_geometry(::world::Geometry* geometry) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(geometry_);
  }
  if (geometry) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(geometry)->GetArena();
    if (message_arena != submessage_arena) {
      geometry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, geometry, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  geometry_ = geometry;
  // @@protoc_insertion_point(field_set_allocated:amun.SimulatorSetup.geometry)
}

// repeated .SSL_GeometryCameraCalibration camera_setup = 2;
inline int SimulatorSetup::_internal_camera_setup_size() const {
  return camera_setup_.size();
}
inline int SimulatorSetup::camera_setup_size() const {
  return _internal_camera_setup_size();
}
inline ::SSL_GeometryCameraCalibration* SimulatorSetup::mutable_camera_setup(int index) {
  // @@protoc_insertion_point(field_mutable:amun.SimulatorSetup.camera_setup)
  return camera_setup_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SSL_GeometryCameraCalibration >*
SimulatorSetup::mutable_camera_setup() {
  // @@protoc_insertion_point(field_mutable_list:amun.SimulatorSetup.camera_setup)
  return &camera_setup_;
}
inline const ::SSL_GeometryCameraCalibration& SimulatorSetup::_internal_camera_setup(int index) const {
  return camera_setup_.Get(index);
}
inline const ::SSL_GeometryCameraCalibration& SimulatorSetup::camera_setup(int index) const {
  // @@protoc_insertion_point(field_get:amun.SimulatorSetup.camera_setup)
  return _internal_camera_setup(index);
}
inline ::SSL_GeometryCameraCalibration* SimulatorSetup::_internal_add_camera_setup() {
  return camera_setup_.Add();
}
inline ::SSL_GeometryCameraCalibration* SimulatorSetup::add_camera_setup() {
  // @@protoc_insertion_point(field_add:amun.SimulatorSetup.camera_setup)
  return _internal_add_camera_setup();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SSL_GeometryCameraCalibration >&
SimulatorSetup::camera_setup() const {
  // @@protoc_insertion_point(field_list:amun.SimulatorSetup.camera_setup)
  return camera_setup_;
}

// -------------------------------------------------------------------

// SimulatorWorstCaseVision

// optional float min_robot_detection_time = 1;
inline bool SimulatorWorstCaseVision::_internal_has_min_robot_detection_time() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SimulatorWorstCaseVision::has_min_robot_detection_time() const {
  return _internal_has_min_robot_detection_time();
}
inline void SimulatorWorstCaseVision::clear_min_robot_detection_time() {
  min_robot_detection_time_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float SimulatorWorstCaseVision::_internal_min_robot_detection_time() const {
  return min_robot_detection_time_;
}
inline float SimulatorWorstCaseVision::min_robot_detection_time() const {
  // @@protoc_insertion_point(field_get:amun.SimulatorWorstCaseVision.min_robot_detection_time)
  return _internal_min_robot_detection_time();
}
inline void SimulatorWorstCaseVision::_internal_set_min_robot_detection_time(float value) {
  _has_bits_[0] |= 0x00000001u;
  min_robot_detection_time_ = value;
}
inline void SimulatorWorstCaseVision::set_min_robot_detection_time(float value) {
  _internal_set_min_robot_detection_time(value);
  // @@protoc_insertion_point(field_set:amun.SimulatorWorstCaseVision.min_robot_detection_time)
}

// optional float min_ball_detection_time = 2;
inline bool SimulatorWorstCaseVision::_internal_has_min_ball_detection_time() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SimulatorWorstCaseVision::has_min_ball_detection_time() const {
  return _internal_has_min_ball_detection_time();
}
inline void SimulatorWorstCaseVision::clear_min_ball_detection_time() {
  min_ball_detection_time_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float SimulatorWorstCaseVision::_internal_min_ball_detection_time() const {
  return min_ball_detection_time_;
}
inline float SimulatorWorstCaseVision::min_ball_detection_time() const {
  // @@protoc_insertion_point(field_get:amun.SimulatorWorstCaseVision.min_ball_detection_time)
  return _internal_min_ball_detection_time();
}
inline void SimulatorWorstCaseVision::_internal_set_min_ball_detection_time(float value) {
  _has_bits_[0] |= 0x00000002u;
  min_ball_detection_time_ = value;
}
inline void SimulatorWorstCaseVision::set_min_ball_detection_time(float value) {
  _internal_set_min_ball_detection_time(value);
  // @@protoc_insertion_point(field_set:amun.SimulatorWorstCaseVision.min_ball_detection_time)
}

// -------------------------------------------------------------------

// CommandSimulator

// optional bool enable = 1;
inline bool CommandSimulator::_internal_has_enable() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CommandSimulator::has_enable() const {
  return _internal_has_enable();
}
inline void CommandSimulator::clear_enable() {
  enable_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool CommandSimulator::_internal_enable() const {
  return enable_;
}
inline bool CommandSimulator::enable() const {
  // @@protoc_insertion_point(field_get:amun.CommandSimulator.enable)
  return _internal_enable();
}
inline void CommandSimulator::_internal_set_enable(bool value) {
  _has_bits_[0] |= 0x00000020u;
  enable_ = value;
}
inline void CommandSimulator::set_enable(bool value) {
  _internal_set_enable(value);
  // @@protoc_insertion_point(field_set:amun.CommandSimulator.enable)
}

// optional .amun.SimulatorSetup simulator_setup = 2;
inline bool CommandSimulator::_internal_has_simulator_setup() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || simulator_setup_ != nullptr);
  return value;
}
inline bool CommandSimulator::has_simulator_setup() const {
  return _internal_has_simulator_setup();
}
inline void CommandSimulator::clear_simulator_setup() {
  if (simulator_setup_ != nullptr) simulator_setup_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::amun::SimulatorSetup& CommandSimulator::_internal_simulator_setup() const {
  const ::amun::SimulatorSetup* p = simulator_setup_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::SimulatorSetup*>(
      &::amun::_SimulatorSetup_default_instance_);
}
inline const ::amun::SimulatorSetup& CommandSimulator::simulator_setup() const {
  // @@protoc_insertion_point(field_get:amun.CommandSimulator.simulator_setup)
  return _internal_simulator_setup();
}
inline void CommandSimulator::unsafe_arena_set_allocated_simulator_setup(
    ::amun::SimulatorSetup* simulator_setup) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(simulator_setup_);
  }
  simulator_setup_ = simulator_setup;
  if (simulator_setup) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.CommandSimulator.simulator_setup)
}
inline ::amun::SimulatorSetup* CommandSimulator::release_simulator_setup() {
  auto temp = unsafe_arena_release_simulator_setup();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::SimulatorSetup* CommandSimulator::unsafe_arena_release_simulator_setup() {
  // @@protoc_insertion_point(field_release:amun.CommandSimulator.simulator_setup)
  _has_bits_[0] &= ~0x00000001u;
  ::amun::SimulatorSetup* temp = simulator_setup_;
  simulator_setup_ = nullptr;
  return temp;
}
inline ::amun::SimulatorSetup* CommandSimulator::_internal_mutable_simulator_setup() {
  _has_bits_[0] |= 0x00000001u;
  if (simulator_setup_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::SimulatorSetup>(GetArena());
    simulator_setup_ = p;
  }
  return simulator_setup_;
}
inline ::amun::SimulatorSetup* CommandSimulator::mutable_simulator_setup() {
  // @@protoc_insertion_point(field_mutable:amun.CommandSimulator.simulator_setup)
  return _internal_mutable_simulator_setup();
}
inline void CommandSimulator::set_allocated_simulator_setup(::amun::SimulatorSetup* simulator_setup) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete simulator_setup_;
  }
  if (simulator_setup) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(simulator_setup);
    if (message_arena != submessage_arena) {
      simulator_setup = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, simulator_setup, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  simulator_setup_ = simulator_setup;
  // @@protoc_insertion_point(field_set_allocated:amun.CommandSimulator.simulator_setup)
}

// optional .amun.SimulatorWorstCaseVision vision_worst_case = 3;
inline bool CommandSimulator::_internal_has_vision_worst_case() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || vision_worst_case_ != nullptr);
  return value;
}
inline bool CommandSimulator::has_vision_worst_case() const {
  return _internal_has_vision_worst_case();
}
inline void CommandSimulator::clear_vision_worst_case() {
  if (vision_worst_case_ != nullptr) vision_worst_case_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::amun::SimulatorWorstCaseVision& CommandSimulator::_internal_vision_worst_case() const {
  const ::amun::SimulatorWorstCaseVision* p = vision_worst_case_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::SimulatorWorstCaseVision*>(
      &::amun::_SimulatorWorstCaseVision_default_instance_);
}
inline const ::amun::SimulatorWorstCaseVision& CommandSimulator::vision_worst_case() const {
  // @@protoc_insertion_point(field_get:amun.CommandSimulator.vision_worst_case)
  return _internal_vision_worst_case();
}
inline void CommandSimulator::unsafe_arena_set_allocated_vision_worst_case(
    ::amun::SimulatorWorstCaseVision* vision_worst_case) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vision_worst_case_);
  }
  vision_worst_case_ = vision_worst_case;
  if (vision_worst_case) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.CommandSimulator.vision_worst_case)
}
inline ::amun::SimulatorWorstCaseVision* CommandSimulator::release_vision_worst_case() {
  auto temp = unsafe_arena_release_vision_worst_case();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::SimulatorWorstCaseVision* CommandSimulator::unsafe_arena_release_vision_worst_case() {
  // @@protoc_insertion_point(field_release:amun.CommandSimulator.vision_worst_case)
  _has_bits_[0] &= ~0x00000002u;
  ::amun::SimulatorWorstCaseVision* temp = vision_worst_case_;
  vision_worst_case_ = nullptr;
  return temp;
}
inline ::amun::SimulatorWorstCaseVision* CommandSimulator::_internal_mutable_vision_worst_case() {
  _has_bits_[0] |= 0x00000002u;
  if (vision_worst_case_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::SimulatorWorstCaseVision>(GetArena());
    vision_worst_case_ = p;
  }
  return vision_worst_case_;
}
inline ::amun::SimulatorWorstCaseVision* CommandSimulator::mutable_vision_worst_case() {
  // @@protoc_insertion_point(field_mutable:amun.CommandSimulator.vision_worst_case)
  return _internal_mutable_vision_worst_case();
}
inline void CommandSimulator::set_allocated_vision_worst_case(::amun::SimulatorWorstCaseVision* vision_worst_case) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete vision_worst_case_;
  }
  if (vision_worst_case) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(vision_worst_case);
    if (message_arena != submessage_arena) {
      vision_worst_case = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vision_worst_case, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  vision_worst_case_ = vision_worst_case;
  // @@protoc_insertion_point(field_set_allocated:amun.CommandSimulator.vision_worst_case)
}

// optional .RealismConfigErForce realism_config = 4;
inline bool CommandSimulator::_internal_has_realism_config() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || realism_config_ != nullptr);
  return value;
}
inline bool CommandSimulator::has_realism_config() const {
  return _internal_has_realism_config();
}
inline const ::RealismConfigErForce& CommandSimulator::_internal_realism_config() const {
  const ::RealismConfigErForce* p = realism_config_;
  return p != nullptr ? *p : *reinterpret_cast<const ::RealismConfigErForce*>(
      &::_RealismConfigErForce_default_instance_);
}
inline const ::RealismConfigErForce& CommandSimulator::realism_config() const {
  // @@protoc_insertion_point(field_get:amun.CommandSimulator.realism_config)
  return _internal_realism_config();
}
inline void CommandSimulator::unsafe_arena_set_allocated_realism_config(
    ::RealismConfigErForce* realism_config) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(realism_config_);
  }
  realism_config_ = realism_config;
  if (realism_config) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.CommandSimulator.realism_config)
}
inline ::RealismConfigErForce* CommandSimulator::release_realism_config() {
  auto temp = unsafe_arena_release_realism_config();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::RealismConfigErForce* CommandSimulator::unsafe_arena_release_realism_config() {
  // @@protoc_insertion_point(field_release:amun.CommandSimulator.realism_config)
  _has_bits_[0] &= ~0x00000004u;
  ::RealismConfigErForce* temp = realism_config_;
  realism_config_ = nullptr;
  return temp;
}
inline ::RealismConfigErForce* CommandSimulator::_internal_mutable_realism_config() {
  _has_bits_[0] |= 0x00000004u;
  if (realism_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::RealismConfigErForce>(GetArena());
    realism_config_ = p;
  }
  return realism_config_;
}
inline ::RealismConfigErForce* CommandSimulator::mutable_realism_config() {
  // @@protoc_insertion_point(field_mutable:amun.CommandSimulator.realism_config)
  return _internal_mutable_realism_config();
}
inline void CommandSimulator::set_allocated_realism_config(::RealismConfigErForce* realism_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(realism_config_);
  }
  if (realism_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(realism_config)->GetArena();
    if (message_arena != submessage_arena) {
      realism_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, realism_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  realism_config_ = realism_config;
  // @@protoc_insertion_point(field_set_allocated:amun.CommandSimulator.realism_config)
}

// optional .world.SimulatorState set_simulator_state = 5;
inline bool CommandSimulator::_internal_has_set_simulator_state() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || set_simulator_state_ != nullptr);
  return value;
}
inline bool CommandSimulator::has_set_simulator_state() const {
  return _internal_has_set_simulator_state();
}
inline const ::world::SimulatorState& CommandSimulator::_internal_set_simulator_state() const {
  const ::world::SimulatorState* p = set_simulator_state_;
  return p != nullptr ? *p : *reinterpret_cast<const ::world::SimulatorState*>(
      &::world::_SimulatorState_default_instance_);
}
inline const ::world::SimulatorState& CommandSimulator::set_simulator_state() const {
  // @@protoc_insertion_point(field_get:amun.CommandSimulator.set_simulator_state)
  return _internal_set_simulator_state();
}
inline void CommandSimulator::unsafe_arena_set_allocated_set_simulator_state(
    ::world::SimulatorState* set_simulator_state) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(set_simulator_state_);
  }
  set_simulator_state_ = set_simulator_state;
  if (set_simulator_state) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.CommandSimulator.set_simulator_state)
}
inline ::world::SimulatorState* CommandSimulator::release_set_simulator_state() {
  auto temp = unsafe_arena_release_set_simulator_state();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::world::SimulatorState* CommandSimulator::unsafe_arena_release_set_simulator_state() {
  // @@protoc_insertion_point(field_release:amun.CommandSimulator.set_simulator_state)
  _has_bits_[0] &= ~0x00000008u;
  ::world::SimulatorState* temp = set_simulator_state_;
  set_simulator_state_ = nullptr;
  return temp;
}
inline ::world::SimulatorState* CommandSimulator::_internal_mutable_set_simulator_state() {
  _has_bits_[0] |= 0x00000008u;
  if (set_simulator_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::world::SimulatorState>(GetArena());
    set_simulator_state_ = p;
  }
  return set_simulator_state_;
}
inline ::world::SimulatorState* CommandSimulator::mutable_set_simulator_state() {
  // @@protoc_insertion_point(field_mutable:amun.CommandSimulator.set_simulator_state)
  return _internal_mutable_set_simulator_state();
}
inline void CommandSimulator::set_allocated_set_simulator_state(::world::SimulatorState* set_simulator_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(set_simulator_state_);
  }
  if (set_simulator_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(set_simulator_state)->GetArena();
    if (message_arena != submessage_arena) {
      set_simulator_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, set_simulator_state, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  set_simulator_state_ = set_simulator_state;
  // @@protoc_insertion_point(field_set_allocated:amun.CommandSimulator.set_simulator_state)
}

// optional .sslsim.SimulatorControl ssl_control = 6;
inline bool CommandSimulator::_internal_has_ssl_control() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || ssl_control_ != nullptr);
  return value;
}
inline bool CommandSimulator::has_ssl_control() const {
  return _internal_has_ssl_control();
}
inline const ::sslsim::SimulatorControl& CommandSimulator::_internal_ssl_control() const {
  const ::sslsim::SimulatorControl* p = ssl_control_;
  return p != nullptr ? *p : *reinterpret_cast<const ::sslsim::SimulatorControl*>(
      &::sslsim::_SimulatorControl_default_instance_);
}
inline const ::sslsim::SimulatorControl& CommandSimulator::ssl_control() const {
  // @@protoc_insertion_point(field_get:amun.CommandSimulator.ssl_control)
  return _internal_ssl_control();
}
inline void CommandSimulator::unsafe_arena_set_allocated_ssl_control(
    ::sslsim::SimulatorControl* ssl_control) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ssl_control_);
  }
  ssl_control_ = ssl_control;
  if (ssl_control) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.CommandSimulator.ssl_control)
}
inline ::sslsim::SimulatorControl* CommandSimulator::release_ssl_control() {
  auto temp = unsafe_arena_release_ssl_control();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::sslsim::SimulatorControl* CommandSimulator::unsafe_arena_release_ssl_control() {
  // @@protoc_insertion_point(field_release:amun.CommandSimulator.ssl_control)
  _has_bits_[0] &= ~0x00000010u;
  ::sslsim::SimulatorControl* temp = ssl_control_;
  ssl_control_ = nullptr;
  return temp;
}
inline ::sslsim::SimulatorControl* CommandSimulator::_internal_mutable_ssl_control() {
  _has_bits_[0] |= 0x00000010u;
  if (ssl_control_ == nullptr) {
    auto* p = CreateMaybeMessage<::sslsim::SimulatorControl>(GetArena());
    ssl_control_ = p;
  }
  return ssl_control_;
}
inline ::sslsim::SimulatorControl* CommandSimulator::mutable_ssl_control() {
  // @@protoc_insertion_point(field_mutable:amun.CommandSimulator.ssl_control)
  return _internal_mutable_ssl_control();
}
inline void CommandSimulator::set_allocated_ssl_control(::sslsim::SimulatorControl* ssl_control) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(ssl_control_);
  }
  if (ssl_control) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ssl_control)->GetArena();
    if (message_arena != submessage_arena) {
      ssl_control = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ssl_control, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  ssl_control_ = ssl_control;
  // @@protoc_insertion_point(field_set_allocated:amun.CommandSimulator.ssl_control)
}

// -------------------------------------------------------------------

// CommandReferee

// optional bool active = 1;
inline bool CommandReferee::_internal_has_active() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandReferee::has_active() const {
  return _internal_has_active();
}
inline void CommandReferee::clear_active() {
  active_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool CommandReferee::_internal_active() const {
  return active_;
}
inline bool CommandReferee::active() const {
  // @@protoc_insertion_point(field_get:amun.CommandReferee.active)
  return _internal_active();
}
inline void CommandReferee::_internal_set_active(bool value) {
  _has_bits_[0] |= 0x00000002u;
  active_ = value;
}
inline void CommandReferee::set_active(bool value) {
  _internal_set_active(value);
  // @@protoc_insertion_point(field_set:amun.CommandReferee.active)
}

// optional bytes command = 2;
inline bool CommandReferee::_internal_has_command() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandReferee::has_command() const {
  return _internal_has_command();
}
inline void CommandReferee::clear_command() {
  command_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandReferee::command() const {
  // @@protoc_insertion_point(field_get:amun.CommandReferee.command)
  return _internal_command();
}
inline void CommandReferee::set_command(const std::string& value) {
  _internal_set_command(value);
  // @@protoc_insertion_point(field_set:amun.CommandReferee.command)
}
inline std::string* CommandReferee::mutable_command() {
  // @@protoc_insertion_point(field_mutable:amun.CommandReferee.command)
  return _internal_mutable_command();
}
inline const std::string& CommandReferee::_internal_command() const {
  return command_.Get();
}
inline void CommandReferee::_internal_set_command(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  command_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CommandReferee::set_command(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  command_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:amun.CommandReferee.command)
}
inline void CommandReferee::set_command(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  command_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:amun.CommandReferee.command)
}
inline void CommandReferee::set_command(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  command_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:amun.CommandReferee.command)
}
inline std::string* CommandReferee::_internal_mutable_command() {
  _has_bits_[0] |= 0x00000001u;
  return command_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CommandReferee::release_command() {
  // @@protoc_insertion_point(field_release:amun.CommandReferee.command)
  if (!_internal_has_command()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return command_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CommandReferee::set_allocated_command(std::string* command) {
  if (command != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  command_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), command,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:amun.CommandReferee.command)
}
inline std::string* CommandReferee::unsafe_arena_release_command() {
  // @@protoc_insertion_point(field_unsafe_arena_release:amun.CommandReferee.command)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return command_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void CommandReferee::unsafe_arena_set_allocated_command(
    std::string* command) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (command != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  command_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      command, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.CommandReferee.command)
}

// optional bool use_internal_autoref = 3;
inline bool CommandReferee::_internal_has_use_internal_autoref() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandReferee::has_use_internal_autoref() const {
  return _internal_has_use_internal_autoref();
}
inline void CommandReferee::clear_use_internal_autoref() {
  use_internal_autoref_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool CommandReferee::_internal_use_internal_autoref() const {
  return use_internal_autoref_;
}
inline bool CommandReferee::use_internal_autoref() const {
  // @@protoc_insertion_point(field_get:amun.CommandReferee.use_internal_autoref)
  return _internal_use_internal_autoref();
}
inline void CommandReferee::_internal_set_use_internal_autoref(bool value) {
  _has_bits_[0] |= 0x00000004u;
  use_internal_autoref_ = value;
}
inline void CommandReferee::set_use_internal_autoref(bool value) {
  _internal_set_use_internal_autoref(value);
  // @@protoc_insertion_point(field_set:amun.CommandReferee.use_internal_autoref)
}

// optional bool use_automatic_robot_exchange = 4;
inline bool CommandReferee::_internal_has_use_automatic_robot_exchange() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CommandReferee::has_use_automatic_robot_exchange() const {
  return _internal_has_use_automatic_robot_exchange();
}
inline void CommandReferee::clear_use_automatic_robot_exchange() {
  use_automatic_robot_exchange_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool CommandReferee::_internal_use_automatic_robot_exchange() const {
  return use_automatic_robot_exchange_;
}
inline bool CommandReferee::use_automatic_robot_exchange() const {
  // @@protoc_insertion_point(field_get:amun.CommandReferee.use_automatic_robot_exchange)
  return _internal_use_automatic_robot_exchange();
}
inline void CommandReferee::_internal_set_use_automatic_robot_exchange(bool value) {
  _has_bits_[0] |= 0x00000008u;
  use_automatic_robot_exchange_ = value;
}
inline void CommandReferee::set_use_automatic_robot_exchange(bool value) {
  _internal_set_use_automatic_robot_exchange(value);
  // @@protoc_insertion_point(field_set:amun.CommandReferee.use_automatic_robot_exchange)
}

// -------------------------------------------------------------------

// CommandStrategyAutomaticEntrypoints_EntrypointForStage

// required .SSL_Referee.Stage stage = 1;
inline bool CommandStrategyAutomaticEntrypoints_EntrypointForStage::_internal_has_stage() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandStrategyAutomaticEntrypoints_EntrypointForStage::has_stage() const {
  return _internal_has_stage();
}
inline void CommandStrategyAutomaticEntrypoints_EntrypointForStage::clear_stage() {
  stage_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::SSL_Referee_Stage CommandStrategyAutomaticEntrypoints_EntrypointForStage::_internal_stage() const {
  return static_cast< ::SSL_Referee_Stage >(stage_);
}
inline ::SSL_Referee_Stage CommandStrategyAutomaticEntrypoints_EntrypointForStage::stage() const {
  // @@protoc_insertion_point(field_get:amun.CommandStrategyAutomaticEntrypoints.EntrypointForStage.stage)
  return _internal_stage();
}
inline void CommandStrategyAutomaticEntrypoints_EntrypointForStage::_internal_set_stage(::SSL_Referee_Stage value) {
  assert(::SSL_Referee_Stage_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  stage_ = value;
}
inline void CommandStrategyAutomaticEntrypoints_EntrypointForStage::set_stage(::SSL_Referee_Stage value) {
  _internal_set_stage(value);
  // @@protoc_insertion_point(field_set:amun.CommandStrategyAutomaticEntrypoints.EntrypointForStage.stage)
}

// required string entry_point = 2;
inline bool CommandStrategyAutomaticEntrypoints_EntrypointForStage::_internal_has_entry_point() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandStrategyAutomaticEntrypoints_EntrypointForStage::has_entry_point() const {
  return _internal_has_entry_point();
}
inline void CommandStrategyAutomaticEntrypoints_EntrypointForStage::clear_entry_point() {
  entry_point_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandStrategyAutomaticEntrypoints_EntrypointForStage::entry_point() const {
  // @@protoc_insertion_point(field_get:amun.CommandStrategyAutomaticEntrypoints.EntrypointForStage.entry_point)
  return _internal_entry_point();
}
inline void CommandStrategyAutomaticEntrypoints_EntrypointForStage::set_entry_point(const std::string& value) {
  _internal_set_entry_point(value);
  // @@protoc_insertion_point(field_set:amun.CommandStrategyAutomaticEntrypoints.EntrypointForStage.entry_point)
}
inline std::string* CommandStrategyAutomaticEntrypoints_EntrypointForStage::mutable_entry_point() {
  // @@protoc_insertion_point(field_mutable:amun.CommandStrategyAutomaticEntrypoints.EntrypointForStage.entry_point)
  return _internal_mutable_entry_point();
}
inline const std::string& CommandStrategyAutomaticEntrypoints_EntrypointForStage::_internal_entry_point() const {
  return entry_point_.Get();
}
inline void CommandStrategyAutomaticEntrypoints_EntrypointForStage::_internal_set_entry_point(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  entry_point_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CommandStrategyAutomaticEntrypoints_EntrypointForStage::set_entry_point(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  entry_point_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:amun.CommandStrategyAutomaticEntrypoints.EntrypointForStage.entry_point)
}
inline void CommandStrategyAutomaticEntrypoints_EntrypointForStage::set_entry_point(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  entry_point_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:amun.CommandStrategyAutomaticEntrypoints.EntrypointForStage.entry_point)
}
inline void CommandStrategyAutomaticEntrypoints_EntrypointForStage::set_entry_point(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  entry_point_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:amun.CommandStrategyAutomaticEntrypoints.EntrypointForStage.entry_point)
}
inline std::string* CommandStrategyAutomaticEntrypoints_EntrypointForStage::_internal_mutable_entry_point() {
  _has_bits_[0] |= 0x00000001u;
  return entry_point_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CommandStrategyAutomaticEntrypoints_EntrypointForStage::release_entry_point() {
  // @@protoc_insertion_point(field_release:amun.CommandStrategyAutomaticEntrypoints.EntrypointForStage.entry_point)
  if (!_internal_has_entry_point()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return entry_point_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CommandStrategyAutomaticEntrypoints_EntrypointForStage::set_allocated_entry_point(std::string* entry_point) {
  if (entry_point != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  entry_point_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), entry_point,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:amun.CommandStrategyAutomaticEntrypoints.EntrypointForStage.entry_point)
}
inline std::string* CommandStrategyAutomaticEntrypoints_EntrypointForStage::unsafe_arena_release_entry_point() {
  // @@protoc_insertion_point(field_unsafe_arena_release:amun.CommandStrategyAutomaticEntrypoints.EntrypointForStage.entry_point)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return entry_point_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void CommandStrategyAutomaticEntrypoints_EntrypointForStage::unsafe_arena_set_allocated_entry_point(
    std::string* entry_point) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (entry_point != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  entry_point_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      entry_point, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.CommandStrategyAutomaticEntrypoints.EntrypointForStage.entry_point)
}

// -------------------------------------------------------------------

// CommandStrategyAutomaticEntrypoints

// repeated .amun.CommandStrategyAutomaticEntrypoints.EntrypointForStage mapping = 1;
inline int CommandStrategyAutomaticEntrypoints::_internal_mapping_size() const {
  return mapping_.size();
}
inline int CommandStrategyAutomaticEntrypoints::mapping_size() const {
  return _internal_mapping_size();
}
inline void CommandStrategyAutomaticEntrypoints::clear_mapping() {
  mapping_.Clear();
}
inline ::amun::CommandStrategyAutomaticEntrypoints_EntrypointForStage* CommandStrategyAutomaticEntrypoints::mutable_mapping(int index) {
  // @@protoc_insertion_point(field_mutable:amun.CommandStrategyAutomaticEntrypoints.mapping)
  return mapping_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::amun::CommandStrategyAutomaticEntrypoints_EntrypointForStage >*
CommandStrategyAutomaticEntrypoints::mutable_mapping() {
  // @@protoc_insertion_point(field_mutable_list:amun.CommandStrategyAutomaticEntrypoints.mapping)
  return &mapping_;
}
inline const ::amun::CommandStrategyAutomaticEntrypoints_EntrypointForStage& CommandStrategyAutomaticEntrypoints::_internal_mapping(int index) const {
  return mapping_.Get(index);
}
inline const ::amun::CommandStrategyAutomaticEntrypoints_EntrypointForStage& CommandStrategyAutomaticEntrypoints::mapping(int index) const {
  // @@protoc_insertion_point(field_get:amun.CommandStrategyAutomaticEntrypoints.mapping)
  return _internal_mapping(index);
}
inline ::amun::CommandStrategyAutomaticEntrypoints_EntrypointForStage* CommandStrategyAutomaticEntrypoints::_internal_add_mapping() {
  return mapping_.Add();
}
inline ::amun::CommandStrategyAutomaticEntrypoints_EntrypointForStage* CommandStrategyAutomaticEntrypoints::add_mapping() {
  // @@protoc_insertion_point(field_add:amun.CommandStrategyAutomaticEntrypoints.mapping)
  return _internal_add_mapping();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::amun::CommandStrategyAutomaticEntrypoints_EntrypointForStage >&
CommandStrategyAutomaticEntrypoints::mapping() const {
  // @@protoc_insertion_point(field_list:amun.CommandStrategyAutomaticEntrypoints.mapping)
  return mapping_;
}

// -------------------------------------------------------------------

// CommandStrategyLoad

// required string filename = 1;
inline bool CommandStrategyLoad::_internal_has_filename() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandStrategyLoad::has_filename() const {
  return _internal_has_filename();
}
inline void CommandStrategyLoad::clear_filename() {
  filename_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandStrategyLoad::filename() const {
  // @@protoc_insertion_point(field_get:amun.CommandStrategyLoad.filename)
  return _internal_filename();
}
inline void CommandStrategyLoad::set_filename(const std::string& value) {
  _internal_set_filename(value);
  // @@protoc_insertion_point(field_set:amun.CommandStrategyLoad.filename)
}
inline std::string* CommandStrategyLoad::mutable_filename() {
  // @@protoc_insertion_point(field_mutable:amun.CommandStrategyLoad.filename)
  return _internal_mutable_filename();
}
inline const std::string& CommandStrategyLoad::_internal_filename() const {
  return filename_.Get();
}
inline void CommandStrategyLoad::_internal_set_filename(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  filename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CommandStrategyLoad::set_filename(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  filename_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:amun.CommandStrategyLoad.filename)
}
inline void CommandStrategyLoad::set_filename(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  filename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:amun.CommandStrategyLoad.filename)
}
inline void CommandStrategyLoad::set_filename(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  filename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:amun.CommandStrategyLoad.filename)
}
inline std::string* CommandStrategyLoad::_internal_mutable_filename() {
  _has_bits_[0] |= 0x00000001u;
  return filename_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CommandStrategyLoad::release_filename() {
  // @@protoc_insertion_point(field_release:amun.CommandStrategyLoad.filename)
  if (!_internal_has_filename()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return filename_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CommandStrategyLoad::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  filename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filename,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:amun.CommandStrategyLoad.filename)
}
inline std::string* CommandStrategyLoad::unsafe_arena_release_filename() {
  // @@protoc_insertion_point(field_unsafe_arena_release:amun.CommandStrategyLoad.filename)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return filename_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void CommandStrategyLoad::unsafe_arena_set_allocated_filename(
    std::string* filename) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (filename != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  filename_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      filename, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.CommandStrategyLoad.filename)
}

// optional string entry_point = 2;
inline bool CommandStrategyLoad::_internal_has_entry_point() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandStrategyLoad::has_entry_point() const {
  return _internal_has_entry_point();
}
inline void CommandStrategyLoad::clear_entry_point() {
  entry_point_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommandStrategyLoad::entry_point() const {
  // @@protoc_insertion_point(field_get:amun.CommandStrategyLoad.entry_point)
  return _internal_entry_point();
}
inline void CommandStrategyLoad::set_entry_point(const std::string& value) {
  _internal_set_entry_point(value);
  // @@protoc_insertion_point(field_set:amun.CommandStrategyLoad.entry_point)
}
inline std::string* CommandStrategyLoad::mutable_entry_point() {
  // @@protoc_insertion_point(field_mutable:amun.CommandStrategyLoad.entry_point)
  return _internal_mutable_entry_point();
}
inline const std::string& CommandStrategyLoad::_internal_entry_point() const {
  return entry_point_.Get();
}
inline void CommandStrategyLoad::_internal_set_entry_point(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  entry_point_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CommandStrategyLoad::set_entry_point(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  entry_point_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:amun.CommandStrategyLoad.entry_point)
}
inline void CommandStrategyLoad::set_entry_point(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  entry_point_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:amun.CommandStrategyLoad.entry_point)
}
inline void CommandStrategyLoad::set_entry_point(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  entry_point_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:amun.CommandStrategyLoad.entry_point)
}
inline std::string* CommandStrategyLoad::_internal_mutable_entry_point() {
  _has_bits_[0] |= 0x00000002u;
  return entry_point_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CommandStrategyLoad::release_entry_point() {
  // @@protoc_insertion_point(field_release:amun.CommandStrategyLoad.entry_point)
  if (!_internal_has_entry_point()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return entry_point_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CommandStrategyLoad::set_allocated_entry_point(std::string* entry_point) {
  if (entry_point != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  entry_point_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), entry_point,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:amun.CommandStrategyLoad.entry_point)
}
inline std::string* CommandStrategyLoad::unsafe_arena_release_entry_point() {
  // @@protoc_insertion_point(field_unsafe_arena_release:amun.CommandStrategyLoad.entry_point)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return entry_point_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void CommandStrategyLoad::unsafe_arena_set_allocated_entry_point(
    std::string* entry_point) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (entry_point != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  entry_point_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      entry_point, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.CommandStrategyLoad.entry_point)
}

// -------------------------------------------------------------------

// CommandStrategyClose

// -------------------------------------------------------------------

// CommandStrategyTriggerDebugger

// -------------------------------------------------------------------

// CommandStrategy

// optional .amun.CommandStrategyLoad load = 1;
inline bool CommandStrategy::_internal_has_load() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || load_ != nullptr);
  return value;
}
inline bool CommandStrategy::has_load() const {
  return _internal_has_load();
}
inline void CommandStrategy::clear_load() {
  if (load_ != nullptr) load_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::amun::CommandStrategyLoad& CommandStrategy::_internal_load() const {
  const ::amun::CommandStrategyLoad* p = load_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::CommandStrategyLoad*>(
      &::amun::_CommandStrategyLoad_default_instance_);
}
inline const ::amun::CommandStrategyLoad& CommandStrategy::load() const {
  // @@protoc_insertion_point(field_get:amun.CommandStrategy.load)
  return _internal_load();
}
inline void CommandStrategy::unsafe_arena_set_allocated_load(
    ::amun::CommandStrategyLoad* load) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(load_);
  }
  load_ = load;
  if (load) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.CommandStrategy.load)
}
inline ::amun::CommandStrategyLoad* CommandStrategy::release_load() {
  auto temp = unsafe_arena_release_load();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::CommandStrategyLoad* CommandStrategy::unsafe_arena_release_load() {
  // @@protoc_insertion_point(field_release:amun.CommandStrategy.load)
  _has_bits_[0] &= ~0x00000002u;
  ::amun::CommandStrategyLoad* temp = load_;
  load_ = nullptr;
  return temp;
}
inline ::amun::CommandStrategyLoad* CommandStrategy::_internal_mutable_load() {
  _has_bits_[0] |= 0x00000002u;
  if (load_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::CommandStrategyLoad>(GetArena());
    load_ = p;
  }
  return load_;
}
inline ::amun::CommandStrategyLoad* CommandStrategy::mutable_load() {
  // @@protoc_insertion_point(field_mutable:amun.CommandStrategy.load)
  return _internal_mutable_load();
}
inline void CommandStrategy::set_allocated_load(::amun::CommandStrategyLoad* load) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete load_;
  }
  if (load) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(load);
    if (message_arena != submessage_arena) {
      load = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, load, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  load_ = load;
  // @@protoc_insertion_point(field_set_allocated:amun.CommandStrategy.load)
}

// optional .amun.CommandStrategyClose close = 2;
inline bool CommandStrategy::_internal_has_close() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || close_ != nullptr);
  return value;
}
inline bool CommandStrategy::has_close() const {
  return _internal_has_close();
}
inline void CommandStrategy::clear_close() {
  if (close_ != nullptr) close_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::amun::CommandStrategyClose& CommandStrategy::_internal_close() const {
  const ::amun::CommandStrategyClose* p = close_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::CommandStrategyClose*>(
      &::amun::_CommandStrategyClose_default_instance_);
}
inline const ::amun::CommandStrategyClose& CommandStrategy::close() const {
  // @@protoc_insertion_point(field_get:amun.CommandStrategy.close)
  return _internal_close();
}
inline void CommandStrategy::unsafe_arena_set_allocated_close(
    ::amun::CommandStrategyClose* close) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(close_);
  }
  close_ = close;
  if (close) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.CommandStrategy.close)
}
inline ::amun::CommandStrategyClose* CommandStrategy::release_close() {
  auto temp = unsafe_arena_release_close();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::CommandStrategyClose* CommandStrategy::unsafe_arena_release_close() {
  // @@protoc_insertion_point(field_release:amun.CommandStrategy.close)
  _has_bits_[0] &= ~0x00000004u;
  ::amun::CommandStrategyClose* temp = close_;
  close_ = nullptr;
  return temp;
}
inline ::amun::CommandStrategyClose* CommandStrategy::_internal_mutable_close() {
  _has_bits_[0] |= 0x00000004u;
  if (close_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::CommandStrategyClose>(GetArena());
    close_ = p;
  }
  return close_;
}
inline ::amun::CommandStrategyClose* CommandStrategy::mutable_close() {
  // @@protoc_insertion_point(field_mutable:amun.CommandStrategy.close)
  return _internal_mutable_close();
}
inline void CommandStrategy::set_allocated_close(::amun::CommandStrategyClose* close) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete close_;
  }
  if (close) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(close);
    if (message_arena != submessage_arena) {
      close = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, close, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  close_ = close;
  // @@protoc_insertion_point(field_set_allocated:amun.CommandStrategy.close)
}

// optional bool reload = 3;
inline bool CommandStrategy::_internal_has_reload() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CommandStrategy::has_reload() const {
  return _internal_has_reload();
}
inline void CommandStrategy::clear_reload() {
  reload_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool CommandStrategy::_internal_reload() const {
  return reload_;
}
inline bool CommandStrategy::reload() const {
  // @@protoc_insertion_point(field_get:amun.CommandStrategy.reload)
  return _internal_reload();
}
inline void CommandStrategy::_internal_set_reload(bool value) {
  _has_bits_[0] |= 0x00000020u;
  reload_ = value;
}
inline void CommandStrategy::set_reload(bool value) {
  _internal_set_reload(value);
  // @@protoc_insertion_point(field_set:amun.CommandStrategy.reload)
}

// optional bool auto_reload = 4;
inline bool CommandStrategy::_internal_has_auto_reload() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CommandStrategy::has_auto_reload() const {
  return _internal_has_auto_reload();
}
inline void CommandStrategy::clear_auto_reload() {
  auto_reload_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool CommandStrategy::_internal_auto_reload() const {
  return auto_reload_;
}
inline bool CommandStrategy::auto_reload() const {
  // @@protoc_insertion_point(field_get:amun.CommandStrategy.auto_reload)
  return _internal_auto_reload();
}
inline void CommandStrategy::_internal_set_auto_reload(bool value) {
  _has_bits_[0] |= 0x00000040u;
  auto_reload_ = value;
}
inline void CommandStrategy::set_auto_reload(bool value) {
  _internal_set_auto_reload(value);
  // @@protoc_insertion_point(field_set:amun.CommandStrategy.auto_reload)
}

// optional bool enable_debug = 5;
inline bool CommandStrategy::_internal_has_enable_debug() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CommandStrategy::has_enable_debug() const {
  return _internal_has_enable_debug();
}
inline void CommandStrategy::clear_enable_debug() {
  enable_debug_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool CommandStrategy::_internal_enable_debug() const {
  return enable_debug_;
}
inline bool CommandStrategy::enable_debug() const {
  // @@protoc_insertion_point(field_get:amun.CommandStrategy.enable_debug)
  return _internal_enable_debug();
}
inline void CommandStrategy::_internal_set_enable_debug(bool value) {
  _has_bits_[0] |= 0x00000080u;
  enable_debug_ = value;
}
inline void CommandStrategy::set_enable_debug(bool value) {
  _internal_set_enable_debug(value);
  // @@protoc_insertion_point(field_set:amun.CommandStrategy.enable_debug)
}

// optional .amun.CommandStrategyTriggerDebugger debug = 6;
inline bool CommandStrategy::_internal_has_debug() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || debug_ != nullptr);
  return value;
}
inline bool CommandStrategy::has_debug() const {
  return _internal_has_debug();
}
inline void CommandStrategy::clear_debug() {
  if (debug_ != nullptr) debug_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::amun::CommandStrategyTriggerDebugger& CommandStrategy::_internal_debug() const {
  const ::amun::CommandStrategyTriggerDebugger* p = debug_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::CommandStrategyTriggerDebugger*>(
      &::amun::_CommandStrategyTriggerDebugger_default_instance_);
}
inline const ::amun::CommandStrategyTriggerDebugger& CommandStrategy::debug() const {
  // @@protoc_insertion_point(field_get:amun.CommandStrategy.debug)
  return _internal_debug();
}
inline void CommandStrategy::unsafe_arena_set_allocated_debug(
    ::amun::CommandStrategyTriggerDebugger* debug) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(debug_);
  }
  debug_ = debug;
  if (debug) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.CommandStrategy.debug)
}
inline ::amun::CommandStrategyTriggerDebugger* CommandStrategy::release_debug() {
  auto temp = unsafe_arena_release_debug();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::CommandStrategyTriggerDebugger* CommandStrategy::unsafe_arena_release_debug() {
  // @@protoc_insertion_point(field_release:amun.CommandStrategy.debug)
  _has_bits_[0] &= ~0x00000008u;
  ::amun::CommandStrategyTriggerDebugger* temp = debug_;
  debug_ = nullptr;
  return temp;
}
inline ::amun::CommandStrategyTriggerDebugger* CommandStrategy::_internal_mutable_debug() {
  _has_bits_[0] |= 0x00000008u;
  if (debug_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::CommandStrategyTriggerDebugger>(GetArena());
    debug_ = p;
  }
  return debug_;
}
inline ::amun::CommandStrategyTriggerDebugger* CommandStrategy::mutable_debug() {
  // @@protoc_insertion_point(field_mutable:amun.CommandStrategy.debug)
  return _internal_mutable_debug();
}
inline void CommandStrategy::set_allocated_debug(::amun::CommandStrategyTriggerDebugger* debug) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete debug_;
  }
  if (debug) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(debug);
    if (message_arena != submessage_arena) {
      debug = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, debug, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  debug_ = debug;
  // @@protoc_insertion_point(field_set_allocated:amun.CommandStrategy.debug)
}

// optional bool performance_mode = 7;
inline bool CommandStrategy::_internal_has_performance_mode() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CommandStrategy::has_performance_mode() const {
  return _internal_has_performance_mode();
}
inline void CommandStrategy::clear_performance_mode() {
  performance_mode_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool CommandStrategy::_internal_performance_mode() const {
  return performance_mode_;
}
inline bool CommandStrategy::performance_mode() const {
  // @@protoc_insertion_point(field_get:amun.CommandStrategy.performance_mode)
  return _internal_performance_mode();
}
inline void CommandStrategy::_internal_set_performance_mode(bool value) {
  _has_bits_[0] |= 0x00000100u;
  performance_mode_ = value;
}
inline void CommandStrategy::set_performance_mode(bool value) {
  _internal_set_performance_mode(value);
  // @@protoc_insertion_point(field_set:amun.CommandStrategy.performance_mode)
}

// optional bool start_profiling = 8;
inline bool CommandStrategy::_internal_has_start_profiling() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CommandStrategy::has_start_profiling() const {
  return _internal_has_start_profiling();
}
inline void CommandStrategy::clear_start_profiling() {
  start_profiling_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool CommandStrategy::_internal_start_profiling() const {
  return start_profiling_;
}
inline bool CommandStrategy::start_profiling() const {
  // @@protoc_insertion_point(field_get:amun.CommandStrategy.start_profiling)
  return _internal_start_profiling();
}
inline void CommandStrategy::_internal_set_start_profiling(bool value) {
  _has_bits_[0] |= 0x00000200u;
  start_profiling_ = value;
}
inline void CommandStrategy::set_start_profiling(bool value) {
  _internal_set_start_profiling(value);
  // @@protoc_insertion_point(field_set:amun.CommandStrategy.start_profiling)
}

// optional string finish_and_save_profile = 9;
inline bool CommandStrategy::_internal_has_finish_and_save_profile() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandStrategy::has_finish_and_save_profile() const {
  return _internal_has_finish_and_save_profile();
}
inline void CommandStrategy::clear_finish_and_save_profile() {
  finish_and_save_profile_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandStrategy::finish_and_save_profile() const {
  // @@protoc_insertion_point(field_get:amun.CommandStrategy.finish_and_save_profile)
  return _internal_finish_and_save_profile();
}
inline void CommandStrategy::set_finish_and_save_profile(const std::string& value) {
  _internal_set_finish_and_save_profile(value);
  // @@protoc_insertion_point(field_set:amun.CommandStrategy.finish_and_save_profile)
}
inline std::string* CommandStrategy::mutable_finish_and_save_profile() {
  // @@protoc_insertion_point(field_mutable:amun.CommandStrategy.finish_and_save_profile)
  return _internal_mutable_finish_and_save_profile();
}
inline const std::string& CommandStrategy::_internal_finish_and_save_profile() const {
  return finish_and_save_profile_.Get();
}
inline void CommandStrategy::_internal_set_finish_and_save_profile(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  finish_and_save_profile_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CommandStrategy::set_finish_and_save_profile(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  finish_and_save_profile_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:amun.CommandStrategy.finish_and_save_profile)
}
inline void CommandStrategy::set_finish_and_save_profile(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  finish_and_save_profile_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:amun.CommandStrategy.finish_and_save_profile)
}
inline void CommandStrategy::set_finish_and_save_profile(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  finish_and_save_profile_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:amun.CommandStrategy.finish_and_save_profile)
}
inline std::string* CommandStrategy::_internal_mutable_finish_and_save_profile() {
  _has_bits_[0] |= 0x00000001u;
  return finish_and_save_profile_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CommandStrategy::release_finish_and_save_profile() {
  // @@protoc_insertion_point(field_release:amun.CommandStrategy.finish_and_save_profile)
  if (!_internal_has_finish_and_save_profile()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return finish_and_save_profile_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CommandStrategy::set_allocated_finish_and_save_profile(std::string* finish_and_save_profile) {
  if (finish_and_save_profile != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  finish_and_save_profile_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), finish_and_save_profile,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:amun.CommandStrategy.finish_and_save_profile)
}
inline std::string* CommandStrategy::unsafe_arena_release_finish_and_save_profile() {
  // @@protoc_insertion_point(field_unsafe_arena_release:amun.CommandStrategy.finish_and_save_profile)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return finish_and_save_profile_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void CommandStrategy::unsafe_arena_set_allocated_finish_and_save_profile(
    std::string* finish_and_save_profile) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (finish_and_save_profile != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  finish_and_save_profile_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      finish_and_save_profile, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.CommandStrategy.finish_and_save_profile)
}

// optional bool tournament_mode = 10;
inline bool CommandStrategy::_internal_has_tournament_mode() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool CommandStrategy::has_tournament_mode() const {
  return _internal_has_tournament_mode();
}
inline void CommandStrategy::clear_tournament_mode() {
  tournament_mode_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool CommandStrategy::_internal_tournament_mode() const {
  return tournament_mode_;
}
inline bool CommandStrategy::tournament_mode() const {
  // @@protoc_insertion_point(field_get:amun.CommandStrategy.tournament_mode)
  return _internal_tournament_mode();
}
inline void CommandStrategy::_internal_set_tournament_mode(bool value) {
  _has_bits_[0] |= 0x00000400u;
  tournament_mode_ = value;
}
inline void CommandStrategy::set_tournament_mode(bool value) {
  _internal_set_tournament_mode(value);
  // @@protoc_insertion_point(field_set:amun.CommandStrategy.tournament_mode)
}

// optional .amun.CommandStrategyAutomaticEntrypoints automatic_entrypoints = 11;
inline bool CommandStrategy::_internal_has_automatic_entrypoints() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || automatic_entrypoints_ != nullptr);
  return value;
}
inline bool CommandStrategy::has_automatic_entrypoints() const {
  return _internal_has_automatic_entrypoints();
}
inline void CommandStrategy::clear_automatic_entrypoints() {
  if (automatic_entrypoints_ != nullptr) automatic_entrypoints_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::amun::CommandStrategyAutomaticEntrypoints& CommandStrategy::_internal_automatic_entrypoints() const {
  const ::amun::CommandStrategyAutomaticEntrypoints* p = automatic_entrypoints_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::CommandStrategyAutomaticEntrypoints*>(
      &::amun::_CommandStrategyAutomaticEntrypoints_default_instance_);
}
inline const ::amun::CommandStrategyAutomaticEntrypoints& CommandStrategy::automatic_entrypoints() const {
  // @@protoc_insertion_point(field_get:amun.CommandStrategy.automatic_entrypoints)
  return _internal_automatic_entrypoints();
}
inline void CommandStrategy::unsafe_arena_set_allocated_automatic_entrypoints(
    ::amun::CommandStrategyAutomaticEntrypoints* automatic_entrypoints) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(automatic_entrypoints_);
  }
  automatic_entrypoints_ = automatic_entrypoints;
  if (automatic_entrypoints) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.CommandStrategy.automatic_entrypoints)
}
inline ::amun::CommandStrategyAutomaticEntrypoints* CommandStrategy::release_automatic_entrypoints() {
  auto temp = unsafe_arena_release_automatic_entrypoints();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::CommandStrategyAutomaticEntrypoints* CommandStrategy::unsafe_arena_release_automatic_entrypoints() {
  // @@protoc_insertion_point(field_release:amun.CommandStrategy.automatic_entrypoints)
  _has_bits_[0] &= ~0x00000010u;
  ::amun::CommandStrategyAutomaticEntrypoints* temp = automatic_entrypoints_;
  automatic_entrypoints_ = nullptr;
  return temp;
}
inline ::amun::CommandStrategyAutomaticEntrypoints* CommandStrategy::_internal_mutable_automatic_entrypoints() {
  _has_bits_[0] |= 0x00000010u;
  if (automatic_entrypoints_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::CommandStrategyAutomaticEntrypoints>(GetArena());
    automatic_entrypoints_ = p;
  }
  return automatic_entrypoints_;
}
inline ::amun::CommandStrategyAutomaticEntrypoints* CommandStrategy::mutable_automatic_entrypoints() {
  // @@protoc_insertion_point(field_mutable:amun.CommandStrategy.automatic_entrypoints)
  return _internal_mutable_automatic_entrypoints();
}
inline void CommandStrategy::set_allocated_automatic_entrypoints(::amun::CommandStrategyAutomaticEntrypoints* automatic_entrypoints) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete automatic_entrypoints_;
  }
  if (automatic_entrypoints) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(automatic_entrypoints);
    if (message_arena != submessage_arena) {
      automatic_entrypoints = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, automatic_entrypoints, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  automatic_entrypoints_ = automatic_entrypoints;
  // @@protoc_insertion_point(field_set_allocated:amun.CommandStrategy.automatic_entrypoints)
}

// -------------------------------------------------------------------

// CommandControl

// repeated .robot.RadioCommand commands = 1;
inline int CommandControl::_internal_commands_size() const {
  return commands_.size();
}
inline int CommandControl::commands_size() const {
  return _internal_commands_size();
}
inline ::robot::RadioCommand* CommandControl::mutable_commands(int index) {
  // @@protoc_insertion_point(field_mutable:amun.CommandControl.commands)
  return commands_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::RadioCommand >*
CommandControl::mutable_commands() {
  // @@protoc_insertion_point(field_mutable_list:amun.CommandControl.commands)
  return &commands_;
}
inline const ::robot::RadioCommand& CommandControl::_internal_commands(int index) const {
  return commands_.Get(index);
}
inline const ::robot::RadioCommand& CommandControl::commands(int index) const {
  // @@protoc_insertion_point(field_get:amun.CommandControl.commands)
  return _internal_commands(index);
}
inline ::robot::RadioCommand* CommandControl::_internal_add_commands() {
  return commands_.Add();
}
inline ::robot::RadioCommand* CommandControl::add_commands() {
  // @@protoc_insertion_point(field_add:amun.CommandControl.commands)
  return _internal_add_commands();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::RadioCommand >&
CommandControl::commands() const {
  // @@protoc_insertion_point(field_list:amun.CommandControl.commands)
  return commands_;
}

// -------------------------------------------------------------------

// TransceiverConfiguration

// required uint32 channel = 1;
inline bool TransceiverConfiguration::_internal_has_channel() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TransceiverConfiguration::has_channel() const {
  return _internal_has_channel();
}
inline void TransceiverConfiguration::clear_channel() {
  channel_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TransceiverConfiguration::_internal_channel() const {
  return channel_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TransceiverConfiguration::channel() const {
  // @@protoc_insertion_point(field_get:amun.TransceiverConfiguration.channel)
  return _internal_channel();
}
inline void TransceiverConfiguration::_internal_set_channel(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  channel_ = value;
}
inline void TransceiverConfiguration::set_channel(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:amun.TransceiverConfiguration.channel)
}

// -------------------------------------------------------------------

// HostAddress

// required string host = 1;
inline bool HostAddress::_internal_has_host() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HostAddress::has_host() const {
  return _internal_has_host();
}
inline void HostAddress::clear_host() {
  host_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HostAddress::host() const {
  // @@protoc_insertion_point(field_get:amun.HostAddress.host)
  return _internal_host();
}
inline void HostAddress::set_host(const std::string& value) {
  _internal_set_host(value);
  // @@protoc_insertion_point(field_set:amun.HostAddress.host)
}
inline std::string* HostAddress::mutable_host() {
  // @@protoc_insertion_point(field_mutable:amun.HostAddress.host)
  return _internal_mutable_host();
}
inline const std::string& HostAddress::_internal_host() const {
  return host_.Get();
}
inline void HostAddress::_internal_set_host(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  host_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void HostAddress::set_host(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  host_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:amun.HostAddress.host)
}
inline void HostAddress::set_host(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  host_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:amun.HostAddress.host)
}
inline void HostAddress::set_host(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  host_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:amun.HostAddress.host)
}
inline std::string* HostAddress::_internal_mutable_host() {
  _has_bits_[0] |= 0x00000001u;
  return host_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* HostAddress::release_host() {
  // @@protoc_insertion_point(field_release:amun.HostAddress.host)
  if (!_internal_has_host()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return host_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void HostAddress::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  host_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), host,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:amun.HostAddress.host)
}
inline std::string* HostAddress::unsafe_arena_release_host() {
  // @@protoc_insertion_point(field_unsafe_arena_release:amun.HostAddress.host)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return host_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void HostAddress::unsafe_arena_set_allocated_host(
    std::string* host) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (host != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  host_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      host, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.HostAddress.host)
}

// required uint32 port = 2;
inline bool HostAddress::_internal_has_port() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool HostAddress::has_port() const {
  return _internal_has_port();
}
inline void HostAddress::clear_port() {
  port_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HostAddress::_internal_port() const {
  return port_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HostAddress::port() const {
  // @@protoc_insertion_point(field_get:amun.HostAddress.port)
  return _internal_port();
}
inline void HostAddress::_internal_set_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  port_ = value;
}
inline void HostAddress::set_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:amun.HostAddress.port)
}

// -------------------------------------------------------------------

// SimulatorNetworking

// required bool control_simulator = 1;
inline bool SimulatorNetworking::_internal_has_control_simulator() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SimulatorNetworking::has_control_simulator() const {
  return _internal_has_control_simulator();
}
inline void SimulatorNetworking::clear_control_simulator() {
  control_simulator_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool SimulatorNetworking::_internal_control_simulator() const {
  return control_simulator_;
}
inline bool SimulatorNetworking::control_simulator() const {
  // @@protoc_insertion_point(field_get:amun.SimulatorNetworking.control_simulator)
  return _internal_control_simulator();
}
inline void SimulatorNetworking::_internal_set_control_simulator(bool value) {
  _has_bits_[0] |= 0x00000001u;
  control_simulator_ = value;
}
inline void SimulatorNetworking::set_control_simulator(bool value) {
  _internal_set_control_simulator(value);
  // @@protoc_insertion_point(field_set:amun.SimulatorNetworking.control_simulator)
}

// required bool control_blue = 2;
inline bool SimulatorNetworking::_internal_has_control_blue() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SimulatorNetworking::has_control_blue() const {
  return _internal_has_control_blue();
}
inline void SimulatorNetworking::clear_control_blue() {
  control_blue_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool SimulatorNetworking::_internal_control_blue() const {
  return control_blue_;
}
inline bool SimulatorNetworking::control_blue() const {
  // @@protoc_insertion_point(field_get:amun.SimulatorNetworking.control_blue)
  return _internal_control_blue();
}
inline void SimulatorNetworking::_internal_set_control_blue(bool value) {
  _has_bits_[0] |= 0x00000002u;
  control_blue_ = value;
}
inline void SimulatorNetworking::set_control_blue(bool value) {
  _internal_set_control_blue(value);
  // @@protoc_insertion_point(field_set:amun.SimulatorNetworking.control_blue)
}

// required bool control_yellow = 3;
inline bool SimulatorNetworking::_internal_has_control_yellow() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SimulatorNetworking::has_control_yellow() const {
  return _internal_has_control_yellow();
}
inline void SimulatorNetworking::clear_control_yellow() {
  control_yellow_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool SimulatorNetworking::_internal_control_yellow() const {
  return control_yellow_;
}
inline bool SimulatorNetworking::control_yellow() const {
  // @@protoc_insertion_point(field_get:amun.SimulatorNetworking.control_yellow)
  return _internal_control_yellow();
}
inline void SimulatorNetworking::_internal_set_control_yellow(bool value) {
  _has_bits_[0] |= 0x00000004u;
  control_yellow_ = value;
}
inline void SimulatorNetworking::set_control_yellow(bool value) {
  _internal_set_control_yellow(value);
  // @@protoc_insertion_point(field_set:amun.SimulatorNetworking.control_yellow)
}

// required uint32 port_blue = 4;
inline bool SimulatorNetworking::_internal_has_port_blue() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SimulatorNetworking::has_port_blue() const {
  return _internal_has_port_blue();
}
inline void SimulatorNetworking::clear_port_blue() {
  port_blue_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SimulatorNetworking::_internal_port_blue() const {
  return port_blue_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SimulatorNetworking::port_blue() const {
  // @@protoc_insertion_point(field_get:amun.SimulatorNetworking.port_blue)
  return _internal_port_blue();
}
inline void SimulatorNetworking::_internal_set_port_blue(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  port_blue_ = value;
}
inline void SimulatorNetworking::set_port_blue(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_port_blue(value);
  // @@protoc_insertion_point(field_set:amun.SimulatorNetworking.port_blue)
}

// required uint32 port_yellow = 5;
inline bool SimulatorNetworking::_internal_has_port_yellow() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SimulatorNetworking::has_port_yellow() const {
  return _internal_has_port_yellow();
}
inline void SimulatorNetworking::clear_port_yellow() {
  port_yellow_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SimulatorNetworking::_internal_port_yellow() const {
  return port_yellow_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SimulatorNetworking::port_yellow() const {
  // @@protoc_insertion_point(field_get:amun.SimulatorNetworking.port_yellow)
  return _internal_port_yellow();
}
inline void SimulatorNetworking::_internal_set_port_yellow(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  port_yellow_ = value;
}
inline void SimulatorNetworking::set_port_yellow(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_port_yellow(value);
  // @@protoc_insertion_point(field_set:amun.SimulatorNetworking.port_yellow)
}

// -------------------------------------------------------------------

// CommandTransceiver

// optional bool enable = 1;
inline bool CommandTransceiver::_internal_has_enable() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CommandTransceiver::has_enable() const {
  return _internal_has_enable();
}
inline void CommandTransceiver::clear_enable() {
  enable_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool CommandTransceiver::_internal_enable() const {
  return enable_;
}
inline bool CommandTransceiver::enable() const {
  // @@protoc_insertion_point(field_get:amun.CommandTransceiver.enable)
  return _internal_enable();
}
inline void CommandTransceiver::_internal_set_enable(bool value) {
  _has_bits_[0] |= 0x00000008u;
  enable_ = value;
}
inline void CommandTransceiver::set_enable(bool value) {
  _internal_set_enable(value);
  // @@protoc_insertion_point(field_set:amun.CommandTransceiver.enable)
}

// optional bool charge = 2;
inline bool CommandTransceiver::_internal_has_charge() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CommandTransceiver::has_charge() const {
  return _internal_has_charge();
}
inline void CommandTransceiver::clear_charge() {
  charge_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool CommandTransceiver::_internal_charge() const {
  return charge_;
}
inline bool CommandTransceiver::charge() const {
  // @@protoc_insertion_point(field_get:amun.CommandTransceiver.charge)
  return _internal_charge();
}
inline void CommandTransceiver::_internal_set_charge(bool value) {
  _has_bits_[0] |= 0x00000010u;
  charge_ = value;
}
inline void CommandTransceiver::set_charge(bool value) {
  _internal_set_charge(value);
  // @@protoc_insertion_point(field_set:amun.CommandTransceiver.charge)
}

// optional .amun.TransceiverConfiguration configuration = 3;
inline bool CommandTransceiver::_internal_has_configuration() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || configuration_ != nullptr);
  return value;
}
inline bool CommandTransceiver::has_configuration() const {
  return _internal_has_configuration();
}
inline void CommandTransceiver::clear_configuration() {
  if (configuration_ != nullptr) configuration_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::amun::TransceiverConfiguration& CommandTransceiver::_internal_configuration() const {
  const ::amun::TransceiverConfiguration* p = configuration_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::TransceiverConfiguration*>(
      &::amun::_TransceiverConfiguration_default_instance_);
}
inline const ::amun::TransceiverConfiguration& CommandTransceiver::configuration() const {
  // @@protoc_insertion_point(field_get:amun.CommandTransceiver.configuration)
  return _internal_configuration();
}
inline void CommandTransceiver::unsafe_arena_set_allocated_configuration(
    ::amun::TransceiverConfiguration* configuration) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(configuration_);
  }
  configuration_ = configuration;
  if (configuration) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.CommandTransceiver.configuration)
}
inline ::amun::TransceiverConfiguration* CommandTransceiver::release_configuration() {
  auto temp = unsafe_arena_release_configuration();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::TransceiverConfiguration* CommandTransceiver::unsafe_arena_release_configuration() {
  // @@protoc_insertion_point(field_release:amun.CommandTransceiver.configuration)
  _has_bits_[0] &= ~0x00000001u;
  ::amun::TransceiverConfiguration* temp = configuration_;
  configuration_ = nullptr;
  return temp;
}
inline ::amun::TransceiverConfiguration* CommandTransceiver::_internal_mutable_configuration() {
  _has_bits_[0] |= 0x00000001u;
  if (configuration_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::TransceiverConfiguration>(GetArena());
    configuration_ = p;
  }
  return configuration_;
}
inline ::amun::TransceiverConfiguration* CommandTransceiver::mutable_configuration() {
  // @@protoc_insertion_point(field_mutable:amun.CommandTransceiver.configuration)
  return _internal_mutable_configuration();
}
inline void CommandTransceiver::set_allocated_configuration(::amun::TransceiverConfiguration* configuration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete configuration_;
  }
  if (configuration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(configuration);
    if (message_arena != submessage_arena) {
      configuration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, configuration, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  configuration_ = configuration;
  // @@protoc_insertion_point(field_set_allocated:amun.CommandTransceiver.configuration)
}

// optional .amun.HostAddress network_configuration = 4;
inline bool CommandTransceiver::_internal_has_network_configuration() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || network_configuration_ != nullptr);
  return value;
}
inline bool CommandTransceiver::has_network_configuration() const {
  return _internal_has_network_configuration();
}
inline void CommandTransceiver::clear_network_configuration() {
  if (network_configuration_ != nullptr) network_configuration_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::amun::HostAddress& CommandTransceiver::_internal_network_configuration() const {
  const ::amun::HostAddress* p = network_configuration_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::HostAddress*>(
      &::amun::_HostAddress_default_instance_);
}
inline const ::amun::HostAddress& CommandTransceiver::network_configuration() const {
  // @@protoc_insertion_point(field_get:amun.CommandTransceiver.network_configuration)
  return _internal_network_configuration();
}
inline void CommandTransceiver::unsafe_arena_set_allocated_network_configuration(
    ::amun::HostAddress* network_configuration) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(network_configuration_);
  }
  network_configuration_ = network_configuration;
  if (network_configuration) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.CommandTransceiver.network_configuration)
}
inline ::amun::HostAddress* CommandTransceiver::release_network_configuration() {
  auto temp = unsafe_arena_release_network_configuration();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::HostAddress* CommandTransceiver::unsafe_arena_release_network_configuration() {
  // @@protoc_insertion_point(field_release:amun.CommandTransceiver.network_configuration)
  _has_bits_[0] &= ~0x00000002u;
  ::amun::HostAddress* temp = network_configuration_;
  network_configuration_ = nullptr;
  return temp;
}
inline ::amun::HostAddress* CommandTransceiver::_internal_mutable_network_configuration() {
  _has_bits_[0] |= 0x00000002u;
  if (network_configuration_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::HostAddress>(GetArena());
    network_configuration_ = p;
  }
  return network_configuration_;
}
inline ::amun::HostAddress* CommandTransceiver::mutable_network_configuration() {
  // @@protoc_insertion_point(field_mutable:amun.CommandTransceiver.network_configuration)
  return _internal_mutable_network_configuration();
}
inline void CommandTransceiver::set_allocated_network_configuration(::amun::HostAddress* network_configuration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete network_configuration_;
  }
  if (network_configuration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(network_configuration);
    if (message_arena != submessage_arena) {
      network_configuration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, network_configuration, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  network_configuration_ = network_configuration;
  // @@protoc_insertion_point(field_set_allocated:amun.CommandTransceiver.network_configuration)
}

// optional bool use_network = 5;
inline bool CommandTransceiver::_internal_has_use_network() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CommandTransceiver::has_use_network() const {
  return _internal_has_use_network();
}
inline void CommandTransceiver::clear_use_network() {
  use_network_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool CommandTransceiver::_internal_use_network() const {
  return use_network_;
}
inline bool CommandTransceiver::use_network() const {
  // @@protoc_insertion_point(field_get:amun.CommandTransceiver.use_network)
  return _internal_use_network();
}
inline void CommandTransceiver::_internal_set_use_network(bool value) {
  _has_bits_[0] |= 0x00000020u;
  use_network_ = value;
}
inline void CommandTransceiver::set_use_network(bool value) {
  _internal_set_use_network(value);
  // @@protoc_insertion_point(field_set:amun.CommandTransceiver.use_network)
}

// optional .amun.SimulatorNetworking simulator_configuration = 6;
inline bool CommandTransceiver::_internal_has_simulator_configuration() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || simulator_configuration_ != nullptr);
  return value;
}
inline bool CommandTransceiver::has_simulator_configuration() const {
  return _internal_has_simulator_configuration();
}
inline void CommandTransceiver::clear_simulator_configuration() {
  if (simulator_configuration_ != nullptr) simulator_configuration_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::amun::SimulatorNetworking& CommandTransceiver::_internal_simulator_configuration() const {
  const ::amun::SimulatorNetworking* p = simulator_configuration_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::SimulatorNetworking*>(
      &::amun::_SimulatorNetworking_default_instance_);
}
inline const ::amun::SimulatorNetworking& CommandTransceiver::simulator_configuration() const {
  // @@protoc_insertion_point(field_get:amun.CommandTransceiver.simulator_configuration)
  return _internal_simulator_configuration();
}
inline void CommandTransceiver::unsafe_arena_set_allocated_simulator_configuration(
    ::amun::SimulatorNetworking* simulator_configuration) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(simulator_configuration_);
  }
  simulator_configuration_ = simulator_configuration;
  if (simulator_configuration) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.CommandTransceiver.simulator_configuration)
}
inline ::amun::SimulatorNetworking* CommandTransceiver::release_simulator_configuration() {
  auto temp = unsafe_arena_release_simulator_configuration();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::SimulatorNetworking* CommandTransceiver::unsafe_arena_release_simulator_configuration() {
  // @@protoc_insertion_point(field_release:amun.CommandTransceiver.simulator_configuration)
  _has_bits_[0] &= ~0x00000004u;
  ::amun::SimulatorNetworking* temp = simulator_configuration_;
  simulator_configuration_ = nullptr;
  return temp;
}
inline ::amun::SimulatorNetworking* CommandTransceiver::_internal_mutable_simulator_configuration() {
  _has_bits_[0] |= 0x00000004u;
  if (simulator_configuration_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::SimulatorNetworking>(GetArena());
    simulator_configuration_ = p;
  }
  return simulator_configuration_;
}
inline ::amun::SimulatorNetworking* CommandTransceiver::mutable_simulator_configuration() {
  // @@protoc_insertion_point(field_mutable:amun.CommandTransceiver.simulator_configuration)
  return _internal_mutable_simulator_configuration();
}
inline void CommandTransceiver::set_allocated_simulator_configuration(::amun::SimulatorNetworking* simulator_configuration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete simulator_configuration_;
  }
  if (simulator_configuration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(simulator_configuration);
    if (message_arena != submessage_arena) {
      simulator_configuration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, simulator_configuration, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  simulator_configuration_ = simulator_configuration;
  // @@protoc_insertion_point(field_set_allocated:amun.CommandTransceiver.simulator_configuration)
}

// -------------------------------------------------------------------

// VirtualFieldTransform

// required float a11 = 1;
inline bool VirtualFieldTransform::_internal_has_a11() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VirtualFieldTransform::has_a11() const {
  return _internal_has_a11();
}
inline void VirtualFieldTransform::clear_a11() {
  a11_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float VirtualFieldTransform::_internal_a11() const {
  return a11_;
}
inline float VirtualFieldTransform::a11() const {
  // @@protoc_insertion_point(field_get:amun.VirtualFieldTransform.a11)
  return _internal_a11();
}
inline void VirtualFieldTransform::_internal_set_a11(float value) {
  _has_bits_[0] |= 0x00000001u;
  a11_ = value;
}
inline void VirtualFieldTransform::set_a11(float value) {
  _internal_set_a11(value);
  // @@protoc_insertion_point(field_set:amun.VirtualFieldTransform.a11)
}

// required float a12 = 2;
inline bool VirtualFieldTransform::_internal_has_a12() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VirtualFieldTransform::has_a12() const {
  return _internal_has_a12();
}
inline void VirtualFieldTransform::clear_a12() {
  a12_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float VirtualFieldTransform::_internal_a12() const {
  return a12_;
}
inline float VirtualFieldTransform::a12() const {
  // @@protoc_insertion_point(field_get:amun.VirtualFieldTransform.a12)
  return _internal_a12();
}
inline void VirtualFieldTransform::_internal_set_a12(float value) {
  _has_bits_[0] |= 0x00000002u;
  a12_ = value;
}
inline void VirtualFieldTransform::set_a12(float value) {
  _internal_set_a12(value);
  // @@protoc_insertion_point(field_set:amun.VirtualFieldTransform.a12)
}

// required float a21 = 3;
inline bool VirtualFieldTransform::_internal_has_a21() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool VirtualFieldTransform::has_a21() const {
  return _internal_has_a21();
}
inline void VirtualFieldTransform::clear_a21() {
  a21_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float VirtualFieldTransform::_internal_a21() const {
  return a21_;
}
inline float VirtualFieldTransform::a21() const {
  // @@protoc_insertion_point(field_get:amun.VirtualFieldTransform.a21)
  return _internal_a21();
}
inline void VirtualFieldTransform::_internal_set_a21(float value) {
  _has_bits_[0] |= 0x00000004u;
  a21_ = value;
}
inline void VirtualFieldTransform::set_a21(float value) {
  _internal_set_a21(value);
  // @@protoc_insertion_point(field_set:amun.VirtualFieldTransform.a21)
}

// required float a22 = 4;
inline bool VirtualFieldTransform::_internal_has_a22() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool VirtualFieldTransform::has_a22() const {
  return _internal_has_a22();
}
inline void VirtualFieldTransform::clear_a22() {
  a22_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float VirtualFieldTransform::_internal_a22() const {
  return a22_;
}
inline float VirtualFieldTransform::a22() const {
  // @@protoc_insertion_point(field_get:amun.VirtualFieldTransform.a22)
  return _internal_a22();
}
inline void VirtualFieldTransform::_internal_set_a22(float value) {
  _has_bits_[0] |= 0x00000008u;
  a22_ = value;
}
inline void VirtualFieldTransform::set_a22(float value) {
  _internal_set_a22(value);
  // @@protoc_insertion_point(field_set:amun.VirtualFieldTransform.a22)
}

// required float offsetX = 5;
inline bool VirtualFieldTransform::_internal_has_offsetx() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool VirtualFieldTransform::has_offsetx() const {
  return _internal_has_offsetx();
}
inline void VirtualFieldTransform::clear_offsetx() {
  offsetx_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float VirtualFieldTransform::_internal_offsetx() const {
  return offsetx_;
}
inline float VirtualFieldTransform::offsetx() const {
  // @@protoc_insertion_point(field_get:amun.VirtualFieldTransform.offsetX)
  return _internal_offsetx();
}
inline void VirtualFieldTransform::_internal_set_offsetx(float value) {
  _has_bits_[0] |= 0x00000010u;
  offsetx_ = value;
}
inline void VirtualFieldTransform::set_offsetx(float value) {
  _internal_set_offsetx(value);
  // @@protoc_insertion_point(field_set:amun.VirtualFieldTransform.offsetX)
}

// required float offsetY = 6;
inline bool VirtualFieldTransform::_internal_has_offsety() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool VirtualFieldTransform::has_offsety() const {
  return _internal_has_offsety();
}
inline void VirtualFieldTransform::clear_offsety() {
  offsety_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline float VirtualFieldTransform::_internal_offsety() const {
  return offsety_;
}
inline float VirtualFieldTransform::offsety() const {
  // @@protoc_insertion_point(field_get:amun.VirtualFieldTransform.offsetY)
  return _internal_offsety();
}
inline void VirtualFieldTransform::_internal_set_offsety(float value) {
  _has_bits_[0] |= 0x00000020u;
  offsety_ = value;
}
inline void VirtualFieldTransform::set_offsety(float value) {
  _internal_set_offsety(value);
  // @@protoc_insertion_point(field_set:amun.VirtualFieldTransform.offsetY)
}

// -------------------------------------------------------------------

// CommandTracking

// optional bool aoi_enabled = 1;
inline bool CommandTracking::_internal_has_aoi_enabled() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CommandTracking::has_aoi_enabled() const {
  return _internal_has_aoi_enabled();
}
inline void CommandTracking::clear_aoi_enabled() {
  aoi_enabled_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool CommandTracking::_internal_aoi_enabled() const {
  return aoi_enabled_;
}
inline bool CommandTracking::aoi_enabled() const {
  // @@protoc_insertion_point(field_get:amun.CommandTracking.aoi_enabled)
  return _internal_aoi_enabled();
}
inline void CommandTracking::_internal_set_aoi_enabled(bool value) {
  _has_bits_[0] |= 0x00000020u;
  aoi_enabled_ = value;
}
inline void CommandTracking::set_aoi_enabled(bool value) {
  _internal_set_aoi_enabled(value);
  // @@protoc_insertion_point(field_set:amun.CommandTracking.aoi_enabled)
}

// optional .world.TrackingAOI aoi = 2;
inline bool CommandTracking::_internal_has_aoi() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || aoi_ != nullptr);
  return value;
}
inline bool CommandTracking::has_aoi() const {
  return _internal_has_aoi();
}
inline const ::world::TrackingAOI& CommandTracking::_internal_aoi() const {
  const ::world::TrackingAOI* p = aoi_;
  return p != nullptr ? *p : *reinterpret_cast<const ::world::TrackingAOI*>(
      &::world::_TrackingAOI_default_instance_);
}
inline const ::world::TrackingAOI& CommandTracking::aoi() const {
  // @@protoc_insertion_point(field_get:amun.CommandTracking.aoi)
  return _internal_aoi();
}
inline void CommandTracking::unsafe_arena_set_allocated_aoi(
    ::world::TrackingAOI* aoi) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(aoi_);
  }
  aoi_ = aoi;
  if (aoi) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.CommandTracking.aoi)
}
inline ::world::TrackingAOI* CommandTracking::release_aoi() {
  auto temp = unsafe_arena_release_aoi();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::world::TrackingAOI* CommandTracking::unsafe_arena_release_aoi() {
  // @@protoc_insertion_point(field_release:amun.CommandTracking.aoi)
  _has_bits_[0] &= ~0x00000001u;
  ::world::TrackingAOI* temp = aoi_;
  aoi_ = nullptr;
  return temp;
}
inline ::world::TrackingAOI* CommandTracking::_internal_mutable_aoi() {
  _has_bits_[0] |= 0x00000001u;
  if (aoi_ == nullptr) {
    auto* p = CreateMaybeMessage<::world::TrackingAOI>(GetArena());
    aoi_ = p;
  }
  return aoi_;
}
inline ::world::TrackingAOI* CommandTracking::mutable_aoi() {
  // @@protoc_insertion_point(field_mutable:amun.CommandTracking.aoi)
  return _internal_mutable_aoi();
}
inline void CommandTracking::set_allocated_aoi(::world::TrackingAOI* aoi) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(aoi_);
  }
  if (aoi) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(aoi)->GetArena();
    if (message_arena != submessage_arena) {
      aoi = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, aoi, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  aoi_ = aoi;
  // @@protoc_insertion_point(field_set_allocated:amun.CommandTracking.aoi)
}

// optional int64 system_delay = 3;
inline bool CommandTracking::_internal_has_system_delay() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CommandTracking::has_system_delay() const {
  return _internal_has_system_delay();
}
inline void CommandTracking::clear_system_delay() {
  system_delay_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CommandTracking::_internal_system_delay() const {
  return system_delay_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CommandTracking::system_delay() const {
  // @@protoc_insertion_point(field_get:amun.CommandTracking.system_delay)
  return _internal_system_delay();
}
inline void CommandTracking::_internal_set_system_delay(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  system_delay_ = value;
}
inline void CommandTracking::set_system_delay(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_system_delay(value);
  // @@protoc_insertion_point(field_set:amun.CommandTracking.system_delay)
}

// optional bool reset = 4;
inline bool CommandTracking::_internal_has_reset() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CommandTracking::has_reset() const {
  return _internal_has_reset();
}
inline void CommandTracking::clear_reset() {
  reset_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool CommandTracking::_internal_reset() const {
  return reset_;
}
inline bool CommandTracking::reset() const {
  // @@protoc_insertion_point(field_get:amun.CommandTracking.reset)
  return _internal_reset();
}
inline void CommandTracking::_internal_set_reset(bool value) {
  _has_bits_[0] |= 0x00000040u;
  reset_ = value;
}
inline void CommandTracking::set_reset(bool value) {
  _internal_set_reset(value);
  // @@protoc_insertion_point(field_set:amun.CommandTracking.reset)
}

// optional bool enable_virtual_field = 5;
inline bool CommandTracking::_internal_has_enable_virtual_field() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CommandTracking::has_enable_virtual_field() const {
  return _internal_has_enable_virtual_field();
}
inline void CommandTracking::clear_enable_virtual_field() {
  enable_virtual_field_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool CommandTracking::_internal_enable_virtual_field() const {
  return enable_virtual_field_;
}
inline bool CommandTracking::enable_virtual_field() const {
  // @@protoc_insertion_point(field_get:amun.CommandTracking.enable_virtual_field)
  return _internal_enable_virtual_field();
}
inline void CommandTracking::_internal_set_enable_virtual_field(bool value) {
  _has_bits_[0] |= 0x00000080u;
  enable_virtual_field_ = value;
}
inline void CommandTracking::set_enable_virtual_field(bool value) {
  _internal_set_enable_virtual_field(value);
  // @@protoc_insertion_point(field_set:amun.CommandTracking.enable_virtual_field)
}

// optional .amun.VirtualFieldTransform field_transform = 6;
inline bool CommandTracking::_internal_has_field_transform() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || field_transform_ != nullptr);
  return value;
}
inline bool CommandTracking::has_field_transform() const {
  return _internal_has_field_transform();
}
inline void CommandTracking::clear_field_transform() {
  if (field_transform_ != nullptr) field_transform_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::amun::VirtualFieldTransform& CommandTracking::_internal_field_transform() const {
  const ::amun::VirtualFieldTransform* p = field_transform_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::VirtualFieldTransform*>(
      &::amun::_VirtualFieldTransform_default_instance_);
}
inline const ::amun::VirtualFieldTransform& CommandTracking::field_transform() const {
  // @@protoc_insertion_point(field_get:amun.CommandTracking.field_transform)
  return _internal_field_transform();
}
inline void CommandTracking::unsafe_arena_set_allocated_field_transform(
    ::amun::VirtualFieldTransform* field_transform) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(field_transform_);
  }
  field_transform_ = field_transform;
  if (field_transform) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.CommandTracking.field_transform)
}
inline ::amun::VirtualFieldTransform* CommandTracking::release_field_transform() {
  auto temp = unsafe_arena_release_field_transform();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::VirtualFieldTransform* CommandTracking::unsafe_arena_release_field_transform() {
  // @@protoc_insertion_point(field_release:amun.CommandTracking.field_transform)
  _has_bits_[0] &= ~0x00000002u;
  ::amun::VirtualFieldTransform* temp = field_transform_;
  field_transform_ = nullptr;
  return temp;
}
inline ::amun::VirtualFieldTransform* CommandTracking::_internal_mutable_field_transform() {
  _has_bits_[0] |= 0x00000002u;
  if (field_transform_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::VirtualFieldTransform>(GetArena());
    field_transform_ = p;
  }
  return field_transform_;
}
inline ::amun::VirtualFieldTransform* CommandTracking::mutable_field_transform() {
  // @@protoc_insertion_point(field_mutable:amun.CommandTracking.field_transform)
  return _internal_mutable_field_transform();
}
inline void CommandTracking::set_allocated_field_transform(::amun::VirtualFieldTransform* field_transform) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete field_transform_;
  }
  if (field_transform) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(field_transform);
    if (message_arena != submessage_arena) {
      field_transform = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, field_transform, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  field_transform_ = field_transform;
  // @@protoc_insertion_point(field_set_allocated:amun.CommandTracking.field_transform)
}

// optional .world.Geometry virtual_geometry = 7;
inline bool CommandTracking::_internal_has_virtual_geometry() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || virtual_geometry_ != nullptr);
  return value;
}
inline bool CommandTracking::has_virtual_geometry() const {
  return _internal_has_virtual_geometry();
}
inline const ::world::Geometry& CommandTracking::_internal_virtual_geometry() const {
  const ::world::Geometry* p = virtual_geometry_;
  return p != nullptr ? *p : *reinterpret_cast<const ::world::Geometry*>(
      &::world::_Geometry_default_instance_);
}
inline const ::world::Geometry& CommandTracking::virtual_geometry() const {
  // @@protoc_insertion_point(field_get:amun.CommandTracking.virtual_geometry)
  return _internal_virtual_geometry();
}
inline void CommandTracking::unsafe_arena_set_allocated_virtual_geometry(
    ::world::Geometry* virtual_geometry) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(virtual_geometry_);
  }
  virtual_geometry_ = virtual_geometry;
  if (virtual_geometry) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.CommandTracking.virtual_geometry)
}
inline ::world::Geometry* CommandTracking::release_virtual_geometry() {
  auto temp = unsafe_arena_release_virtual_geometry();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::world::Geometry* CommandTracking::unsafe_arena_release_virtual_geometry() {
  // @@protoc_insertion_point(field_release:amun.CommandTracking.virtual_geometry)
  _has_bits_[0] &= ~0x00000004u;
  ::world::Geometry* temp = virtual_geometry_;
  virtual_geometry_ = nullptr;
  return temp;
}
inline ::world::Geometry* CommandTracking::_internal_mutable_virtual_geometry() {
  _has_bits_[0] |= 0x00000004u;
  if (virtual_geometry_ == nullptr) {
    auto* p = CreateMaybeMessage<::world::Geometry>(GetArena());
    virtual_geometry_ = p;
  }
  return virtual_geometry_;
}
inline ::world::Geometry* CommandTracking::mutable_virtual_geometry() {
  // @@protoc_insertion_point(field_mutable:amun.CommandTracking.virtual_geometry)
  return _internal_mutable_virtual_geometry();
}
inline void CommandTracking::set_allocated_virtual_geometry(::world::Geometry* virtual_geometry) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(virtual_geometry_);
  }
  if (virtual_geometry) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(virtual_geometry)->GetArena();
    if (message_arena != submessage_arena) {
      virtual_geometry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, virtual_geometry, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  virtual_geometry_ = virtual_geometry;
  // @@protoc_insertion_point(field_set_allocated:amun.CommandTracking.virtual_geometry)
}

// optional bool tracking_replay_enabled = 8;
inline bool CommandTracking::_internal_has_tracking_replay_enabled() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CommandTracking::has_tracking_replay_enabled() const {
  return _internal_has_tracking_replay_enabled();
}
inline void CommandTracking::clear_tracking_replay_enabled() {
  tracking_replay_enabled_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool CommandTracking::_internal_tracking_replay_enabled() const {
  return tracking_replay_enabled_;
}
inline bool CommandTracking::tracking_replay_enabled() const {
  // @@protoc_insertion_point(field_get:amun.CommandTracking.tracking_replay_enabled)
  return _internal_tracking_replay_enabled();
}
inline void CommandTracking::_internal_set_tracking_replay_enabled(bool value) {
  _has_bits_[0] |= 0x00000100u;
  tracking_replay_enabled_ = value;
}
inline void CommandTracking::set_tracking_replay_enabled(bool value) {
  _internal_set_tracking_replay_enabled(value);
  // @@protoc_insertion_point(field_set:amun.CommandTracking.tracking_replay_enabled)
}

// optional .world.BallModel ball_model = 9;
inline bool CommandTracking::_internal_has_ball_model() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || ball_model_ != nullptr);
  return value;
}
inline bool CommandTracking::has_ball_model() const {
  return _internal_has_ball_model();
}
inline const ::world::BallModel& CommandTracking::_internal_ball_model() const {
  const ::world::BallModel* p = ball_model_;
  return p != nullptr ? *p : *reinterpret_cast<const ::world::BallModel*>(
      &::world::_BallModel_default_instance_);
}
inline const ::world::BallModel& CommandTracking::ball_model() const {
  // @@protoc_insertion_point(field_get:amun.CommandTracking.ball_model)
  return _internal_ball_model();
}
inline void CommandTracking::unsafe_arena_set_allocated_ball_model(
    ::world::BallModel* ball_model) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ball_model_);
  }
  ball_model_ = ball_model;
  if (ball_model) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.CommandTracking.ball_model)
}
inline ::world::BallModel* CommandTracking::release_ball_model() {
  auto temp = unsafe_arena_release_ball_model();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::world::BallModel* CommandTracking::unsafe_arena_release_ball_model() {
  // @@protoc_insertion_point(field_release:amun.CommandTracking.ball_model)
  _has_bits_[0] &= ~0x00000008u;
  ::world::BallModel* temp = ball_model_;
  ball_model_ = nullptr;
  return temp;
}
inline ::world::BallModel* CommandTracking::_internal_mutable_ball_model() {
  _has_bits_[0] |= 0x00000008u;
  if (ball_model_ == nullptr) {
    auto* p = CreateMaybeMessage<::world::BallModel>(GetArena());
    ball_model_ = p;
  }
  return ball_model_;
}
inline ::world::BallModel* CommandTracking::mutable_ball_model() {
  // @@protoc_insertion_point(field_mutable:amun.CommandTracking.ball_model)
  return _internal_mutable_ball_model();
}
inline void CommandTracking::set_allocated_ball_model(::world::BallModel* ball_model) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(ball_model_);
  }
  if (ball_model) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ball_model)->GetArena();
    if (message_arena != submessage_arena) {
      ball_model = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ball_model, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  ball_model_ = ball_model;
  // @@protoc_insertion_point(field_set_allocated:amun.CommandTracking.ball_model)
}

// -------------------------------------------------------------------

// CommandStrategyChangeOption

// required string name = 1;
inline bool CommandStrategyChangeOption::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandStrategyChangeOption::has_name() const {
  return _internal_has_name();
}
inline void CommandStrategyChangeOption::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandStrategyChangeOption::name() const {
  // @@protoc_insertion_point(field_get:amun.CommandStrategyChangeOption.name)
  return _internal_name();
}
inline void CommandStrategyChangeOption::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:amun.CommandStrategyChangeOption.name)
}
inline std::string* CommandStrategyChangeOption::mutable_name() {
  // @@protoc_insertion_point(field_mutable:amun.CommandStrategyChangeOption.name)
  return _internal_mutable_name();
}
inline const std::string& CommandStrategyChangeOption::_internal_name() const {
  return name_.Get();
}
inline void CommandStrategyChangeOption::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CommandStrategyChangeOption::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:amun.CommandStrategyChangeOption.name)
}
inline void CommandStrategyChangeOption::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:amun.CommandStrategyChangeOption.name)
}
inline void CommandStrategyChangeOption::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:amun.CommandStrategyChangeOption.name)
}
inline std::string* CommandStrategyChangeOption::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CommandStrategyChangeOption::release_name() {
  // @@protoc_insertion_point(field_release:amun.CommandStrategyChangeOption.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CommandStrategyChangeOption::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:amun.CommandStrategyChangeOption.name)
}
inline std::string* CommandStrategyChangeOption::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:amun.CommandStrategyChangeOption.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void CommandStrategyChangeOption::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.CommandStrategyChangeOption.name)
}

// required bool value = 2;
inline bool CommandStrategyChangeOption::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandStrategyChangeOption::has_value() const {
  return _internal_has_value();
}
inline void CommandStrategyChangeOption::clear_value() {
  value_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool CommandStrategyChangeOption::_internal_value() const {
  return value_;
}
inline bool CommandStrategyChangeOption::value() const {
  // @@protoc_insertion_point(field_get:amun.CommandStrategyChangeOption.value)
  return _internal_value();
}
inline void CommandStrategyChangeOption::_internal_set_value(bool value) {
  _has_bits_[0] |= 0x00000002u;
  value_ = value;
}
inline void CommandStrategyChangeOption::set_value(bool value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:amun.CommandStrategyChangeOption.value)
}

// -------------------------------------------------------------------

// CommandAmun

// optional uint32 vision_port = 1;
inline bool CommandAmun::_internal_has_vision_port() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandAmun::has_vision_port() const {
  return _internal_has_vision_port();
}
inline void CommandAmun::clear_vision_port() {
  vision_port_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CommandAmun::_internal_vision_port() const {
  return vision_port_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CommandAmun::vision_port() const {
  // @@protoc_insertion_point(field_get:amun.CommandAmun.vision_port)
  return _internal_vision_port();
}
inline void CommandAmun::_internal_set_vision_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  vision_port_ = value;
}
inline void CommandAmun::set_vision_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_vision_port(value);
  // @@protoc_insertion_point(field_set:amun.CommandAmun.vision_port)
}

// optional uint32 referee_port = 2;
inline bool CommandAmun::_internal_has_referee_port() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandAmun::has_referee_port() const {
  return _internal_has_referee_port();
}
inline void CommandAmun::clear_referee_port() {
  referee_port_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CommandAmun::_internal_referee_port() const {
  return referee_port_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CommandAmun::referee_port() const {
  // @@protoc_insertion_point(field_get:amun.CommandAmun.referee_port)
  return _internal_referee_port();
}
inline void CommandAmun::_internal_set_referee_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  referee_port_ = value;
}
inline void CommandAmun::set_referee_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_referee_port(value);
  // @@protoc_insertion_point(field_set:amun.CommandAmun.referee_port)
}

// optional uint32 tracker_port = 4;
inline bool CommandAmun::_internal_has_tracker_port() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CommandAmun::has_tracker_port() const {
  return _internal_has_tracker_port();
}
inline void CommandAmun::clear_tracker_port() {
  tracker_port_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CommandAmun::_internal_tracker_port() const {
  return tracker_port_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 CommandAmun::tracker_port() const {
  // @@protoc_insertion_point(field_get:amun.CommandAmun.tracker_port)
  return _internal_tracker_port();
}
inline void CommandAmun::_internal_set_tracker_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  tracker_port_ = value;
}
inline void CommandAmun::set_tracker_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_tracker_port(value);
  // @@protoc_insertion_point(field_set:amun.CommandAmun.tracker_port)
}

// optional .amun.CommandStrategyChangeOption change_option = 3;
inline bool CommandAmun::_internal_has_change_option() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || change_option_ != nullptr);
  return value;
}
inline bool CommandAmun::has_change_option() const {
  return _internal_has_change_option();
}
inline void CommandAmun::clear_change_option() {
  if (change_option_ != nullptr) change_option_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::amun::CommandStrategyChangeOption& CommandAmun::_internal_change_option() const {
  const ::amun::CommandStrategyChangeOption* p = change_option_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::CommandStrategyChangeOption*>(
      &::amun::_CommandStrategyChangeOption_default_instance_);
}
inline const ::amun::CommandStrategyChangeOption& CommandAmun::change_option() const {
  // @@protoc_insertion_point(field_get:amun.CommandAmun.change_option)
  return _internal_change_option();
}
inline void CommandAmun::unsafe_arena_set_allocated_change_option(
    ::amun::CommandStrategyChangeOption* change_option) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(change_option_);
  }
  change_option_ = change_option;
  if (change_option) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.CommandAmun.change_option)
}
inline ::amun::CommandStrategyChangeOption* CommandAmun::release_change_option() {
  auto temp = unsafe_arena_release_change_option();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::CommandStrategyChangeOption* CommandAmun::unsafe_arena_release_change_option() {
  // @@protoc_insertion_point(field_release:amun.CommandAmun.change_option)
  _has_bits_[0] &= ~0x00000001u;
  ::amun::CommandStrategyChangeOption* temp = change_option_;
  change_option_ = nullptr;
  return temp;
}
inline ::amun::CommandStrategyChangeOption* CommandAmun::_internal_mutable_change_option() {
  _has_bits_[0] |= 0x00000001u;
  if (change_option_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::CommandStrategyChangeOption>(GetArena());
    change_option_ = p;
  }
  return change_option_;
}
inline ::amun::CommandStrategyChangeOption* CommandAmun::mutable_change_option() {
  // @@protoc_insertion_point(field_mutable:amun.CommandAmun.change_option)
  return _internal_mutable_change_option();
}
inline void CommandAmun::set_allocated_change_option(::amun::CommandStrategyChangeOption* change_option) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete change_option_;
  }
  if (change_option) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(change_option);
    if (message_arena != submessage_arena) {
      change_option = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, change_option, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  change_option_ = change_option;
  // @@protoc_insertion_point(field_set_allocated:amun.CommandAmun.change_option)
}

// -------------------------------------------------------------------

// CommandDebuggerInputDisable

// -------------------------------------------------------------------

// CommandDebuggerInputLine

// optional string line = 1;
inline bool CommandDebuggerInputLine::_internal_has_line() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandDebuggerInputLine::has_line() const {
  return _internal_has_line();
}
inline void CommandDebuggerInputLine::clear_line() {
  line_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandDebuggerInputLine::line() const {
  // @@protoc_insertion_point(field_get:amun.CommandDebuggerInputLine.line)
  return _internal_line();
}
inline void CommandDebuggerInputLine::set_line(const std::string& value) {
  _internal_set_line(value);
  // @@protoc_insertion_point(field_set:amun.CommandDebuggerInputLine.line)
}
inline std::string* CommandDebuggerInputLine::mutable_line() {
  // @@protoc_insertion_point(field_mutable:amun.CommandDebuggerInputLine.line)
  return _internal_mutable_line();
}
inline const std::string& CommandDebuggerInputLine::_internal_line() const {
  return line_.Get();
}
inline void CommandDebuggerInputLine::_internal_set_line(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  line_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CommandDebuggerInputLine::set_line(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  line_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:amun.CommandDebuggerInputLine.line)
}
inline void CommandDebuggerInputLine::set_line(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  line_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:amun.CommandDebuggerInputLine.line)
}
inline void CommandDebuggerInputLine::set_line(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  line_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:amun.CommandDebuggerInputLine.line)
}
inline std::string* CommandDebuggerInputLine::_internal_mutable_line() {
  _has_bits_[0] |= 0x00000001u;
  return line_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CommandDebuggerInputLine::release_line() {
  // @@protoc_insertion_point(field_release:amun.CommandDebuggerInputLine.line)
  if (!_internal_has_line()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return line_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CommandDebuggerInputLine::set_allocated_line(std::string* line) {
  if (line != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  line_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), line,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:amun.CommandDebuggerInputLine.line)
}
inline std::string* CommandDebuggerInputLine::unsafe_arena_release_line() {
  // @@protoc_insertion_point(field_unsafe_arena_release:amun.CommandDebuggerInputLine.line)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return line_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void CommandDebuggerInputLine::unsafe_arena_set_allocated_line(
    std::string* line) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (line != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  line_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      line, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.CommandDebuggerInputLine.line)
}

// -------------------------------------------------------------------

// CommandDebuggerInput

// required .amun.DebuggerInputTarget strategy_type = 1;
inline bool CommandDebuggerInput::_internal_has_strategy_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandDebuggerInput::has_strategy_type() const {
  return _internal_has_strategy_type();
}
inline void CommandDebuggerInput::clear_strategy_type() {
  strategy_type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::amun::DebuggerInputTarget CommandDebuggerInput::_internal_strategy_type() const {
  return static_cast< ::amun::DebuggerInputTarget >(strategy_type_);
}
inline ::amun::DebuggerInputTarget CommandDebuggerInput::strategy_type() const {
  // @@protoc_insertion_point(field_get:amun.CommandDebuggerInput.strategy_type)
  return _internal_strategy_type();
}
inline void CommandDebuggerInput::_internal_set_strategy_type(::amun::DebuggerInputTarget value) {
  assert(::amun::DebuggerInputTarget_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  strategy_type_ = value;
}
inline void CommandDebuggerInput::set_strategy_type(::amun::DebuggerInputTarget value) {
  _internal_set_strategy_type(value);
  // @@protoc_insertion_point(field_set:amun.CommandDebuggerInput.strategy_type)
}

// optional .amun.CommandDebuggerInputDisable disable = 2;
inline bool CommandDebuggerInput::_internal_has_disable() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || disable_ != nullptr);
  return value;
}
inline bool CommandDebuggerInput::has_disable() const {
  return _internal_has_disable();
}
inline void CommandDebuggerInput::clear_disable() {
  if (disable_ != nullptr) disable_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::amun::CommandDebuggerInputDisable& CommandDebuggerInput::_internal_disable() const {
  const ::amun::CommandDebuggerInputDisable* p = disable_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::CommandDebuggerInputDisable*>(
      &::amun::_CommandDebuggerInputDisable_default_instance_);
}
inline const ::amun::CommandDebuggerInputDisable& CommandDebuggerInput::disable() const {
  // @@protoc_insertion_point(field_get:amun.CommandDebuggerInput.disable)
  return _internal_disable();
}
inline void CommandDebuggerInput::unsafe_arena_set_allocated_disable(
    ::amun::CommandDebuggerInputDisable* disable) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(disable_);
  }
  disable_ = disable;
  if (disable) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.CommandDebuggerInput.disable)
}
inline ::amun::CommandDebuggerInputDisable* CommandDebuggerInput::release_disable() {
  auto temp = unsafe_arena_release_disable();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::CommandDebuggerInputDisable* CommandDebuggerInput::unsafe_arena_release_disable() {
  // @@protoc_insertion_point(field_release:amun.CommandDebuggerInput.disable)
  _has_bits_[0] &= ~0x00000001u;
  ::amun::CommandDebuggerInputDisable* temp = disable_;
  disable_ = nullptr;
  return temp;
}
inline ::amun::CommandDebuggerInputDisable* CommandDebuggerInput::_internal_mutable_disable() {
  _has_bits_[0] |= 0x00000001u;
  if (disable_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::CommandDebuggerInputDisable>(GetArena());
    disable_ = p;
  }
  return disable_;
}
inline ::amun::CommandDebuggerInputDisable* CommandDebuggerInput::mutable_disable() {
  // @@protoc_insertion_point(field_mutable:amun.CommandDebuggerInput.disable)
  return _internal_mutable_disable();
}
inline void CommandDebuggerInput::set_allocated_disable(::amun::CommandDebuggerInputDisable* disable) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete disable_;
  }
  if (disable) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(disable);
    if (message_arena != submessage_arena) {
      disable = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, disable, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  disable_ = disable;
  // @@protoc_insertion_point(field_set_allocated:amun.CommandDebuggerInput.disable)
}

// optional .amun.CommandDebuggerInputLine queue_line = 3;
inline bool CommandDebuggerInput::_internal_has_queue_line() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || queue_line_ != nullptr);
  return value;
}
inline bool CommandDebuggerInput::has_queue_line() const {
  return _internal_has_queue_line();
}
inline void CommandDebuggerInput::clear_queue_line() {
  if (queue_line_ != nullptr) queue_line_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::amun::CommandDebuggerInputLine& CommandDebuggerInput::_internal_queue_line() const {
  const ::amun::CommandDebuggerInputLine* p = queue_line_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::CommandDebuggerInputLine*>(
      &::amun::_CommandDebuggerInputLine_default_instance_);
}
inline const ::amun::CommandDebuggerInputLine& CommandDebuggerInput::queue_line() const {
  // @@protoc_insertion_point(field_get:amun.CommandDebuggerInput.queue_line)
  return _internal_queue_line();
}
inline void CommandDebuggerInput::unsafe_arena_set_allocated_queue_line(
    ::amun::CommandDebuggerInputLine* queue_line) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(queue_line_);
  }
  queue_line_ = queue_line;
  if (queue_line) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.CommandDebuggerInput.queue_line)
}
inline ::amun::CommandDebuggerInputLine* CommandDebuggerInput::release_queue_line() {
  auto temp = unsafe_arena_release_queue_line();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::CommandDebuggerInputLine* CommandDebuggerInput::unsafe_arena_release_queue_line() {
  // @@protoc_insertion_point(field_release:amun.CommandDebuggerInput.queue_line)
  _has_bits_[0] &= ~0x00000002u;
  ::amun::CommandDebuggerInputLine* temp = queue_line_;
  queue_line_ = nullptr;
  return temp;
}
inline ::amun::CommandDebuggerInputLine* CommandDebuggerInput::_internal_mutable_queue_line() {
  _has_bits_[0] |= 0x00000002u;
  if (queue_line_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::CommandDebuggerInputLine>(GetArena());
    queue_line_ = p;
  }
  return queue_line_;
}
inline ::amun::CommandDebuggerInputLine* CommandDebuggerInput::mutable_queue_line() {
  // @@protoc_insertion_point(field_mutable:amun.CommandDebuggerInput.queue_line)
  return _internal_mutable_queue_line();
}
inline void CommandDebuggerInput::set_allocated_queue_line(::amun::CommandDebuggerInputLine* queue_line) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete queue_line_;
  }
  if (queue_line) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(queue_line);
    if (message_arena != submessage_arena) {
      queue_line = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, queue_line, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  queue_line_ = queue_line;
  // @@protoc_insertion_point(field_set_allocated:amun.CommandDebuggerInput.queue_line)
}

// -------------------------------------------------------------------

// PauseSimulatorCommand

// required .amun.PauseSimulatorReason reason = 1;
inline bool PauseSimulatorCommand::_internal_has_reason() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PauseSimulatorCommand::has_reason() const {
  return _internal_has_reason();
}
inline void PauseSimulatorCommand::clear_reason() {
  reason_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::amun::PauseSimulatorReason PauseSimulatorCommand::_internal_reason() const {
  return static_cast< ::amun::PauseSimulatorReason >(reason_);
}
inline ::amun::PauseSimulatorReason PauseSimulatorCommand::reason() const {
  // @@protoc_insertion_point(field_get:amun.PauseSimulatorCommand.reason)
  return _internal_reason();
}
inline void PauseSimulatorCommand::_internal_set_reason(::amun::PauseSimulatorReason value) {
  assert(::amun::PauseSimulatorReason_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  reason_ = value;
}
inline void PauseSimulatorCommand::set_reason(::amun::PauseSimulatorReason value) {
  _internal_set_reason(value);
  // @@protoc_insertion_point(field_set:amun.PauseSimulatorCommand.reason)
}

// optional bool pause = 2;
inline bool PauseSimulatorCommand::_internal_has_pause() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PauseSimulatorCommand::has_pause() const {
  return _internal_has_pause();
}
inline void PauseSimulatorCommand::clear_pause() {
  pause_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool PauseSimulatorCommand::_internal_pause() const {
  return pause_;
}
inline bool PauseSimulatorCommand::pause() const {
  // @@protoc_insertion_point(field_get:amun.PauseSimulatorCommand.pause)
  return _internal_pause();
}
inline void PauseSimulatorCommand::_internal_set_pause(bool value) {
  _has_bits_[0] |= 0x00000001u;
  pause_ = value;
}
inline void PauseSimulatorCommand::set_pause(bool value) {
  _internal_set_pause(value);
  // @@protoc_insertion_point(field_set:amun.PauseSimulatorCommand.pause)
}

// optional bool toggle = 3;
inline bool PauseSimulatorCommand::_internal_has_toggle() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PauseSimulatorCommand::has_toggle() const {
  return _internal_has_toggle();
}
inline void PauseSimulatorCommand::clear_toggle() {
  toggle_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool PauseSimulatorCommand::_internal_toggle() const {
  return toggle_;
}
inline bool PauseSimulatorCommand::toggle() const {
  // @@protoc_insertion_point(field_get:amun.PauseSimulatorCommand.toggle)
  return _internal_toggle();
}
inline void PauseSimulatorCommand::_internal_set_toggle(bool value) {
  _has_bits_[0] |= 0x00000002u;
  toggle_ = value;
}
inline void PauseSimulatorCommand::set_toggle(bool value) {
  _internal_set_toggle(value);
  // @@protoc_insertion_point(field_set:amun.PauseSimulatorCommand.toggle)
}

// -------------------------------------------------------------------

// CommandReplay

// optional bool enable = 1;
inline bool CommandReplay::_internal_has_enable() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandReplay::has_enable() const {
  return _internal_has_enable();
}
inline void CommandReplay::clear_enable() {
  enable_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool CommandReplay::_internal_enable() const {
  return enable_;
}
inline bool CommandReplay::enable() const {
  // @@protoc_insertion_point(field_get:amun.CommandReplay.enable)
  return _internal_enable();
}
inline void CommandReplay::_internal_set_enable(bool value) {
  _has_bits_[0] |= 0x00000004u;
  enable_ = value;
}
inline void CommandReplay::set_enable(bool value) {
  _internal_set_enable(value);
  // @@protoc_insertion_point(field_set:amun.CommandReplay.enable)
}

// optional bool enable_blue_strategy = 2;
inline bool CommandReplay::_internal_has_enable_blue_strategy() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CommandReplay::has_enable_blue_strategy() const {
  return _internal_has_enable_blue_strategy();
}
inline void CommandReplay::clear_enable_blue_strategy() {
  enable_blue_strategy_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool CommandReplay::_internal_enable_blue_strategy() const {
  return enable_blue_strategy_;
}
inline bool CommandReplay::enable_blue_strategy() const {
  // @@protoc_insertion_point(field_get:amun.CommandReplay.enable_blue_strategy)
  return _internal_enable_blue_strategy();
}
inline void CommandReplay::_internal_set_enable_blue_strategy(bool value) {
  _has_bits_[0] |= 0x00000008u;
  enable_blue_strategy_ = value;
}
inline void CommandReplay::set_enable_blue_strategy(bool value) {
  _internal_set_enable_blue_strategy(value);
  // @@protoc_insertion_point(field_set:amun.CommandReplay.enable_blue_strategy)
}

// optional .amun.CommandStrategy blue_strategy = 3;
inline bool CommandReplay::_internal_has_blue_strategy() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || blue_strategy_ != nullptr);
  return value;
}
inline bool CommandReplay::has_blue_strategy() const {
  return _internal_has_blue_strategy();
}
inline void CommandReplay::clear_blue_strategy() {
  if (blue_strategy_ != nullptr) blue_strategy_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::amun::CommandStrategy& CommandReplay::_internal_blue_strategy() const {
  const ::amun::CommandStrategy* p = blue_strategy_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::CommandStrategy*>(
      &::amun::_CommandStrategy_default_instance_);
}
inline const ::amun::CommandStrategy& CommandReplay::blue_strategy() const {
  // @@protoc_insertion_point(field_get:amun.CommandReplay.blue_strategy)
  return _internal_blue_strategy();
}
inline void CommandReplay::unsafe_arena_set_allocated_blue_strategy(
    ::amun::CommandStrategy* blue_strategy) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(blue_strategy_);
  }
  blue_strategy_ = blue_strategy;
  if (blue_strategy) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.CommandReplay.blue_strategy)
}
inline ::amun::CommandStrategy* CommandReplay::release_blue_strategy() {
  auto temp = unsafe_arena_release_blue_strategy();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::CommandStrategy* CommandReplay::unsafe_arena_release_blue_strategy() {
  // @@protoc_insertion_point(field_release:amun.CommandReplay.blue_strategy)
  _has_bits_[0] &= ~0x00000001u;
  ::amun::CommandStrategy* temp = blue_strategy_;
  blue_strategy_ = nullptr;
  return temp;
}
inline ::amun::CommandStrategy* CommandReplay::_internal_mutable_blue_strategy() {
  _has_bits_[0] |= 0x00000001u;
  if (blue_strategy_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::CommandStrategy>(GetArena());
    blue_strategy_ = p;
  }
  return blue_strategy_;
}
inline ::amun::CommandStrategy* CommandReplay::mutable_blue_strategy() {
  // @@protoc_insertion_point(field_mutable:amun.CommandReplay.blue_strategy)
  return _internal_mutable_blue_strategy();
}
inline void CommandReplay::set_allocated_blue_strategy(::amun::CommandStrategy* blue_strategy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete blue_strategy_;
  }
  if (blue_strategy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(blue_strategy);
    if (message_arena != submessage_arena) {
      blue_strategy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, blue_strategy, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  blue_strategy_ = blue_strategy;
  // @@protoc_insertion_point(field_set_allocated:amun.CommandReplay.blue_strategy)
}

// optional bool enable_yellow_strategy = 4;
inline bool CommandReplay::_internal_has_enable_yellow_strategy() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CommandReplay::has_enable_yellow_strategy() const {
  return _internal_has_enable_yellow_strategy();
}
inline void CommandReplay::clear_enable_yellow_strategy() {
  enable_yellow_strategy_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool CommandReplay::_internal_enable_yellow_strategy() const {
  return enable_yellow_strategy_;
}
inline bool CommandReplay::enable_yellow_strategy() const {
  // @@protoc_insertion_point(field_get:amun.CommandReplay.enable_yellow_strategy)
  return _internal_enable_yellow_strategy();
}
inline void CommandReplay::_internal_set_enable_yellow_strategy(bool value) {
  _has_bits_[0] |= 0x00000010u;
  enable_yellow_strategy_ = value;
}
inline void CommandReplay::set_enable_yellow_strategy(bool value) {
  _internal_set_enable_yellow_strategy(value);
  // @@protoc_insertion_point(field_set:amun.CommandReplay.enable_yellow_strategy)
}

// optional .amun.CommandStrategy yellow_strategy = 5;
inline bool CommandReplay::_internal_has_yellow_strategy() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || yellow_strategy_ != nullptr);
  return value;
}
inline bool CommandReplay::has_yellow_strategy() const {
  return _internal_has_yellow_strategy();
}
inline void CommandReplay::clear_yellow_strategy() {
  if (yellow_strategy_ != nullptr) yellow_strategy_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::amun::CommandStrategy& CommandReplay::_internal_yellow_strategy() const {
  const ::amun::CommandStrategy* p = yellow_strategy_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::CommandStrategy*>(
      &::amun::_CommandStrategy_default_instance_);
}
inline const ::amun::CommandStrategy& CommandReplay::yellow_strategy() const {
  // @@protoc_insertion_point(field_get:amun.CommandReplay.yellow_strategy)
  return _internal_yellow_strategy();
}
inline void CommandReplay::unsafe_arena_set_allocated_yellow_strategy(
    ::amun::CommandStrategy* yellow_strategy) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(yellow_strategy_);
  }
  yellow_strategy_ = yellow_strategy;
  if (yellow_strategy) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.CommandReplay.yellow_strategy)
}
inline ::amun::CommandStrategy* CommandReplay::release_yellow_strategy() {
  auto temp = unsafe_arena_release_yellow_strategy();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::CommandStrategy* CommandReplay::unsafe_arena_release_yellow_strategy() {
  // @@protoc_insertion_point(field_release:amun.CommandReplay.yellow_strategy)
  _has_bits_[0] &= ~0x00000002u;
  ::amun::CommandStrategy* temp = yellow_strategy_;
  yellow_strategy_ = nullptr;
  return temp;
}
inline ::amun::CommandStrategy* CommandReplay::_internal_mutable_yellow_strategy() {
  _has_bits_[0] |= 0x00000002u;
  if (yellow_strategy_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::CommandStrategy>(GetArena());
    yellow_strategy_ = p;
  }
  return yellow_strategy_;
}
inline ::amun::CommandStrategy* CommandReplay::mutable_yellow_strategy() {
  // @@protoc_insertion_point(field_mutable:amun.CommandReplay.yellow_strategy)
  return _internal_mutable_yellow_strategy();
}
inline void CommandReplay::set_allocated_yellow_strategy(::amun::CommandStrategy* yellow_strategy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete yellow_strategy_;
  }
  if (yellow_strategy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(yellow_strategy);
    if (message_arena != submessage_arena) {
      yellow_strategy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, yellow_strategy, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  yellow_strategy_ = yellow_strategy;
  // @@protoc_insertion_point(field_set_allocated:amun.CommandReplay.yellow_strategy)
}

// -------------------------------------------------------------------

// Flag

// -------------------------------------------------------------------

// CommandPlayback

// optional int32 seek_time = 1;
inline bool CommandPlayback::_internal_has_seek_time() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CommandPlayback::has_seek_time() const {
  return _internal_has_seek_time();
}
inline void CommandPlayback::clear_seek_time() {
  seek_time_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CommandPlayback::_internal_seek_time() const {
  return seek_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CommandPlayback::seek_time() const {
  // @@protoc_insertion_point(field_get:amun.CommandPlayback.seek_time)
  return _internal_seek_time();
}
inline void CommandPlayback::_internal_set_seek_time(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  seek_time_ = value;
}
inline void CommandPlayback::set_seek_time(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_seek_time(value);
  // @@protoc_insertion_point(field_set:amun.CommandPlayback.seek_time)
}

// optional int32 seek_packet = 2;
inline bool CommandPlayback::_internal_has_seek_packet() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CommandPlayback::has_seek_packet() const {
  return _internal_has_seek_packet();
}
inline void CommandPlayback::clear_seek_packet() {
  seek_packet_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CommandPlayback::_internal_seek_packet() const {
  return seek_packet_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CommandPlayback::seek_packet() const {
  // @@protoc_insertion_point(field_get:amun.CommandPlayback.seek_packet)
  return _internal_seek_packet();
}
inline void CommandPlayback::_internal_set_seek_packet(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000080u;
  seek_packet_ = value;
}
inline void CommandPlayback::set_seek_packet(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_seek_packet(value);
  // @@protoc_insertion_point(field_set:amun.CommandPlayback.seek_packet)
}

// optional int32 seek_time_backwards = 3;
inline bool CommandPlayback::_internal_has_seek_time_backwards() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CommandPlayback::has_seek_time_backwards() const {
  return _internal_has_seek_time_backwards();
}
inline void CommandPlayback::clear_seek_time_backwards() {
  seek_time_backwards_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CommandPlayback::_internal_seek_time_backwards() const {
  return seek_time_backwards_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CommandPlayback::seek_time_backwards() const {
  // @@protoc_insertion_point(field_get:amun.CommandPlayback.seek_time_backwards)
  return _internal_seek_time_backwards();
}
inline void CommandPlayback::_internal_set_seek_time_backwards(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000100u;
  seek_time_backwards_ = value;
}
inline void CommandPlayback::set_seek_time_backwards(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_seek_time_backwards(value);
  // @@protoc_insertion_point(field_set:amun.CommandPlayback.seek_time_backwards)
}

// optional int32 playback_speed = 4;
inline bool CommandPlayback::_internal_has_playback_speed() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CommandPlayback::has_playback_speed() const {
  return _internal_has_playback_speed();
}
inline void CommandPlayback::clear_playback_speed() {
  playback_speed_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CommandPlayback::_internal_playback_speed() const {
  return playback_speed_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CommandPlayback::playback_speed() const {
  // @@protoc_insertion_point(field_get:amun.CommandPlayback.playback_speed)
  return _internal_playback_speed();
}
inline void CommandPlayback::_internal_set_playback_speed(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000200u;
  playback_speed_ = value;
}
inline void CommandPlayback::set_playback_speed(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_playback_speed(value);
  // @@protoc_insertion_point(field_set:amun.CommandPlayback.playback_speed)
}

// optional .amun.Flag toggle_paused = 5;
inline bool CommandPlayback::_internal_has_toggle_paused() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || toggle_paused_ != nullptr);
  return value;
}
inline bool CommandPlayback::has_toggle_paused() const {
  return _internal_has_toggle_paused();
}
inline void CommandPlayback::clear_toggle_paused() {
  if (toggle_paused_ != nullptr) toggle_paused_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::amun::Flag& CommandPlayback::_internal_toggle_paused() const {
  const ::amun::Flag* p = toggle_paused_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::Flag*>(
      &::amun::_Flag_default_instance_);
}
inline const ::amun::Flag& CommandPlayback::toggle_paused() const {
  // @@protoc_insertion_point(field_get:amun.CommandPlayback.toggle_paused)
  return _internal_toggle_paused();
}
inline void CommandPlayback::unsafe_arena_set_allocated_toggle_paused(
    ::amun::Flag* toggle_paused) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(toggle_paused_);
  }
  toggle_paused_ = toggle_paused;
  if (toggle_paused) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.CommandPlayback.toggle_paused)
}
inline ::amun::Flag* CommandPlayback::release_toggle_paused() {
  auto temp = unsafe_arena_release_toggle_paused();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::Flag* CommandPlayback::unsafe_arena_release_toggle_paused() {
  // @@protoc_insertion_point(field_release:amun.CommandPlayback.toggle_paused)
  _has_bits_[0] &= ~0x00000004u;
  ::amun::Flag* temp = toggle_paused_;
  toggle_paused_ = nullptr;
  return temp;
}
inline ::amun::Flag* CommandPlayback::_internal_mutable_toggle_paused() {
  _has_bits_[0] |= 0x00000004u;
  if (toggle_paused_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::Flag>(GetArena());
    toggle_paused_ = p;
  }
  return toggle_paused_;
}
inline ::amun::Flag* CommandPlayback::mutable_toggle_paused() {
  // @@protoc_insertion_point(field_mutable:amun.CommandPlayback.toggle_paused)
  return _internal_mutable_toggle_paused();
}
inline void CommandPlayback::set_allocated_toggle_paused(::amun::Flag* toggle_paused) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete toggle_paused_;
  }
  if (toggle_paused) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(toggle_paused);
    if (message_arena != submessage_arena) {
      toggle_paused = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, toggle_paused, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  toggle_paused_ = toggle_paused;
  // @@protoc_insertion_point(field_set_allocated:amun.CommandPlayback.toggle_paused)
}

// optional bool run_playback = 6;
inline bool CommandPlayback::_internal_has_run_playback() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool CommandPlayback::has_run_playback() const {
  return _internal_has_run_playback();
}
inline void CommandPlayback::clear_run_playback() {
  run_playback_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool CommandPlayback::_internal_run_playback() const {
  return run_playback_;
}
inline bool CommandPlayback::run_playback() const {
  // @@protoc_insertion_point(field_get:amun.CommandPlayback.run_playback)
  return _internal_run_playback();
}
inline void CommandPlayback::_internal_set_run_playback(bool value) {
  _has_bits_[0] |= 0x00000400u;
  run_playback_ = value;
}
inline void CommandPlayback::set_run_playback(bool value) {
  _internal_set_run_playback(value);
  // @@protoc_insertion_point(field_set:amun.CommandPlayback.run_playback)
}

// optional .logfile.LogRequest log_path = 7;
inline bool CommandPlayback::_internal_has_log_path() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || log_path_ != nullptr);
  return value;
}
inline bool CommandPlayback::has_log_path() const {
  return _internal_has_log_path();
}
inline const ::logfile::LogRequest& CommandPlayback::_internal_log_path() const {
  const ::logfile::LogRequest* p = log_path_;
  return p != nullptr ? *p : *reinterpret_cast<const ::logfile::LogRequest*>(
      &::logfile::_LogRequest_default_instance_);
}
inline const ::logfile::LogRequest& CommandPlayback::log_path() const {
  // @@protoc_insertion_point(field_get:amun.CommandPlayback.log_path)
  return _internal_log_path();
}
inline void CommandPlayback::unsafe_arena_set_allocated_log_path(
    ::logfile::LogRequest* log_path) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(log_path_);
  }
  log_path_ = log_path;
  if (log_path) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.CommandPlayback.log_path)
}
inline ::logfile::LogRequest* CommandPlayback::release_log_path() {
  auto temp = unsafe_arena_release_log_path();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::logfile::LogRequest* CommandPlayback::unsafe_arena_release_log_path() {
  // @@protoc_insertion_point(field_release:amun.CommandPlayback.log_path)
  _has_bits_[0] &= ~0x00000008u;
  ::logfile::LogRequest* temp = log_path_;
  log_path_ = nullptr;
  return temp;
}
inline ::logfile::LogRequest* CommandPlayback::_internal_mutable_log_path() {
  _has_bits_[0] |= 0x00000008u;
  if (log_path_ == nullptr) {
    auto* p = CreateMaybeMessage<::logfile::LogRequest>(GetArena());
    log_path_ = p;
  }
  return log_path_;
}
inline ::logfile::LogRequest* CommandPlayback::mutable_log_path() {
  // @@protoc_insertion_point(field_mutable:amun.CommandPlayback.log_path)
  return _internal_mutable_log_path();
}
inline void CommandPlayback::set_allocated_log_path(::logfile::LogRequest* log_path) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(log_path_);
  }
  if (log_path) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(log_path)->GetArena();
    if (message_arena != submessage_arena) {
      log_path = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, log_path, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  log_path_ = log_path;
  // @@protoc_insertion_point(field_set_allocated:amun.CommandPlayback.log_path)
}

// optional .amun.Flag instant_replay = 8;
inline bool CommandPlayback::_internal_has_instant_replay() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || instant_replay_ != nullptr);
  return value;
}
inline bool CommandPlayback::has_instant_replay() const {
  return _internal_has_instant_replay();
}
inline void CommandPlayback::clear_instant_replay() {
  if (instant_replay_ != nullptr) instant_replay_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::amun::Flag& CommandPlayback::_internal_instant_replay() const {
  const ::amun::Flag* p = instant_replay_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::Flag*>(
      &::amun::_Flag_default_instance_);
}
inline const ::amun::Flag& CommandPlayback::instant_replay() const {
  // @@protoc_insertion_point(field_get:amun.CommandPlayback.instant_replay)
  return _internal_instant_replay();
}
inline void CommandPlayback::unsafe_arena_set_allocated_instant_replay(
    ::amun::Flag* instant_replay) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(instant_replay_);
  }
  instant_replay_ = instant_replay;
  if (instant_replay) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.CommandPlayback.instant_replay)
}
inline ::amun::Flag* CommandPlayback::release_instant_replay() {
  auto temp = unsafe_arena_release_instant_replay();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::Flag* CommandPlayback::unsafe_arena_release_instant_replay() {
  // @@protoc_insertion_point(field_release:amun.CommandPlayback.instant_replay)
  _has_bits_[0] &= ~0x00000010u;
  ::amun::Flag* temp = instant_replay_;
  instant_replay_ = nullptr;
  return temp;
}
inline ::amun::Flag* CommandPlayback::_internal_mutable_instant_replay() {
  _has_bits_[0] |= 0x00000010u;
  if (instant_replay_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::Flag>(GetArena());
    instant_replay_ = p;
  }
  return instant_replay_;
}
inline ::amun::Flag* CommandPlayback::mutable_instant_replay() {
  // @@protoc_insertion_point(field_mutable:amun.CommandPlayback.instant_replay)
  return _internal_mutable_instant_replay();
}
inline void CommandPlayback::set_allocated_instant_replay(::amun::Flag* instant_replay) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete instant_replay_;
  }
  if (instant_replay) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(instant_replay);
    if (message_arena != submessage_arena) {
      instant_replay = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instant_replay, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  instant_replay_ = instant_replay;
  // @@protoc_insertion_point(field_set_allocated:amun.CommandPlayback.instant_replay)
}

// optional string export_vision_log = 9;
inline bool CommandPlayback::_internal_has_export_vision_log() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandPlayback::has_export_vision_log() const {
  return _internal_has_export_vision_log();
}
inline void CommandPlayback::clear_export_vision_log() {
  export_vision_log_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandPlayback::export_vision_log() const {
  // @@protoc_insertion_point(field_get:amun.CommandPlayback.export_vision_log)
  return _internal_export_vision_log();
}
inline void CommandPlayback::set_export_vision_log(const std::string& value) {
  _internal_set_export_vision_log(value);
  // @@protoc_insertion_point(field_set:amun.CommandPlayback.export_vision_log)
}
inline std::string* CommandPlayback::mutable_export_vision_log() {
  // @@protoc_insertion_point(field_mutable:amun.CommandPlayback.export_vision_log)
  return _internal_mutable_export_vision_log();
}
inline const std::string& CommandPlayback::_internal_export_vision_log() const {
  return export_vision_log_.Get();
}
inline void CommandPlayback::_internal_set_export_vision_log(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  export_vision_log_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CommandPlayback::set_export_vision_log(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  export_vision_log_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:amun.CommandPlayback.export_vision_log)
}
inline void CommandPlayback::set_export_vision_log(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  export_vision_log_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:amun.CommandPlayback.export_vision_log)
}
inline void CommandPlayback::set_export_vision_log(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  export_vision_log_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:amun.CommandPlayback.export_vision_log)
}
inline std::string* CommandPlayback::_internal_mutable_export_vision_log() {
  _has_bits_[0] |= 0x00000001u;
  return export_vision_log_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CommandPlayback::release_export_vision_log() {
  // @@protoc_insertion_point(field_release:amun.CommandPlayback.export_vision_log)
  if (!_internal_has_export_vision_log()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return export_vision_log_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CommandPlayback::set_allocated_export_vision_log(std::string* export_vision_log) {
  if (export_vision_log != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  export_vision_log_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), export_vision_log,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:amun.CommandPlayback.export_vision_log)
}
inline std::string* CommandPlayback::unsafe_arena_release_export_vision_log() {
  // @@protoc_insertion_point(field_unsafe_arena_release:amun.CommandPlayback.export_vision_log)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return export_vision_log_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void CommandPlayback::unsafe_arena_set_allocated_export_vision_log(
    std::string* export_vision_log) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (export_vision_log != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  export_vision_log_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      export_vision_log, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.CommandPlayback.export_vision_log)
}

// optional .amun.Flag get_uid = 10;
inline bool CommandPlayback::_internal_has_get_uid() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || get_uid_ != nullptr);
  return value;
}
inline bool CommandPlayback::has_get_uid() const {
  return _internal_has_get_uid();
}
inline void CommandPlayback::clear_get_uid() {
  if (get_uid_ != nullptr) get_uid_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::amun::Flag& CommandPlayback::_internal_get_uid() const {
  const ::amun::Flag* p = get_uid_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::Flag*>(
      &::amun::_Flag_default_instance_);
}
inline const ::amun::Flag& CommandPlayback::get_uid() const {
  // @@protoc_insertion_point(field_get:amun.CommandPlayback.get_uid)
  return _internal_get_uid();
}
inline void CommandPlayback::unsafe_arena_set_allocated_get_uid(
    ::amun::Flag* get_uid) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(get_uid_);
  }
  get_uid_ = get_uid;
  if (get_uid) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.CommandPlayback.get_uid)
}
inline ::amun::Flag* CommandPlayback::release_get_uid() {
  auto temp = unsafe_arena_release_get_uid();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::Flag* CommandPlayback::unsafe_arena_release_get_uid() {
  // @@protoc_insertion_point(field_release:amun.CommandPlayback.get_uid)
  _has_bits_[0] &= ~0x00000020u;
  ::amun::Flag* temp = get_uid_;
  get_uid_ = nullptr;
  return temp;
}
inline ::amun::Flag* CommandPlayback::_internal_mutable_get_uid() {
  _has_bits_[0] |= 0x00000020u;
  if (get_uid_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::Flag>(GetArena());
    get_uid_ = p;
  }
  return get_uid_;
}
inline ::amun::Flag* CommandPlayback::mutable_get_uid() {
  // @@protoc_insertion_point(field_mutable:amun.CommandPlayback.get_uid)
  return _internal_mutable_get_uid();
}
inline void CommandPlayback::set_allocated_get_uid(::amun::Flag* get_uid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete get_uid_;
  }
  if (get_uid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(get_uid);
    if (message_arena != submessage_arena) {
      get_uid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, get_uid, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  get_uid_ = get_uid;
  // @@protoc_insertion_point(field_set_allocated:amun.CommandPlayback.get_uid)
}

// optional string find_logfile = 11;
inline bool CommandPlayback::_internal_has_find_logfile() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommandPlayback::has_find_logfile() const {
  return _internal_has_find_logfile();
}
inline void CommandPlayback::clear_find_logfile() {
  find_logfile_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommandPlayback::find_logfile() const {
  // @@protoc_insertion_point(field_get:amun.CommandPlayback.find_logfile)
  return _internal_find_logfile();
}
inline void CommandPlayback::set_find_logfile(const std::string& value) {
  _internal_set_find_logfile(value);
  // @@protoc_insertion_point(field_set:amun.CommandPlayback.find_logfile)
}
inline std::string* CommandPlayback::mutable_find_logfile() {
  // @@protoc_insertion_point(field_mutable:amun.CommandPlayback.find_logfile)
  return _internal_mutable_find_logfile();
}
inline const std::string& CommandPlayback::_internal_find_logfile() const {
  return find_logfile_.Get();
}
inline void CommandPlayback::_internal_set_find_logfile(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  find_logfile_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CommandPlayback::set_find_logfile(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  find_logfile_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:amun.CommandPlayback.find_logfile)
}
inline void CommandPlayback::set_find_logfile(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  find_logfile_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:amun.CommandPlayback.find_logfile)
}
inline void CommandPlayback::set_find_logfile(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  find_logfile_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:amun.CommandPlayback.find_logfile)
}
inline std::string* CommandPlayback::_internal_mutable_find_logfile() {
  _has_bits_[0] |= 0x00000002u;
  return find_logfile_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CommandPlayback::release_find_logfile() {
  // @@protoc_insertion_point(field_release:amun.CommandPlayback.find_logfile)
  if (!_internal_has_find_logfile()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return find_logfile_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CommandPlayback::set_allocated_find_logfile(std::string* find_logfile) {
  if (find_logfile != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  find_logfile_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), find_logfile,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:amun.CommandPlayback.find_logfile)
}
inline std::string* CommandPlayback::unsafe_arena_release_find_logfile() {
  // @@protoc_insertion_point(field_unsafe_arena_release:amun.CommandPlayback.find_logfile)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return find_logfile_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void CommandPlayback::unsafe_arena_set_allocated_find_logfile(
    std::string* find_logfile) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (find_logfile != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  find_logfile_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      find_logfile, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.CommandPlayback.find_logfile)
}

// optional int32 playback_limit = 12;
inline bool CommandPlayback::_internal_has_playback_limit() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool CommandPlayback::has_playback_limit() const {
  return _internal_has_playback_limit();
}
inline void CommandPlayback::clear_playback_limit() {
  playback_limit_ = 0;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CommandPlayback::_internal_playback_limit() const {
  return playback_limit_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CommandPlayback::playback_limit() const {
  // @@protoc_insertion_point(field_get:amun.CommandPlayback.playback_limit)
  return _internal_playback_limit();
}
inline void CommandPlayback::_internal_set_playback_limit(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000800u;
  playback_limit_ = value;
}
inline void CommandPlayback::set_playback_limit(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_playback_limit(value);
  // @@protoc_insertion_point(field_set:amun.CommandPlayback.playback_limit)
}

// -------------------------------------------------------------------

// CommandRecord

// optional bool use_logfile_location = 1;
inline bool CommandRecord::_internal_has_use_logfile_location() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CommandRecord::has_use_logfile_location() const {
  return _internal_has_use_logfile_location();
}
inline void CommandRecord::clear_use_logfile_location() {
  use_logfile_location_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool CommandRecord::_internal_use_logfile_location() const {
  return use_logfile_location_;
}
inline bool CommandRecord::use_logfile_location() const {
  // @@protoc_insertion_point(field_get:amun.CommandRecord.use_logfile_location)
  return _internal_use_logfile_location();
}
inline void CommandRecord::_internal_set_use_logfile_location(bool value) {
  _has_bits_[0] |= 0x00000004u;
  use_logfile_location_ = value;
}
inline void CommandRecord::set_use_logfile_location(bool value) {
  _internal_set_use_logfile_location(value);
  // @@protoc_insertion_point(field_set:amun.CommandRecord.use_logfile_location)
}

// optional .amun.Flag save_backlog = 2;
inline bool CommandRecord::_internal_has_save_backlog() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || save_backlog_ != nullptr);
  return value;
}
inline bool CommandRecord::has_save_backlog() const {
  return _internal_has_save_backlog();
}
inline void CommandRecord::clear_save_backlog() {
  if (save_backlog_ != nullptr) save_backlog_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::amun::Flag& CommandRecord::_internal_save_backlog() const {
  const ::amun::Flag* p = save_backlog_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::Flag*>(
      &::amun::_Flag_default_instance_);
}
inline const ::amun::Flag& CommandRecord::save_backlog() const {
  // @@protoc_insertion_point(field_get:amun.CommandRecord.save_backlog)
  return _internal_save_backlog();
}
inline void CommandRecord::unsafe_arena_set_allocated_save_backlog(
    ::amun::Flag* save_backlog) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(save_backlog_);
  }
  save_backlog_ = save_backlog;
  if (save_backlog) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.CommandRecord.save_backlog)
}
inline ::amun::Flag* CommandRecord::release_save_backlog() {
  auto temp = unsafe_arena_release_save_backlog();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::Flag* CommandRecord::unsafe_arena_release_save_backlog() {
  // @@protoc_insertion_point(field_release:amun.CommandRecord.save_backlog)
  _has_bits_[0] &= ~0x00000002u;
  ::amun::Flag* temp = save_backlog_;
  save_backlog_ = nullptr;
  return temp;
}
inline ::amun::Flag* CommandRecord::_internal_mutable_save_backlog() {
  _has_bits_[0] |= 0x00000002u;
  if (save_backlog_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::Flag>(GetArena());
    save_backlog_ = p;
  }
  return save_backlog_;
}
inline ::amun::Flag* CommandRecord::mutable_save_backlog() {
  // @@protoc_insertion_point(field_mutable:amun.CommandRecord.save_backlog)
  return _internal_mutable_save_backlog();
}
inline void CommandRecord::set_allocated_save_backlog(::amun::Flag* save_backlog) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete save_backlog_;
  }
  if (save_backlog) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(save_backlog);
    if (message_arena != submessage_arena) {
      save_backlog = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, save_backlog, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  save_backlog_ = save_backlog;
  // @@protoc_insertion_point(field_set_allocated:amun.CommandRecord.save_backlog)
}

// optional bool run_logging = 3;
inline bool CommandRecord::_internal_has_run_logging() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CommandRecord::has_run_logging() const {
  return _internal_has_run_logging();
}
inline void CommandRecord::clear_run_logging() {
  run_logging_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool CommandRecord::_internal_run_logging() const {
  return run_logging_;
}
inline bool CommandRecord::run_logging() const {
  // @@protoc_insertion_point(field_get:amun.CommandRecord.run_logging)
  return _internal_run_logging();
}
inline void CommandRecord::_internal_set_run_logging(bool value) {
  _has_bits_[0] |= 0x00000008u;
  run_logging_ = value;
}
inline void CommandRecord::set_run_logging(bool value) {
  _internal_set_run_logging(value);
  // @@protoc_insertion_point(field_set:amun.CommandRecord.run_logging)
}

// optional bool for_replay = 4;
inline bool CommandRecord::_internal_has_for_replay() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CommandRecord::has_for_replay() const {
  return _internal_has_for_replay();
}
inline void CommandRecord::clear_for_replay() {
  for_replay_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool CommandRecord::_internal_for_replay() const {
  return for_replay_;
}
inline bool CommandRecord::for_replay() const {
  // @@protoc_insertion_point(field_get:amun.CommandRecord.for_replay)
  return _internal_for_replay();
}
inline void CommandRecord::_internal_set_for_replay(bool value) {
  _has_bits_[0] |= 0x00000010u;
  for_replay_ = value;
}
inline void CommandRecord::set_for_replay(bool value) {
  _internal_set_for_replay(value);
  // @@protoc_insertion_point(field_set:amun.CommandRecord.for_replay)
}

// optional int32 request_backlog = 5;
inline bool CommandRecord::_internal_has_request_backlog() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CommandRecord::has_request_backlog() const {
  return _internal_has_request_backlog();
}
inline void CommandRecord::clear_request_backlog() {
  request_backlog_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CommandRecord::_internal_request_backlog() const {
  return request_backlog_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CommandRecord::request_backlog() const {
  // @@protoc_insertion_point(field_get:amun.CommandRecord.request_backlog)
  return _internal_request_backlog();
}
inline void CommandRecord::_internal_set_request_backlog(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  request_backlog_ = value;
}
inline void CommandRecord::set_request_backlog(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_request_backlog(value);
  // @@protoc_insertion_point(field_set:amun.CommandRecord.request_backlog)
}

// optional string overwrite_record_filename = 6;
inline bool CommandRecord::_internal_has_overwrite_record_filename() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommandRecord::has_overwrite_record_filename() const {
  return _internal_has_overwrite_record_filename();
}
inline void CommandRecord::clear_overwrite_record_filename() {
  overwrite_record_filename_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommandRecord::overwrite_record_filename() const {
  // @@protoc_insertion_point(field_get:amun.CommandRecord.overwrite_record_filename)
  return _internal_overwrite_record_filename();
}
inline void CommandRecord::set_overwrite_record_filename(const std::string& value) {
  _internal_set_overwrite_record_filename(value);
  // @@protoc_insertion_point(field_set:amun.CommandRecord.overwrite_record_filename)
}
inline std::string* CommandRecord::mutable_overwrite_record_filename() {
  // @@protoc_insertion_point(field_mutable:amun.CommandRecord.overwrite_record_filename)
  return _internal_mutable_overwrite_record_filename();
}
inline const std::string& CommandRecord::_internal_overwrite_record_filename() const {
  return overwrite_record_filename_.Get();
}
inline void CommandRecord::_internal_set_overwrite_record_filename(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  overwrite_record_filename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CommandRecord::set_overwrite_record_filename(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  overwrite_record_filename_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:amun.CommandRecord.overwrite_record_filename)
}
inline void CommandRecord::set_overwrite_record_filename(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  overwrite_record_filename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:amun.CommandRecord.overwrite_record_filename)
}
inline void CommandRecord::set_overwrite_record_filename(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  overwrite_record_filename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:amun.CommandRecord.overwrite_record_filename)
}
inline std::string* CommandRecord::_internal_mutable_overwrite_record_filename() {
  _has_bits_[0] |= 0x00000001u;
  return overwrite_record_filename_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CommandRecord::release_overwrite_record_filename() {
  // @@protoc_insertion_point(field_release:amun.CommandRecord.overwrite_record_filename)
  if (!_internal_has_overwrite_record_filename()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return overwrite_record_filename_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CommandRecord::set_allocated_overwrite_record_filename(std::string* overwrite_record_filename) {
  if (overwrite_record_filename != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  overwrite_record_filename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), overwrite_record_filename,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:amun.CommandRecord.overwrite_record_filename)
}
inline std::string* CommandRecord::unsafe_arena_release_overwrite_record_filename() {
  // @@protoc_insertion_point(field_unsafe_arena_release:amun.CommandRecord.overwrite_record_filename)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return overwrite_record_filename_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void CommandRecord::unsafe_arena_set_allocated_overwrite_record_filename(
    std::string* overwrite_record_filename) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (overwrite_record_filename != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  overwrite_record_filename_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      overwrite_record_filename, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.CommandRecord.overwrite_record_filename)
}

// -------------------------------------------------------------------

// Command

// optional .amun.CommandSimulator simulator = 1;
inline bool Command::_internal_has_simulator() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || simulator_ != nullptr);
  return value;
}
inline bool Command::has_simulator() const {
  return _internal_has_simulator();
}
inline void Command::clear_simulator() {
  if (simulator_ != nullptr) simulator_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::amun::CommandSimulator& Command::_internal_simulator() const {
  const ::amun::CommandSimulator* p = simulator_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::CommandSimulator*>(
      &::amun::_CommandSimulator_default_instance_);
}
inline const ::amun::CommandSimulator& Command::simulator() const {
  // @@protoc_insertion_point(field_get:amun.Command.simulator)
  return _internal_simulator();
}
inline void Command::unsafe_arena_set_allocated_simulator(
    ::amun::CommandSimulator* simulator) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(simulator_);
  }
  simulator_ = simulator;
  if (simulator) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.Command.simulator)
}
inline ::amun::CommandSimulator* Command::release_simulator() {
  auto temp = unsafe_arena_release_simulator();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::CommandSimulator* Command::unsafe_arena_release_simulator() {
  // @@protoc_insertion_point(field_release:amun.Command.simulator)
  _has_bits_[0] &= ~0x00000001u;
  ::amun::CommandSimulator* temp = simulator_;
  simulator_ = nullptr;
  return temp;
}
inline ::amun::CommandSimulator* Command::_internal_mutable_simulator() {
  _has_bits_[0] |= 0x00000001u;
  if (simulator_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::CommandSimulator>(GetArena());
    simulator_ = p;
  }
  return simulator_;
}
inline ::amun::CommandSimulator* Command::mutable_simulator() {
  // @@protoc_insertion_point(field_mutable:amun.Command.simulator)
  return _internal_mutable_simulator();
}
inline void Command::set_allocated_simulator(::amun::CommandSimulator* simulator) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete simulator_;
  }
  if (simulator) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(simulator);
    if (message_arena != submessage_arena) {
      simulator = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, simulator, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  simulator_ = simulator;
  // @@protoc_insertion_point(field_set_allocated:amun.Command.simulator)
}

// optional .amun.CommandReferee referee = 2;
inline bool Command::_internal_has_referee() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || referee_ != nullptr);
  return value;
}
inline bool Command::has_referee() const {
  return _internal_has_referee();
}
inline void Command::clear_referee() {
  if (referee_ != nullptr) referee_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::amun::CommandReferee& Command::_internal_referee() const {
  const ::amun::CommandReferee* p = referee_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::CommandReferee*>(
      &::amun::_CommandReferee_default_instance_);
}
inline const ::amun::CommandReferee& Command::referee() const {
  // @@protoc_insertion_point(field_get:amun.Command.referee)
  return _internal_referee();
}
inline void Command::unsafe_arena_set_allocated_referee(
    ::amun::CommandReferee* referee) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(referee_);
  }
  referee_ = referee;
  if (referee) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.Command.referee)
}
inline ::amun::CommandReferee* Command::release_referee() {
  auto temp = unsafe_arena_release_referee();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::CommandReferee* Command::unsafe_arena_release_referee() {
  // @@protoc_insertion_point(field_release:amun.Command.referee)
  _has_bits_[0] &= ~0x00000002u;
  ::amun::CommandReferee* temp = referee_;
  referee_ = nullptr;
  return temp;
}
inline ::amun::CommandReferee* Command::_internal_mutable_referee() {
  _has_bits_[0] |= 0x00000002u;
  if (referee_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::CommandReferee>(GetArena());
    referee_ = p;
  }
  return referee_;
}
inline ::amun::CommandReferee* Command::mutable_referee() {
  // @@protoc_insertion_point(field_mutable:amun.Command.referee)
  return _internal_mutable_referee();
}
inline void Command::set_allocated_referee(::amun::CommandReferee* referee) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete referee_;
  }
  if (referee) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(referee);
    if (message_arena != submessage_arena) {
      referee = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, referee, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  referee_ = referee;
  // @@protoc_insertion_point(field_set_allocated:amun.Command.referee)
}

// optional .robot.Team set_team_blue = 3;
inline bool Command::_internal_has_set_team_blue() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || set_team_blue_ != nullptr);
  return value;
}
inline bool Command::has_set_team_blue() const {
  return _internal_has_set_team_blue();
}
inline const ::robot::Team& Command::_internal_set_team_blue() const {
  const ::robot::Team* p = set_team_blue_;
  return p != nullptr ? *p : *reinterpret_cast<const ::robot::Team*>(
      &::robot::_Team_default_instance_);
}
inline const ::robot::Team& Command::set_team_blue() const {
  // @@protoc_insertion_point(field_get:amun.Command.set_team_blue)
  return _internal_set_team_blue();
}
inline void Command::unsafe_arena_set_allocated_set_team_blue(
    ::robot::Team* set_team_blue) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(set_team_blue_);
  }
  set_team_blue_ = set_team_blue;
  if (set_team_blue) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.Command.set_team_blue)
}
inline ::robot::Team* Command::release_set_team_blue() {
  auto temp = unsafe_arena_release_set_team_blue();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::robot::Team* Command::unsafe_arena_release_set_team_blue() {
  // @@protoc_insertion_point(field_release:amun.Command.set_team_blue)
  _has_bits_[0] &= ~0x00000004u;
  ::robot::Team* temp = set_team_blue_;
  set_team_blue_ = nullptr;
  return temp;
}
inline ::robot::Team* Command::_internal_mutable_set_team_blue() {
  _has_bits_[0] |= 0x00000004u;
  if (set_team_blue_ == nullptr) {
    auto* p = CreateMaybeMessage<::robot::Team>(GetArena());
    set_team_blue_ = p;
  }
  return set_team_blue_;
}
inline ::robot::Team* Command::mutable_set_team_blue() {
  // @@protoc_insertion_point(field_mutable:amun.Command.set_team_blue)
  return _internal_mutable_set_team_blue();
}
inline void Command::set_allocated_set_team_blue(::robot::Team* set_team_blue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(set_team_blue_);
  }
  if (set_team_blue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(set_team_blue)->GetArena();
    if (message_arena != submessage_arena) {
      set_team_blue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, set_team_blue, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  set_team_blue_ = set_team_blue;
  // @@protoc_insertion_point(field_set_allocated:amun.Command.set_team_blue)
}

// optional .robot.Team set_team_yellow = 4;
inline bool Command::_internal_has_set_team_yellow() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || set_team_yellow_ != nullptr);
  return value;
}
inline bool Command::has_set_team_yellow() const {
  return _internal_has_set_team_yellow();
}
inline const ::robot::Team& Command::_internal_set_team_yellow() const {
  const ::robot::Team* p = set_team_yellow_;
  return p != nullptr ? *p : *reinterpret_cast<const ::robot::Team*>(
      &::robot::_Team_default_instance_);
}
inline const ::robot::Team& Command::set_team_yellow() const {
  // @@protoc_insertion_point(field_get:amun.Command.set_team_yellow)
  return _internal_set_team_yellow();
}
inline void Command::unsafe_arena_set_allocated_set_team_yellow(
    ::robot::Team* set_team_yellow) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(set_team_yellow_);
  }
  set_team_yellow_ = set_team_yellow;
  if (set_team_yellow) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.Command.set_team_yellow)
}
inline ::robot::Team* Command::release_set_team_yellow() {
  auto temp = unsafe_arena_release_set_team_yellow();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::robot::Team* Command::unsafe_arena_release_set_team_yellow() {
  // @@protoc_insertion_point(field_release:amun.Command.set_team_yellow)
  _has_bits_[0] &= ~0x00000008u;
  ::robot::Team* temp = set_team_yellow_;
  set_team_yellow_ = nullptr;
  return temp;
}
inline ::robot::Team* Command::_internal_mutable_set_team_yellow() {
  _has_bits_[0] |= 0x00000008u;
  if (set_team_yellow_ == nullptr) {
    auto* p = CreateMaybeMessage<::robot::Team>(GetArena());
    set_team_yellow_ = p;
  }
  return set_team_yellow_;
}
inline ::robot::Team* Command::mutable_set_team_yellow() {
  // @@protoc_insertion_point(field_mutable:amun.Command.set_team_yellow)
  return _internal_mutable_set_team_yellow();
}
inline void Command::set_allocated_set_team_yellow(::robot::Team* set_team_yellow) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(set_team_yellow_);
  }
  if (set_team_yellow) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(set_team_yellow)->GetArena();
    if (message_arena != submessage_arena) {
      set_team_yellow = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, set_team_yellow, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  set_team_yellow_ = set_team_yellow;
  // @@protoc_insertion_point(field_set_allocated:amun.Command.set_team_yellow)
}

// optional .amun.CommandStrategy strategy_blue = 5;
inline bool Command::_internal_has_strategy_blue() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || strategy_blue_ != nullptr);
  return value;
}
inline bool Command::has_strategy_blue() const {
  return _internal_has_strategy_blue();
}
inline void Command::clear_strategy_blue() {
  if (strategy_blue_ != nullptr) strategy_blue_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::amun::CommandStrategy& Command::_internal_strategy_blue() const {
  const ::amun::CommandStrategy* p = strategy_blue_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::CommandStrategy*>(
      &::amun::_CommandStrategy_default_instance_);
}
inline const ::amun::CommandStrategy& Command::strategy_blue() const {
  // @@protoc_insertion_point(field_get:amun.Command.strategy_blue)
  return _internal_strategy_blue();
}
inline void Command::unsafe_arena_set_allocated_strategy_blue(
    ::amun::CommandStrategy* strategy_blue) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(strategy_blue_);
  }
  strategy_blue_ = strategy_blue;
  if (strategy_blue) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.Command.strategy_blue)
}
inline ::amun::CommandStrategy* Command::release_strategy_blue() {
  auto temp = unsafe_arena_release_strategy_blue();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::CommandStrategy* Command::unsafe_arena_release_strategy_blue() {
  // @@protoc_insertion_point(field_release:amun.Command.strategy_blue)
  _has_bits_[0] &= ~0x00000010u;
  ::amun::CommandStrategy* temp = strategy_blue_;
  strategy_blue_ = nullptr;
  return temp;
}
inline ::amun::CommandStrategy* Command::_internal_mutable_strategy_blue() {
  _has_bits_[0] |= 0x00000010u;
  if (strategy_blue_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::CommandStrategy>(GetArena());
    strategy_blue_ = p;
  }
  return strategy_blue_;
}
inline ::amun::CommandStrategy* Command::mutable_strategy_blue() {
  // @@protoc_insertion_point(field_mutable:amun.Command.strategy_blue)
  return _internal_mutable_strategy_blue();
}
inline void Command::set_allocated_strategy_blue(::amun::CommandStrategy* strategy_blue) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete strategy_blue_;
  }
  if (strategy_blue) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(strategy_blue);
    if (message_arena != submessage_arena) {
      strategy_blue = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, strategy_blue, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  strategy_blue_ = strategy_blue;
  // @@protoc_insertion_point(field_set_allocated:amun.Command.strategy_blue)
}

// optional .amun.CommandStrategy strategy_yellow = 6;
inline bool Command::_internal_has_strategy_yellow() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || strategy_yellow_ != nullptr);
  return value;
}
inline bool Command::has_strategy_yellow() const {
  return _internal_has_strategy_yellow();
}
inline void Command::clear_strategy_yellow() {
  if (strategy_yellow_ != nullptr) strategy_yellow_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::amun::CommandStrategy& Command::_internal_strategy_yellow() const {
  const ::amun::CommandStrategy* p = strategy_yellow_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::CommandStrategy*>(
      &::amun::_CommandStrategy_default_instance_);
}
inline const ::amun::CommandStrategy& Command::strategy_yellow() const {
  // @@protoc_insertion_point(field_get:amun.Command.strategy_yellow)
  return _internal_strategy_yellow();
}
inline void Command::unsafe_arena_set_allocated_strategy_yellow(
    ::amun::CommandStrategy* strategy_yellow) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(strategy_yellow_);
  }
  strategy_yellow_ = strategy_yellow;
  if (strategy_yellow) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.Command.strategy_yellow)
}
inline ::amun::CommandStrategy* Command::release_strategy_yellow() {
  auto temp = unsafe_arena_release_strategy_yellow();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::CommandStrategy* Command::unsafe_arena_release_strategy_yellow() {
  // @@protoc_insertion_point(field_release:amun.Command.strategy_yellow)
  _has_bits_[0] &= ~0x00000020u;
  ::amun::CommandStrategy* temp = strategy_yellow_;
  strategy_yellow_ = nullptr;
  return temp;
}
inline ::amun::CommandStrategy* Command::_internal_mutable_strategy_yellow() {
  _has_bits_[0] |= 0x00000020u;
  if (strategy_yellow_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::CommandStrategy>(GetArena());
    strategy_yellow_ = p;
  }
  return strategy_yellow_;
}
inline ::amun::CommandStrategy* Command::mutable_strategy_yellow() {
  // @@protoc_insertion_point(field_mutable:amun.Command.strategy_yellow)
  return _internal_mutable_strategy_yellow();
}
inline void Command::set_allocated_strategy_yellow(::amun::CommandStrategy* strategy_yellow) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete strategy_yellow_;
  }
  if (strategy_yellow) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(strategy_yellow);
    if (message_arena != submessage_arena) {
      strategy_yellow = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, strategy_yellow, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  strategy_yellow_ = strategy_yellow;
  // @@protoc_insertion_point(field_set_allocated:amun.Command.strategy_yellow)
}

// optional .amun.CommandStrategy strategy_autoref = 7;
inline bool Command::_internal_has_strategy_autoref() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || strategy_autoref_ != nullptr);
  return value;
}
inline bool Command::has_strategy_autoref() const {
  return _internal_has_strategy_autoref();
}
inline void Command::clear_strategy_autoref() {
  if (strategy_autoref_ != nullptr) strategy_autoref_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::amun::CommandStrategy& Command::_internal_strategy_autoref() const {
  const ::amun::CommandStrategy* p = strategy_autoref_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::CommandStrategy*>(
      &::amun::_CommandStrategy_default_instance_);
}
inline const ::amun::CommandStrategy& Command::strategy_autoref() const {
  // @@protoc_insertion_point(field_get:amun.Command.strategy_autoref)
  return _internal_strategy_autoref();
}
inline void Command::unsafe_arena_set_allocated_strategy_autoref(
    ::amun::CommandStrategy* strategy_autoref) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(strategy_autoref_);
  }
  strategy_autoref_ = strategy_autoref;
  if (strategy_autoref) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.Command.strategy_autoref)
}
inline ::amun::CommandStrategy* Command::release_strategy_autoref() {
  auto temp = unsafe_arena_release_strategy_autoref();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::CommandStrategy* Command::unsafe_arena_release_strategy_autoref() {
  // @@protoc_insertion_point(field_release:amun.Command.strategy_autoref)
  _has_bits_[0] &= ~0x00000040u;
  ::amun::CommandStrategy* temp = strategy_autoref_;
  strategy_autoref_ = nullptr;
  return temp;
}
inline ::amun::CommandStrategy* Command::_internal_mutable_strategy_autoref() {
  _has_bits_[0] |= 0x00000040u;
  if (strategy_autoref_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::CommandStrategy>(GetArena());
    strategy_autoref_ = p;
  }
  return strategy_autoref_;
}
inline ::amun::CommandStrategy* Command::mutable_strategy_autoref() {
  // @@protoc_insertion_point(field_mutable:amun.Command.strategy_autoref)
  return _internal_mutable_strategy_autoref();
}
inline void Command::set_allocated_strategy_autoref(::amun::CommandStrategy* strategy_autoref) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete strategy_autoref_;
  }
  if (strategy_autoref) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(strategy_autoref);
    if (message_arena != submessage_arena) {
      strategy_autoref = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, strategy_autoref, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  strategy_autoref_ = strategy_autoref;
  // @@protoc_insertion_point(field_set_allocated:amun.Command.strategy_autoref)
}

// optional .amun.CommandControl control = 8;
inline bool Command::_internal_has_control() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || control_ != nullptr);
  return value;
}
inline bool Command::has_control() const {
  return _internal_has_control();
}
inline void Command::clear_control() {
  if (control_ != nullptr) control_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::amun::CommandControl& Command::_internal_control() const {
  const ::amun::CommandControl* p = control_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::CommandControl*>(
      &::amun::_CommandControl_default_instance_);
}
inline const ::amun::CommandControl& Command::control() const {
  // @@protoc_insertion_point(field_get:amun.Command.control)
  return _internal_control();
}
inline void Command::unsafe_arena_set_allocated_control(
    ::amun::CommandControl* control) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(control_);
  }
  control_ = control;
  if (control) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.Command.control)
}
inline ::amun::CommandControl* Command::release_control() {
  auto temp = unsafe_arena_release_control();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::CommandControl* Command::unsafe_arena_release_control() {
  // @@protoc_insertion_point(field_release:amun.Command.control)
  _has_bits_[0] &= ~0x00000080u;
  ::amun::CommandControl* temp = control_;
  control_ = nullptr;
  return temp;
}
inline ::amun::CommandControl* Command::_internal_mutable_control() {
  _has_bits_[0] |= 0x00000080u;
  if (control_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::CommandControl>(GetArena());
    control_ = p;
  }
  return control_;
}
inline ::amun::CommandControl* Command::mutable_control() {
  // @@protoc_insertion_point(field_mutable:amun.Command.control)
  return _internal_mutable_control();
}
inline void Command::set_allocated_control(::amun::CommandControl* control) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete control_;
  }
  if (control) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(control);
    if (message_arena != submessage_arena) {
      control = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, control, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  control_ = control;
  // @@protoc_insertion_point(field_set_allocated:amun.Command.control)
}

// optional .amun.CommandTransceiver transceiver = 9;
inline bool Command::_internal_has_transceiver() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || transceiver_ != nullptr);
  return value;
}
inline bool Command::has_transceiver() const {
  return _internal_has_transceiver();
}
inline void Command::clear_transceiver() {
  if (transceiver_ != nullptr) transceiver_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::amun::CommandTransceiver& Command::_internal_transceiver() const {
  const ::amun::CommandTransceiver* p = transceiver_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::CommandTransceiver*>(
      &::amun::_CommandTransceiver_default_instance_);
}
inline const ::amun::CommandTransceiver& Command::transceiver() const {
  // @@protoc_insertion_point(field_get:amun.Command.transceiver)
  return _internal_transceiver();
}
inline void Command::unsafe_arena_set_allocated_transceiver(
    ::amun::CommandTransceiver* transceiver) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transceiver_);
  }
  transceiver_ = transceiver;
  if (transceiver) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.Command.transceiver)
}
inline ::amun::CommandTransceiver* Command::release_transceiver() {
  auto temp = unsafe_arena_release_transceiver();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::CommandTransceiver* Command::unsafe_arena_release_transceiver() {
  // @@protoc_insertion_point(field_release:amun.Command.transceiver)
  _has_bits_[0] &= ~0x00000100u;
  ::amun::CommandTransceiver* temp = transceiver_;
  transceiver_ = nullptr;
  return temp;
}
inline ::amun::CommandTransceiver* Command::_internal_mutable_transceiver() {
  _has_bits_[0] |= 0x00000100u;
  if (transceiver_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::CommandTransceiver>(GetArena());
    transceiver_ = p;
  }
  return transceiver_;
}
inline ::amun::CommandTransceiver* Command::mutable_transceiver() {
  // @@protoc_insertion_point(field_mutable:amun.Command.transceiver)
  return _internal_mutable_transceiver();
}
inline void Command::set_allocated_transceiver(::amun::CommandTransceiver* transceiver) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete transceiver_;
  }
  if (transceiver) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(transceiver);
    if (message_arena != submessage_arena) {
      transceiver = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transceiver, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  transceiver_ = transceiver;
  // @@protoc_insertion_point(field_set_allocated:amun.Command.transceiver)
}

// optional .amun.CommandTracking tracking = 11;
inline bool Command::_internal_has_tracking() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || tracking_ != nullptr);
  return value;
}
inline bool Command::has_tracking() const {
  return _internal_has_tracking();
}
inline void Command::clear_tracking() {
  if (tracking_ != nullptr) tracking_->Clear();
  _has_bits_[0] &= ~0x00000200u;
}
inline const ::amun::CommandTracking& Command::_internal_tracking() const {
  const ::amun::CommandTracking* p = tracking_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::CommandTracking*>(
      &::amun::_CommandTracking_default_instance_);
}
inline const ::amun::CommandTracking& Command::tracking() const {
  // @@protoc_insertion_point(field_get:amun.Command.tracking)
  return _internal_tracking();
}
inline void Command::unsafe_arena_set_allocated_tracking(
    ::amun::CommandTracking* tracking) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tracking_);
  }
  tracking_ = tracking;
  if (tracking) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.Command.tracking)
}
inline ::amun::CommandTracking* Command::release_tracking() {
  auto temp = unsafe_arena_release_tracking();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::CommandTracking* Command::unsafe_arena_release_tracking() {
  // @@protoc_insertion_point(field_release:amun.Command.tracking)
  _has_bits_[0] &= ~0x00000200u;
  ::amun::CommandTracking* temp = tracking_;
  tracking_ = nullptr;
  return temp;
}
inline ::amun::CommandTracking* Command::_internal_mutable_tracking() {
  _has_bits_[0] |= 0x00000200u;
  if (tracking_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::CommandTracking>(GetArena());
    tracking_ = p;
  }
  return tracking_;
}
inline ::amun::CommandTracking* Command::mutable_tracking() {
  // @@protoc_insertion_point(field_mutable:amun.Command.tracking)
  return _internal_mutable_tracking();
}
inline void Command::set_allocated_tracking(::amun::CommandTracking* tracking) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete tracking_;
  }
  if (tracking) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(tracking);
    if (message_arena != submessage_arena) {
      tracking = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tracking, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  tracking_ = tracking;
  // @@protoc_insertion_point(field_set_allocated:amun.Command.tracking)
}

// optional .amun.CommandAmun amun = 12;
inline bool Command::_internal_has_amun() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || amun_ != nullptr);
  return value;
}
inline bool Command::has_amun() const {
  return _internal_has_amun();
}
inline void Command::clear_amun() {
  if (amun_ != nullptr) amun_->Clear();
  _has_bits_[0] &= ~0x00000400u;
}
inline const ::amun::CommandAmun& Command::_internal_amun() const {
  const ::amun::CommandAmun* p = amun_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::CommandAmun*>(
      &::amun::_CommandAmun_default_instance_);
}
inline const ::amun::CommandAmun& Command::amun() const {
  // @@protoc_insertion_point(field_get:amun.Command.amun)
  return _internal_amun();
}
inline void Command::unsafe_arena_set_allocated_amun(
    ::amun::CommandAmun* amun) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(amun_);
  }
  amun_ = amun;
  if (amun) {
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.Command.amun)
}
inline ::amun::CommandAmun* Command::release_amun() {
  auto temp = unsafe_arena_release_amun();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::CommandAmun* Command::unsafe_arena_release_amun() {
  // @@protoc_insertion_point(field_release:amun.Command.amun)
  _has_bits_[0] &= ~0x00000400u;
  ::amun::CommandAmun* temp = amun_;
  amun_ = nullptr;
  return temp;
}
inline ::amun::CommandAmun* Command::_internal_mutable_amun() {
  _has_bits_[0] |= 0x00000400u;
  if (amun_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::CommandAmun>(GetArena());
    amun_ = p;
  }
  return amun_;
}
inline ::amun::CommandAmun* Command::mutable_amun() {
  // @@protoc_insertion_point(field_mutable:amun.Command.amun)
  return _internal_mutable_amun();
}
inline void Command::set_allocated_amun(::amun::CommandAmun* amun) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete amun_;
  }
  if (amun) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(amun);
    if (message_arena != submessage_arena) {
      amun = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, amun, submessage_arena);
    }
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  amun_ = amun;
  // @@protoc_insertion_point(field_set_allocated:amun.Command.amun)
}

// optional .amun.HostAddress mixed_team_destination = 13;
inline bool Command::_internal_has_mixed_team_destination() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || mixed_team_destination_ != nullptr);
  return value;
}
inline bool Command::has_mixed_team_destination() const {
  return _internal_has_mixed_team_destination();
}
inline void Command::clear_mixed_team_destination() {
  if (mixed_team_destination_ != nullptr) mixed_team_destination_->Clear();
  _has_bits_[0] &= ~0x00000800u;
}
inline const ::amun::HostAddress& Command::_internal_mixed_team_destination() const {
  const ::amun::HostAddress* p = mixed_team_destination_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::HostAddress*>(
      &::amun::_HostAddress_default_instance_);
}
inline const ::amun::HostAddress& Command::mixed_team_destination() const {
  // @@protoc_insertion_point(field_get:amun.Command.mixed_team_destination)
  return _internal_mixed_team_destination();
}
inline void Command::unsafe_arena_set_allocated_mixed_team_destination(
    ::amun::HostAddress* mixed_team_destination) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mixed_team_destination_);
  }
  mixed_team_destination_ = mixed_team_destination;
  if (mixed_team_destination) {
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.Command.mixed_team_destination)
}
inline ::amun::HostAddress* Command::release_mixed_team_destination() {
  auto temp = unsafe_arena_release_mixed_team_destination();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::HostAddress* Command::unsafe_arena_release_mixed_team_destination() {
  // @@protoc_insertion_point(field_release:amun.Command.mixed_team_destination)
  _has_bits_[0] &= ~0x00000800u;
  ::amun::HostAddress* temp = mixed_team_destination_;
  mixed_team_destination_ = nullptr;
  return temp;
}
inline ::amun::HostAddress* Command::_internal_mutable_mixed_team_destination() {
  _has_bits_[0] |= 0x00000800u;
  if (mixed_team_destination_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::HostAddress>(GetArena());
    mixed_team_destination_ = p;
  }
  return mixed_team_destination_;
}
inline ::amun::HostAddress* Command::mutable_mixed_team_destination() {
  // @@protoc_insertion_point(field_mutable:amun.Command.mixed_team_destination)
  return _internal_mutable_mixed_team_destination();
}
inline void Command::set_allocated_mixed_team_destination(::amun::HostAddress* mixed_team_destination) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete mixed_team_destination_;
  }
  if (mixed_team_destination) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(mixed_team_destination);
    if (message_arena != submessage_arena) {
      mixed_team_destination = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mixed_team_destination, submessage_arena);
    }
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  mixed_team_destination_ = mixed_team_destination;
  // @@protoc_insertion_point(field_set_allocated:amun.Command.mixed_team_destination)
}

// repeated .amun.RobotMoveCommand robot_move_blue = 14;
inline int Command::_internal_robot_move_blue_size() const {
  return robot_move_blue_.size();
}
inline int Command::robot_move_blue_size() const {
  return _internal_robot_move_blue_size();
}
inline void Command::clear_robot_move_blue() {
  robot_move_blue_.Clear();
}
inline ::amun::RobotMoveCommand* Command::mutable_robot_move_blue(int index) {
  // @@protoc_insertion_point(field_mutable:amun.Command.robot_move_blue)
  return robot_move_blue_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::amun::RobotMoveCommand >*
Command::mutable_robot_move_blue() {
  // @@protoc_insertion_point(field_mutable_list:amun.Command.robot_move_blue)
  return &robot_move_blue_;
}
inline const ::amun::RobotMoveCommand& Command::_internal_robot_move_blue(int index) const {
  return robot_move_blue_.Get(index);
}
inline const ::amun::RobotMoveCommand& Command::robot_move_blue(int index) const {
  // @@protoc_insertion_point(field_get:amun.Command.robot_move_blue)
  return _internal_robot_move_blue(index);
}
inline ::amun::RobotMoveCommand* Command::_internal_add_robot_move_blue() {
  return robot_move_blue_.Add();
}
inline ::amun::RobotMoveCommand* Command::add_robot_move_blue() {
  // @@protoc_insertion_point(field_add:amun.Command.robot_move_blue)
  return _internal_add_robot_move_blue();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::amun::RobotMoveCommand >&
Command::robot_move_blue() const {
  // @@protoc_insertion_point(field_list:amun.Command.robot_move_blue)
  return robot_move_blue_;
}

// repeated .amun.RobotMoveCommand robot_move_yellow = 15;
inline int Command::_internal_robot_move_yellow_size() const {
  return robot_move_yellow_.size();
}
inline int Command::robot_move_yellow_size() const {
  return _internal_robot_move_yellow_size();
}
inline void Command::clear_robot_move_yellow() {
  robot_move_yellow_.Clear();
}
inline ::amun::RobotMoveCommand* Command::mutable_robot_move_yellow(int index) {
  // @@protoc_insertion_point(field_mutable:amun.Command.robot_move_yellow)
  return robot_move_yellow_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::amun::RobotMoveCommand >*
Command::mutable_robot_move_yellow() {
  // @@protoc_insertion_point(field_mutable_list:amun.Command.robot_move_yellow)
  return &robot_move_yellow_;
}
inline const ::amun::RobotMoveCommand& Command::_internal_robot_move_yellow(int index) const {
  return robot_move_yellow_.Get(index);
}
inline const ::amun::RobotMoveCommand& Command::robot_move_yellow(int index) const {
  // @@protoc_insertion_point(field_get:amun.Command.robot_move_yellow)
  return _internal_robot_move_yellow(index);
}
inline ::amun::RobotMoveCommand* Command::_internal_add_robot_move_yellow() {
  return robot_move_yellow_.Add();
}
inline ::amun::RobotMoveCommand* Command::add_robot_move_yellow() {
  // @@protoc_insertion_point(field_add:amun.Command.robot_move_yellow)
  return _internal_add_robot_move_yellow();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::amun::RobotMoveCommand >&
Command::robot_move_yellow() const {
  // @@protoc_insertion_point(field_list:amun.Command.robot_move_yellow)
  return robot_move_yellow_;
}

// optional .amun.CommandDebuggerInput debugger_input = 16;
inline bool Command::_internal_has_debugger_input() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || debugger_input_ != nullptr);
  return value;
}
inline bool Command::has_debugger_input() const {
  return _internal_has_debugger_input();
}
inline void Command::clear_debugger_input() {
  if (debugger_input_ != nullptr) debugger_input_->Clear();
  _has_bits_[0] &= ~0x00001000u;
}
inline const ::amun::CommandDebuggerInput& Command::_internal_debugger_input() const {
  const ::amun::CommandDebuggerInput* p = debugger_input_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::CommandDebuggerInput*>(
      &::amun::_CommandDebuggerInput_default_instance_);
}
inline const ::amun::CommandDebuggerInput& Command::debugger_input() const {
  // @@protoc_insertion_point(field_get:amun.Command.debugger_input)
  return _internal_debugger_input();
}
inline void Command::unsafe_arena_set_allocated_debugger_input(
    ::amun::CommandDebuggerInput* debugger_input) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(debugger_input_);
  }
  debugger_input_ = debugger_input;
  if (debugger_input) {
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.Command.debugger_input)
}
inline ::amun::CommandDebuggerInput* Command::release_debugger_input() {
  auto temp = unsafe_arena_release_debugger_input();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::CommandDebuggerInput* Command::unsafe_arena_release_debugger_input() {
  // @@protoc_insertion_point(field_release:amun.Command.debugger_input)
  _has_bits_[0] &= ~0x00001000u;
  ::amun::CommandDebuggerInput* temp = debugger_input_;
  debugger_input_ = nullptr;
  return temp;
}
inline ::amun::CommandDebuggerInput* Command::_internal_mutable_debugger_input() {
  _has_bits_[0] |= 0x00001000u;
  if (debugger_input_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::CommandDebuggerInput>(GetArena());
    debugger_input_ = p;
  }
  return debugger_input_;
}
inline ::amun::CommandDebuggerInput* Command::mutable_debugger_input() {
  // @@protoc_insertion_point(field_mutable:amun.Command.debugger_input)
  return _internal_mutable_debugger_input();
}
inline void Command::set_allocated_debugger_input(::amun::CommandDebuggerInput* debugger_input) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete debugger_input_;
  }
  if (debugger_input) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(debugger_input);
    if (message_arena != submessage_arena) {
      debugger_input = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, debugger_input, submessage_arena);
    }
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  debugger_input_ = debugger_input;
  // @@protoc_insertion_point(field_set_allocated:amun.Command.debugger_input)
}

// optional .amun.PauseSimulatorCommand pause_simulator = 17;
inline bool Command::_internal_has_pause_simulator() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || pause_simulator_ != nullptr);
  return value;
}
inline bool Command::has_pause_simulator() const {
  return _internal_has_pause_simulator();
}
inline void Command::clear_pause_simulator() {
  if (pause_simulator_ != nullptr) pause_simulator_->Clear();
  _has_bits_[0] &= ~0x00002000u;
}
inline const ::amun::PauseSimulatorCommand& Command::_internal_pause_simulator() const {
  const ::amun::PauseSimulatorCommand* p = pause_simulator_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::PauseSimulatorCommand*>(
      &::amun::_PauseSimulatorCommand_default_instance_);
}
inline const ::amun::PauseSimulatorCommand& Command::pause_simulator() const {
  // @@protoc_insertion_point(field_get:amun.Command.pause_simulator)
  return _internal_pause_simulator();
}
inline void Command::unsafe_arena_set_allocated_pause_simulator(
    ::amun::PauseSimulatorCommand* pause_simulator) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pause_simulator_);
  }
  pause_simulator_ = pause_simulator;
  if (pause_simulator) {
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.Command.pause_simulator)
}
inline ::amun::PauseSimulatorCommand* Command::release_pause_simulator() {
  auto temp = unsafe_arena_release_pause_simulator();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::PauseSimulatorCommand* Command::unsafe_arena_release_pause_simulator() {
  // @@protoc_insertion_point(field_release:amun.Command.pause_simulator)
  _has_bits_[0] &= ~0x00002000u;
  ::amun::PauseSimulatorCommand* temp = pause_simulator_;
  pause_simulator_ = nullptr;
  return temp;
}
inline ::amun::PauseSimulatorCommand* Command::_internal_mutable_pause_simulator() {
  _has_bits_[0] |= 0x00002000u;
  if (pause_simulator_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::PauseSimulatorCommand>(GetArena());
    pause_simulator_ = p;
  }
  return pause_simulator_;
}
inline ::amun::PauseSimulatorCommand* Command::mutable_pause_simulator() {
  // @@protoc_insertion_point(field_mutable:amun.Command.pause_simulator)
  return _internal_mutable_pause_simulator();
}
inline void Command::set_allocated_pause_simulator(::amun::PauseSimulatorCommand* pause_simulator) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete pause_simulator_;
  }
  if (pause_simulator) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(pause_simulator);
    if (message_arena != submessage_arena) {
      pause_simulator = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pause_simulator, submessage_arena);
    }
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  pause_simulator_ = pause_simulator;
  // @@protoc_insertion_point(field_set_allocated:amun.Command.pause_simulator)
}

// optional .amun.CommandReplay replay = 18;
inline bool Command::_internal_has_replay() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!value || replay_ != nullptr);
  return value;
}
inline bool Command::has_replay() const {
  return _internal_has_replay();
}
inline void Command::clear_replay() {
  if (replay_ != nullptr) replay_->Clear();
  _has_bits_[0] &= ~0x00004000u;
}
inline const ::amun::CommandReplay& Command::_internal_replay() const {
  const ::amun::CommandReplay* p = replay_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::CommandReplay*>(
      &::amun::_CommandReplay_default_instance_);
}
inline const ::amun::CommandReplay& Command::replay() const {
  // @@protoc_insertion_point(field_get:amun.Command.replay)
  return _internal_replay();
}
inline void Command::unsafe_arena_set_allocated_replay(
    ::amun::CommandReplay* replay) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(replay_);
  }
  replay_ = replay;
  if (replay) {
    _has_bits_[0] |= 0x00004000u;
  } else {
    _has_bits_[0] &= ~0x00004000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.Command.replay)
}
inline ::amun::CommandReplay* Command::release_replay() {
  auto temp = unsafe_arena_release_replay();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::CommandReplay* Command::unsafe_arena_release_replay() {
  // @@protoc_insertion_point(field_release:amun.Command.replay)
  _has_bits_[0] &= ~0x00004000u;
  ::amun::CommandReplay* temp = replay_;
  replay_ = nullptr;
  return temp;
}
inline ::amun::CommandReplay* Command::_internal_mutable_replay() {
  _has_bits_[0] |= 0x00004000u;
  if (replay_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::CommandReplay>(GetArena());
    replay_ = p;
  }
  return replay_;
}
inline ::amun::CommandReplay* Command::mutable_replay() {
  // @@protoc_insertion_point(field_mutable:amun.Command.replay)
  return _internal_mutable_replay();
}
inline void Command::set_allocated_replay(::amun::CommandReplay* replay) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete replay_;
  }
  if (replay) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(replay);
    if (message_arena != submessage_arena) {
      replay = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, replay, submessage_arena);
    }
    _has_bits_[0] |= 0x00004000u;
  } else {
    _has_bits_[0] &= ~0x00004000u;
  }
  replay_ = replay;
  // @@protoc_insertion_point(field_set_allocated:amun.Command.replay)
}

// optional .amun.CommandPlayback playback = 19;
inline bool Command::_internal_has_playback() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  PROTOBUF_ASSUME(!value || playback_ != nullptr);
  return value;
}
inline bool Command::has_playback() const {
  return _internal_has_playback();
}
inline void Command::clear_playback() {
  if (playback_ != nullptr) playback_->Clear();
  _has_bits_[0] &= ~0x00008000u;
}
inline const ::amun::CommandPlayback& Command::_internal_playback() const {
  const ::amun::CommandPlayback* p = playback_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::CommandPlayback*>(
      &::amun::_CommandPlayback_default_instance_);
}
inline const ::amun::CommandPlayback& Command::playback() const {
  // @@protoc_insertion_point(field_get:amun.Command.playback)
  return _internal_playback();
}
inline void Command::unsafe_arena_set_allocated_playback(
    ::amun::CommandPlayback* playback) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(playback_);
  }
  playback_ = playback;
  if (playback) {
    _has_bits_[0] |= 0x00008000u;
  } else {
    _has_bits_[0] &= ~0x00008000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.Command.playback)
}
inline ::amun::CommandPlayback* Command::release_playback() {
  auto temp = unsafe_arena_release_playback();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::CommandPlayback* Command::unsafe_arena_release_playback() {
  // @@protoc_insertion_point(field_release:amun.Command.playback)
  _has_bits_[0] &= ~0x00008000u;
  ::amun::CommandPlayback* temp = playback_;
  playback_ = nullptr;
  return temp;
}
inline ::amun::CommandPlayback* Command::_internal_mutable_playback() {
  _has_bits_[0] |= 0x00008000u;
  if (playback_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::CommandPlayback>(GetArena());
    playback_ = p;
  }
  return playback_;
}
inline ::amun::CommandPlayback* Command::mutable_playback() {
  // @@protoc_insertion_point(field_mutable:amun.Command.playback)
  return _internal_mutable_playback();
}
inline void Command::set_allocated_playback(::amun::CommandPlayback* playback) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete playback_;
  }
  if (playback) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(playback);
    if (message_arena != submessage_arena) {
      playback = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, playback, submessage_arena);
    }
    _has_bits_[0] |= 0x00008000u;
  } else {
    _has_bits_[0] &= ~0x00008000u;
  }
  playback_ = playback;
  // @@protoc_insertion_point(field_set_allocated:amun.Command.playback)
}

// optional .amun.CommandRecord record = 20;
inline bool Command::_internal_has_record() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  PROTOBUF_ASSUME(!value || record_ != nullptr);
  return value;
}
inline bool Command::has_record() const {
  return _internal_has_record();
}
inline void Command::clear_record() {
  if (record_ != nullptr) record_->Clear();
  _has_bits_[0] &= ~0x00010000u;
}
inline const ::amun::CommandRecord& Command::_internal_record() const {
  const ::amun::CommandRecord* p = record_;
  return p != nullptr ? *p : *reinterpret_cast<const ::amun::CommandRecord*>(
      &::amun::_CommandRecord_default_instance_);
}
inline const ::amun::CommandRecord& Command::record() const {
  // @@protoc_insertion_point(field_get:amun.Command.record)
  return _internal_record();
}
inline void Command::unsafe_arena_set_allocated_record(
    ::amun::CommandRecord* record) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(record_);
  }
  record_ = record;
  if (record) {
    _has_bits_[0] |= 0x00010000u;
  } else {
    _has_bits_[0] &= ~0x00010000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:amun.Command.record)
}
inline ::amun::CommandRecord* Command::release_record() {
  auto temp = unsafe_arena_release_record();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::amun::CommandRecord* Command::unsafe_arena_release_record() {
  // @@protoc_insertion_point(field_release:amun.Command.record)
  _has_bits_[0] &= ~0x00010000u;
  ::amun::CommandRecord* temp = record_;
  record_ = nullptr;
  return temp;
}
inline ::amun::CommandRecord* Command::_internal_mutable_record() {
  _has_bits_[0] |= 0x00010000u;
  if (record_ == nullptr) {
    auto* p = CreateMaybeMessage<::amun::CommandRecord>(GetArena());
    record_ = p;
  }
  return record_;
}
inline ::amun::CommandRecord* Command::mutable_record() {
  // @@protoc_insertion_point(field_mutable:amun.Command.record)
  return _internal_mutable_record();
}
inline void Command::set_allocated_record(::amun::CommandRecord* record) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete record_;
  }
  if (record) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(record);
    if (message_arena != submessage_arena) {
      record = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, record, submessage_arena);
    }
    _has_bits_[0] |= 0x00010000u;
  } else {
    _has_bits_[0] &= ~0x00010000u;
  }
  record_ = record;
  // @@protoc_insertion_point(field_set_allocated:amun.Command.record)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace amun

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::amun::DebuggerInputTarget> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::amun::DebuggerInputTarget>() {
  return ::amun::DebuggerInputTarget_descriptor();
}
template <> struct is_proto_enum< ::amun::PauseSimulatorReason> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::amun::PauseSimulatorReason>() {
  return ::amun::PauseSimulatorReason_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_command_2eproto
