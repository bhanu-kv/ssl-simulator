// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: world.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_world_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_world_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "robot.pb.h"
#include "ssl_mixed_team.pb.h"
#include "ssl_wrapper.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_world_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_world_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[13]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_world_2eproto;
namespace world {
class Ball;
class BallDefaultTypeInternal;
extern BallDefaultTypeInternal _Ball_default_instance_;
class BallModel;
class BallModelDefaultTypeInternal;
extern BallModelDefaultTypeInternal _BallModel_default_instance_;
class BallPosition;
class BallPositionDefaultTypeInternal;
extern BallPositionDefaultTypeInternal _BallPosition_default_instance_;
class DivisionDimensions;
class DivisionDimensionsDefaultTypeInternal;
extern DivisionDimensionsDefaultTypeInternal _DivisionDimensions_default_instance_;
class Geometry;
class GeometryDefaultTypeInternal;
extern GeometryDefaultTypeInternal _Geometry_default_instance_;
class Quaternion;
class QuaternionDefaultTypeInternal;
extern QuaternionDefaultTypeInternal _Quaternion_default_instance_;
class Robot;
class RobotDefaultTypeInternal;
extern RobotDefaultTypeInternal _Robot_default_instance_;
class RobotPosition;
class RobotPositionDefaultTypeInternal;
extern RobotPositionDefaultTypeInternal _RobotPosition_default_instance_;
class SimBall;
class SimBallDefaultTypeInternal;
extern SimBallDefaultTypeInternal _SimBall_default_instance_;
class SimRobot;
class SimRobotDefaultTypeInternal;
extern SimRobotDefaultTypeInternal _SimRobot_default_instance_;
class SimulatorState;
class SimulatorStateDefaultTypeInternal;
extern SimulatorStateDefaultTypeInternal _SimulatorState_default_instance_;
class State;
class StateDefaultTypeInternal;
extern StateDefaultTypeInternal _State_default_instance_;
class TrackingAOI;
class TrackingAOIDefaultTypeInternal;
extern TrackingAOIDefaultTypeInternal _TrackingAOI_default_instance_;
}  // namespace world
PROTOBUF_NAMESPACE_OPEN
template<> ::world::Ball* Arena::CreateMaybeMessage<::world::Ball>(Arena*);
template<> ::world::BallModel* Arena::CreateMaybeMessage<::world::BallModel>(Arena*);
template<> ::world::BallPosition* Arena::CreateMaybeMessage<::world::BallPosition>(Arena*);
template<> ::world::DivisionDimensions* Arena::CreateMaybeMessage<::world::DivisionDimensions>(Arena*);
template<> ::world::Geometry* Arena::CreateMaybeMessage<::world::Geometry>(Arena*);
template<> ::world::Quaternion* Arena::CreateMaybeMessage<::world::Quaternion>(Arena*);
template<> ::world::Robot* Arena::CreateMaybeMessage<::world::Robot>(Arena*);
template<> ::world::RobotPosition* Arena::CreateMaybeMessage<::world::RobotPosition>(Arena*);
template<> ::world::SimBall* Arena::CreateMaybeMessage<::world::SimBall>(Arena*);
template<> ::world::SimRobot* Arena::CreateMaybeMessage<::world::SimRobot>(Arena*);
template<> ::world::SimulatorState* Arena::CreateMaybeMessage<::world::SimulatorState>(Arena*);
template<> ::world::State* Arena::CreateMaybeMessage<::world::State>(Arena*);
template<> ::world::TrackingAOI* Arena::CreateMaybeMessage<::world::TrackingAOI>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace world {

enum Geometry_GeometryType : int {
  Geometry_GeometryType_TYPE_2014 = 1,
  Geometry_GeometryType_TYPE_2018 = 2
};
bool Geometry_GeometryType_IsValid(int value);
constexpr Geometry_GeometryType Geometry_GeometryType_GeometryType_MIN = Geometry_GeometryType_TYPE_2014;
constexpr Geometry_GeometryType Geometry_GeometryType_GeometryType_MAX = Geometry_GeometryType_TYPE_2018;
constexpr int Geometry_GeometryType_GeometryType_ARRAYSIZE = Geometry_GeometryType_GeometryType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Geometry_GeometryType_descriptor();
template<typename T>
inline const std::string& Geometry_GeometryType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Geometry_GeometryType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Geometry_GeometryType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Geometry_GeometryType_descriptor(), enum_t_value);
}
inline bool Geometry_GeometryType_Parse(
    const std::string& name, Geometry_GeometryType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Geometry_GeometryType>(
    Geometry_GeometryType_descriptor(), name, value);
}
enum Geometry_Division : int {
  Geometry_Division_A = 1,
  Geometry_Division_B = 2
};
bool Geometry_Division_IsValid(int value);
constexpr Geometry_Division Geometry_Division_Division_MIN = Geometry_Division_A;
constexpr Geometry_Division Geometry_Division_Division_MAX = Geometry_Division_B;
constexpr int Geometry_Division_Division_ARRAYSIZE = Geometry_Division_Division_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Geometry_Division_descriptor();
template<typename T>
inline const std::string& Geometry_Division_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Geometry_Division>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Geometry_Division_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Geometry_Division_descriptor(), enum_t_value);
}
inline bool Geometry_Division_Parse(
    const std::string& name, Geometry_Division* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Geometry_Division>(
    Geometry_Division_descriptor(), name, value);
}
enum WorldSource : int {
  INTERNAL_SIMULATION = 1,
  EXTERNAL_SIMULATION = 2,
  REAL_LIFE = 3
};
bool WorldSource_IsValid(int value);
constexpr WorldSource WorldSource_MIN = INTERNAL_SIMULATION;
constexpr WorldSource WorldSource_MAX = REAL_LIFE;
constexpr int WorldSource_ARRAYSIZE = WorldSource_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WorldSource_descriptor();
template<typename T>
inline const std::string& WorldSource_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WorldSource>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WorldSource_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WorldSource_descriptor(), enum_t_value);
}
inline bool WorldSource_Parse(
    const std::string& name, WorldSource* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WorldSource>(
    WorldSource_descriptor(), name, value);
}
// ===================================================================

class Geometry PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:world.Geometry) */ {
 public:
  inline Geometry() : Geometry(nullptr) {};
  virtual ~Geometry();

  Geometry(const Geometry& from);
  Geometry(Geometry&& from) noexcept
    : Geometry() {
    *this = ::std::move(from);
  }

  inline Geometry& operator=(const Geometry& from) {
    CopyFrom(from);
    return *this;
  }
  inline Geometry& operator=(Geometry&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Geometry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Geometry* internal_default_instance() {
    return reinterpret_cast<const Geometry*>(
               &_Geometry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Geometry& a, Geometry& b) {
    a.Swap(&b);
  }
  inline void Swap(Geometry* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Geometry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Geometry* New() const final {
    return CreateMaybeMessage<Geometry>(nullptr);
  }

  Geometry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Geometry>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Geometry& from);
  void MergeFrom(const Geometry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Geometry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "world.Geometry";
  }
  protected:
  explicit Geometry(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_world_2eproto);
    return ::descriptor_table_world_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Geometry_GeometryType GeometryType;
  static constexpr GeometryType TYPE_2014 =
    Geometry_GeometryType_TYPE_2014;
  static constexpr GeometryType TYPE_2018 =
    Geometry_GeometryType_TYPE_2018;
  static inline bool GeometryType_IsValid(int value) {
    return Geometry_GeometryType_IsValid(value);
  }
  static constexpr GeometryType GeometryType_MIN =
    Geometry_GeometryType_GeometryType_MIN;
  static constexpr GeometryType GeometryType_MAX =
    Geometry_GeometryType_GeometryType_MAX;
  static constexpr int GeometryType_ARRAYSIZE =
    Geometry_GeometryType_GeometryType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  GeometryType_descriptor() {
    return Geometry_GeometryType_descriptor();
  }
  template<typename T>
  static inline const std::string& GeometryType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, GeometryType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function GeometryType_Name.");
    return Geometry_GeometryType_Name(enum_t_value);
  }
  static inline bool GeometryType_Parse(const std::string& name,
      GeometryType* value) {
    return Geometry_GeometryType_Parse(name, value);
  }

  typedef Geometry_Division Division;
  static constexpr Division A =
    Geometry_Division_A;
  static constexpr Division B =
    Geometry_Division_B;
  static inline bool Division_IsValid(int value) {
    return Geometry_Division_IsValid(value);
  }
  static constexpr Division Division_MIN =
    Geometry_Division_Division_MIN;
  static constexpr Division Division_MAX =
    Geometry_Division_Division_MAX;
  static constexpr int Division_ARRAYSIZE =
    Geometry_Division_Division_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Division_descriptor() {
    return Geometry_Division_descriptor();
  }
  template<typename T>
  static inline const std::string& Division_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Division>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Division_Name.");
    return Geometry_Division_Name(enum_t_value);
  }
  static inline bool Division_Parse(const std::string& name,
      Division* value) {
    return Geometry_Division_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kBallModelFieldNumber = 20,
    kLineWidthFieldNumber = 1,
    kFieldWidthFieldNumber = 2,
    kFieldHeightFieldNumber = 3,
    kBoundaryWidthFieldNumber = 4,
    kGoalWidthFieldNumber = 6,
    kGoalDepthFieldNumber = 7,
    kGoalWallWidthFieldNumber = 8,
    kCenterCircleRadiusFieldNumber = 9,
    kDefenseRadiusFieldNumber = 10,
    kDefenseStretchFieldNumber = 11,
    kFreeKickFromDefenseDistFieldNumber = 12,
    kPenaltySpotFromFieldLineDistFieldNumber = 13,
    kPenaltyLineFromSpotDistFieldNumber = 14,
    kGoalHeightFieldNumber = 15,
    kCornerBlockCathetusLengthFieldNumber = 21,
    kDefenseWidthFieldNumber = 16,
    kDefenseHeightFieldNumber = 17,
    kTypeFieldNumber = 18,
    kDivisionFieldNumber = 19,
  };
  // optional .world.BallModel ball_model = 20;
  bool has_ball_model() const;
  private:
  bool _internal_has_ball_model() const;
  public:
  void clear_ball_model();
  const ::world::BallModel& ball_model() const;
  ::world::BallModel* release_ball_model();
  ::world::BallModel* mutable_ball_model();
  void set_allocated_ball_model(::world::BallModel* ball_model);
  private:
  const ::world::BallModel& _internal_ball_model() const;
  ::world::BallModel* _internal_mutable_ball_model();
  public:
  void unsafe_arena_set_allocated_ball_model(
      ::world::BallModel* ball_model);
  ::world::BallModel* unsafe_arena_release_ball_model();

  // required float line_width = 1;
  bool has_line_width() const;
  private:
  bool _internal_has_line_width() const;
  public:
  void clear_line_width();
  float line_width() const;
  void set_line_width(float value);
  private:
  float _internal_line_width() const;
  void _internal_set_line_width(float value);
  public:

  // required float field_width = 2;
  bool has_field_width() const;
  private:
  bool _internal_has_field_width() const;
  public:
  void clear_field_width();
  float field_width() const;
  void set_field_width(float value);
  private:
  float _internal_field_width() const;
  void _internal_set_field_width(float value);
  public:

  // required float field_height = 3;
  bool has_field_height() const;
  private:
  bool _internal_has_field_height() const;
  public:
  void clear_field_height();
  float field_height() const;
  void set_field_height(float value);
  private:
  float _internal_field_height() const;
  void _internal_set_field_height(float value);
  public:

  // required float boundary_width = 4;
  bool has_boundary_width() const;
  private:
  bool _internal_has_boundary_width() const;
  public:
  void clear_boundary_width();
  float boundary_width() const;
  void set_boundary_width(float value);
  private:
  float _internal_boundary_width() const;
  void _internal_set_boundary_width(float value);
  public:

  // required float goal_width = 6;
  bool has_goal_width() const;
  private:
  bool _internal_has_goal_width() const;
  public:
  void clear_goal_width();
  float goal_width() const;
  void set_goal_width(float value);
  private:
  float _internal_goal_width() const;
  void _internal_set_goal_width(float value);
  public:

  // required float goal_depth = 7;
  bool has_goal_depth() const;
  private:
  bool _internal_has_goal_depth() const;
  public:
  void clear_goal_depth();
  float goal_depth() const;
  void set_goal_depth(float value);
  private:
  float _internal_goal_depth() const;
  void _internal_set_goal_depth(float value);
  public:

  // required float goal_wall_width = 8;
  bool has_goal_wall_width() const;
  private:
  bool _internal_has_goal_wall_width() const;
  public:
  void clear_goal_wall_width();
  float goal_wall_width() const;
  void set_goal_wall_width(float value);
  private:
  float _internal_goal_wall_width() const;
  void _internal_set_goal_wall_width(float value);
  public:

  // required float center_circle_radius = 9;
  bool has_center_circle_radius() const;
  private:
  bool _internal_has_center_circle_radius() const;
  public:
  void clear_center_circle_radius();
  float center_circle_radius() const;
  void set_center_circle_radius(float value);
  private:
  float _internal_center_circle_radius() const;
  void _internal_set_center_circle_radius(float value);
  public:

  // required float defense_radius = 10;
  bool has_defense_radius() const;
  private:
  bool _internal_has_defense_radius() const;
  public:
  void clear_defense_radius();
  float defense_radius() const;
  void set_defense_radius(float value);
  private:
  float _internal_defense_radius() const;
  void _internal_set_defense_radius(float value);
  public:

  // required float defense_stretch = 11;
  bool has_defense_stretch() const;
  private:
  bool _internal_has_defense_stretch() const;
  public:
  void clear_defense_stretch();
  float defense_stretch() const;
  void set_defense_stretch(float value);
  private:
  float _internal_defense_stretch() const;
  void _internal_set_defense_stretch(float value);
  public:

  // required float free_kick_from_defense_dist = 12;
  bool has_free_kick_from_defense_dist() const;
  private:
  bool _internal_has_free_kick_from_defense_dist() const;
  public:
  void clear_free_kick_from_defense_dist();
  float free_kick_from_defense_dist() const;
  void set_free_kick_from_defense_dist(float value);
  private:
  float _internal_free_kick_from_defense_dist() const;
  void _internal_set_free_kick_from_defense_dist(float value);
  public:

  // required float penalty_spot_from_field_line_dist = 13;
  bool has_penalty_spot_from_field_line_dist() const;
  private:
  bool _internal_has_penalty_spot_from_field_line_dist() const;
  public:
  void clear_penalty_spot_from_field_line_dist();
  float penalty_spot_from_field_line_dist() const;
  void set_penalty_spot_from_field_line_dist(float value);
  private:
  float _internal_penalty_spot_from_field_line_dist() const;
  void _internal_set_penalty_spot_from_field_line_dist(float value);
  public:

  // required float penalty_line_from_spot_dist = 14;
  bool has_penalty_line_from_spot_dist() const;
  private:
  bool _internal_has_penalty_line_from_spot_dist() const;
  public:
  void clear_penalty_line_from_spot_dist();
  float penalty_line_from_spot_dist() const;
  void set_penalty_line_from_spot_dist(float value);
  private:
  float _internal_penalty_line_from_spot_dist() const;
  void _internal_set_penalty_line_from_spot_dist(float value);
  public:

  // required float goal_height = 15;
  bool has_goal_height() const;
  private:
  bool _internal_has_goal_height() const;
  public:
  void clear_goal_height();
  float goal_height() const;
  void set_goal_height(float value);
  private:
  float _internal_goal_height() const;
  void _internal_set_goal_height(float value);
  public:

  // optional float corner_block_cathetus_length = 21;
  bool has_corner_block_cathetus_length() const;
  private:
  bool _internal_has_corner_block_cathetus_length() const;
  public:
  void clear_corner_block_cathetus_length();
  float corner_block_cathetus_length() const;
  void set_corner_block_cathetus_length(float value);
  private:
  float _internal_corner_block_cathetus_length() const;
  void _internal_set_corner_block_cathetus_length(float value);
  public:

  // optional float defense_width = 16 [default = 2];
  bool has_defense_width() const;
  private:
  bool _internal_has_defense_width() const;
  public:
  void clear_defense_width();
  float defense_width() const;
  void set_defense_width(float value);
  private:
  float _internal_defense_width() const;
  void _internal_set_defense_width(float value);
  public:

  // optional float defense_height = 17 [default = 1];
  bool has_defense_height() const;
  private:
  bool _internal_has_defense_height() const;
  public:
  void clear_defense_height();
  float defense_height() const;
  void set_defense_height(float value);
  private:
  float _internal_defense_height() const;
  void _internal_set_defense_height(float value);
  public:

  // optional .world.Geometry.GeometryType type = 18 [default = TYPE_2014];
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::world::Geometry_GeometryType type() const;
  void set_type(::world::Geometry_GeometryType value);
  private:
  ::world::Geometry_GeometryType _internal_type() const;
  void _internal_set_type(::world::Geometry_GeometryType value);
  public:

  // optional .world.Geometry.Division division = 19 [default = A];
  bool has_division() const;
  private:
  bool _internal_has_division() const;
  public:
  void clear_division();
  ::world::Geometry_Division division() const;
  void set_division(::world::Geometry_Division value);
  private:
  ::world::Geometry_Division _internal_division() const;
  void _internal_set_division(::world::Geometry_Division value);
  public:

  // @@protoc_insertion_point(class_scope:world.Geometry)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::world::BallModel* ball_model_;
  float line_width_;
  float field_width_;
  float field_height_;
  float boundary_width_;
  float goal_width_;
  float goal_depth_;
  float goal_wall_width_;
  float center_circle_radius_;
  float defense_radius_;
  float defense_stretch_;
  float free_kick_from_defense_dist_;
  float penalty_spot_from_field_line_dist_;
  float penalty_line_from_spot_dist_;
  float goal_height_;
  float corner_block_cathetus_length_;
  float defense_width_;
  float defense_height_;
  int type_;
  int division_;
  friend struct ::TableStruct_world_2eproto;
};
// -------------------------------------------------------------------

class BallModel PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:world.BallModel) */ {
 public:
  inline BallModel() : BallModel(nullptr) {};
  virtual ~BallModel();

  BallModel(const BallModel& from);
  BallModel(BallModel&& from) noexcept
    : BallModel() {
    *this = ::std::move(from);
  }

  inline BallModel& operator=(const BallModel& from) {
    CopyFrom(from);
    return *this;
  }
  inline BallModel& operator=(BallModel&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BallModel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BallModel* internal_default_instance() {
    return reinterpret_cast<const BallModel*>(
               &_BallModel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(BallModel& a, BallModel& b) {
    a.Swap(&b);
  }
  inline void Swap(BallModel* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BallModel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BallModel* New() const final {
    return CreateMaybeMessage<BallModel>(nullptr);
  }

  BallModel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BallModel>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BallModel& from);
  void MergeFrom(const BallModel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BallModel* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "world.BallModel";
  }
  protected:
  explicit BallModel(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_world_2eproto);
    return ::descriptor_table_world_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFastDecelerationFieldNumber = 1,
    kSlowDecelerationFieldNumber = 2,
    kSwitchRatioFieldNumber = 3,
    kZDampingFieldNumber = 4,
    kXyDampingFieldNumber = 5,
  };
  // optional float fast_deceleration = 1;
  bool has_fast_deceleration() const;
  private:
  bool _internal_has_fast_deceleration() const;
  public:
  void clear_fast_deceleration();
  float fast_deceleration() const;
  void set_fast_deceleration(float value);
  private:
  float _internal_fast_deceleration() const;
  void _internal_set_fast_deceleration(float value);
  public:

  // optional float slow_deceleration = 2;
  bool has_slow_deceleration() const;
  private:
  bool _internal_has_slow_deceleration() const;
  public:
  void clear_slow_deceleration();
  float slow_deceleration() const;
  void set_slow_deceleration(float value);
  private:
  float _internal_slow_deceleration() const;
  void _internal_set_slow_deceleration(float value);
  public:

  // optional float switch_ratio = 3;
  bool has_switch_ratio() const;
  private:
  bool _internal_has_switch_ratio() const;
  public:
  void clear_switch_ratio();
  float switch_ratio() const;
  void set_switch_ratio(float value);
  private:
  float _internal_switch_ratio() const;
  void _internal_set_switch_ratio(float value);
  public:

  // optional float z_damping = 4;
  bool has_z_damping() const;
  private:
  bool _internal_has_z_damping() const;
  public:
  void clear_z_damping();
  float z_damping() const;
  void set_z_damping(float value);
  private:
  float _internal_z_damping() const;
  void _internal_set_z_damping(float value);
  public:

  // optional float xy_damping = 5;
  bool has_xy_damping() const;
  private:
  bool _internal_has_xy_damping() const;
  public:
  void clear_xy_damping();
  float xy_damping() const;
  void set_xy_damping(float value);
  private:
  float _internal_xy_damping() const;
  void _internal_set_xy_damping(float value);
  public:

  // @@protoc_insertion_point(class_scope:world.BallModel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float fast_deceleration_;
  float slow_deceleration_;
  float switch_ratio_;
  float z_damping_;
  float xy_damping_;
  friend struct ::TableStruct_world_2eproto;
};
// -------------------------------------------------------------------

class DivisionDimensions PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:world.DivisionDimensions) */ {
 public:
  inline DivisionDimensions() : DivisionDimensions(nullptr) {};
  virtual ~DivisionDimensions();

  DivisionDimensions(const DivisionDimensions& from);
  DivisionDimensions(DivisionDimensions&& from) noexcept
    : DivisionDimensions() {
    *this = ::std::move(from);
  }

  inline DivisionDimensions& operator=(const DivisionDimensions& from) {
    CopyFrom(from);
    return *this;
  }
  inline DivisionDimensions& operator=(DivisionDimensions&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DivisionDimensions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DivisionDimensions* internal_default_instance() {
    return reinterpret_cast<const DivisionDimensions*>(
               &_DivisionDimensions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DivisionDimensions& a, DivisionDimensions& b) {
    a.Swap(&b);
  }
  inline void Swap(DivisionDimensions* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DivisionDimensions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DivisionDimensions* New() const final {
    return CreateMaybeMessage<DivisionDimensions>(nullptr);
  }

  DivisionDimensions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DivisionDimensions>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DivisionDimensions& from);
  void MergeFrom(const DivisionDimensions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DivisionDimensions* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "world.DivisionDimensions";
  }
  protected:
  explicit DivisionDimensions(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_world_2eproto);
    return ::descriptor_table_world_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldWidthAFieldNumber = 1,
    kFieldHeightAFieldNumber = 2,
    kFieldWidthBFieldNumber = 3,
    kFieldHeightBFieldNumber = 4,
  };
  // required float field_width_a = 1;
  bool has_field_width_a() const;
  private:
  bool _internal_has_field_width_a() const;
  public:
  void clear_field_width_a();
  float field_width_a() const;
  void set_field_width_a(float value);
  private:
  float _internal_field_width_a() const;
  void _internal_set_field_width_a(float value);
  public:

  // required float field_height_a = 2;
  bool has_field_height_a() const;
  private:
  bool _internal_has_field_height_a() const;
  public:
  void clear_field_height_a();
  float field_height_a() const;
  void set_field_height_a(float value);
  private:
  float _internal_field_height_a() const;
  void _internal_set_field_height_a(float value);
  public:

  // required float field_width_b = 3;
  bool has_field_width_b() const;
  private:
  bool _internal_has_field_width_b() const;
  public:
  void clear_field_width_b();
  float field_width_b() const;
  void set_field_width_b(float value);
  private:
  float _internal_field_width_b() const;
  void _internal_set_field_width_b(float value);
  public:

  // required float field_height_b = 4;
  bool has_field_height_b() const;
  private:
  bool _internal_has_field_height_b() const;
  public:
  void clear_field_height_b();
  float field_height_b() const;
  void set_field_height_b(float value);
  private:
  float _internal_field_height_b() const;
  void _internal_set_field_height_b(float value);
  public:

  // @@protoc_insertion_point(class_scope:world.DivisionDimensions)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float field_width_a_;
  float field_height_a_;
  float field_width_b_;
  float field_height_b_;
  friend struct ::TableStruct_world_2eproto;
};
// -------------------------------------------------------------------

class BallPosition PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:world.BallPosition) */ {
 public:
  inline BallPosition() : BallPosition(nullptr) {};
  virtual ~BallPosition();

  BallPosition(const BallPosition& from);
  BallPosition(BallPosition&& from) noexcept
    : BallPosition() {
    *this = ::std::move(from);
  }

  inline BallPosition& operator=(const BallPosition& from) {
    CopyFrom(from);
    return *this;
  }
  inline BallPosition& operator=(BallPosition&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BallPosition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BallPosition* internal_default_instance() {
    return reinterpret_cast<const BallPosition*>(
               &_BallPosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(BallPosition& a, BallPosition& b) {
    a.Swap(&b);
  }
  inline void Swap(BallPosition* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BallPosition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BallPosition* New() const final {
    return CreateMaybeMessage<BallPosition>(nullptr);
  }

  BallPosition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BallPosition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BallPosition& from);
  void MergeFrom(const BallPosition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BallPosition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "world.BallPosition";
  }
  protected:
  explicit BallPosition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_world_2eproto);
    return ::descriptor_table_world_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeFieldNumber = 1,
    kPXFieldNumber = 2,
    kPYFieldNumber = 3,
    kVXFieldNumber = 5,
    kVYFieldNumber = 6,
    kSystemDelayFieldNumber = 7,
    kTimeDiffScaledFieldNumber = 8,
    kCameraIdFieldNumber = 9,
    kDerivedZFieldNumber = 10,
    kVisionProcessingTimeFieldNumber = 12,
    kAreaFieldNumber = 11,
  };
  // required int64 time = 1;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  ::PROTOBUF_NAMESPACE_ID::int64 time() const;
  void set_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_time() const;
  void _internal_set_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required float p_x = 2;
  bool has_p_x() const;
  private:
  bool _internal_has_p_x() const;
  public:
  void clear_p_x();
  float p_x() const;
  void set_p_x(float value);
  private:
  float _internal_p_x() const;
  void _internal_set_p_x(float value);
  public:

  // required float p_y = 3;
  bool has_p_y() const;
  private:
  bool _internal_has_p_y() const;
  public:
  void clear_p_y();
  float p_y() const;
  void set_p_y(float value);
  private:
  float _internal_p_y() const;
  void _internal_set_p_y(float value);
  public:

  // optional float v_x = 5;
  bool has_v_x() const;
  private:
  bool _internal_has_v_x() const;
  public:
  void clear_v_x();
  float v_x() const;
  void set_v_x(float value);
  private:
  float _internal_v_x() const;
  void _internal_set_v_x(float value);
  public:

  // optional float v_y = 6;
  bool has_v_y() const;
  private:
  bool _internal_has_v_y() const;
  public:
  void clear_v_y();
  float v_y() const;
  void set_v_y(float value);
  private:
  float _internal_v_y() const;
  void _internal_set_v_y(float value);
  public:

  // optional float system_delay = 7;
  bool has_system_delay() const;
  private:
  bool _internal_has_system_delay() const;
  public:
  void clear_system_delay();
  float system_delay() const;
  void set_system_delay(float value);
  private:
  float _internal_system_delay() const;
  void _internal_set_system_delay(float value);
  public:

  // optional float time_diff_scaled = 8;
  bool has_time_diff_scaled() const;
  private:
  bool _internal_has_time_diff_scaled() const;
  public:
  void clear_time_diff_scaled();
  float time_diff_scaled() const;
  void set_time_diff_scaled(float value);
  private:
  float _internal_time_diff_scaled() const;
  void _internal_set_time_diff_scaled(float value);
  public:

  // optional uint32 camera_id = 9;
  bool has_camera_id() const;
  private:
  bool _internal_has_camera_id() const;
  public:
  void clear_camera_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 camera_id() const;
  void set_camera_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_camera_id() const;
  void _internal_set_camera_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional float derived_z = 10;
  bool has_derived_z() const;
  private:
  bool _internal_has_derived_z() const;
  public:
  void clear_derived_z();
  float derived_z() const;
  void set_derived_z(float value);
  private:
  float _internal_derived_z() const;
  void _internal_set_derived_z(float value);
  public:

  // optional int64 vision_processing_time = 12;
  bool has_vision_processing_time() const;
  private:
  bool _internal_has_vision_processing_time() const;
  public:
  void clear_vision_processing_time();
  ::PROTOBUF_NAMESPACE_ID::int64 vision_processing_time() const;
  void set_vision_processing_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_vision_processing_time() const;
  void _internal_set_vision_processing_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional float area = 11;
  bool has_area() const;
  private:
  bool _internal_has_area() const;
  public:
  void clear_area();
  float area() const;
  void set_area(float value);
  private:
  float _internal_area() const;
  void _internal_set_area(float value);
  public:

  // @@protoc_insertion_point(class_scope:world.BallPosition)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 time_;
  float p_x_;
  float p_y_;
  float v_x_;
  float v_y_;
  float system_delay_;
  float time_diff_scaled_;
  ::PROTOBUF_NAMESPACE_ID::uint32 camera_id_;
  float derived_z_;
  ::PROTOBUF_NAMESPACE_ID::int64 vision_processing_time_;
  float area_;
  friend struct ::TableStruct_world_2eproto;
};
// -------------------------------------------------------------------

class Ball PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:world.Ball) */ {
 public:
  inline Ball() : Ball(nullptr) {};
  virtual ~Ball();

  Ball(const Ball& from);
  Ball(Ball&& from) noexcept
    : Ball() {
    *this = ::std::move(from);
  }

  inline Ball& operator=(const Ball& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ball& operator=(Ball&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Ball& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Ball* internal_default_instance() {
    return reinterpret_cast<const Ball*>(
               &_Ball_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Ball& a, Ball& b) {
    a.Swap(&b);
  }
  inline void Swap(Ball* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ball* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Ball* New() const final {
    return CreateMaybeMessage<Ball>(nullptr);
  }

  Ball* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Ball>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Ball& from);
  void MergeFrom(const Ball& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ball* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "world.Ball";
  }
  protected:
  explicit Ball(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_world_2eproto);
    return ::descriptor_table_world_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRawFieldNumber = 5,
    kPXFieldNumber = 1,
    kPYFieldNumber = 2,
    kVXFieldNumber = 3,
    kVYFieldNumber = 4,
    kPZFieldNumber = 6,
    kVZFieldNumber = 7,
    kTouchdownXFieldNumber = 8,
    kTouchdownYFieldNumber = 9,
    kIsBouncingFieldNumber = 10,
    kMaxSpeedFieldNumber = 11,
  };
  // repeated .world.BallPosition raw = 5;
  int raw_size() const;
  private:
  int _internal_raw_size() const;
  public:
  void clear_raw();
  ::world::BallPosition* mutable_raw(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world::BallPosition >*
      mutable_raw();
  private:
  const ::world::BallPosition& _internal_raw(int index) const;
  ::world::BallPosition* _internal_add_raw();
  public:
  const ::world::BallPosition& raw(int index) const;
  ::world::BallPosition* add_raw();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world::BallPosition >&
      raw() const;

  // required float p_x = 1;
  bool has_p_x() const;
  private:
  bool _internal_has_p_x() const;
  public:
  void clear_p_x();
  float p_x() const;
  void set_p_x(float value);
  private:
  float _internal_p_x() const;
  void _internal_set_p_x(float value);
  public:

  // required float p_y = 2;
  bool has_p_y() const;
  private:
  bool _internal_has_p_y() const;
  public:
  void clear_p_y();
  float p_y() const;
  void set_p_y(float value);
  private:
  float _internal_p_y() const;
  void _internal_set_p_y(float value);
  public:

  // required float v_x = 3;
  bool has_v_x() const;
  private:
  bool _internal_has_v_x() const;
  public:
  void clear_v_x();
  float v_x() const;
  void set_v_x(float value);
  private:
  float _internal_v_x() const;
  void _internal_set_v_x(float value);
  public:

  // required float v_y = 4;
  bool has_v_y() const;
  private:
  bool _internal_has_v_y() const;
  public:
  void clear_v_y();
  float v_y() const;
  void set_v_y(float value);
  private:
  float _internal_v_y() const;
  void _internal_set_v_y(float value);
  public:

  // optional float p_z = 6;
  bool has_p_z() const;
  private:
  bool _internal_has_p_z() const;
  public:
  void clear_p_z();
  float p_z() const;
  void set_p_z(float value);
  private:
  float _internal_p_z() const;
  void _internal_set_p_z(float value);
  public:

  // optional float v_z = 7;
  bool has_v_z() const;
  private:
  bool _internal_has_v_z() const;
  public:
  void clear_v_z();
  float v_z() const;
  void set_v_z(float value);
  private:
  float _internal_v_z() const;
  void _internal_set_v_z(float value);
  public:

  // optional float touchdown_x = 8;
  bool has_touchdown_x() const;
  private:
  bool _internal_has_touchdown_x() const;
  public:
  void clear_touchdown_x();
  float touchdown_x() const;
  void set_touchdown_x(float value);
  private:
  float _internal_touchdown_x() const;
  void _internal_set_touchdown_x(float value);
  public:

  // optional float touchdown_y = 9;
  bool has_touchdown_y() const;
  private:
  bool _internal_has_touchdown_y() const;
  public:
  void clear_touchdown_y();
  float touchdown_y() const;
  void set_touchdown_y(float value);
  private:
  float _internal_touchdown_y() const;
  void _internal_set_touchdown_y(float value);
  public:

  // optional bool is_bouncing = 10;
  bool has_is_bouncing() const;
  private:
  bool _internal_has_is_bouncing() const;
  public:
  void clear_is_bouncing();
  bool is_bouncing() const;
  void set_is_bouncing(bool value);
  private:
  bool _internal_is_bouncing() const;
  void _internal_set_is_bouncing(bool value);
  public:

  // optional float max_speed = 11;
  bool has_max_speed() const;
  private:
  bool _internal_has_max_speed() const;
  public:
  void clear_max_speed();
  float max_speed() const;
  void set_max_speed(float value);
  private:
  float _internal_max_speed() const;
  void _internal_set_max_speed(float value);
  public:

  // @@protoc_insertion_point(class_scope:world.Ball)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world::BallPosition > raw_;
  float p_x_;
  float p_y_;
  float v_x_;
  float v_y_;
  float p_z_;
  float v_z_;
  float touchdown_x_;
  float touchdown_y_;
  bool is_bouncing_;
  float max_speed_;
  friend struct ::TableStruct_world_2eproto;
};
// -------------------------------------------------------------------

class RobotPosition PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:world.RobotPosition) */ {
 public:
  inline RobotPosition() : RobotPosition(nullptr) {};
  virtual ~RobotPosition();

  RobotPosition(const RobotPosition& from);
  RobotPosition(RobotPosition&& from) noexcept
    : RobotPosition() {
    *this = ::std::move(from);
  }

  inline RobotPosition& operator=(const RobotPosition& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotPosition& operator=(RobotPosition&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RobotPosition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RobotPosition* internal_default_instance() {
    return reinterpret_cast<const RobotPosition*>(
               &_RobotPosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RobotPosition& a, RobotPosition& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotPosition* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotPosition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RobotPosition* New() const final {
    return CreateMaybeMessage<RobotPosition>(nullptr);
  }

  RobotPosition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RobotPosition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RobotPosition& from);
  void MergeFrom(const RobotPosition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotPosition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "world.RobotPosition";
  }
  protected:
  explicit RobotPosition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_world_2eproto);
    return ::descriptor_table_world_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeFieldNumber = 1,
    kPXFieldNumber = 2,
    kPYFieldNumber = 3,
    kPhiFieldNumber = 4,
    kVXFieldNumber = 5,
    kVYFieldNumber = 6,
    kSystemDelayFieldNumber = 7,
    kTimeDiffScaledFieldNumber = 8,
    kOmegaFieldNumber = 9,
    kVisionProcessingTimeFieldNumber = 11,
    kCameraIdFieldNumber = 10,
  };
  // required int64 time = 1;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  ::PROTOBUF_NAMESPACE_ID::int64 time() const;
  void set_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_time() const;
  void _internal_set_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required float p_x = 2;
  bool has_p_x() const;
  private:
  bool _internal_has_p_x() const;
  public:
  void clear_p_x();
  float p_x() const;
  void set_p_x(float value);
  private:
  float _internal_p_x() const;
  void _internal_set_p_x(float value);
  public:

  // required float p_y = 3;
  bool has_p_y() const;
  private:
  bool _internal_has_p_y() const;
  public:
  void clear_p_y();
  float p_y() const;
  void set_p_y(float value);
  private:
  float _internal_p_y() const;
  void _internal_set_p_y(float value);
  public:

  // required float phi = 4;
  bool has_phi() const;
  private:
  bool _internal_has_phi() const;
  public:
  void clear_phi();
  float phi() const;
  void set_phi(float value);
  private:
  float _internal_phi() const;
  void _internal_set_phi(float value);
  public:

  // optional float v_x = 5;
  bool has_v_x() const;
  private:
  bool _internal_has_v_x() const;
  public:
  void clear_v_x();
  float v_x() const;
  void set_v_x(float value);
  private:
  float _internal_v_x() const;
  void _internal_set_v_x(float value);
  public:

  // optional float v_y = 6;
  bool has_v_y() const;
  private:
  bool _internal_has_v_y() const;
  public:
  void clear_v_y();
  float v_y() const;
  void set_v_y(float value);
  private:
  float _internal_v_y() const;
  void _internal_set_v_y(float value);
  public:

  // optional float system_delay = 7;
  bool has_system_delay() const;
  private:
  bool _internal_has_system_delay() const;
  public:
  void clear_system_delay();
  float system_delay() const;
  void set_system_delay(float value);
  private:
  float _internal_system_delay() const;
  void _internal_set_system_delay(float value);
  public:

  // optional float time_diff_scaled = 8;
  bool has_time_diff_scaled() const;
  private:
  bool _internal_has_time_diff_scaled() const;
  public:
  void clear_time_diff_scaled();
  float time_diff_scaled() const;
  void set_time_diff_scaled(float value);
  private:
  float _internal_time_diff_scaled() const;
  void _internal_set_time_diff_scaled(float value);
  public:

  // optional float omega = 9;
  bool has_omega() const;
  private:
  bool _internal_has_omega() const;
  public:
  void clear_omega();
  float omega() const;
  void set_omega(float value);
  private:
  float _internal_omega() const;
  void _internal_set_omega(float value);
  public:

  // optional int64 vision_processing_time = 11;
  bool has_vision_processing_time() const;
  private:
  bool _internal_has_vision_processing_time() const;
  public:
  void clear_vision_processing_time();
  ::PROTOBUF_NAMESPACE_ID::int64 vision_processing_time() const;
  void set_vision_processing_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_vision_processing_time() const;
  void _internal_set_vision_processing_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional uint32 camera_id = 10;
  bool has_camera_id() const;
  private:
  bool _internal_has_camera_id() const;
  public:
  void clear_camera_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 camera_id() const;
  void set_camera_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_camera_id() const;
  void _internal_set_camera_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:world.RobotPosition)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 time_;
  float p_x_;
  float p_y_;
  float phi_;
  float v_x_;
  float v_y_;
  float system_delay_;
  float time_diff_scaled_;
  float omega_;
  ::PROTOBUF_NAMESPACE_ID::int64 vision_processing_time_;
  ::PROTOBUF_NAMESPACE_ID::uint32 camera_id_;
  friend struct ::TableStruct_world_2eproto;
};
// -------------------------------------------------------------------

class Robot PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:world.Robot) */ {
 public:
  inline Robot() : Robot(nullptr) {};
  virtual ~Robot();

  Robot(const Robot& from);
  Robot(Robot&& from) noexcept
    : Robot() {
    *this = ::std::move(from);
  }

  inline Robot& operator=(const Robot& from) {
    CopyFrom(from);
    return *this;
  }
  inline Robot& operator=(Robot&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Robot& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Robot* internal_default_instance() {
    return reinterpret_cast<const Robot*>(
               &_Robot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Robot& a, Robot& b) {
    a.Swap(&b);
  }
  inline void Swap(Robot* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Robot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Robot* New() const final {
    return CreateMaybeMessage<Robot>(nullptr);
  }

  Robot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Robot>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Robot& from);
  void MergeFrom(const Robot& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Robot* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "world.Robot";
  }
  protected:
  explicit Robot(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_world_2eproto);
    return ::descriptor_table_world_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRawFieldNumber = 8,
    kIdFieldNumber = 1,
    kPXFieldNumber = 2,
    kPYFieldNumber = 3,
    kPhiFieldNumber = 4,
    kVXFieldNumber = 5,
    kVYFieldNumber = 6,
    kOmegaFieldNumber = 7,
  };
  // repeated .world.RobotPosition raw = 8;
  int raw_size() const;
  private:
  int _internal_raw_size() const;
  public:
  void clear_raw();
  ::world::RobotPosition* mutable_raw(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world::RobotPosition >*
      mutable_raw();
  private:
  const ::world::RobotPosition& _internal_raw(int index) const;
  ::world::RobotPosition* _internal_add_raw();
  public:
  const ::world::RobotPosition& raw(int index) const;
  ::world::RobotPosition* add_raw();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world::RobotPosition >&
      raw() const;

  // required uint32 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required float p_x = 2;
  bool has_p_x() const;
  private:
  bool _internal_has_p_x() const;
  public:
  void clear_p_x();
  float p_x() const;
  void set_p_x(float value);
  private:
  float _internal_p_x() const;
  void _internal_set_p_x(float value);
  public:

  // required float p_y = 3;
  bool has_p_y() const;
  private:
  bool _internal_has_p_y() const;
  public:
  void clear_p_y();
  float p_y() const;
  void set_p_y(float value);
  private:
  float _internal_p_y() const;
  void _internal_set_p_y(float value);
  public:

  // required float phi = 4;
  bool has_phi() const;
  private:
  bool _internal_has_phi() const;
  public:
  void clear_phi();
  float phi() const;
  void set_phi(float value);
  private:
  float _internal_phi() const;
  void _internal_set_phi(float value);
  public:

  // required float v_x = 5;
  bool has_v_x() const;
  private:
  bool _internal_has_v_x() const;
  public:
  void clear_v_x();
  float v_x() const;
  void set_v_x(float value);
  private:
  float _internal_v_x() const;
  void _internal_set_v_x(float value);
  public:

  // required float v_y = 6;
  bool has_v_y() const;
  private:
  bool _internal_has_v_y() const;
  public:
  void clear_v_y();
  float v_y() const;
  void set_v_y(float value);
  private:
  float _internal_v_y() const;
  void _internal_set_v_y(float value);
  public:

  // required float omega = 7;
  bool has_omega() const;
  private:
  bool _internal_has_omega() const;
  public:
  void clear_omega();
  float omega() const;
  void set_omega(float value);
  private:
  float _internal_omega() const;
  void _internal_set_omega(float value);
  public:

  // @@protoc_insertion_point(class_scope:world.Robot)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world::RobotPosition > raw_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  float p_x_;
  float p_y_;
  float phi_;
  float v_x_;
  float v_y_;
  float omega_;
  friend struct ::TableStruct_world_2eproto;
};
// -------------------------------------------------------------------

class TrackingAOI PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:world.TrackingAOI) */ {
 public:
  inline TrackingAOI() : TrackingAOI(nullptr) {};
  virtual ~TrackingAOI();

  TrackingAOI(const TrackingAOI& from);
  TrackingAOI(TrackingAOI&& from) noexcept
    : TrackingAOI() {
    *this = ::std::move(from);
  }

  inline TrackingAOI& operator=(const TrackingAOI& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackingAOI& operator=(TrackingAOI&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TrackingAOI& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrackingAOI* internal_default_instance() {
    return reinterpret_cast<const TrackingAOI*>(
               &_TrackingAOI_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TrackingAOI& a, TrackingAOI& b) {
    a.Swap(&b);
  }
  inline void Swap(TrackingAOI* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackingAOI* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TrackingAOI* New() const final {
    return CreateMaybeMessage<TrackingAOI>(nullptr);
  }

  TrackingAOI* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TrackingAOI>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TrackingAOI& from);
  void MergeFrom(const TrackingAOI& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrackingAOI* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "world.TrackingAOI";
  }
  protected:
  explicit TrackingAOI(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_world_2eproto);
    return ::descriptor_table_world_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kX1FieldNumber = 1,
    kY1FieldNumber = 2,
    kX2FieldNumber = 3,
    kY2FieldNumber = 4,
  };
  // required float x1 = 1;
  bool has_x1() const;
  private:
  bool _internal_has_x1() const;
  public:
  void clear_x1();
  float x1() const;
  void set_x1(float value);
  private:
  float _internal_x1() const;
  void _internal_set_x1(float value);
  public:

  // required float y1 = 2;
  bool has_y1() const;
  private:
  bool _internal_has_y1() const;
  public:
  void clear_y1();
  float y1() const;
  void set_y1(float value);
  private:
  float _internal_y1() const;
  void _internal_set_y1(float value);
  public:

  // required float x2 = 3;
  bool has_x2() const;
  private:
  bool _internal_has_x2() const;
  public:
  void clear_x2();
  float x2() const;
  void set_x2(float value);
  private:
  float _internal_x2() const;
  void _internal_set_x2(float value);
  public:

  // required float y2 = 4;
  bool has_y2() const;
  private:
  bool _internal_has_y2() const;
  public:
  void clear_y2();
  float y2() const;
  void set_y2(float value);
  private:
  float _internal_y2() const;
  void _internal_set_y2(float value);
  public:

  // @@protoc_insertion_point(class_scope:world.TrackingAOI)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float x1_;
  float y1_;
  float x2_;
  float y2_;
  friend struct ::TableStruct_world_2eproto;
};
// -------------------------------------------------------------------

class State PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:world.State) */ {
 public:
  inline State() : State(nullptr) {};
  virtual ~State();

  State(const State& from);
  State(State&& from) noexcept
    : State() {
    *this = ::std::move(from);
  }

  inline State& operator=(const State& from) {
    CopyFrom(from);
    return *this;
  }
  inline State& operator=(State&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const State& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const State* internal_default_instance() {
    return reinterpret_cast<const State*>(
               &_State_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(State& a, State& b) {
    a.Swap(&b);
  }
  inline void Swap(State* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(State* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline State* New() const final {
    return CreateMaybeMessage<State>(nullptr);
  }

  State* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<State>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const State& from);
  void MergeFrom(const State& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(State* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "world.State";
  }
  protected:
  explicit State(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_world_2eproto);
    return ::descriptor_table_world_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kYellowFieldNumber = 3,
    kBlueFieldNumber = 4,
    kRadioResponseFieldNumber = 5,
    kVisionFramesFieldNumber = 10,
    kSimpleTrackingYellowFieldNumber = 11,
    kSimpleTrackingBlueFieldNumber = 12,
    kRealityFieldNumber = 13,
    kVisionFrameTimesFieldNumber = 14,
    kBallFieldNumber = 2,
    kMixedTeamInfoFieldNumber = 8,
    kTrackingAoiFieldNumber = 9,
    kSimpleTrackingBallFieldNumber = 17,
    kTimeFieldNumber = 1,
    kSystemDelayFieldNumber = 15,
    kIsSimulatedFieldNumber = 6,
    kHasVisionDataFieldNumber = 7,
    kWorldSourceFieldNumber = 16,
  };
  // repeated .world.Robot yellow = 3;
  int yellow_size() const;
  private:
  int _internal_yellow_size() const;
  public:
  void clear_yellow();
  ::world::Robot* mutable_yellow(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world::Robot >*
      mutable_yellow();
  private:
  const ::world::Robot& _internal_yellow(int index) const;
  ::world::Robot* _internal_add_yellow();
  public:
  const ::world::Robot& yellow(int index) const;
  ::world::Robot* add_yellow();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world::Robot >&
      yellow() const;

  // repeated .world.Robot blue = 4;
  int blue_size() const;
  private:
  int _internal_blue_size() const;
  public:
  void clear_blue();
  ::world::Robot* mutable_blue(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world::Robot >*
      mutable_blue();
  private:
  const ::world::Robot& _internal_blue(int index) const;
  ::world::Robot* _internal_add_blue();
  public:
  const ::world::Robot& blue(int index) const;
  ::world::Robot* add_blue();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world::Robot >&
      blue() const;

  // repeated .robot.RadioResponse radio_response = 5;
  int radio_response_size() const;
  private:
  int _internal_radio_response_size() const;
  public:
  void clear_radio_response();
  ::robot::RadioResponse* mutable_radio_response(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::RadioResponse >*
      mutable_radio_response();
  private:
  const ::robot::RadioResponse& _internal_radio_response(int index) const;
  ::robot::RadioResponse* _internal_add_radio_response();
  public:
  const ::robot::RadioResponse& radio_response(int index) const;
  ::robot::RadioResponse* add_radio_response();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::RadioResponse >&
      radio_response() const;

  // repeated .SSL_WrapperPacket vision_frames = 10;
  int vision_frames_size() const;
  private:
  int _internal_vision_frames_size() const;
  public:
  void clear_vision_frames();
  ::SSL_WrapperPacket* mutable_vision_frames(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SSL_WrapperPacket >*
      mutable_vision_frames();
  private:
  const ::SSL_WrapperPacket& _internal_vision_frames(int index) const;
  ::SSL_WrapperPacket* _internal_add_vision_frames();
  public:
  const ::SSL_WrapperPacket& vision_frames(int index) const;
  ::SSL_WrapperPacket* add_vision_frames();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SSL_WrapperPacket >&
      vision_frames() const;

  // repeated .world.Robot simple_tracking_yellow = 11;
  int simple_tracking_yellow_size() const;
  private:
  int _internal_simple_tracking_yellow_size() const;
  public:
  void clear_simple_tracking_yellow();
  ::world::Robot* mutable_simple_tracking_yellow(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world::Robot >*
      mutable_simple_tracking_yellow();
  private:
  const ::world::Robot& _internal_simple_tracking_yellow(int index) const;
  ::world::Robot* _internal_add_simple_tracking_yellow();
  public:
  const ::world::Robot& simple_tracking_yellow(int index) const;
  ::world::Robot* add_simple_tracking_yellow();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world::Robot >&
      simple_tracking_yellow() const;

  // repeated .world.Robot simple_tracking_blue = 12;
  int simple_tracking_blue_size() const;
  private:
  int _internal_simple_tracking_blue_size() const;
  public:
  void clear_simple_tracking_blue();
  ::world::Robot* mutable_simple_tracking_blue(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world::Robot >*
      mutable_simple_tracking_blue();
  private:
  const ::world::Robot& _internal_simple_tracking_blue(int index) const;
  ::world::Robot* _internal_add_simple_tracking_blue();
  public:
  const ::world::Robot& simple_tracking_blue(int index) const;
  ::world::Robot* add_simple_tracking_blue();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world::Robot >&
      simple_tracking_blue() const;

  // repeated .world.SimulatorState reality = 13;
  int reality_size() const;
  private:
  int _internal_reality_size() const;
  public:
  void clear_reality();
  ::world::SimulatorState* mutable_reality(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world::SimulatorState >*
      mutable_reality();
  private:
  const ::world::SimulatorState& _internal_reality(int index) const;
  ::world::SimulatorState* _internal_add_reality();
  public:
  const ::world::SimulatorState& reality(int index) const;
  ::world::SimulatorState* add_reality();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world::SimulatorState >&
      reality() const;

  // repeated int64 vision_frame_times = 14;
  int vision_frame_times_size() const;
  private:
  int _internal_vision_frame_times_size() const;
  public:
  void clear_vision_frame_times();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_vision_frame_times(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_vision_frame_times() const;
  void _internal_add_vision_frame_times(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_vision_frame_times();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 vision_frame_times(int index) const;
  void set_vision_frame_times(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_vision_frame_times(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      vision_frame_times() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_vision_frame_times();

  // optional .world.Ball ball = 2;
  bool has_ball() const;
  private:
  bool _internal_has_ball() const;
  public:
  void clear_ball();
  const ::world::Ball& ball() const;
  ::world::Ball* release_ball();
  ::world::Ball* mutable_ball();
  void set_allocated_ball(::world::Ball* ball);
  private:
  const ::world::Ball& _internal_ball() const;
  ::world::Ball* _internal_mutable_ball();
  public:
  void unsafe_arena_set_allocated_ball(
      ::world::Ball* ball);
  ::world::Ball* unsafe_arena_release_ball();

  // optional .ssl.TeamPlan mixed_team_info = 8;
  bool has_mixed_team_info() const;
  private:
  bool _internal_has_mixed_team_info() const;
  public:
  void clear_mixed_team_info();
  const ::ssl::TeamPlan& mixed_team_info() const;
  ::ssl::TeamPlan* release_mixed_team_info();
  ::ssl::TeamPlan* mutable_mixed_team_info();
  void set_allocated_mixed_team_info(::ssl::TeamPlan* mixed_team_info);
  private:
  const ::ssl::TeamPlan& _internal_mixed_team_info() const;
  ::ssl::TeamPlan* _internal_mutable_mixed_team_info();
  public:
  void unsafe_arena_set_allocated_mixed_team_info(
      ::ssl::TeamPlan* mixed_team_info);
  ::ssl::TeamPlan* unsafe_arena_release_mixed_team_info();

  // optional .world.TrackingAOI tracking_aoi = 9;
  bool has_tracking_aoi() const;
  private:
  bool _internal_has_tracking_aoi() const;
  public:
  void clear_tracking_aoi();
  const ::world::TrackingAOI& tracking_aoi() const;
  ::world::TrackingAOI* release_tracking_aoi();
  ::world::TrackingAOI* mutable_tracking_aoi();
  void set_allocated_tracking_aoi(::world::TrackingAOI* tracking_aoi);
  private:
  const ::world::TrackingAOI& _internal_tracking_aoi() const;
  ::world::TrackingAOI* _internal_mutable_tracking_aoi();
  public:
  void unsafe_arena_set_allocated_tracking_aoi(
      ::world::TrackingAOI* tracking_aoi);
  ::world::TrackingAOI* unsafe_arena_release_tracking_aoi();

  // optional .world.Ball simple_tracking_ball = 17;
  bool has_simple_tracking_ball() const;
  private:
  bool _internal_has_simple_tracking_ball() const;
  public:
  void clear_simple_tracking_ball();
  const ::world::Ball& simple_tracking_ball() const;
  ::world::Ball* release_simple_tracking_ball();
  ::world::Ball* mutable_simple_tracking_ball();
  void set_allocated_simple_tracking_ball(::world::Ball* simple_tracking_ball);
  private:
  const ::world::Ball& _internal_simple_tracking_ball() const;
  ::world::Ball* _internal_mutable_simple_tracking_ball();
  public:
  void unsafe_arena_set_allocated_simple_tracking_ball(
      ::world::Ball* simple_tracking_ball);
  ::world::Ball* unsafe_arena_release_simple_tracking_ball();

  // required int64 time = 1;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  ::PROTOBUF_NAMESPACE_ID::int64 time() const;
  void set_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_time() const;
  void _internal_set_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 system_delay = 15;
  bool has_system_delay() const;
  private:
  bool _internal_has_system_delay() const;
  public:
  void clear_system_delay();
  ::PROTOBUF_NAMESPACE_ID::int64 system_delay() const;
  void set_system_delay(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_system_delay() const;
  void _internal_set_system_delay(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional bool is_simulated = 6;
  bool has_is_simulated() const;
  private:
  bool _internal_has_is_simulated() const;
  public:
  void clear_is_simulated();
  bool is_simulated() const;
  void set_is_simulated(bool value);
  private:
  bool _internal_is_simulated() const;
  void _internal_set_is_simulated(bool value);
  public:

  // optional bool has_vision_data = 7;
  bool has_has_vision_data() const;
  private:
  bool _internal_has_has_vision_data() const;
  public:
  void clear_has_vision_data();
  bool has_vision_data() const;
  void set_has_vision_data(bool value);
  private:
  bool _internal_has_vision_data() const;
  void _internal_set_has_vision_data(bool value);
  public:

  // optional .world.WorldSource world_source = 16;
  bool has_world_source() const;
  private:
  bool _internal_has_world_source() const;
  public:
  void clear_world_source();
  ::world::WorldSource world_source() const;
  void set_world_source(::world::WorldSource value);
  private:
  ::world::WorldSource _internal_world_source() const;
  void _internal_set_world_source(::world::WorldSource value);
  public:

  // @@protoc_insertion_point(class_scope:world.State)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world::Robot > yellow_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world::Robot > blue_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::RadioResponse > radio_response_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SSL_WrapperPacket > vision_frames_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world::Robot > simple_tracking_yellow_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world::Robot > simple_tracking_blue_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world::SimulatorState > reality_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > vision_frame_times_;
  ::world::Ball* ball_;
  ::ssl::TeamPlan* mixed_team_info_;
  ::world::TrackingAOI* tracking_aoi_;
  ::world::Ball* simple_tracking_ball_;
  ::PROTOBUF_NAMESPACE_ID::int64 time_;
  ::PROTOBUF_NAMESPACE_ID::int64 system_delay_;
  bool is_simulated_;
  bool has_vision_data_;
  int world_source_;
  friend struct ::TableStruct_world_2eproto;
};
// -------------------------------------------------------------------

class SimulatorState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:world.SimulatorState) */ {
 public:
  inline SimulatorState() : SimulatorState(nullptr) {};
  virtual ~SimulatorState();

  SimulatorState(const SimulatorState& from);
  SimulatorState(SimulatorState&& from) noexcept
    : SimulatorState() {
    *this = ::std::move(from);
  }

  inline SimulatorState& operator=(const SimulatorState& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimulatorState& operator=(SimulatorState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SimulatorState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SimulatorState* internal_default_instance() {
    return reinterpret_cast<const SimulatorState*>(
               &_SimulatorState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SimulatorState& a, SimulatorState& b) {
    a.Swap(&b);
  }
  inline void Swap(SimulatorState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SimulatorState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SimulatorState* New() const final {
    return CreateMaybeMessage<SimulatorState>(nullptr);
  }

  SimulatorState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SimulatorState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SimulatorState& from);
  void MergeFrom(const SimulatorState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimulatorState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "world.SimulatorState";
  }
  protected:
  explicit SimulatorState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_world_2eproto);
    return ::descriptor_table_world_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlueRobotsFieldNumber = 1,
    kYellowRobotsFieldNumber = 2,
    kBallFieldNumber = 3,
    kTimeFieldNumber = 4,
  };
  // repeated .world.SimRobot blue_robots = 1;
  int blue_robots_size() const;
  private:
  int _internal_blue_robots_size() const;
  public:
  void clear_blue_robots();
  ::world::SimRobot* mutable_blue_robots(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world::SimRobot >*
      mutable_blue_robots();
  private:
  const ::world::SimRobot& _internal_blue_robots(int index) const;
  ::world::SimRobot* _internal_add_blue_robots();
  public:
  const ::world::SimRobot& blue_robots(int index) const;
  ::world::SimRobot* add_blue_robots();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world::SimRobot >&
      blue_robots() const;

  // repeated .world.SimRobot yellow_robots = 2;
  int yellow_robots_size() const;
  private:
  int _internal_yellow_robots_size() const;
  public:
  void clear_yellow_robots();
  ::world::SimRobot* mutable_yellow_robots(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world::SimRobot >*
      mutable_yellow_robots();
  private:
  const ::world::SimRobot& _internal_yellow_robots(int index) const;
  ::world::SimRobot* _internal_add_yellow_robots();
  public:
  const ::world::SimRobot& yellow_robots(int index) const;
  ::world::SimRobot* add_yellow_robots();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world::SimRobot >&
      yellow_robots() const;

  // optional .world.SimBall ball = 3;
  bool has_ball() const;
  private:
  bool _internal_has_ball() const;
  public:
  void clear_ball();
  const ::world::SimBall& ball() const;
  ::world::SimBall* release_ball();
  ::world::SimBall* mutable_ball();
  void set_allocated_ball(::world::SimBall* ball);
  private:
  const ::world::SimBall& _internal_ball() const;
  ::world::SimBall* _internal_mutable_ball();
  public:
  void unsafe_arena_set_allocated_ball(
      ::world::SimBall* ball);
  ::world::SimBall* unsafe_arena_release_ball();

  // optional int64 time = 4;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  ::PROTOBUF_NAMESPACE_ID::int64 time() const;
  void set_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_time() const;
  void _internal_set_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:world.SimulatorState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world::SimRobot > blue_robots_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world::SimRobot > yellow_robots_;
  ::world::SimBall* ball_;
  ::PROTOBUF_NAMESPACE_ID::int64 time_;
  friend struct ::TableStruct_world_2eproto;
};
// -------------------------------------------------------------------

class SimBall PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:world.SimBall) */ {
 public:
  inline SimBall() : SimBall(nullptr) {};
  virtual ~SimBall();

  SimBall(const SimBall& from);
  SimBall(SimBall&& from) noexcept
    : SimBall() {
    *this = ::std::move(from);
  }

  inline SimBall& operator=(const SimBall& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimBall& operator=(SimBall&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SimBall& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SimBall* internal_default_instance() {
    return reinterpret_cast<const SimBall*>(
               &_SimBall_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SimBall& a, SimBall& b) {
    a.Swap(&b);
  }
  inline void Swap(SimBall* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SimBall* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SimBall* New() const final {
    return CreateMaybeMessage<SimBall>(nullptr);
  }

  SimBall* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SimBall>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SimBall& from);
  void MergeFrom(const SimBall& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimBall* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "world.SimBall";
  }
  protected:
  explicit SimBall(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_world_2eproto);
    return ::descriptor_table_world_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPXFieldNumber = 1,
    kPYFieldNumber = 2,
    kPZFieldNumber = 3,
    kVXFieldNumber = 4,
    kVYFieldNumber = 5,
    kVZFieldNumber = 6,
    kAngularXFieldNumber = 7,
    kAngularYFieldNumber = 8,
    kAngularZFieldNumber = 9,
  };
  // required float p_x = 1;
  bool has_p_x() const;
  private:
  bool _internal_has_p_x() const;
  public:
  void clear_p_x();
  float p_x() const;
  void set_p_x(float value);
  private:
  float _internal_p_x() const;
  void _internal_set_p_x(float value);
  public:

  // required float p_y = 2;
  bool has_p_y() const;
  private:
  bool _internal_has_p_y() const;
  public:
  void clear_p_y();
  float p_y() const;
  void set_p_y(float value);
  private:
  float _internal_p_y() const;
  void _internal_set_p_y(float value);
  public:

  // required float p_z = 3;
  bool has_p_z() const;
  private:
  bool _internal_has_p_z() const;
  public:
  void clear_p_z();
  float p_z() const;
  void set_p_z(float value);
  private:
  float _internal_p_z() const;
  void _internal_set_p_z(float value);
  public:

  // required float v_x = 4;
  bool has_v_x() const;
  private:
  bool _internal_has_v_x() const;
  public:
  void clear_v_x();
  float v_x() const;
  void set_v_x(float value);
  private:
  float _internal_v_x() const;
  void _internal_set_v_x(float value);
  public:

  // required float v_y = 5;
  bool has_v_y() const;
  private:
  bool _internal_has_v_y() const;
  public:
  void clear_v_y();
  float v_y() const;
  void set_v_y(float value);
  private:
  float _internal_v_y() const;
  void _internal_set_v_y(float value);
  public:

  // required float v_z = 6;
  bool has_v_z() const;
  private:
  bool _internal_has_v_z() const;
  public:
  void clear_v_z();
  float v_z() const;
  void set_v_z(float value);
  private:
  float _internal_v_z() const;
  void _internal_set_v_z(float value);
  public:

  // optional float angular_x = 7;
  bool has_angular_x() const;
  private:
  bool _internal_has_angular_x() const;
  public:
  void clear_angular_x();
  float angular_x() const;
  void set_angular_x(float value);
  private:
  float _internal_angular_x() const;
  void _internal_set_angular_x(float value);
  public:

  // optional float angular_y = 8;
  bool has_angular_y() const;
  private:
  bool _internal_has_angular_y() const;
  public:
  void clear_angular_y();
  float angular_y() const;
  void set_angular_y(float value);
  private:
  float _internal_angular_y() const;
  void _internal_set_angular_y(float value);
  public:

  // optional float angular_z = 9;
  bool has_angular_z() const;
  private:
  bool _internal_has_angular_z() const;
  public:
  void clear_angular_z();
  float angular_z() const;
  void set_angular_z(float value);
  private:
  float _internal_angular_z() const;
  void _internal_set_angular_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:world.SimBall)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float p_x_;
  float p_y_;
  float p_z_;
  float v_x_;
  float v_y_;
  float v_z_;
  float angular_x_;
  float angular_y_;
  float angular_z_;
  friend struct ::TableStruct_world_2eproto;
};
// -------------------------------------------------------------------

class Quaternion PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:world.Quaternion) */ {
 public:
  inline Quaternion() : Quaternion(nullptr) {};
  virtual ~Quaternion();

  Quaternion(const Quaternion& from);
  Quaternion(Quaternion&& from) noexcept
    : Quaternion() {
    *this = ::std::move(from);
  }

  inline Quaternion& operator=(const Quaternion& from) {
    CopyFrom(from);
    return *this;
  }
  inline Quaternion& operator=(Quaternion&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Quaternion& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Quaternion* internal_default_instance() {
    return reinterpret_cast<const Quaternion*>(
               &_Quaternion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Quaternion& a, Quaternion& b) {
    a.Swap(&b);
  }
  inline void Swap(Quaternion* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Quaternion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Quaternion* New() const final {
    return CreateMaybeMessage<Quaternion>(nullptr);
  }

  Quaternion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Quaternion>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Quaternion& from);
  void MergeFrom(const Quaternion& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Quaternion* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "world.Quaternion";
  }
  protected:
  explicit Quaternion(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_world_2eproto);
    return ::descriptor_table_world_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIFieldNumber = 1,
    kJFieldNumber = 2,
    kKFieldNumber = 3,
    kRealFieldNumber = 4,
  };
  // required float i = 1;
  bool has_i() const;
  private:
  bool _internal_has_i() const;
  public:
  void clear_i();
  float i() const;
  void set_i(float value);
  private:
  float _internal_i() const;
  void _internal_set_i(float value);
  public:

  // required float j = 2;
  bool has_j() const;
  private:
  bool _internal_has_j() const;
  public:
  void clear_j();
  float j() const;
  void set_j(float value);
  private:
  float _internal_j() const;
  void _internal_set_j(float value);
  public:

  // required float k = 3;
  bool has_k() const;
  private:
  bool _internal_has_k() const;
  public:
  void clear_k();
  float k() const;
  void set_k(float value);
  private:
  float _internal_k() const;
  void _internal_set_k(float value);
  public:

  // required float real = 4;
  bool has_real() const;
  private:
  bool _internal_has_real() const;
  public:
  void clear_real();
  float real() const;
  void set_real(float value);
  private:
  float _internal_real() const;
  void _internal_set_real(float value);
  public:

  // @@protoc_insertion_point(class_scope:world.Quaternion)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float i_;
  float j_;
  float k_;
  float real_;
  friend struct ::TableStruct_world_2eproto;
};
// -------------------------------------------------------------------

class SimRobot PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:world.SimRobot) */ {
 public:
  inline SimRobot() : SimRobot(nullptr) {};
  virtual ~SimRobot();

  SimRobot(const SimRobot& from);
  SimRobot(SimRobot&& from) noexcept
    : SimRobot() {
    *this = ::std::move(from);
  }

  inline SimRobot& operator=(const SimRobot& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimRobot& operator=(SimRobot&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SimRobot& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SimRobot* internal_default_instance() {
    return reinterpret_cast<const SimRobot*>(
               &_SimRobot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SimRobot& a, SimRobot& b) {
    a.Swap(&b);
  }
  inline void Swap(SimRobot* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SimRobot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SimRobot* New() const final {
    return CreateMaybeMessage<SimRobot>(nullptr);
  }

  SimRobot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SimRobot>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SimRobot& from);
  void MergeFrom(const SimRobot& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimRobot* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "world.SimRobot";
  }
  protected:
  explicit SimRobot(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_world_2eproto);
    return ::descriptor_table_world_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRotationFieldNumber = 5,
    kIdFieldNumber = 1,
    kPXFieldNumber = 2,
    kPYFieldNumber = 3,
    kPZFieldNumber = 4,
    kVXFieldNumber = 6,
    kVYFieldNumber = 7,
    kVZFieldNumber = 8,
    kRXFieldNumber = 9,
    kRYFieldNumber = 10,
    kRZFieldNumber = 11,
    kTouchesBallFieldNumber = 12,
  };
  // required .world.Quaternion rotation = 5;
  bool has_rotation() const;
  private:
  bool _internal_has_rotation() const;
  public:
  void clear_rotation();
  const ::world::Quaternion& rotation() const;
  ::world::Quaternion* release_rotation();
  ::world::Quaternion* mutable_rotation();
  void set_allocated_rotation(::world::Quaternion* rotation);
  private:
  const ::world::Quaternion& _internal_rotation() const;
  ::world::Quaternion* _internal_mutable_rotation();
  public:
  void unsafe_arena_set_allocated_rotation(
      ::world::Quaternion* rotation);
  ::world::Quaternion* unsafe_arena_release_rotation();

  // required uint32 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required float p_x = 2;
  bool has_p_x() const;
  private:
  bool _internal_has_p_x() const;
  public:
  void clear_p_x();
  float p_x() const;
  void set_p_x(float value);
  private:
  float _internal_p_x() const;
  void _internal_set_p_x(float value);
  public:

  // required float p_y = 3;
  bool has_p_y() const;
  private:
  bool _internal_has_p_y() const;
  public:
  void clear_p_y();
  float p_y() const;
  void set_p_y(float value);
  private:
  float _internal_p_y() const;
  void _internal_set_p_y(float value);
  public:

  // required float p_z = 4;
  bool has_p_z() const;
  private:
  bool _internal_has_p_z() const;
  public:
  void clear_p_z();
  float p_z() const;
  void set_p_z(float value);
  private:
  float _internal_p_z() const;
  void _internal_set_p_z(float value);
  public:

  // required float v_x = 6;
  bool has_v_x() const;
  private:
  bool _internal_has_v_x() const;
  public:
  void clear_v_x();
  float v_x() const;
  void set_v_x(float value);
  private:
  float _internal_v_x() const;
  void _internal_set_v_x(float value);
  public:

  // required float v_y = 7;
  bool has_v_y() const;
  private:
  bool _internal_has_v_y() const;
  public:
  void clear_v_y();
  float v_y() const;
  void set_v_y(float value);
  private:
  float _internal_v_y() const;
  void _internal_set_v_y(float value);
  public:

  // required float v_z = 8;
  bool has_v_z() const;
  private:
  bool _internal_has_v_z() const;
  public:
  void clear_v_z();
  float v_z() const;
  void set_v_z(float value);
  private:
  float _internal_v_z() const;
  void _internal_set_v_z(float value);
  public:

  // required float r_x = 9;
  bool has_r_x() const;
  private:
  bool _internal_has_r_x() const;
  public:
  void clear_r_x();
  float r_x() const;
  void set_r_x(float value);
  private:
  float _internal_r_x() const;
  void _internal_set_r_x(float value);
  public:

  // required float r_y = 10;
  bool has_r_y() const;
  private:
  bool _internal_has_r_y() const;
  public:
  void clear_r_y();
  float r_y() const;
  void set_r_y(float value);
  private:
  float _internal_r_y() const;
  void _internal_set_r_y(float value);
  public:

  // required float r_z = 11;
  bool has_r_z() const;
  private:
  bool _internal_has_r_z() const;
  public:
  void clear_r_z();
  float r_z() const;
  void set_r_z(float value);
  private:
  float _internal_r_z() const;
  void _internal_set_r_z(float value);
  public:

  // optional bool touches_ball = 12;
  bool has_touches_ball() const;
  private:
  bool _internal_has_touches_ball() const;
  public:
  void clear_touches_ball();
  bool touches_ball() const;
  void set_touches_ball(bool value);
  private:
  bool _internal_touches_ball() const;
  void _internal_set_touches_ball(bool value);
  public:

  // @@protoc_insertion_point(class_scope:world.SimRobot)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::world::Quaternion* rotation_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  float p_x_;
  float p_y_;
  float p_z_;
  float v_x_;
  float v_y_;
  float v_z_;
  float r_x_;
  float r_y_;
  float r_z_;
  bool touches_ball_;
  friend struct ::TableStruct_world_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Geometry

// required float line_width = 1;
inline bool Geometry::_internal_has_line_width() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Geometry::has_line_width() const {
  return _internal_has_line_width();
}
inline void Geometry::clear_line_width() {
  line_width_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float Geometry::_internal_line_width() const {
  return line_width_;
}
inline float Geometry::line_width() const {
  // @@protoc_insertion_point(field_get:world.Geometry.line_width)
  return _internal_line_width();
}
inline void Geometry::_internal_set_line_width(float value) {
  _has_bits_[0] |= 0x00000002u;
  line_width_ = value;
}
inline void Geometry::set_line_width(float value) {
  _internal_set_line_width(value);
  // @@protoc_insertion_point(field_set:world.Geometry.line_width)
}

// required float field_width = 2;
inline bool Geometry::_internal_has_field_width() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Geometry::has_field_width() const {
  return _internal_has_field_width();
}
inline void Geometry::clear_field_width() {
  field_width_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float Geometry::_internal_field_width() const {
  return field_width_;
}
inline float Geometry::field_width() const {
  // @@protoc_insertion_point(field_get:world.Geometry.field_width)
  return _internal_field_width();
}
inline void Geometry::_internal_set_field_width(float value) {
  _has_bits_[0] |= 0x00000004u;
  field_width_ = value;
}
inline void Geometry::set_field_width(float value) {
  _internal_set_field_width(value);
  // @@protoc_insertion_point(field_set:world.Geometry.field_width)
}

// required float field_height = 3;
inline bool Geometry::_internal_has_field_height() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Geometry::has_field_height() const {
  return _internal_has_field_height();
}
inline void Geometry::clear_field_height() {
  field_height_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float Geometry::_internal_field_height() const {
  return field_height_;
}
inline float Geometry::field_height() const {
  // @@protoc_insertion_point(field_get:world.Geometry.field_height)
  return _internal_field_height();
}
inline void Geometry::_internal_set_field_height(float value) {
  _has_bits_[0] |= 0x00000008u;
  field_height_ = value;
}
inline void Geometry::set_field_height(float value) {
  _internal_set_field_height(value);
  // @@protoc_insertion_point(field_set:world.Geometry.field_height)
}

// required float boundary_width = 4;
inline bool Geometry::_internal_has_boundary_width() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Geometry::has_boundary_width() const {
  return _internal_has_boundary_width();
}
inline void Geometry::clear_boundary_width() {
  boundary_width_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float Geometry::_internal_boundary_width() const {
  return boundary_width_;
}
inline float Geometry::boundary_width() const {
  // @@protoc_insertion_point(field_get:world.Geometry.boundary_width)
  return _internal_boundary_width();
}
inline void Geometry::_internal_set_boundary_width(float value) {
  _has_bits_[0] |= 0x00000010u;
  boundary_width_ = value;
}
inline void Geometry::set_boundary_width(float value) {
  _internal_set_boundary_width(value);
  // @@protoc_insertion_point(field_set:world.Geometry.boundary_width)
}

// required float goal_width = 6;
inline bool Geometry::_internal_has_goal_width() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Geometry::has_goal_width() const {
  return _internal_has_goal_width();
}
inline void Geometry::clear_goal_width() {
  goal_width_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline float Geometry::_internal_goal_width() const {
  return goal_width_;
}
inline float Geometry::goal_width() const {
  // @@protoc_insertion_point(field_get:world.Geometry.goal_width)
  return _internal_goal_width();
}
inline void Geometry::_internal_set_goal_width(float value) {
  _has_bits_[0] |= 0x00000020u;
  goal_width_ = value;
}
inline void Geometry::set_goal_width(float value) {
  _internal_set_goal_width(value);
  // @@protoc_insertion_point(field_set:world.Geometry.goal_width)
}

// required float goal_depth = 7;
inline bool Geometry::_internal_has_goal_depth() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Geometry::has_goal_depth() const {
  return _internal_has_goal_depth();
}
inline void Geometry::clear_goal_depth() {
  goal_depth_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline float Geometry::_internal_goal_depth() const {
  return goal_depth_;
}
inline float Geometry::goal_depth() const {
  // @@protoc_insertion_point(field_get:world.Geometry.goal_depth)
  return _internal_goal_depth();
}
inline void Geometry::_internal_set_goal_depth(float value) {
  _has_bits_[0] |= 0x00000040u;
  goal_depth_ = value;
}
inline void Geometry::set_goal_depth(float value) {
  _internal_set_goal_depth(value);
  // @@protoc_insertion_point(field_set:world.Geometry.goal_depth)
}

// required float goal_wall_width = 8;
inline bool Geometry::_internal_has_goal_wall_width() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Geometry::has_goal_wall_width() const {
  return _internal_has_goal_wall_width();
}
inline void Geometry::clear_goal_wall_width() {
  goal_wall_width_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline float Geometry::_internal_goal_wall_width() const {
  return goal_wall_width_;
}
inline float Geometry::goal_wall_width() const {
  // @@protoc_insertion_point(field_get:world.Geometry.goal_wall_width)
  return _internal_goal_wall_width();
}
inline void Geometry::_internal_set_goal_wall_width(float value) {
  _has_bits_[0] |= 0x00000080u;
  goal_wall_width_ = value;
}
inline void Geometry::set_goal_wall_width(float value) {
  _internal_set_goal_wall_width(value);
  // @@protoc_insertion_point(field_set:world.Geometry.goal_wall_width)
}

// required float center_circle_radius = 9;
inline bool Geometry::_internal_has_center_circle_radius() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Geometry::has_center_circle_radius() const {
  return _internal_has_center_circle_radius();
}
inline void Geometry::clear_center_circle_radius() {
  center_circle_radius_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline float Geometry::_internal_center_circle_radius() const {
  return center_circle_radius_;
}
inline float Geometry::center_circle_radius() const {
  // @@protoc_insertion_point(field_get:world.Geometry.center_circle_radius)
  return _internal_center_circle_radius();
}
inline void Geometry::_internal_set_center_circle_radius(float value) {
  _has_bits_[0] |= 0x00000100u;
  center_circle_radius_ = value;
}
inline void Geometry::set_center_circle_radius(float value) {
  _internal_set_center_circle_radius(value);
  // @@protoc_insertion_point(field_set:world.Geometry.center_circle_radius)
}

// required float defense_radius = 10;
inline bool Geometry::_internal_has_defense_radius() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Geometry::has_defense_radius() const {
  return _internal_has_defense_radius();
}
inline void Geometry::clear_defense_radius() {
  defense_radius_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline float Geometry::_internal_defense_radius() const {
  return defense_radius_;
}
inline float Geometry::defense_radius() const {
  // @@protoc_insertion_point(field_get:world.Geometry.defense_radius)
  return _internal_defense_radius();
}
inline void Geometry::_internal_set_defense_radius(float value) {
  _has_bits_[0] |= 0x00000200u;
  defense_radius_ = value;
}
inline void Geometry::set_defense_radius(float value) {
  _internal_set_defense_radius(value);
  // @@protoc_insertion_point(field_set:world.Geometry.defense_radius)
}

// required float defense_stretch = 11;
inline bool Geometry::_internal_has_defense_stretch() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool Geometry::has_defense_stretch() const {
  return _internal_has_defense_stretch();
}
inline void Geometry::clear_defense_stretch() {
  defense_stretch_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline float Geometry::_internal_defense_stretch() const {
  return defense_stretch_;
}
inline float Geometry::defense_stretch() const {
  // @@protoc_insertion_point(field_get:world.Geometry.defense_stretch)
  return _internal_defense_stretch();
}
inline void Geometry::_internal_set_defense_stretch(float value) {
  _has_bits_[0] |= 0x00000400u;
  defense_stretch_ = value;
}
inline void Geometry::set_defense_stretch(float value) {
  _internal_set_defense_stretch(value);
  // @@protoc_insertion_point(field_set:world.Geometry.defense_stretch)
}

// required float free_kick_from_defense_dist = 12;
inline bool Geometry::_internal_has_free_kick_from_defense_dist() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool Geometry::has_free_kick_from_defense_dist() const {
  return _internal_has_free_kick_from_defense_dist();
}
inline void Geometry::clear_free_kick_from_defense_dist() {
  free_kick_from_defense_dist_ = 0;
  _has_bits_[0] &= ~0x00000800u;
}
inline float Geometry::_internal_free_kick_from_defense_dist() const {
  return free_kick_from_defense_dist_;
}
inline float Geometry::free_kick_from_defense_dist() const {
  // @@protoc_insertion_point(field_get:world.Geometry.free_kick_from_defense_dist)
  return _internal_free_kick_from_defense_dist();
}
inline void Geometry::_internal_set_free_kick_from_defense_dist(float value) {
  _has_bits_[0] |= 0x00000800u;
  free_kick_from_defense_dist_ = value;
}
inline void Geometry::set_free_kick_from_defense_dist(float value) {
  _internal_set_free_kick_from_defense_dist(value);
  // @@protoc_insertion_point(field_set:world.Geometry.free_kick_from_defense_dist)
}

// required float penalty_spot_from_field_line_dist = 13;
inline bool Geometry::_internal_has_penalty_spot_from_field_line_dist() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool Geometry::has_penalty_spot_from_field_line_dist() const {
  return _internal_has_penalty_spot_from_field_line_dist();
}
inline void Geometry::clear_penalty_spot_from_field_line_dist() {
  penalty_spot_from_field_line_dist_ = 0;
  _has_bits_[0] &= ~0x00001000u;
}
inline float Geometry::_internal_penalty_spot_from_field_line_dist() const {
  return penalty_spot_from_field_line_dist_;
}
inline float Geometry::penalty_spot_from_field_line_dist() const {
  // @@protoc_insertion_point(field_get:world.Geometry.penalty_spot_from_field_line_dist)
  return _internal_penalty_spot_from_field_line_dist();
}
inline void Geometry::_internal_set_penalty_spot_from_field_line_dist(float value) {
  _has_bits_[0] |= 0x00001000u;
  penalty_spot_from_field_line_dist_ = value;
}
inline void Geometry::set_penalty_spot_from_field_line_dist(float value) {
  _internal_set_penalty_spot_from_field_line_dist(value);
  // @@protoc_insertion_point(field_set:world.Geometry.penalty_spot_from_field_line_dist)
}

// required float penalty_line_from_spot_dist = 14;
inline bool Geometry::_internal_has_penalty_line_from_spot_dist() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool Geometry::has_penalty_line_from_spot_dist() const {
  return _internal_has_penalty_line_from_spot_dist();
}
inline void Geometry::clear_penalty_line_from_spot_dist() {
  penalty_line_from_spot_dist_ = 0;
  _has_bits_[0] &= ~0x00002000u;
}
inline float Geometry::_internal_penalty_line_from_spot_dist() const {
  return penalty_line_from_spot_dist_;
}
inline float Geometry::penalty_line_from_spot_dist() const {
  // @@protoc_insertion_point(field_get:world.Geometry.penalty_line_from_spot_dist)
  return _internal_penalty_line_from_spot_dist();
}
inline void Geometry::_internal_set_penalty_line_from_spot_dist(float value) {
  _has_bits_[0] |= 0x00002000u;
  penalty_line_from_spot_dist_ = value;
}
inline void Geometry::set_penalty_line_from_spot_dist(float value) {
  _internal_set_penalty_line_from_spot_dist(value);
  // @@protoc_insertion_point(field_set:world.Geometry.penalty_line_from_spot_dist)
}

// required float goal_height = 15;
inline bool Geometry::_internal_has_goal_height() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool Geometry::has_goal_height() const {
  return _internal_has_goal_height();
}
inline void Geometry::clear_goal_height() {
  goal_height_ = 0;
  _has_bits_[0] &= ~0x00004000u;
}
inline float Geometry::_internal_goal_height() const {
  return goal_height_;
}
inline float Geometry::goal_height() const {
  // @@protoc_insertion_point(field_get:world.Geometry.goal_height)
  return _internal_goal_height();
}
inline void Geometry::_internal_set_goal_height(float value) {
  _has_bits_[0] |= 0x00004000u;
  goal_height_ = value;
}
inline void Geometry::set_goal_height(float value) {
  _internal_set_goal_height(value);
  // @@protoc_insertion_point(field_set:world.Geometry.goal_height)
}

// optional float defense_width = 16 [default = 2];
inline bool Geometry::_internal_has_defense_width() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool Geometry::has_defense_width() const {
  return _internal_has_defense_width();
}
inline void Geometry::clear_defense_width() {
  defense_width_ = 2;
  _has_bits_[0] &= ~0x00010000u;
}
inline float Geometry::_internal_defense_width() const {
  return defense_width_;
}
inline float Geometry::defense_width() const {
  // @@protoc_insertion_point(field_get:world.Geometry.defense_width)
  return _internal_defense_width();
}
inline void Geometry::_internal_set_defense_width(float value) {
  _has_bits_[0] |= 0x00010000u;
  defense_width_ = value;
}
inline void Geometry::set_defense_width(float value) {
  _internal_set_defense_width(value);
  // @@protoc_insertion_point(field_set:world.Geometry.defense_width)
}

// optional float defense_height = 17 [default = 1];
inline bool Geometry::_internal_has_defense_height() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool Geometry::has_defense_height() const {
  return _internal_has_defense_height();
}
inline void Geometry::clear_defense_height() {
  defense_height_ = 1;
  _has_bits_[0] &= ~0x00020000u;
}
inline float Geometry::_internal_defense_height() const {
  return defense_height_;
}
inline float Geometry::defense_height() const {
  // @@protoc_insertion_point(field_get:world.Geometry.defense_height)
  return _internal_defense_height();
}
inline void Geometry::_internal_set_defense_height(float value) {
  _has_bits_[0] |= 0x00020000u;
  defense_height_ = value;
}
inline void Geometry::set_defense_height(float value) {
  _internal_set_defense_height(value);
  // @@protoc_insertion_point(field_set:world.Geometry.defense_height)
}

// optional .world.Geometry.GeometryType type = 18 [default = TYPE_2014];
inline bool Geometry::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool Geometry::has_type() const {
  return _internal_has_type();
}
inline void Geometry::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00040000u;
}
inline ::world::Geometry_GeometryType Geometry::_internal_type() const {
  return static_cast< ::world::Geometry_GeometryType >(type_);
}
inline ::world::Geometry_GeometryType Geometry::type() const {
  // @@protoc_insertion_point(field_get:world.Geometry.type)
  return _internal_type();
}
inline void Geometry::_internal_set_type(::world::Geometry_GeometryType value) {
  assert(::world::Geometry_GeometryType_IsValid(value));
  _has_bits_[0] |= 0x00040000u;
  type_ = value;
}
inline void Geometry::set_type(::world::Geometry_GeometryType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:world.Geometry.type)
}

// optional .world.Geometry.Division division = 19 [default = A];
inline bool Geometry::_internal_has_division() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool Geometry::has_division() const {
  return _internal_has_division();
}
inline void Geometry::clear_division() {
  division_ = 1;
  _has_bits_[0] &= ~0x00080000u;
}
inline ::world::Geometry_Division Geometry::_internal_division() const {
  return static_cast< ::world::Geometry_Division >(division_);
}
inline ::world::Geometry_Division Geometry::division() const {
  // @@protoc_insertion_point(field_get:world.Geometry.division)
  return _internal_division();
}
inline void Geometry::_internal_set_division(::world::Geometry_Division value) {
  assert(::world::Geometry_Division_IsValid(value));
  _has_bits_[0] |= 0x00080000u;
  division_ = value;
}
inline void Geometry::set_division(::world::Geometry_Division value) {
  _internal_set_division(value);
  // @@protoc_insertion_point(field_set:world.Geometry.division)
}

// optional .world.BallModel ball_model = 20;
inline bool Geometry::_internal_has_ball_model() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || ball_model_ != nullptr);
  return value;
}
inline bool Geometry::has_ball_model() const {
  return _internal_has_ball_model();
}
inline void Geometry::clear_ball_model() {
  if (ball_model_ != nullptr) ball_model_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::world::BallModel& Geometry::_internal_ball_model() const {
  const ::world::BallModel* p = ball_model_;
  return p != nullptr ? *p : *reinterpret_cast<const ::world::BallModel*>(
      &::world::_BallModel_default_instance_);
}
inline const ::world::BallModel& Geometry::ball_model() const {
  // @@protoc_insertion_point(field_get:world.Geometry.ball_model)
  return _internal_ball_model();
}
inline void Geometry::unsafe_arena_set_allocated_ball_model(
    ::world::BallModel* ball_model) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ball_model_);
  }
  ball_model_ = ball_model;
  if (ball_model) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world.Geometry.ball_model)
}
inline ::world::BallModel* Geometry::release_ball_model() {
  auto temp = unsafe_arena_release_ball_model();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::world::BallModel* Geometry::unsafe_arena_release_ball_model() {
  // @@protoc_insertion_point(field_release:world.Geometry.ball_model)
  _has_bits_[0] &= ~0x00000001u;
  ::world::BallModel* temp = ball_model_;
  ball_model_ = nullptr;
  return temp;
}
inline ::world::BallModel* Geometry::_internal_mutable_ball_model() {
  _has_bits_[0] |= 0x00000001u;
  if (ball_model_ == nullptr) {
    auto* p = CreateMaybeMessage<::world::BallModel>(GetArena());
    ball_model_ = p;
  }
  return ball_model_;
}
inline ::world::BallModel* Geometry::mutable_ball_model() {
  // @@protoc_insertion_point(field_mutable:world.Geometry.ball_model)
  return _internal_mutable_ball_model();
}
inline void Geometry::set_allocated_ball_model(::world::BallModel* ball_model) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete ball_model_;
  }
  if (ball_model) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(ball_model);
    if (message_arena != submessage_arena) {
      ball_model = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ball_model, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ball_model_ = ball_model;
  // @@protoc_insertion_point(field_set_allocated:world.Geometry.ball_model)
}

// optional float corner_block_cathetus_length = 21;
inline bool Geometry::_internal_has_corner_block_cathetus_length() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool Geometry::has_corner_block_cathetus_length() const {
  return _internal_has_corner_block_cathetus_length();
}
inline void Geometry::clear_corner_block_cathetus_length() {
  corner_block_cathetus_length_ = 0;
  _has_bits_[0] &= ~0x00008000u;
}
inline float Geometry::_internal_corner_block_cathetus_length() const {
  return corner_block_cathetus_length_;
}
inline float Geometry::corner_block_cathetus_length() const {
  // @@protoc_insertion_point(field_get:world.Geometry.corner_block_cathetus_length)
  return _internal_corner_block_cathetus_length();
}
inline void Geometry::_internal_set_corner_block_cathetus_length(float value) {
  _has_bits_[0] |= 0x00008000u;
  corner_block_cathetus_length_ = value;
}
inline void Geometry::set_corner_block_cathetus_length(float value) {
  _internal_set_corner_block_cathetus_length(value);
  // @@protoc_insertion_point(field_set:world.Geometry.corner_block_cathetus_length)
}

// -------------------------------------------------------------------

// BallModel

// optional float fast_deceleration = 1;
inline bool BallModel::_internal_has_fast_deceleration() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BallModel::has_fast_deceleration() const {
  return _internal_has_fast_deceleration();
}
inline void BallModel::clear_fast_deceleration() {
  fast_deceleration_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float BallModel::_internal_fast_deceleration() const {
  return fast_deceleration_;
}
inline float BallModel::fast_deceleration() const {
  // @@protoc_insertion_point(field_get:world.BallModel.fast_deceleration)
  return _internal_fast_deceleration();
}
inline void BallModel::_internal_set_fast_deceleration(float value) {
  _has_bits_[0] |= 0x00000001u;
  fast_deceleration_ = value;
}
inline void BallModel::set_fast_deceleration(float value) {
  _internal_set_fast_deceleration(value);
  // @@protoc_insertion_point(field_set:world.BallModel.fast_deceleration)
}

// optional float slow_deceleration = 2;
inline bool BallModel::_internal_has_slow_deceleration() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BallModel::has_slow_deceleration() const {
  return _internal_has_slow_deceleration();
}
inline void BallModel::clear_slow_deceleration() {
  slow_deceleration_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float BallModel::_internal_slow_deceleration() const {
  return slow_deceleration_;
}
inline float BallModel::slow_deceleration() const {
  // @@protoc_insertion_point(field_get:world.BallModel.slow_deceleration)
  return _internal_slow_deceleration();
}
inline void BallModel::_internal_set_slow_deceleration(float value) {
  _has_bits_[0] |= 0x00000002u;
  slow_deceleration_ = value;
}
inline void BallModel::set_slow_deceleration(float value) {
  _internal_set_slow_deceleration(value);
  // @@protoc_insertion_point(field_set:world.BallModel.slow_deceleration)
}

// optional float switch_ratio = 3;
inline bool BallModel::_internal_has_switch_ratio() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BallModel::has_switch_ratio() const {
  return _internal_has_switch_ratio();
}
inline void BallModel::clear_switch_ratio() {
  switch_ratio_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float BallModel::_internal_switch_ratio() const {
  return switch_ratio_;
}
inline float BallModel::switch_ratio() const {
  // @@protoc_insertion_point(field_get:world.BallModel.switch_ratio)
  return _internal_switch_ratio();
}
inline void BallModel::_internal_set_switch_ratio(float value) {
  _has_bits_[0] |= 0x00000004u;
  switch_ratio_ = value;
}
inline void BallModel::set_switch_ratio(float value) {
  _internal_set_switch_ratio(value);
  // @@protoc_insertion_point(field_set:world.BallModel.switch_ratio)
}

// optional float z_damping = 4;
inline bool BallModel::_internal_has_z_damping() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool BallModel::has_z_damping() const {
  return _internal_has_z_damping();
}
inline void BallModel::clear_z_damping() {
  z_damping_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float BallModel::_internal_z_damping() const {
  return z_damping_;
}
inline float BallModel::z_damping() const {
  // @@protoc_insertion_point(field_get:world.BallModel.z_damping)
  return _internal_z_damping();
}
inline void BallModel::_internal_set_z_damping(float value) {
  _has_bits_[0] |= 0x00000008u;
  z_damping_ = value;
}
inline void BallModel::set_z_damping(float value) {
  _internal_set_z_damping(value);
  // @@protoc_insertion_point(field_set:world.BallModel.z_damping)
}

// optional float xy_damping = 5;
inline bool BallModel::_internal_has_xy_damping() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool BallModel::has_xy_damping() const {
  return _internal_has_xy_damping();
}
inline void BallModel::clear_xy_damping() {
  xy_damping_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float BallModel::_internal_xy_damping() const {
  return xy_damping_;
}
inline float BallModel::xy_damping() const {
  // @@protoc_insertion_point(field_get:world.BallModel.xy_damping)
  return _internal_xy_damping();
}
inline void BallModel::_internal_set_xy_damping(float value) {
  _has_bits_[0] |= 0x00000010u;
  xy_damping_ = value;
}
inline void BallModel::set_xy_damping(float value) {
  _internal_set_xy_damping(value);
  // @@protoc_insertion_point(field_set:world.BallModel.xy_damping)
}

// -------------------------------------------------------------------

// DivisionDimensions

// required float field_width_a = 1;
inline bool DivisionDimensions::_internal_has_field_width_a() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DivisionDimensions::has_field_width_a() const {
  return _internal_has_field_width_a();
}
inline void DivisionDimensions::clear_field_width_a() {
  field_width_a_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float DivisionDimensions::_internal_field_width_a() const {
  return field_width_a_;
}
inline float DivisionDimensions::field_width_a() const {
  // @@protoc_insertion_point(field_get:world.DivisionDimensions.field_width_a)
  return _internal_field_width_a();
}
inline void DivisionDimensions::_internal_set_field_width_a(float value) {
  _has_bits_[0] |= 0x00000001u;
  field_width_a_ = value;
}
inline void DivisionDimensions::set_field_width_a(float value) {
  _internal_set_field_width_a(value);
  // @@protoc_insertion_point(field_set:world.DivisionDimensions.field_width_a)
}

// required float field_height_a = 2;
inline bool DivisionDimensions::_internal_has_field_height_a() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DivisionDimensions::has_field_height_a() const {
  return _internal_has_field_height_a();
}
inline void DivisionDimensions::clear_field_height_a() {
  field_height_a_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float DivisionDimensions::_internal_field_height_a() const {
  return field_height_a_;
}
inline float DivisionDimensions::field_height_a() const {
  // @@protoc_insertion_point(field_get:world.DivisionDimensions.field_height_a)
  return _internal_field_height_a();
}
inline void DivisionDimensions::_internal_set_field_height_a(float value) {
  _has_bits_[0] |= 0x00000002u;
  field_height_a_ = value;
}
inline void DivisionDimensions::set_field_height_a(float value) {
  _internal_set_field_height_a(value);
  // @@protoc_insertion_point(field_set:world.DivisionDimensions.field_height_a)
}

// required float field_width_b = 3;
inline bool DivisionDimensions::_internal_has_field_width_b() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DivisionDimensions::has_field_width_b() const {
  return _internal_has_field_width_b();
}
inline void DivisionDimensions::clear_field_width_b() {
  field_width_b_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float DivisionDimensions::_internal_field_width_b() const {
  return field_width_b_;
}
inline float DivisionDimensions::field_width_b() const {
  // @@protoc_insertion_point(field_get:world.DivisionDimensions.field_width_b)
  return _internal_field_width_b();
}
inline void DivisionDimensions::_internal_set_field_width_b(float value) {
  _has_bits_[0] |= 0x00000004u;
  field_width_b_ = value;
}
inline void DivisionDimensions::set_field_width_b(float value) {
  _internal_set_field_width_b(value);
  // @@protoc_insertion_point(field_set:world.DivisionDimensions.field_width_b)
}

// required float field_height_b = 4;
inline bool DivisionDimensions::_internal_has_field_height_b() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DivisionDimensions::has_field_height_b() const {
  return _internal_has_field_height_b();
}
inline void DivisionDimensions::clear_field_height_b() {
  field_height_b_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float DivisionDimensions::_internal_field_height_b() const {
  return field_height_b_;
}
inline float DivisionDimensions::field_height_b() const {
  // @@protoc_insertion_point(field_get:world.DivisionDimensions.field_height_b)
  return _internal_field_height_b();
}
inline void DivisionDimensions::_internal_set_field_height_b(float value) {
  _has_bits_[0] |= 0x00000008u;
  field_height_b_ = value;
}
inline void DivisionDimensions::set_field_height_b(float value) {
  _internal_set_field_height_b(value);
  // @@protoc_insertion_point(field_set:world.DivisionDimensions.field_height_b)
}

// -------------------------------------------------------------------

// BallPosition

// required int64 time = 1;
inline bool BallPosition::_internal_has_time() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BallPosition::has_time() const {
  return _internal_has_time();
}
inline void BallPosition::clear_time() {
  time_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BallPosition::_internal_time() const {
  return time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BallPosition::time() const {
  // @@protoc_insertion_point(field_get:world.BallPosition.time)
  return _internal_time();
}
inline void BallPosition::_internal_set_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  time_ = value;
}
inline void BallPosition::set_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:world.BallPosition.time)
}

// required float p_x = 2;
inline bool BallPosition::_internal_has_p_x() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BallPosition::has_p_x() const {
  return _internal_has_p_x();
}
inline void BallPosition::clear_p_x() {
  p_x_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float BallPosition::_internal_p_x() const {
  return p_x_;
}
inline float BallPosition::p_x() const {
  // @@protoc_insertion_point(field_get:world.BallPosition.p_x)
  return _internal_p_x();
}
inline void BallPosition::_internal_set_p_x(float value) {
  _has_bits_[0] |= 0x00000002u;
  p_x_ = value;
}
inline void BallPosition::set_p_x(float value) {
  _internal_set_p_x(value);
  // @@protoc_insertion_point(field_set:world.BallPosition.p_x)
}

// required float p_y = 3;
inline bool BallPosition::_internal_has_p_y() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BallPosition::has_p_y() const {
  return _internal_has_p_y();
}
inline void BallPosition::clear_p_y() {
  p_y_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float BallPosition::_internal_p_y() const {
  return p_y_;
}
inline float BallPosition::p_y() const {
  // @@protoc_insertion_point(field_get:world.BallPosition.p_y)
  return _internal_p_y();
}
inline void BallPosition::_internal_set_p_y(float value) {
  _has_bits_[0] |= 0x00000004u;
  p_y_ = value;
}
inline void BallPosition::set_p_y(float value) {
  _internal_set_p_y(value);
  // @@protoc_insertion_point(field_set:world.BallPosition.p_y)
}

// optional float derived_z = 10;
inline bool BallPosition::_internal_has_derived_z() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool BallPosition::has_derived_z() const {
  return _internal_has_derived_z();
}
inline void BallPosition::clear_derived_z() {
  derived_z_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline float BallPosition::_internal_derived_z() const {
  return derived_z_;
}
inline float BallPosition::derived_z() const {
  // @@protoc_insertion_point(field_get:world.BallPosition.derived_z)
  return _internal_derived_z();
}
inline void BallPosition::_internal_set_derived_z(float value) {
  _has_bits_[0] |= 0x00000100u;
  derived_z_ = value;
}
inline void BallPosition::set_derived_z(float value) {
  _internal_set_derived_z(value);
  // @@protoc_insertion_point(field_set:world.BallPosition.derived_z)
}

// optional float v_x = 5;
inline bool BallPosition::_internal_has_v_x() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool BallPosition::has_v_x() const {
  return _internal_has_v_x();
}
inline void BallPosition::clear_v_x() {
  v_x_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float BallPosition::_internal_v_x() const {
  return v_x_;
}
inline float BallPosition::v_x() const {
  // @@protoc_insertion_point(field_get:world.BallPosition.v_x)
  return _internal_v_x();
}
inline void BallPosition::_internal_set_v_x(float value) {
  _has_bits_[0] |= 0x00000008u;
  v_x_ = value;
}
inline void BallPosition::set_v_x(float value) {
  _internal_set_v_x(value);
  // @@protoc_insertion_point(field_set:world.BallPosition.v_x)
}

// optional float v_y = 6;
inline bool BallPosition::_internal_has_v_y() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool BallPosition::has_v_y() const {
  return _internal_has_v_y();
}
inline void BallPosition::clear_v_y() {
  v_y_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float BallPosition::_internal_v_y() const {
  return v_y_;
}
inline float BallPosition::v_y() const {
  // @@protoc_insertion_point(field_get:world.BallPosition.v_y)
  return _internal_v_y();
}
inline void BallPosition::_internal_set_v_y(float value) {
  _has_bits_[0] |= 0x00000010u;
  v_y_ = value;
}
inline void BallPosition::set_v_y(float value) {
  _internal_set_v_y(value);
  // @@protoc_insertion_point(field_set:world.BallPosition.v_y)
}

// optional float system_delay = 7;
inline bool BallPosition::_internal_has_system_delay() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool BallPosition::has_system_delay() const {
  return _internal_has_system_delay();
}
inline void BallPosition::clear_system_delay() {
  system_delay_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline float BallPosition::_internal_system_delay() const {
  return system_delay_;
}
inline float BallPosition::system_delay() const {
  // @@protoc_insertion_point(field_get:world.BallPosition.system_delay)
  return _internal_system_delay();
}
inline void BallPosition::_internal_set_system_delay(float value) {
  _has_bits_[0] |= 0x00000020u;
  system_delay_ = value;
}
inline void BallPosition::set_system_delay(float value) {
  _internal_set_system_delay(value);
  // @@protoc_insertion_point(field_set:world.BallPosition.system_delay)
}

// optional float time_diff_scaled = 8;
inline bool BallPosition::_internal_has_time_diff_scaled() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool BallPosition::has_time_diff_scaled() const {
  return _internal_has_time_diff_scaled();
}
inline void BallPosition::clear_time_diff_scaled() {
  time_diff_scaled_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline float BallPosition::_internal_time_diff_scaled() const {
  return time_diff_scaled_;
}
inline float BallPosition::time_diff_scaled() const {
  // @@protoc_insertion_point(field_get:world.BallPosition.time_diff_scaled)
  return _internal_time_diff_scaled();
}
inline void BallPosition::_internal_set_time_diff_scaled(float value) {
  _has_bits_[0] |= 0x00000040u;
  time_diff_scaled_ = value;
}
inline void BallPosition::set_time_diff_scaled(float value) {
  _internal_set_time_diff_scaled(value);
  // @@protoc_insertion_point(field_set:world.BallPosition.time_diff_scaled)
}

// optional uint32 camera_id = 9;
inline bool BallPosition::_internal_has_camera_id() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool BallPosition::has_camera_id() const {
  return _internal_has_camera_id();
}
inline void BallPosition::clear_camera_id() {
  camera_id_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 BallPosition::_internal_camera_id() const {
  return camera_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 BallPosition::camera_id() const {
  // @@protoc_insertion_point(field_get:world.BallPosition.camera_id)
  return _internal_camera_id();
}
inline void BallPosition::_internal_set_camera_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  camera_id_ = value;
}
inline void BallPosition::set_camera_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_camera_id(value);
  // @@protoc_insertion_point(field_set:world.BallPosition.camera_id)
}

// optional float area = 11;
inline bool BallPosition::_internal_has_area() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool BallPosition::has_area() const {
  return _internal_has_area();
}
inline void BallPosition::clear_area() {
  area_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline float BallPosition::_internal_area() const {
  return area_;
}
inline float BallPosition::area() const {
  // @@protoc_insertion_point(field_get:world.BallPosition.area)
  return _internal_area();
}
inline void BallPosition::_internal_set_area(float value) {
  _has_bits_[0] |= 0x00000400u;
  area_ = value;
}
inline void BallPosition::set_area(float value) {
  _internal_set_area(value);
  // @@protoc_insertion_point(field_set:world.BallPosition.area)
}

// optional int64 vision_processing_time = 12;
inline bool BallPosition::_internal_has_vision_processing_time() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool BallPosition::has_vision_processing_time() const {
  return _internal_has_vision_processing_time();
}
inline void BallPosition::clear_vision_processing_time() {
  vision_processing_time_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BallPosition::_internal_vision_processing_time() const {
  return vision_processing_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BallPosition::vision_processing_time() const {
  // @@protoc_insertion_point(field_get:world.BallPosition.vision_processing_time)
  return _internal_vision_processing_time();
}
inline void BallPosition::_internal_set_vision_processing_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000200u;
  vision_processing_time_ = value;
}
inline void BallPosition::set_vision_processing_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_vision_processing_time(value);
  // @@protoc_insertion_point(field_set:world.BallPosition.vision_processing_time)
}

// -------------------------------------------------------------------

// Ball

// required float p_x = 1;
inline bool Ball::_internal_has_p_x() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Ball::has_p_x() const {
  return _internal_has_p_x();
}
inline void Ball::clear_p_x() {
  p_x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float Ball::_internal_p_x() const {
  return p_x_;
}
inline float Ball::p_x() const {
  // @@protoc_insertion_point(field_get:world.Ball.p_x)
  return _internal_p_x();
}
inline void Ball::_internal_set_p_x(float value) {
  _has_bits_[0] |= 0x00000001u;
  p_x_ = value;
}
inline void Ball::set_p_x(float value) {
  _internal_set_p_x(value);
  // @@protoc_insertion_point(field_set:world.Ball.p_x)
}

// required float p_y = 2;
inline bool Ball::_internal_has_p_y() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Ball::has_p_y() const {
  return _internal_has_p_y();
}
inline void Ball::clear_p_y() {
  p_y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float Ball::_internal_p_y() const {
  return p_y_;
}
inline float Ball::p_y() const {
  // @@protoc_insertion_point(field_get:world.Ball.p_y)
  return _internal_p_y();
}
inline void Ball::_internal_set_p_y(float value) {
  _has_bits_[0] |= 0x00000002u;
  p_y_ = value;
}
inline void Ball::set_p_y(float value) {
  _internal_set_p_y(value);
  // @@protoc_insertion_point(field_set:world.Ball.p_y)
}

// optional float p_z = 6;
inline bool Ball::_internal_has_p_z() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Ball::has_p_z() const {
  return _internal_has_p_z();
}
inline void Ball::clear_p_z() {
  p_z_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float Ball::_internal_p_z() const {
  return p_z_;
}
inline float Ball::p_z() const {
  // @@protoc_insertion_point(field_get:world.Ball.p_z)
  return _internal_p_z();
}
inline void Ball::_internal_set_p_z(float value) {
  _has_bits_[0] |= 0x00000010u;
  p_z_ = value;
}
inline void Ball::set_p_z(float value) {
  _internal_set_p_z(value);
  // @@protoc_insertion_point(field_set:world.Ball.p_z)
}

// required float v_x = 3;
inline bool Ball::_internal_has_v_x() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Ball::has_v_x() const {
  return _internal_has_v_x();
}
inline void Ball::clear_v_x() {
  v_x_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float Ball::_internal_v_x() const {
  return v_x_;
}
inline float Ball::v_x() const {
  // @@protoc_insertion_point(field_get:world.Ball.v_x)
  return _internal_v_x();
}
inline void Ball::_internal_set_v_x(float value) {
  _has_bits_[0] |= 0x00000004u;
  v_x_ = value;
}
inline void Ball::set_v_x(float value) {
  _internal_set_v_x(value);
  // @@protoc_insertion_point(field_set:world.Ball.v_x)
}

// required float v_y = 4;
inline bool Ball::_internal_has_v_y() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Ball::has_v_y() const {
  return _internal_has_v_y();
}
inline void Ball::clear_v_y() {
  v_y_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float Ball::_internal_v_y() const {
  return v_y_;
}
inline float Ball::v_y() const {
  // @@protoc_insertion_point(field_get:world.Ball.v_y)
  return _internal_v_y();
}
inline void Ball::_internal_set_v_y(float value) {
  _has_bits_[0] |= 0x00000008u;
  v_y_ = value;
}
inline void Ball::set_v_y(float value) {
  _internal_set_v_y(value);
  // @@protoc_insertion_point(field_set:world.Ball.v_y)
}

// optional float v_z = 7;
inline bool Ball::_internal_has_v_z() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Ball::has_v_z() const {
  return _internal_has_v_z();
}
inline void Ball::clear_v_z() {
  v_z_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline float Ball::_internal_v_z() const {
  return v_z_;
}
inline float Ball::v_z() const {
  // @@protoc_insertion_point(field_get:world.Ball.v_z)
  return _internal_v_z();
}
inline void Ball::_internal_set_v_z(float value) {
  _has_bits_[0] |= 0x00000020u;
  v_z_ = value;
}
inline void Ball::set_v_z(float value) {
  _internal_set_v_z(value);
  // @@protoc_insertion_point(field_set:world.Ball.v_z)
}

// optional float touchdown_x = 8;
inline bool Ball::_internal_has_touchdown_x() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Ball::has_touchdown_x() const {
  return _internal_has_touchdown_x();
}
inline void Ball::clear_touchdown_x() {
  touchdown_x_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline float Ball::_internal_touchdown_x() const {
  return touchdown_x_;
}
inline float Ball::touchdown_x() const {
  // @@protoc_insertion_point(field_get:world.Ball.touchdown_x)
  return _internal_touchdown_x();
}
inline void Ball::_internal_set_touchdown_x(float value) {
  _has_bits_[0] |= 0x00000040u;
  touchdown_x_ = value;
}
inline void Ball::set_touchdown_x(float value) {
  _internal_set_touchdown_x(value);
  // @@protoc_insertion_point(field_set:world.Ball.touchdown_x)
}

// optional float touchdown_y = 9;
inline bool Ball::_internal_has_touchdown_y() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Ball::has_touchdown_y() const {
  return _internal_has_touchdown_y();
}
inline void Ball::clear_touchdown_y() {
  touchdown_y_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline float Ball::_internal_touchdown_y() const {
  return touchdown_y_;
}
inline float Ball::touchdown_y() const {
  // @@protoc_insertion_point(field_get:world.Ball.touchdown_y)
  return _internal_touchdown_y();
}
inline void Ball::_internal_set_touchdown_y(float value) {
  _has_bits_[0] |= 0x00000080u;
  touchdown_y_ = value;
}
inline void Ball::set_touchdown_y(float value) {
  _internal_set_touchdown_y(value);
  // @@protoc_insertion_point(field_set:world.Ball.touchdown_y)
}

// optional bool is_bouncing = 10;
inline bool Ball::_internal_has_is_bouncing() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Ball::has_is_bouncing() const {
  return _internal_has_is_bouncing();
}
inline void Ball::clear_is_bouncing() {
  is_bouncing_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool Ball::_internal_is_bouncing() const {
  return is_bouncing_;
}
inline bool Ball::is_bouncing() const {
  // @@protoc_insertion_point(field_get:world.Ball.is_bouncing)
  return _internal_is_bouncing();
}
inline void Ball::_internal_set_is_bouncing(bool value) {
  _has_bits_[0] |= 0x00000100u;
  is_bouncing_ = value;
}
inline void Ball::set_is_bouncing(bool value) {
  _internal_set_is_bouncing(value);
  // @@protoc_insertion_point(field_set:world.Ball.is_bouncing)
}

// optional float max_speed = 11;
inline bool Ball::_internal_has_max_speed() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Ball::has_max_speed() const {
  return _internal_has_max_speed();
}
inline void Ball::clear_max_speed() {
  max_speed_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline float Ball::_internal_max_speed() const {
  return max_speed_;
}
inline float Ball::max_speed() const {
  // @@protoc_insertion_point(field_get:world.Ball.max_speed)
  return _internal_max_speed();
}
inline void Ball::_internal_set_max_speed(float value) {
  _has_bits_[0] |= 0x00000200u;
  max_speed_ = value;
}
inline void Ball::set_max_speed(float value) {
  _internal_set_max_speed(value);
  // @@protoc_insertion_point(field_set:world.Ball.max_speed)
}

// repeated .world.BallPosition raw = 5;
inline int Ball::_internal_raw_size() const {
  return raw_.size();
}
inline int Ball::raw_size() const {
  return _internal_raw_size();
}
inline void Ball::clear_raw() {
  raw_.Clear();
}
inline ::world::BallPosition* Ball::mutable_raw(int index) {
  // @@protoc_insertion_point(field_mutable:world.Ball.raw)
  return raw_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world::BallPosition >*
Ball::mutable_raw() {
  // @@protoc_insertion_point(field_mutable_list:world.Ball.raw)
  return &raw_;
}
inline const ::world::BallPosition& Ball::_internal_raw(int index) const {
  return raw_.Get(index);
}
inline const ::world::BallPosition& Ball::raw(int index) const {
  // @@protoc_insertion_point(field_get:world.Ball.raw)
  return _internal_raw(index);
}
inline ::world::BallPosition* Ball::_internal_add_raw() {
  return raw_.Add();
}
inline ::world::BallPosition* Ball::add_raw() {
  // @@protoc_insertion_point(field_add:world.Ball.raw)
  return _internal_add_raw();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world::BallPosition >&
Ball::raw() const {
  // @@protoc_insertion_point(field_list:world.Ball.raw)
  return raw_;
}

// -------------------------------------------------------------------

// RobotPosition

// required int64 time = 1;
inline bool RobotPosition::_internal_has_time() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RobotPosition::has_time() const {
  return _internal_has_time();
}
inline void RobotPosition::clear_time() {
  time_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RobotPosition::_internal_time() const {
  return time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RobotPosition::time() const {
  // @@protoc_insertion_point(field_get:world.RobotPosition.time)
  return _internal_time();
}
inline void RobotPosition::_internal_set_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  time_ = value;
}
inline void RobotPosition::set_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:world.RobotPosition.time)
}

// required float p_x = 2;
inline bool RobotPosition::_internal_has_p_x() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RobotPosition::has_p_x() const {
  return _internal_has_p_x();
}
inline void RobotPosition::clear_p_x() {
  p_x_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float RobotPosition::_internal_p_x() const {
  return p_x_;
}
inline float RobotPosition::p_x() const {
  // @@protoc_insertion_point(field_get:world.RobotPosition.p_x)
  return _internal_p_x();
}
inline void RobotPosition::_internal_set_p_x(float value) {
  _has_bits_[0] |= 0x00000002u;
  p_x_ = value;
}
inline void RobotPosition::set_p_x(float value) {
  _internal_set_p_x(value);
  // @@protoc_insertion_point(field_set:world.RobotPosition.p_x)
}

// required float p_y = 3;
inline bool RobotPosition::_internal_has_p_y() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RobotPosition::has_p_y() const {
  return _internal_has_p_y();
}
inline void RobotPosition::clear_p_y() {
  p_y_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float RobotPosition::_internal_p_y() const {
  return p_y_;
}
inline float RobotPosition::p_y() const {
  // @@protoc_insertion_point(field_get:world.RobotPosition.p_y)
  return _internal_p_y();
}
inline void RobotPosition::_internal_set_p_y(float value) {
  _has_bits_[0] |= 0x00000004u;
  p_y_ = value;
}
inline void RobotPosition::set_p_y(float value) {
  _internal_set_p_y(value);
  // @@protoc_insertion_point(field_set:world.RobotPosition.p_y)
}

// required float phi = 4;
inline bool RobotPosition::_internal_has_phi() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RobotPosition::has_phi() const {
  return _internal_has_phi();
}
inline void RobotPosition::clear_phi() {
  phi_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float RobotPosition::_internal_phi() const {
  return phi_;
}
inline float RobotPosition::phi() const {
  // @@protoc_insertion_point(field_get:world.RobotPosition.phi)
  return _internal_phi();
}
inline void RobotPosition::_internal_set_phi(float value) {
  _has_bits_[0] |= 0x00000008u;
  phi_ = value;
}
inline void RobotPosition::set_phi(float value) {
  _internal_set_phi(value);
  // @@protoc_insertion_point(field_set:world.RobotPosition.phi)
}

// optional float v_x = 5;
inline bool RobotPosition::_internal_has_v_x() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RobotPosition::has_v_x() const {
  return _internal_has_v_x();
}
inline void RobotPosition::clear_v_x() {
  v_x_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float RobotPosition::_internal_v_x() const {
  return v_x_;
}
inline float RobotPosition::v_x() const {
  // @@protoc_insertion_point(field_get:world.RobotPosition.v_x)
  return _internal_v_x();
}
inline void RobotPosition::_internal_set_v_x(float value) {
  _has_bits_[0] |= 0x00000010u;
  v_x_ = value;
}
inline void RobotPosition::set_v_x(float value) {
  _internal_set_v_x(value);
  // @@protoc_insertion_point(field_set:world.RobotPosition.v_x)
}

// optional float v_y = 6;
inline bool RobotPosition::_internal_has_v_y() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool RobotPosition::has_v_y() const {
  return _internal_has_v_y();
}
inline void RobotPosition::clear_v_y() {
  v_y_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline float RobotPosition::_internal_v_y() const {
  return v_y_;
}
inline float RobotPosition::v_y() const {
  // @@protoc_insertion_point(field_get:world.RobotPosition.v_y)
  return _internal_v_y();
}
inline void RobotPosition::_internal_set_v_y(float value) {
  _has_bits_[0] |= 0x00000020u;
  v_y_ = value;
}
inline void RobotPosition::set_v_y(float value) {
  _internal_set_v_y(value);
  // @@protoc_insertion_point(field_set:world.RobotPosition.v_y)
}

// optional float system_delay = 7;
inline bool RobotPosition::_internal_has_system_delay() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool RobotPosition::has_system_delay() const {
  return _internal_has_system_delay();
}
inline void RobotPosition::clear_system_delay() {
  system_delay_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline float RobotPosition::_internal_system_delay() const {
  return system_delay_;
}
inline float RobotPosition::system_delay() const {
  // @@protoc_insertion_point(field_get:world.RobotPosition.system_delay)
  return _internal_system_delay();
}
inline void RobotPosition::_internal_set_system_delay(float value) {
  _has_bits_[0] |= 0x00000040u;
  system_delay_ = value;
}
inline void RobotPosition::set_system_delay(float value) {
  _internal_set_system_delay(value);
  // @@protoc_insertion_point(field_set:world.RobotPosition.system_delay)
}

// optional float time_diff_scaled = 8;
inline bool RobotPosition::_internal_has_time_diff_scaled() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool RobotPosition::has_time_diff_scaled() const {
  return _internal_has_time_diff_scaled();
}
inline void RobotPosition::clear_time_diff_scaled() {
  time_diff_scaled_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline float RobotPosition::_internal_time_diff_scaled() const {
  return time_diff_scaled_;
}
inline float RobotPosition::time_diff_scaled() const {
  // @@protoc_insertion_point(field_get:world.RobotPosition.time_diff_scaled)
  return _internal_time_diff_scaled();
}
inline void RobotPosition::_internal_set_time_diff_scaled(float value) {
  _has_bits_[0] |= 0x00000080u;
  time_diff_scaled_ = value;
}
inline void RobotPosition::set_time_diff_scaled(float value) {
  _internal_set_time_diff_scaled(value);
  // @@protoc_insertion_point(field_set:world.RobotPosition.time_diff_scaled)
}

// optional float omega = 9;
inline bool RobotPosition::_internal_has_omega() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool RobotPosition::has_omega() const {
  return _internal_has_omega();
}
inline void RobotPosition::clear_omega() {
  omega_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline float RobotPosition::_internal_omega() const {
  return omega_;
}
inline float RobotPosition::omega() const {
  // @@protoc_insertion_point(field_get:world.RobotPosition.omega)
  return _internal_omega();
}
inline void RobotPosition::_internal_set_omega(float value) {
  _has_bits_[0] |= 0x00000100u;
  omega_ = value;
}
inline void RobotPosition::set_omega(float value) {
  _internal_set_omega(value);
  // @@protoc_insertion_point(field_set:world.RobotPosition.omega)
}

// optional uint32 camera_id = 10;
inline bool RobotPosition::_internal_has_camera_id() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool RobotPosition::has_camera_id() const {
  return _internal_has_camera_id();
}
inline void RobotPosition::clear_camera_id() {
  camera_id_ = 0u;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RobotPosition::_internal_camera_id() const {
  return camera_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RobotPosition::camera_id() const {
  // @@protoc_insertion_point(field_get:world.RobotPosition.camera_id)
  return _internal_camera_id();
}
inline void RobotPosition::_internal_set_camera_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000400u;
  camera_id_ = value;
}
inline void RobotPosition::set_camera_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_camera_id(value);
  // @@protoc_insertion_point(field_set:world.RobotPosition.camera_id)
}

// optional int64 vision_processing_time = 11;
inline bool RobotPosition::_internal_has_vision_processing_time() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool RobotPosition::has_vision_processing_time() const {
  return _internal_has_vision_processing_time();
}
inline void RobotPosition::clear_vision_processing_time() {
  vision_processing_time_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RobotPosition::_internal_vision_processing_time() const {
  return vision_processing_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RobotPosition::vision_processing_time() const {
  // @@protoc_insertion_point(field_get:world.RobotPosition.vision_processing_time)
  return _internal_vision_processing_time();
}
inline void RobotPosition::_internal_set_vision_processing_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000200u;
  vision_processing_time_ = value;
}
inline void RobotPosition::set_vision_processing_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_vision_processing_time(value);
  // @@protoc_insertion_point(field_set:world.RobotPosition.vision_processing_time)
}

// -------------------------------------------------------------------

// Robot

// required uint32 id = 1;
inline bool Robot::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Robot::has_id() const {
  return _internal_has_id();
}
inline void Robot::clear_id() {
  id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Robot::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Robot::id() const {
  // @@protoc_insertion_point(field_get:world.Robot.id)
  return _internal_id();
}
inline void Robot::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  id_ = value;
}
inline void Robot::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:world.Robot.id)
}

// required float p_x = 2;
inline bool Robot::_internal_has_p_x() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Robot::has_p_x() const {
  return _internal_has_p_x();
}
inline void Robot::clear_p_x() {
  p_x_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float Robot::_internal_p_x() const {
  return p_x_;
}
inline float Robot::p_x() const {
  // @@protoc_insertion_point(field_get:world.Robot.p_x)
  return _internal_p_x();
}
inline void Robot::_internal_set_p_x(float value) {
  _has_bits_[0] |= 0x00000002u;
  p_x_ = value;
}
inline void Robot::set_p_x(float value) {
  _internal_set_p_x(value);
  // @@protoc_insertion_point(field_set:world.Robot.p_x)
}

// required float p_y = 3;
inline bool Robot::_internal_has_p_y() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Robot::has_p_y() const {
  return _internal_has_p_y();
}
inline void Robot::clear_p_y() {
  p_y_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float Robot::_internal_p_y() const {
  return p_y_;
}
inline float Robot::p_y() const {
  // @@protoc_insertion_point(field_get:world.Robot.p_y)
  return _internal_p_y();
}
inline void Robot::_internal_set_p_y(float value) {
  _has_bits_[0] |= 0x00000004u;
  p_y_ = value;
}
inline void Robot::set_p_y(float value) {
  _internal_set_p_y(value);
  // @@protoc_insertion_point(field_set:world.Robot.p_y)
}

// required float phi = 4;
inline bool Robot::_internal_has_phi() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Robot::has_phi() const {
  return _internal_has_phi();
}
inline void Robot::clear_phi() {
  phi_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float Robot::_internal_phi() const {
  return phi_;
}
inline float Robot::phi() const {
  // @@protoc_insertion_point(field_get:world.Robot.phi)
  return _internal_phi();
}
inline void Robot::_internal_set_phi(float value) {
  _has_bits_[0] |= 0x00000008u;
  phi_ = value;
}
inline void Robot::set_phi(float value) {
  _internal_set_phi(value);
  // @@protoc_insertion_point(field_set:world.Robot.phi)
}

// required float v_x = 5;
inline bool Robot::_internal_has_v_x() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Robot::has_v_x() const {
  return _internal_has_v_x();
}
inline void Robot::clear_v_x() {
  v_x_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float Robot::_internal_v_x() const {
  return v_x_;
}
inline float Robot::v_x() const {
  // @@protoc_insertion_point(field_get:world.Robot.v_x)
  return _internal_v_x();
}
inline void Robot::_internal_set_v_x(float value) {
  _has_bits_[0] |= 0x00000010u;
  v_x_ = value;
}
inline void Robot::set_v_x(float value) {
  _internal_set_v_x(value);
  // @@protoc_insertion_point(field_set:world.Robot.v_x)
}

// required float v_y = 6;
inline bool Robot::_internal_has_v_y() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Robot::has_v_y() const {
  return _internal_has_v_y();
}
inline void Robot::clear_v_y() {
  v_y_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline float Robot::_internal_v_y() const {
  return v_y_;
}
inline float Robot::v_y() const {
  // @@protoc_insertion_point(field_get:world.Robot.v_y)
  return _internal_v_y();
}
inline void Robot::_internal_set_v_y(float value) {
  _has_bits_[0] |= 0x00000020u;
  v_y_ = value;
}
inline void Robot::set_v_y(float value) {
  _internal_set_v_y(value);
  // @@protoc_insertion_point(field_set:world.Robot.v_y)
}

// required float omega = 7;
inline bool Robot::_internal_has_omega() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Robot::has_omega() const {
  return _internal_has_omega();
}
inline void Robot::clear_omega() {
  omega_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline float Robot::_internal_omega() const {
  return omega_;
}
inline float Robot::omega() const {
  // @@protoc_insertion_point(field_get:world.Robot.omega)
  return _internal_omega();
}
inline void Robot::_internal_set_omega(float value) {
  _has_bits_[0] |= 0x00000040u;
  omega_ = value;
}
inline void Robot::set_omega(float value) {
  _internal_set_omega(value);
  // @@protoc_insertion_point(field_set:world.Robot.omega)
}

// repeated .world.RobotPosition raw = 8;
inline int Robot::_internal_raw_size() const {
  return raw_.size();
}
inline int Robot::raw_size() const {
  return _internal_raw_size();
}
inline void Robot::clear_raw() {
  raw_.Clear();
}
inline ::world::RobotPosition* Robot::mutable_raw(int index) {
  // @@protoc_insertion_point(field_mutable:world.Robot.raw)
  return raw_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world::RobotPosition >*
Robot::mutable_raw() {
  // @@protoc_insertion_point(field_mutable_list:world.Robot.raw)
  return &raw_;
}
inline const ::world::RobotPosition& Robot::_internal_raw(int index) const {
  return raw_.Get(index);
}
inline const ::world::RobotPosition& Robot::raw(int index) const {
  // @@protoc_insertion_point(field_get:world.Robot.raw)
  return _internal_raw(index);
}
inline ::world::RobotPosition* Robot::_internal_add_raw() {
  return raw_.Add();
}
inline ::world::RobotPosition* Robot::add_raw() {
  // @@protoc_insertion_point(field_add:world.Robot.raw)
  return _internal_add_raw();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world::RobotPosition >&
Robot::raw() const {
  // @@protoc_insertion_point(field_list:world.Robot.raw)
  return raw_;
}

// -------------------------------------------------------------------

// TrackingAOI

// required float x1 = 1;
inline bool TrackingAOI::_internal_has_x1() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TrackingAOI::has_x1() const {
  return _internal_has_x1();
}
inline void TrackingAOI::clear_x1() {
  x1_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float TrackingAOI::_internal_x1() const {
  return x1_;
}
inline float TrackingAOI::x1() const {
  // @@protoc_insertion_point(field_get:world.TrackingAOI.x1)
  return _internal_x1();
}
inline void TrackingAOI::_internal_set_x1(float value) {
  _has_bits_[0] |= 0x00000001u;
  x1_ = value;
}
inline void TrackingAOI::set_x1(float value) {
  _internal_set_x1(value);
  // @@protoc_insertion_point(field_set:world.TrackingAOI.x1)
}

// required float y1 = 2;
inline bool TrackingAOI::_internal_has_y1() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TrackingAOI::has_y1() const {
  return _internal_has_y1();
}
inline void TrackingAOI::clear_y1() {
  y1_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float TrackingAOI::_internal_y1() const {
  return y1_;
}
inline float TrackingAOI::y1() const {
  // @@protoc_insertion_point(field_get:world.TrackingAOI.y1)
  return _internal_y1();
}
inline void TrackingAOI::_internal_set_y1(float value) {
  _has_bits_[0] |= 0x00000002u;
  y1_ = value;
}
inline void TrackingAOI::set_y1(float value) {
  _internal_set_y1(value);
  // @@protoc_insertion_point(field_set:world.TrackingAOI.y1)
}

// required float x2 = 3;
inline bool TrackingAOI::_internal_has_x2() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TrackingAOI::has_x2() const {
  return _internal_has_x2();
}
inline void TrackingAOI::clear_x2() {
  x2_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float TrackingAOI::_internal_x2() const {
  return x2_;
}
inline float TrackingAOI::x2() const {
  // @@protoc_insertion_point(field_get:world.TrackingAOI.x2)
  return _internal_x2();
}
inline void TrackingAOI::_internal_set_x2(float value) {
  _has_bits_[0] |= 0x00000004u;
  x2_ = value;
}
inline void TrackingAOI::set_x2(float value) {
  _internal_set_x2(value);
  // @@protoc_insertion_point(field_set:world.TrackingAOI.x2)
}

// required float y2 = 4;
inline bool TrackingAOI::_internal_has_y2() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TrackingAOI::has_y2() const {
  return _internal_has_y2();
}
inline void TrackingAOI::clear_y2() {
  y2_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float TrackingAOI::_internal_y2() const {
  return y2_;
}
inline float TrackingAOI::y2() const {
  // @@protoc_insertion_point(field_get:world.TrackingAOI.y2)
  return _internal_y2();
}
inline void TrackingAOI::_internal_set_y2(float value) {
  _has_bits_[0] |= 0x00000008u;
  y2_ = value;
}
inline void TrackingAOI::set_y2(float value) {
  _internal_set_y2(value);
  // @@protoc_insertion_point(field_set:world.TrackingAOI.y2)
}

// -------------------------------------------------------------------

// State

// required int64 time = 1;
inline bool State::_internal_has_time() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool State::has_time() const {
  return _internal_has_time();
}
inline void State::clear_time() {
  time_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 State::_internal_time() const {
  return time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 State::time() const {
  // @@protoc_insertion_point(field_get:world.State.time)
  return _internal_time();
}
inline void State::_internal_set_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  time_ = value;
}
inline void State::set_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:world.State.time)
}

// optional .world.Ball ball = 2;
inline bool State::_internal_has_ball() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || ball_ != nullptr);
  return value;
}
inline bool State::has_ball() const {
  return _internal_has_ball();
}
inline void State::clear_ball() {
  if (ball_ != nullptr) ball_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::world::Ball& State::_internal_ball() const {
  const ::world::Ball* p = ball_;
  return p != nullptr ? *p : *reinterpret_cast<const ::world::Ball*>(
      &::world::_Ball_default_instance_);
}
inline const ::world::Ball& State::ball() const {
  // @@protoc_insertion_point(field_get:world.State.ball)
  return _internal_ball();
}
inline void State::unsafe_arena_set_allocated_ball(
    ::world::Ball* ball) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ball_);
  }
  ball_ = ball;
  if (ball) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world.State.ball)
}
inline ::world::Ball* State::release_ball() {
  auto temp = unsafe_arena_release_ball();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::world::Ball* State::unsafe_arena_release_ball() {
  // @@protoc_insertion_point(field_release:world.State.ball)
  _has_bits_[0] &= ~0x00000001u;
  ::world::Ball* temp = ball_;
  ball_ = nullptr;
  return temp;
}
inline ::world::Ball* State::_internal_mutable_ball() {
  _has_bits_[0] |= 0x00000001u;
  if (ball_ == nullptr) {
    auto* p = CreateMaybeMessage<::world::Ball>(GetArena());
    ball_ = p;
  }
  return ball_;
}
inline ::world::Ball* State::mutable_ball() {
  // @@protoc_insertion_point(field_mutable:world.State.ball)
  return _internal_mutable_ball();
}
inline void State::set_allocated_ball(::world::Ball* ball) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete ball_;
  }
  if (ball) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(ball);
    if (message_arena != submessage_arena) {
      ball = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ball, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ball_ = ball;
  // @@protoc_insertion_point(field_set_allocated:world.State.ball)
}

// repeated .world.Robot yellow = 3;
inline int State::_internal_yellow_size() const {
  return yellow_.size();
}
inline int State::yellow_size() const {
  return _internal_yellow_size();
}
inline void State::clear_yellow() {
  yellow_.Clear();
}
inline ::world::Robot* State::mutable_yellow(int index) {
  // @@protoc_insertion_point(field_mutable:world.State.yellow)
  return yellow_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world::Robot >*
State::mutable_yellow() {
  // @@protoc_insertion_point(field_mutable_list:world.State.yellow)
  return &yellow_;
}
inline const ::world::Robot& State::_internal_yellow(int index) const {
  return yellow_.Get(index);
}
inline const ::world::Robot& State::yellow(int index) const {
  // @@protoc_insertion_point(field_get:world.State.yellow)
  return _internal_yellow(index);
}
inline ::world::Robot* State::_internal_add_yellow() {
  return yellow_.Add();
}
inline ::world::Robot* State::add_yellow() {
  // @@protoc_insertion_point(field_add:world.State.yellow)
  return _internal_add_yellow();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world::Robot >&
State::yellow() const {
  // @@protoc_insertion_point(field_list:world.State.yellow)
  return yellow_;
}

// repeated .world.Robot blue = 4;
inline int State::_internal_blue_size() const {
  return blue_.size();
}
inline int State::blue_size() const {
  return _internal_blue_size();
}
inline void State::clear_blue() {
  blue_.Clear();
}
inline ::world::Robot* State::mutable_blue(int index) {
  // @@protoc_insertion_point(field_mutable:world.State.blue)
  return blue_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world::Robot >*
State::mutable_blue() {
  // @@protoc_insertion_point(field_mutable_list:world.State.blue)
  return &blue_;
}
inline const ::world::Robot& State::_internal_blue(int index) const {
  return blue_.Get(index);
}
inline const ::world::Robot& State::blue(int index) const {
  // @@protoc_insertion_point(field_get:world.State.blue)
  return _internal_blue(index);
}
inline ::world::Robot* State::_internal_add_blue() {
  return blue_.Add();
}
inline ::world::Robot* State::add_blue() {
  // @@protoc_insertion_point(field_add:world.State.blue)
  return _internal_add_blue();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world::Robot >&
State::blue() const {
  // @@protoc_insertion_point(field_list:world.State.blue)
  return blue_;
}

// repeated .robot.RadioResponse radio_response = 5;
inline int State::_internal_radio_response_size() const {
  return radio_response_.size();
}
inline int State::radio_response_size() const {
  return _internal_radio_response_size();
}
inline ::robot::RadioResponse* State::mutable_radio_response(int index) {
  // @@protoc_insertion_point(field_mutable:world.State.radio_response)
  return radio_response_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::RadioResponse >*
State::mutable_radio_response() {
  // @@protoc_insertion_point(field_mutable_list:world.State.radio_response)
  return &radio_response_;
}
inline const ::robot::RadioResponse& State::_internal_radio_response(int index) const {
  return radio_response_.Get(index);
}
inline const ::robot::RadioResponse& State::radio_response(int index) const {
  // @@protoc_insertion_point(field_get:world.State.radio_response)
  return _internal_radio_response(index);
}
inline ::robot::RadioResponse* State::_internal_add_radio_response() {
  return radio_response_.Add();
}
inline ::robot::RadioResponse* State::add_radio_response() {
  // @@protoc_insertion_point(field_add:world.State.radio_response)
  return _internal_add_radio_response();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::RadioResponse >&
State::radio_response() const {
  // @@protoc_insertion_point(field_list:world.State.radio_response)
  return radio_response_;
}

// optional bool is_simulated = 6;
inline bool State::_internal_has_is_simulated() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool State::has_is_simulated() const {
  return _internal_has_is_simulated();
}
inline void State::clear_is_simulated() {
  is_simulated_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool State::_internal_is_simulated() const {
  return is_simulated_;
}
inline bool State::is_simulated() const {
  // @@protoc_insertion_point(field_get:world.State.is_simulated)
  return _internal_is_simulated();
}
inline void State::_internal_set_is_simulated(bool value) {
  _has_bits_[0] |= 0x00000040u;
  is_simulated_ = value;
}
inline void State::set_is_simulated(bool value) {
  _internal_set_is_simulated(value);
  // @@protoc_insertion_point(field_set:world.State.is_simulated)
}

// optional bool has_vision_data = 7;
inline bool State::_internal_has_has_vision_data() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool State::has_has_vision_data() const {
  return _internal_has_has_vision_data();
}
inline void State::clear_has_vision_data() {
  has_vision_data_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool State::_internal_has_vision_data() const {
  return has_vision_data_;
}
inline bool State::has_vision_data() const {
  // @@protoc_insertion_point(field_get:world.State.has_vision_data)
  return _internal_has_vision_data();
}
inline void State::_internal_set_has_vision_data(bool value) {
  _has_bits_[0] |= 0x00000080u;
  has_vision_data_ = value;
}
inline void State::set_has_vision_data(bool value) {
  _internal_set_has_vision_data(value);
  // @@protoc_insertion_point(field_set:world.State.has_vision_data)
}

// optional .ssl.TeamPlan mixed_team_info = 8;
inline bool State::_internal_has_mixed_team_info() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || mixed_team_info_ != nullptr);
  return value;
}
inline bool State::has_mixed_team_info() const {
  return _internal_has_mixed_team_info();
}
inline const ::ssl::TeamPlan& State::_internal_mixed_team_info() const {
  const ::ssl::TeamPlan* p = mixed_team_info_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ssl::TeamPlan*>(
      &::ssl::_TeamPlan_default_instance_);
}
inline const ::ssl::TeamPlan& State::mixed_team_info() const {
  // @@protoc_insertion_point(field_get:world.State.mixed_team_info)
  return _internal_mixed_team_info();
}
inline void State::unsafe_arena_set_allocated_mixed_team_info(
    ::ssl::TeamPlan* mixed_team_info) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mixed_team_info_);
  }
  mixed_team_info_ = mixed_team_info;
  if (mixed_team_info) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world.State.mixed_team_info)
}
inline ::ssl::TeamPlan* State::release_mixed_team_info() {
  auto temp = unsafe_arena_release_mixed_team_info();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ssl::TeamPlan* State::unsafe_arena_release_mixed_team_info() {
  // @@protoc_insertion_point(field_release:world.State.mixed_team_info)
  _has_bits_[0] &= ~0x00000002u;
  ::ssl::TeamPlan* temp = mixed_team_info_;
  mixed_team_info_ = nullptr;
  return temp;
}
inline ::ssl::TeamPlan* State::_internal_mutable_mixed_team_info() {
  _has_bits_[0] |= 0x00000002u;
  if (mixed_team_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::ssl::TeamPlan>(GetArena());
    mixed_team_info_ = p;
  }
  return mixed_team_info_;
}
inline ::ssl::TeamPlan* State::mutable_mixed_team_info() {
  // @@protoc_insertion_point(field_mutable:world.State.mixed_team_info)
  return _internal_mutable_mixed_team_info();
}
inline void State::set_allocated_mixed_team_info(::ssl::TeamPlan* mixed_team_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(mixed_team_info_);
  }
  if (mixed_team_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mixed_team_info)->GetArena();
    if (message_arena != submessage_arena) {
      mixed_team_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mixed_team_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  mixed_team_info_ = mixed_team_info;
  // @@protoc_insertion_point(field_set_allocated:world.State.mixed_team_info)
}

// optional .world.TrackingAOI tracking_aoi = 9;
inline bool State::_internal_has_tracking_aoi() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || tracking_aoi_ != nullptr);
  return value;
}
inline bool State::has_tracking_aoi() const {
  return _internal_has_tracking_aoi();
}
inline void State::clear_tracking_aoi() {
  if (tracking_aoi_ != nullptr) tracking_aoi_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::world::TrackingAOI& State::_internal_tracking_aoi() const {
  const ::world::TrackingAOI* p = tracking_aoi_;
  return p != nullptr ? *p : *reinterpret_cast<const ::world::TrackingAOI*>(
      &::world::_TrackingAOI_default_instance_);
}
inline const ::world::TrackingAOI& State::tracking_aoi() const {
  // @@protoc_insertion_point(field_get:world.State.tracking_aoi)
  return _internal_tracking_aoi();
}
inline void State::unsafe_arena_set_allocated_tracking_aoi(
    ::world::TrackingAOI* tracking_aoi) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tracking_aoi_);
  }
  tracking_aoi_ = tracking_aoi;
  if (tracking_aoi) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world.State.tracking_aoi)
}
inline ::world::TrackingAOI* State::release_tracking_aoi() {
  auto temp = unsafe_arena_release_tracking_aoi();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::world::TrackingAOI* State::unsafe_arena_release_tracking_aoi() {
  // @@protoc_insertion_point(field_release:world.State.tracking_aoi)
  _has_bits_[0] &= ~0x00000004u;
  ::world::TrackingAOI* temp = tracking_aoi_;
  tracking_aoi_ = nullptr;
  return temp;
}
inline ::world::TrackingAOI* State::_internal_mutable_tracking_aoi() {
  _has_bits_[0] |= 0x00000004u;
  if (tracking_aoi_ == nullptr) {
    auto* p = CreateMaybeMessage<::world::TrackingAOI>(GetArena());
    tracking_aoi_ = p;
  }
  return tracking_aoi_;
}
inline ::world::TrackingAOI* State::mutable_tracking_aoi() {
  // @@protoc_insertion_point(field_mutable:world.State.tracking_aoi)
  return _internal_mutable_tracking_aoi();
}
inline void State::set_allocated_tracking_aoi(::world::TrackingAOI* tracking_aoi) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete tracking_aoi_;
  }
  if (tracking_aoi) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(tracking_aoi);
    if (message_arena != submessage_arena) {
      tracking_aoi = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tracking_aoi, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  tracking_aoi_ = tracking_aoi;
  // @@protoc_insertion_point(field_set_allocated:world.State.tracking_aoi)
}

// repeated .world.Robot simple_tracking_yellow = 11;
inline int State::_internal_simple_tracking_yellow_size() const {
  return simple_tracking_yellow_.size();
}
inline int State::simple_tracking_yellow_size() const {
  return _internal_simple_tracking_yellow_size();
}
inline void State::clear_simple_tracking_yellow() {
  simple_tracking_yellow_.Clear();
}
inline ::world::Robot* State::mutable_simple_tracking_yellow(int index) {
  // @@protoc_insertion_point(field_mutable:world.State.simple_tracking_yellow)
  return simple_tracking_yellow_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world::Robot >*
State::mutable_simple_tracking_yellow() {
  // @@protoc_insertion_point(field_mutable_list:world.State.simple_tracking_yellow)
  return &simple_tracking_yellow_;
}
inline const ::world::Robot& State::_internal_simple_tracking_yellow(int index) const {
  return simple_tracking_yellow_.Get(index);
}
inline const ::world::Robot& State::simple_tracking_yellow(int index) const {
  // @@protoc_insertion_point(field_get:world.State.simple_tracking_yellow)
  return _internal_simple_tracking_yellow(index);
}
inline ::world::Robot* State::_internal_add_simple_tracking_yellow() {
  return simple_tracking_yellow_.Add();
}
inline ::world::Robot* State::add_simple_tracking_yellow() {
  // @@protoc_insertion_point(field_add:world.State.simple_tracking_yellow)
  return _internal_add_simple_tracking_yellow();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world::Robot >&
State::simple_tracking_yellow() const {
  // @@protoc_insertion_point(field_list:world.State.simple_tracking_yellow)
  return simple_tracking_yellow_;
}

// repeated .world.Robot simple_tracking_blue = 12;
inline int State::_internal_simple_tracking_blue_size() const {
  return simple_tracking_blue_.size();
}
inline int State::simple_tracking_blue_size() const {
  return _internal_simple_tracking_blue_size();
}
inline void State::clear_simple_tracking_blue() {
  simple_tracking_blue_.Clear();
}
inline ::world::Robot* State::mutable_simple_tracking_blue(int index) {
  // @@protoc_insertion_point(field_mutable:world.State.simple_tracking_blue)
  return simple_tracking_blue_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world::Robot >*
State::mutable_simple_tracking_blue() {
  // @@protoc_insertion_point(field_mutable_list:world.State.simple_tracking_blue)
  return &simple_tracking_blue_;
}
inline const ::world::Robot& State::_internal_simple_tracking_blue(int index) const {
  return simple_tracking_blue_.Get(index);
}
inline const ::world::Robot& State::simple_tracking_blue(int index) const {
  // @@protoc_insertion_point(field_get:world.State.simple_tracking_blue)
  return _internal_simple_tracking_blue(index);
}
inline ::world::Robot* State::_internal_add_simple_tracking_blue() {
  return simple_tracking_blue_.Add();
}
inline ::world::Robot* State::add_simple_tracking_blue() {
  // @@protoc_insertion_point(field_add:world.State.simple_tracking_blue)
  return _internal_add_simple_tracking_blue();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world::Robot >&
State::simple_tracking_blue() const {
  // @@protoc_insertion_point(field_list:world.State.simple_tracking_blue)
  return simple_tracking_blue_;
}

// optional .world.Ball simple_tracking_ball = 17;
inline bool State::_internal_has_simple_tracking_ball() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || simple_tracking_ball_ != nullptr);
  return value;
}
inline bool State::has_simple_tracking_ball() const {
  return _internal_has_simple_tracking_ball();
}
inline void State::clear_simple_tracking_ball() {
  if (simple_tracking_ball_ != nullptr) simple_tracking_ball_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::world::Ball& State::_internal_simple_tracking_ball() const {
  const ::world::Ball* p = simple_tracking_ball_;
  return p != nullptr ? *p : *reinterpret_cast<const ::world::Ball*>(
      &::world::_Ball_default_instance_);
}
inline const ::world::Ball& State::simple_tracking_ball() const {
  // @@protoc_insertion_point(field_get:world.State.simple_tracking_ball)
  return _internal_simple_tracking_ball();
}
inline void State::unsafe_arena_set_allocated_simple_tracking_ball(
    ::world::Ball* simple_tracking_ball) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(simple_tracking_ball_);
  }
  simple_tracking_ball_ = simple_tracking_ball;
  if (simple_tracking_ball) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world.State.simple_tracking_ball)
}
inline ::world::Ball* State::release_simple_tracking_ball() {
  auto temp = unsafe_arena_release_simple_tracking_ball();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::world::Ball* State::unsafe_arena_release_simple_tracking_ball() {
  // @@protoc_insertion_point(field_release:world.State.simple_tracking_ball)
  _has_bits_[0] &= ~0x00000008u;
  ::world::Ball* temp = simple_tracking_ball_;
  simple_tracking_ball_ = nullptr;
  return temp;
}
inline ::world::Ball* State::_internal_mutable_simple_tracking_ball() {
  _has_bits_[0] |= 0x00000008u;
  if (simple_tracking_ball_ == nullptr) {
    auto* p = CreateMaybeMessage<::world::Ball>(GetArena());
    simple_tracking_ball_ = p;
  }
  return simple_tracking_ball_;
}
inline ::world::Ball* State::mutable_simple_tracking_ball() {
  // @@protoc_insertion_point(field_mutable:world.State.simple_tracking_ball)
  return _internal_mutable_simple_tracking_ball();
}
inline void State::set_allocated_simple_tracking_ball(::world::Ball* simple_tracking_ball) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete simple_tracking_ball_;
  }
  if (simple_tracking_ball) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(simple_tracking_ball);
    if (message_arena != submessage_arena) {
      simple_tracking_ball = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, simple_tracking_ball, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  simple_tracking_ball_ = simple_tracking_ball;
  // @@protoc_insertion_point(field_set_allocated:world.State.simple_tracking_ball)
}

// repeated .world.SimulatorState reality = 13;
inline int State::_internal_reality_size() const {
  return reality_.size();
}
inline int State::reality_size() const {
  return _internal_reality_size();
}
inline void State::clear_reality() {
  reality_.Clear();
}
inline ::world::SimulatorState* State::mutable_reality(int index) {
  // @@protoc_insertion_point(field_mutable:world.State.reality)
  return reality_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world::SimulatorState >*
State::mutable_reality() {
  // @@protoc_insertion_point(field_mutable_list:world.State.reality)
  return &reality_;
}
inline const ::world::SimulatorState& State::_internal_reality(int index) const {
  return reality_.Get(index);
}
inline const ::world::SimulatorState& State::reality(int index) const {
  // @@protoc_insertion_point(field_get:world.State.reality)
  return _internal_reality(index);
}
inline ::world::SimulatorState* State::_internal_add_reality() {
  return reality_.Add();
}
inline ::world::SimulatorState* State::add_reality() {
  // @@protoc_insertion_point(field_add:world.State.reality)
  return _internal_add_reality();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world::SimulatorState >&
State::reality() const {
  // @@protoc_insertion_point(field_list:world.State.reality)
  return reality_;
}

// repeated .SSL_WrapperPacket vision_frames = 10;
inline int State::_internal_vision_frames_size() const {
  return vision_frames_.size();
}
inline int State::vision_frames_size() const {
  return _internal_vision_frames_size();
}
inline ::SSL_WrapperPacket* State::mutable_vision_frames(int index) {
  // @@protoc_insertion_point(field_mutable:world.State.vision_frames)
  return vision_frames_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SSL_WrapperPacket >*
State::mutable_vision_frames() {
  // @@protoc_insertion_point(field_mutable_list:world.State.vision_frames)
  return &vision_frames_;
}
inline const ::SSL_WrapperPacket& State::_internal_vision_frames(int index) const {
  return vision_frames_.Get(index);
}
inline const ::SSL_WrapperPacket& State::vision_frames(int index) const {
  // @@protoc_insertion_point(field_get:world.State.vision_frames)
  return _internal_vision_frames(index);
}
inline ::SSL_WrapperPacket* State::_internal_add_vision_frames() {
  return vision_frames_.Add();
}
inline ::SSL_WrapperPacket* State::add_vision_frames() {
  // @@protoc_insertion_point(field_add:world.State.vision_frames)
  return _internal_add_vision_frames();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SSL_WrapperPacket >&
State::vision_frames() const {
  // @@protoc_insertion_point(field_list:world.State.vision_frames)
  return vision_frames_;
}

// repeated int64 vision_frame_times = 14;
inline int State::_internal_vision_frame_times_size() const {
  return vision_frame_times_.size();
}
inline int State::vision_frame_times_size() const {
  return _internal_vision_frame_times_size();
}
inline void State::clear_vision_frame_times() {
  vision_frame_times_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 State::_internal_vision_frame_times(int index) const {
  return vision_frame_times_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 State::vision_frame_times(int index) const {
  // @@protoc_insertion_point(field_get:world.State.vision_frame_times)
  return _internal_vision_frame_times(index);
}
inline void State::set_vision_frame_times(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  vision_frame_times_.Set(index, value);
  // @@protoc_insertion_point(field_set:world.State.vision_frame_times)
}
inline void State::_internal_add_vision_frame_times(::PROTOBUF_NAMESPACE_ID::int64 value) {
  vision_frame_times_.Add(value);
}
inline void State::add_vision_frame_times(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_vision_frame_times(value);
  // @@protoc_insertion_point(field_add:world.State.vision_frame_times)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
State::_internal_vision_frame_times() const {
  return vision_frame_times_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
State::vision_frame_times() const {
  // @@protoc_insertion_point(field_list:world.State.vision_frame_times)
  return _internal_vision_frame_times();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
State::_internal_mutable_vision_frame_times() {
  return &vision_frame_times_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
State::mutable_vision_frame_times() {
  // @@protoc_insertion_point(field_mutable_list:world.State.vision_frame_times)
  return _internal_mutable_vision_frame_times();
}

// optional int64 system_delay = 15;
inline bool State::_internal_has_system_delay() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool State::has_system_delay() const {
  return _internal_has_system_delay();
}
inline void State::clear_system_delay() {
  system_delay_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 State::_internal_system_delay() const {
  return system_delay_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 State::system_delay() const {
  // @@protoc_insertion_point(field_get:world.State.system_delay)
  return _internal_system_delay();
}
inline void State::_internal_set_system_delay(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000020u;
  system_delay_ = value;
}
inline void State::set_system_delay(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_system_delay(value);
  // @@protoc_insertion_point(field_set:world.State.system_delay)
}

// optional .world.WorldSource world_source = 16;
inline bool State::_internal_has_world_source() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool State::has_world_source() const {
  return _internal_has_world_source();
}
inline void State::clear_world_source() {
  world_source_ = 1;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::world::WorldSource State::_internal_world_source() const {
  return static_cast< ::world::WorldSource >(world_source_);
}
inline ::world::WorldSource State::world_source() const {
  // @@protoc_insertion_point(field_get:world.State.world_source)
  return _internal_world_source();
}
inline void State::_internal_set_world_source(::world::WorldSource value) {
  assert(::world::WorldSource_IsValid(value));
  _has_bits_[0] |= 0x00000100u;
  world_source_ = value;
}
inline void State::set_world_source(::world::WorldSource value) {
  _internal_set_world_source(value);
  // @@protoc_insertion_point(field_set:world.State.world_source)
}

// -------------------------------------------------------------------

// SimulatorState

// repeated .world.SimRobot blue_robots = 1;
inline int SimulatorState::_internal_blue_robots_size() const {
  return blue_robots_.size();
}
inline int SimulatorState::blue_robots_size() const {
  return _internal_blue_robots_size();
}
inline void SimulatorState::clear_blue_robots() {
  blue_robots_.Clear();
}
inline ::world::SimRobot* SimulatorState::mutable_blue_robots(int index) {
  // @@protoc_insertion_point(field_mutable:world.SimulatorState.blue_robots)
  return blue_robots_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world::SimRobot >*
SimulatorState::mutable_blue_robots() {
  // @@protoc_insertion_point(field_mutable_list:world.SimulatorState.blue_robots)
  return &blue_robots_;
}
inline const ::world::SimRobot& SimulatorState::_internal_blue_robots(int index) const {
  return blue_robots_.Get(index);
}
inline const ::world::SimRobot& SimulatorState::blue_robots(int index) const {
  // @@protoc_insertion_point(field_get:world.SimulatorState.blue_robots)
  return _internal_blue_robots(index);
}
inline ::world::SimRobot* SimulatorState::_internal_add_blue_robots() {
  return blue_robots_.Add();
}
inline ::world::SimRobot* SimulatorState::add_blue_robots() {
  // @@protoc_insertion_point(field_add:world.SimulatorState.blue_robots)
  return _internal_add_blue_robots();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world::SimRobot >&
SimulatorState::blue_robots() const {
  // @@protoc_insertion_point(field_list:world.SimulatorState.blue_robots)
  return blue_robots_;
}

// repeated .world.SimRobot yellow_robots = 2;
inline int SimulatorState::_internal_yellow_robots_size() const {
  return yellow_robots_.size();
}
inline int SimulatorState::yellow_robots_size() const {
  return _internal_yellow_robots_size();
}
inline void SimulatorState::clear_yellow_robots() {
  yellow_robots_.Clear();
}
inline ::world::SimRobot* SimulatorState::mutable_yellow_robots(int index) {
  // @@protoc_insertion_point(field_mutable:world.SimulatorState.yellow_robots)
  return yellow_robots_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world::SimRobot >*
SimulatorState::mutable_yellow_robots() {
  // @@protoc_insertion_point(field_mutable_list:world.SimulatorState.yellow_robots)
  return &yellow_robots_;
}
inline const ::world::SimRobot& SimulatorState::_internal_yellow_robots(int index) const {
  return yellow_robots_.Get(index);
}
inline const ::world::SimRobot& SimulatorState::yellow_robots(int index) const {
  // @@protoc_insertion_point(field_get:world.SimulatorState.yellow_robots)
  return _internal_yellow_robots(index);
}
inline ::world::SimRobot* SimulatorState::_internal_add_yellow_robots() {
  return yellow_robots_.Add();
}
inline ::world::SimRobot* SimulatorState::add_yellow_robots() {
  // @@protoc_insertion_point(field_add:world.SimulatorState.yellow_robots)
  return _internal_add_yellow_robots();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::world::SimRobot >&
SimulatorState::yellow_robots() const {
  // @@protoc_insertion_point(field_list:world.SimulatorState.yellow_robots)
  return yellow_robots_;
}

// optional .world.SimBall ball = 3;
inline bool SimulatorState::_internal_has_ball() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || ball_ != nullptr);
  return value;
}
inline bool SimulatorState::has_ball() const {
  return _internal_has_ball();
}
inline void SimulatorState::clear_ball() {
  if (ball_ != nullptr) ball_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::world::SimBall& SimulatorState::_internal_ball() const {
  const ::world::SimBall* p = ball_;
  return p != nullptr ? *p : *reinterpret_cast<const ::world::SimBall*>(
      &::world::_SimBall_default_instance_);
}
inline const ::world::SimBall& SimulatorState::ball() const {
  // @@protoc_insertion_point(field_get:world.SimulatorState.ball)
  return _internal_ball();
}
inline void SimulatorState::unsafe_arena_set_allocated_ball(
    ::world::SimBall* ball) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ball_);
  }
  ball_ = ball;
  if (ball) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world.SimulatorState.ball)
}
inline ::world::SimBall* SimulatorState::release_ball() {
  auto temp = unsafe_arena_release_ball();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::world::SimBall* SimulatorState::unsafe_arena_release_ball() {
  // @@protoc_insertion_point(field_release:world.SimulatorState.ball)
  _has_bits_[0] &= ~0x00000001u;
  ::world::SimBall* temp = ball_;
  ball_ = nullptr;
  return temp;
}
inline ::world::SimBall* SimulatorState::_internal_mutable_ball() {
  _has_bits_[0] |= 0x00000001u;
  if (ball_ == nullptr) {
    auto* p = CreateMaybeMessage<::world::SimBall>(GetArena());
    ball_ = p;
  }
  return ball_;
}
inline ::world::SimBall* SimulatorState::mutable_ball() {
  // @@protoc_insertion_point(field_mutable:world.SimulatorState.ball)
  return _internal_mutable_ball();
}
inline void SimulatorState::set_allocated_ball(::world::SimBall* ball) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete ball_;
  }
  if (ball) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(ball);
    if (message_arena != submessage_arena) {
      ball = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ball, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ball_ = ball;
  // @@protoc_insertion_point(field_set_allocated:world.SimulatorState.ball)
}

// optional int64 time = 4;
inline bool SimulatorState::_internal_has_time() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SimulatorState::has_time() const {
  return _internal_has_time();
}
inline void SimulatorState::clear_time() {
  time_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SimulatorState::_internal_time() const {
  return time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SimulatorState::time() const {
  // @@protoc_insertion_point(field_get:world.SimulatorState.time)
  return _internal_time();
}
inline void SimulatorState::_internal_set_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  time_ = value;
}
inline void SimulatorState::set_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:world.SimulatorState.time)
}

// -------------------------------------------------------------------

// SimBall

// required float p_x = 1;
inline bool SimBall::_internal_has_p_x() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SimBall::has_p_x() const {
  return _internal_has_p_x();
}
inline void SimBall::clear_p_x() {
  p_x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float SimBall::_internal_p_x() const {
  return p_x_;
}
inline float SimBall::p_x() const {
  // @@protoc_insertion_point(field_get:world.SimBall.p_x)
  return _internal_p_x();
}
inline void SimBall::_internal_set_p_x(float value) {
  _has_bits_[0] |= 0x00000001u;
  p_x_ = value;
}
inline void SimBall::set_p_x(float value) {
  _internal_set_p_x(value);
  // @@protoc_insertion_point(field_set:world.SimBall.p_x)
}

// required float p_y = 2;
inline bool SimBall::_internal_has_p_y() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SimBall::has_p_y() const {
  return _internal_has_p_y();
}
inline void SimBall::clear_p_y() {
  p_y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float SimBall::_internal_p_y() const {
  return p_y_;
}
inline float SimBall::p_y() const {
  // @@protoc_insertion_point(field_get:world.SimBall.p_y)
  return _internal_p_y();
}
inline void SimBall::_internal_set_p_y(float value) {
  _has_bits_[0] |= 0x00000002u;
  p_y_ = value;
}
inline void SimBall::set_p_y(float value) {
  _internal_set_p_y(value);
  // @@protoc_insertion_point(field_set:world.SimBall.p_y)
}

// required float p_z = 3;
inline bool SimBall::_internal_has_p_z() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SimBall::has_p_z() const {
  return _internal_has_p_z();
}
inline void SimBall::clear_p_z() {
  p_z_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float SimBall::_internal_p_z() const {
  return p_z_;
}
inline float SimBall::p_z() const {
  // @@protoc_insertion_point(field_get:world.SimBall.p_z)
  return _internal_p_z();
}
inline void SimBall::_internal_set_p_z(float value) {
  _has_bits_[0] |= 0x00000004u;
  p_z_ = value;
}
inline void SimBall::set_p_z(float value) {
  _internal_set_p_z(value);
  // @@protoc_insertion_point(field_set:world.SimBall.p_z)
}

// required float v_x = 4;
inline bool SimBall::_internal_has_v_x() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SimBall::has_v_x() const {
  return _internal_has_v_x();
}
inline void SimBall::clear_v_x() {
  v_x_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float SimBall::_internal_v_x() const {
  return v_x_;
}
inline float SimBall::v_x() const {
  // @@protoc_insertion_point(field_get:world.SimBall.v_x)
  return _internal_v_x();
}
inline void SimBall::_internal_set_v_x(float value) {
  _has_bits_[0] |= 0x00000008u;
  v_x_ = value;
}
inline void SimBall::set_v_x(float value) {
  _internal_set_v_x(value);
  // @@protoc_insertion_point(field_set:world.SimBall.v_x)
}

// required float v_y = 5;
inline bool SimBall::_internal_has_v_y() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SimBall::has_v_y() const {
  return _internal_has_v_y();
}
inline void SimBall::clear_v_y() {
  v_y_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float SimBall::_internal_v_y() const {
  return v_y_;
}
inline float SimBall::v_y() const {
  // @@protoc_insertion_point(field_get:world.SimBall.v_y)
  return _internal_v_y();
}
inline void SimBall::_internal_set_v_y(float value) {
  _has_bits_[0] |= 0x00000010u;
  v_y_ = value;
}
inline void SimBall::set_v_y(float value) {
  _internal_set_v_y(value);
  // @@protoc_insertion_point(field_set:world.SimBall.v_y)
}

// required float v_z = 6;
inline bool SimBall::_internal_has_v_z() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool SimBall::has_v_z() const {
  return _internal_has_v_z();
}
inline void SimBall::clear_v_z() {
  v_z_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline float SimBall::_internal_v_z() const {
  return v_z_;
}
inline float SimBall::v_z() const {
  // @@protoc_insertion_point(field_get:world.SimBall.v_z)
  return _internal_v_z();
}
inline void SimBall::_internal_set_v_z(float value) {
  _has_bits_[0] |= 0x00000020u;
  v_z_ = value;
}
inline void SimBall::set_v_z(float value) {
  _internal_set_v_z(value);
  // @@protoc_insertion_point(field_set:world.SimBall.v_z)
}

// optional float angular_x = 7;
inline bool SimBall::_internal_has_angular_x() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool SimBall::has_angular_x() const {
  return _internal_has_angular_x();
}
inline void SimBall::clear_angular_x() {
  angular_x_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline float SimBall::_internal_angular_x() const {
  return angular_x_;
}
inline float SimBall::angular_x() const {
  // @@protoc_insertion_point(field_get:world.SimBall.angular_x)
  return _internal_angular_x();
}
inline void SimBall::_internal_set_angular_x(float value) {
  _has_bits_[0] |= 0x00000040u;
  angular_x_ = value;
}
inline void SimBall::set_angular_x(float value) {
  _internal_set_angular_x(value);
  // @@protoc_insertion_point(field_set:world.SimBall.angular_x)
}

// optional float angular_y = 8;
inline bool SimBall::_internal_has_angular_y() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool SimBall::has_angular_y() const {
  return _internal_has_angular_y();
}
inline void SimBall::clear_angular_y() {
  angular_y_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline float SimBall::_internal_angular_y() const {
  return angular_y_;
}
inline float SimBall::angular_y() const {
  // @@protoc_insertion_point(field_get:world.SimBall.angular_y)
  return _internal_angular_y();
}
inline void SimBall::_internal_set_angular_y(float value) {
  _has_bits_[0] |= 0x00000080u;
  angular_y_ = value;
}
inline void SimBall::set_angular_y(float value) {
  _internal_set_angular_y(value);
  // @@protoc_insertion_point(field_set:world.SimBall.angular_y)
}

// optional float angular_z = 9;
inline bool SimBall::_internal_has_angular_z() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool SimBall::has_angular_z() const {
  return _internal_has_angular_z();
}
inline void SimBall::clear_angular_z() {
  angular_z_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline float SimBall::_internal_angular_z() const {
  return angular_z_;
}
inline float SimBall::angular_z() const {
  // @@protoc_insertion_point(field_get:world.SimBall.angular_z)
  return _internal_angular_z();
}
inline void SimBall::_internal_set_angular_z(float value) {
  _has_bits_[0] |= 0x00000100u;
  angular_z_ = value;
}
inline void SimBall::set_angular_z(float value) {
  _internal_set_angular_z(value);
  // @@protoc_insertion_point(field_set:world.SimBall.angular_z)
}

// -------------------------------------------------------------------

// Quaternion

// required float i = 1;
inline bool Quaternion::_internal_has_i() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Quaternion::has_i() const {
  return _internal_has_i();
}
inline void Quaternion::clear_i() {
  i_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float Quaternion::_internal_i() const {
  return i_;
}
inline float Quaternion::i() const {
  // @@protoc_insertion_point(field_get:world.Quaternion.i)
  return _internal_i();
}
inline void Quaternion::_internal_set_i(float value) {
  _has_bits_[0] |= 0x00000001u;
  i_ = value;
}
inline void Quaternion::set_i(float value) {
  _internal_set_i(value);
  // @@protoc_insertion_point(field_set:world.Quaternion.i)
}

// required float j = 2;
inline bool Quaternion::_internal_has_j() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Quaternion::has_j() const {
  return _internal_has_j();
}
inline void Quaternion::clear_j() {
  j_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float Quaternion::_internal_j() const {
  return j_;
}
inline float Quaternion::j() const {
  // @@protoc_insertion_point(field_get:world.Quaternion.j)
  return _internal_j();
}
inline void Quaternion::_internal_set_j(float value) {
  _has_bits_[0] |= 0x00000002u;
  j_ = value;
}
inline void Quaternion::set_j(float value) {
  _internal_set_j(value);
  // @@protoc_insertion_point(field_set:world.Quaternion.j)
}

// required float k = 3;
inline bool Quaternion::_internal_has_k() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Quaternion::has_k() const {
  return _internal_has_k();
}
inline void Quaternion::clear_k() {
  k_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float Quaternion::_internal_k() const {
  return k_;
}
inline float Quaternion::k() const {
  // @@protoc_insertion_point(field_get:world.Quaternion.k)
  return _internal_k();
}
inline void Quaternion::_internal_set_k(float value) {
  _has_bits_[0] |= 0x00000004u;
  k_ = value;
}
inline void Quaternion::set_k(float value) {
  _internal_set_k(value);
  // @@protoc_insertion_point(field_set:world.Quaternion.k)
}

// required float real = 4;
inline bool Quaternion::_internal_has_real() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Quaternion::has_real() const {
  return _internal_has_real();
}
inline void Quaternion::clear_real() {
  real_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float Quaternion::_internal_real() const {
  return real_;
}
inline float Quaternion::real() const {
  // @@protoc_insertion_point(field_get:world.Quaternion.real)
  return _internal_real();
}
inline void Quaternion::_internal_set_real(float value) {
  _has_bits_[0] |= 0x00000008u;
  real_ = value;
}
inline void Quaternion::set_real(float value) {
  _internal_set_real(value);
  // @@protoc_insertion_point(field_set:world.Quaternion.real)
}

// -------------------------------------------------------------------

// SimRobot

// required uint32 id = 1;
inline bool SimRobot::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SimRobot::has_id() const {
  return _internal_has_id();
}
inline void SimRobot::clear_id() {
  id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SimRobot::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SimRobot::id() const {
  // @@protoc_insertion_point(field_get:world.SimRobot.id)
  return _internal_id();
}
inline void SimRobot::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  id_ = value;
}
inline void SimRobot::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:world.SimRobot.id)
}

// required float p_x = 2;
inline bool SimRobot::_internal_has_p_x() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SimRobot::has_p_x() const {
  return _internal_has_p_x();
}
inline void SimRobot::clear_p_x() {
  p_x_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float SimRobot::_internal_p_x() const {
  return p_x_;
}
inline float SimRobot::p_x() const {
  // @@protoc_insertion_point(field_get:world.SimRobot.p_x)
  return _internal_p_x();
}
inline void SimRobot::_internal_set_p_x(float value) {
  _has_bits_[0] |= 0x00000004u;
  p_x_ = value;
}
inline void SimRobot::set_p_x(float value) {
  _internal_set_p_x(value);
  // @@protoc_insertion_point(field_set:world.SimRobot.p_x)
}

// required float p_y = 3;
inline bool SimRobot::_internal_has_p_y() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SimRobot::has_p_y() const {
  return _internal_has_p_y();
}
inline void SimRobot::clear_p_y() {
  p_y_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float SimRobot::_internal_p_y() const {
  return p_y_;
}
inline float SimRobot::p_y() const {
  // @@protoc_insertion_point(field_get:world.SimRobot.p_y)
  return _internal_p_y();
}
inline void SimRobot::_internal_set_p_y(float value) {
  _has_bits_[0] |= 0x00000008u;
  p_y_ = value;
}
inline void SimRobot::set_p_y(float value) {
  _internal_set_p_y(value);
  // @@protoc_insertion_point(field_set:world.SimRobot.p_y)
}

// required float p_z = 4;
inline bool SimRobot::_internal_has_p_z() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SimRobot::has_p_z() const {
  return _internal_has_p_z();
}
inline void SimRobot::clear_p_z() {
  p_z_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float SimRobot::_internal_p_z() const {
  return p_z_;
}
inline float SimRobot::p_z() const {
  // @@protoc_insertion_point(field_get:world.SimRobot.p_z)
  return _internal_p_z();
}
inline void SimRobot::_internal_set_p_z(float value) {
  _has_bits_[0] |= 0x00000010u;
  p_z_ = value;
}
inline void SimRobot::set_p_z(float value) {
  _internal_set_p_z(value);
  // @@protoc_insertion_point(field_set:world.SimRobot.p_z)
}

// required .world.Quaternion rotation = 5;
inline bool SimRobot::_internal_has_rotation() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || rotation_ != nullptr);
  return value;
}
inline bool SimRobot::has_rotation() const {
  return _internal_has_rotation();
}
inline void SimRobot::clear_rotation() {
  if (rotation_ != nullptr) rotation_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::world::Quaternion& SimRobot::_internal_rotation() const {
  const ::world::Quaternion* p = rotation_;
  return p != nullptr ? *p : *reinterpret_cast<const ::world::Quaternion*>(
      &::world::_Quaternion_default_instance_);
}
inline const ::world::Quaternion& SimRobot::rotation() const {
  // @@protoc_insertion_point(field_get:world.SimRobot.rotation)
  return _internal_rotation();
}
inline void SimRobot::unsafe_arena_set_allocated_rotation(
    ::world::Quaternion* rotation) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rotation_);
  }
  rotation_ = rotation;
  if (rotation) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:world.SimRobot.rotation)
}
inline ::world::Quaternion* SimRobot::release_rotation() {
  auto temp = unsafe_arena_release_rotation();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::world::Quaternion* SimRobot::unsafe_arena_release_rotation() {
  // @@protoc_insertion_point(field_release:world.SimRobot.rotation)
  _has_bits_[0] &= ~0x00000001u;
  ::world::Quaternion* temp = rotation_;
  rotation_ = nullptr;
  return temp;
}
inline ::world::Quaternion* SimRobot::_internal_mutable_rotation() {
  _has_bits_[0] |= 0x00000001u;
  if (rotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::world::Quaternion>(GetArena());
    rotation_ = p;
  }
  return rotation_;
}
inline ::world::Quaternion* SimRobot::mutable_rotation() {
  // @@protoc_insertion_point(field_mutable:world.SimRobot.rotation)
  return _internal_mutable_rotation();
}
inline void SimRobot::set_allocated_rotation(::world::Quaternion* rotation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete rotation_;
  }
  if (rotation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(rotation);
    if (message_arena != submessage_arena) {
      rotation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rotation, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  rotation_ = rotation;
  // @@protoc_insertion_point(field_set_allocated:world.SimRobot.rotation)
}

// required float v_x = 6;
inline bool SimRobot::_internal_has_v_x() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool SimRobot::has_v_x() const {
  return _internal_has_v_x();
}
inline void SimRobot::clear_v_x() {
  v_x_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline float SimRobot::_internal_v_x() const {
  return v_x_;
}
inline float SimRobot::v_x() const {
  // @@protoc_insertion_point(field_get:world.SimRobot.v_x)
  return _internal_v_x();
}
inline void SimRobot::_internal_set_v_x(float value) {
  _has_bits_[0] |= 0x00000020u;
  v_x_ = value;
}
inline void SimRobot::set_v_x(float value) {
  _internal_set_v_x(value);
  // @@protoc_insertion_point(field_set:world.SimRobot.v_x)
}

// required float v_y = 7;
inline bool SimRobot::_internal_has_v_y() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool SimRobot::has_v_y() const {
  return _internal_has_v_y();
}
inline void SimRobot::clear_v_y() {
  v_y_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline float SimRobot::_internal_v_y() const {
  return v_y_;
}
inline float SimRobot::v_y() const {
  // @@protoc_insertion_point(field_get:world.SimRobot.v_y)
  return _internal_v_y();
}
inline void SimRobot::_internal_set_v_y(float value) {
  _has_bits_[0] |= 0x00000040u;
  v_y_ = value;
}
inline void SimRobot::set_v_y(float value) {
  _internal_set_v_y(value);
  // @@protoc_insertion_point(field_set:world.SimRobot.v_y)
}

// required float v_z = 8;
inline bool SimRobot::_internal_has_v_z() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool SimRobot::has_v_z() const {
  return _internal_has_v_z();
}
inline void SimRobot::clear_v_z() {
  v_z_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline float SimRobot::_internal_v_z() const {
  return v_z_;
}
inline float SimRobot::v_z() const {
  // @@protoc_insertion_point(field_get:world.SimRobot.v_z)
  return _internal_v_z();
}
inline void SimRobot::_internal_set_v_z(float value) {
  _has_bits_[0] |= 0x00000080u;
  v_z_ = value;
}
inline void SimRobot::set_v_z(float value) {
  _internal_set_v_z(value);
  // @@protoc_insertion_point(field_set:world.SimRobot.v_z)
}

// required float r_x = 9;
inline bool SimRobot::_internal_has_r_x() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool SimRobot::has_r_x() const {
  return _internal_has_r_x();
}
inline void SimRobot::clear_r_x() {
  r_x_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline float SimRobot::_internal_r_x() const {
  return r_x_;
}
inline float SimRobot::r_x() const {
  // @@protoc_insertion_point(field_get:world.SimRobot.r_x)
  return _internal_r_x();
}
inline void SimRobot::_internal_set_r_x(float value) {
  _has_bits_[0] |= 0x00000100u;
  r_x_ = value;
}
inline void SimRobot::set_r_x(float value) {
  _internal_set_r_x(value);
  // @@protoc_insertion_point(field_set:world.SimRobot.r_x)
}

// required float r_y = 10;
inline bool SimRobot::_internal_has_r_y() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool SimRobot::has_r_y() const {
  return _internal_has_r_y();
}
inline void SimRobot::clear_r_y() {
  r_y_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline float SimRobot::_internal_r_y() const {
  return r_y_;
}
inline float SimRobot::r_y() const {
  // @@protoc_insertion_point(field_get:world.SimRobot.r_y)
  return _internal_r_y();
}
inline void SimRobot::_internal_set_r_y(float value) {
  _has_bits_[0] |= 0x00000200u;
  r_y_ = value;
}
inline void SimRobot::set_r_y(float value) {
  _internal_set_r_y(value);
  // @@protoc_insertion_point(field_set:world.SimRobot.r_y)
}

// required float r_z = 11;
inline bool SimRobot::_internal_has_r_z() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool SimRobot::has_r_z() const {
  return _internal_has_r_z();
}
inline void SimRobot::clear_r_z() {
  r_z_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline float SimRobot::_internal_r_z() const {
  return r_z_;
}
inline float SimRobot::r_z() const {
  // @@protoc_insertion_point(field_get:world.SimRobot.r_z)
  return _internal_r_z();
}
inline void SimRobot::_internal_set_r_z(float value) {
  _has_bits_[0] |= 0x00000400u;
  r_z_ = value;
}
inline void SimRobot::set_r_z(float value) {
  _internal_set_r_z(value);
  // @@protoc_insertion_point(field_set:world.SimRobot.r_z)
}

// optional bool touches_ball = 12;
inline bool SimRobot::_internal_has_touches_ball() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool SimRobot::has_touches_ball() const {
  return _internal_has_touches_ball();
}
inline void SimRobot::clear_touches_ball() {
  touches_ball_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool SimRobot::_internal_touches_ball() const {
  return touches_ball_;
}
inline bool SimRobot::touches_ball() const {
  // @@protoc_insertion_point(field_get:world.SimRobot.touches_ball)
  return _internal_touches_ball();
}
inline void SimRobot::_internal_set_touches_ball(bool value) {
  _has_bits_[0] |= 0x00000800u;
  touches_ball_ = value;
}
inline void SimRobot::set_touches_ball(bool value) {
  _internal_set_touches_ball(value);
  // @@protoc_insertion_point(field_set:world.SimRobot.touches_ball)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace world

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::world::Geometry_GeometryType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::world::Geometry_GeometryType>() {
  return ::world::Geometry_GeometryType_descriptor();
}
template <> struct is_proto_enum< ::world::Geometry_Division> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::world::Geometry_Division>() {
  return ::world::Geometry_Division_descriptor();
}
template <> struct is_proto_enum< ::world::WorldSource> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::world::WorldSource>() {
  return ::world::WorldSource_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_world_2eproto
