// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: robot.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_robot_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_robot_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_robot_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_robot_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[14]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_robot_2eproto;
namespace robot {
class Command;
class CommandDefaultTypeInternal;
extern CommandDefaultTypeInternal _Command_default_instance_;
class ControllerInput;
class ControllerInputDefaultTypeInternal;
extern ControllerInputDefaultTypeInternal _ControllerInput_default_instance_;
class ExtendedError;
class ExtendedErrorDefaultTypeInternal;
extern ExtendedErrorDefaultTypeInternal _ExtendedError_default_instance_;
class Generation;
class GenerationDefaultTypeInternal;
extern GenerationDefaultTypeInternal _Generation_default_instance_;
class LimitParameters;
class LimitParametersDefaultTypeInternal;
extern LimitParametersDefaultTypeInternal _LimitParameters_default_instance_;
class Polynomial;
class PolynomialDefaultTypeInternal;
extern PolynomialDefaultTypeInternal _Polynomial_default_instance_;
class RadioCommand;
class RadioCommandDefaultTypeInternal;
extern RadioCommandDefaultTypeInternal _RadioCommand_default_instance_;
class RadioResponse;
class RadioResponseDefaultTypeInternal;
extern RadioResponseDefaultTypeInternal _RadioResponse_default_instance_;
class SimulationLimits;
class SimulationLimitsDefaultTypeInternal;
extern SimulationLimitsDefaultTypeInternal _SimulationLimits_default_instance_;
class Specs;
class SpecsDefaultTypeInternal;
extern SpecsDefaultTypeInternal _Specs_default_instance_;
class SpeedStatus;
class SpeedStatusDefaultTypeInternal;
extern SpeedStatusDefaultTypeInternal _SpeedStatus_default_instance_;
class SpeedVector;
class SpeedVectorDefaultTypeInternal;
extern SpeedVectorDefaultTypeInternal _SpeedVector_default_instance_;
class Spline;
class SplineDefaultTypeInternal;
extern SplineDefaultTypeInternal _Spline_default_instance_;
class Team;
class TeamDefaultTypeInternal;
extern TeamDefaultTypeInternal _Team_default_instance_;
}  // namespace robot
PROTOBUF_NAMESPACE_OPEN
template<> ::robot::Command* Arena::CreateMaybeMessage<::robot::Command>(Arena*);
template<> ::robot::ControllerInput* Arena::CreateMaybeMessage<::robot::ControllerInput>(Arena*);
template<> ::robot::ExtendedError* Arena::CreateMaybeMessage<::robot::ExtendedError>(Arena*);
template<> ::robot::Generation* Arena::CreateMaybeMessage<::robot::Generation>(Arena*);
template<> ::robot::LimitParameters* Arena::CreateMaybeMessage<::robot::LimitParameters>(Arena*);
template<> ::robot::Polynomial* Arena::CreateMaybeMessage<::robot::Polynomial>(Arena*);
template<> ::robot::RadioCommand* Arena::CreateMaybeMessage<::robot::RadioCommand>(Arena*);
template<> ::robot::RadioResponse* Arena::CreateMaybeMessage<::robot::RadioResponse>(Arena*);
template<> ::robot::SimulationLimits* Arena::CreateMaybeMessage<::robot::SimulationLimits>(Arena*);
template<> ::robot::Specs* Arena::CreateMaybeMessage<::robot::Specs>(Arena*);
template<> ::robot::SpeedStatus* Arena::CreateMaybeMessage<::robot::SpeedStatus>(Arena*);
template<> ::robot::SpeedVector* Arena::CreateMaybeMessage<::robot::SpeedVector>(Arena*);
template<> ::robot::Spline* Arena::CreateMaybeMessage<::robot::Spline>(Arena*);
template<> ::robot::Team* Arena::CreateMaybeMessage<::robot::Team>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace robot {

enum Specs_GenerationType : int {
  Specs_GenerationType_Regular = 1,
  Specs_GenerationType_Ally = 2
};
bool Specs_GenerationType_IsValid(int value);
constexpr Specs_GenerationType Specs_GenerationType_GenerationType_MIN = Specs_GenerationType_Regular;
constexpr Specs_GenerationType Specs_GenerationType_GenerationType_MAX = Specs_GenerationType_Ally;
constexpr int Specs_GenerationType_GenerationType_ARRAYSIZE = Specs_GenerationType_GenerationType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Specs_GenerationType_descriptor();
template<typename T>
inline const std::string& Specs_GenerationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Specs_GenerationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Specs_GenerationType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Specs_GenerationType_descriptor(), enum_t_value);
}
inline bool Specs_GenerationType_Parse(
    const std::string& name, Specs_GenerationType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Specs_GenerationType>(
    Specs_GenerationType_descriptor(), name, value);
}
enum Command_KickStyle : int {
  Command_KickStyle_Linear = 1,
  Command_KickStyle_Chip = 2
};
bool Command_KickStyle_IsValid(int value);
constexpr Command_KickStyle Command_KickStyle_KickStyle_MIN = Command_KickStyle_Linear;
constexpr Command_KickStyle Command_KickStyle_KickStyle_MAX = Command_KickStyle_Chip;
constexpr int Command_KickStyle_KickStyle_ARRAYSIZE = Command_KickStyle_KickStyle_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Command_KickStyle_descriptor();
template<typename T>
inline const std::string& Command_KickStyle_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Command_KickStyle>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Command_KickStyle_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Command_KickStyle_descriptor(), enum_t_value);
}
inline bool Command_KickStyle_Parse(
    const std::string& name, Command_KickStyle* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Command_KickStyle>(
    Command_KickStyle_descriptor(), name, value);
}
// ===================================================================

class LimitParameters PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:robot.LimitParameters) */ {
 public:
  inline LimitParameters() : LimitParameters(nullptr) {};
  virtual ~LimitParameters();

  LimitParameters(const LimitParameters& from);
  LimitParameters(LimitParameters&& from) noexcept
    : LimitParameters() {
    *this = ::std::move(from);
  }

  inline LimitParameters& operator=(const LimitParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline LimitParameters& operator=(LimitParameters&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LimitParameters& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LimitParameters* internal_default_instance() {
    return reinterpret_cast<const LimitParameters*>(
               &_LimitParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(LimitParameters& a, LimitParameters& b) {
    a.Swap(&b);
  }
  inline void Swap(LimitParameters* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LimitParameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LimitParameters* New() const final {
    return CreateMaybeMessage<LimitParameters>(nullptr);
  }

  LimitParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LimitParameters>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LimitParameters& from);
  void MergeFrom(const LimitParameters& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LimitParameters* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "robot.LimitParameters";
  }
  protected:
  explicit LimitParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_robot_2eproto);
    return ::descriptor_table_robot_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kASpeedupFMaxFieldNumber = 1,
    kASpeedupSMaxFieldNumber = 2,
    kASpeedupPhiMaxFieldNumber = 3,
    kABrakeFMaxFieldNumber = 4,
    kABrakeSMaxFieldNumber = 5,
    kABrakePhiMaxFieldNumber = 6,
  };
  // optional float a_speedup_f_max = 1;
  bool has_a_speedup_f_max() const;
  private:
  bool _internal_has_a_speedup_f_max() const;
  public:
  void clear_a_speedup_f_max();
  float a_speedup_f_max() const;
  void set_a_speedup_f_max(float value);
  private:
  float _internal_a_speedup_f_max() const;
  void _internal_set_a_speedup_f_max(float value);
  public:

  // optional float a_speedup_s_max = 2;
  bool has_a_speedup_s_max() const;
  private:
  bool _internal_has_a_speedup_s_max() const;
  public:
  void clear_a_speedup_s_max();
  float a_speedup_s_max() const;
  void set_a_speedup_s_max(float value);
  private:
  float _internal_a_speedup_s_max() const;
  void _internal_set_a_speedup_s_max(float value);
  public:

  // optional float a_speedup_phi_max = 3;
  bool has_a_speedup_phi_max() const;
  private:
  bool _internal_has_a_speedup_phi_max() const;
  public:
  void clear_a_speedup_phi_max();
  float a_speedup_phi_max() const;
  void set_a_speedup_phi_max(float value);
  private:
  float _internal_a_speedup_phi_max() const;
  void _internal_set_a_speedup_phi_max(float value);
  public:

  // optional float a_brake_f_max = 4;
  bool has_a_brake_f_max() const;
  private:
  bool _internal_has_a_brake_f_max() const;
  public:
  void clear_a_brake_f_max();
  float a_brake_f_max() const;
  void set_a_brake_f_max(float value);
  private:
  float _internal_a_brake_f_max() const;
  void _internal_set_a_brake_f_max(float value);
  public:

  // optional float a_brake_s_max = 5;
  bool has_a_brake_s_max() const;
  private:
  bool _internal_has_a_brake_s_max() const;
  public:
  void clear_a_brake_s_max();
  float a_brake_s_max() const;
  void set_a_brake_s_max(float value);
  private:
  float _internal_a_brake_s_max() const;
  void _internal_set_a_brake_s_max(float value);
  public:

  // optional float a_brake_phi_max = 6;
  bool has_a_brake_phi_max() const;
  private:
  bool _internal_has_a_brake_phi_max() const;
  public:
  void clear_a_brake_phi_max();
  float a_brake_phi_max() const;
  void set_a_brake_phi_max(float value);
  private:
  float _internal_a_brake_phi_max() const;
  void _internal_set_a_brake_phi_max(float value);
  public:

  // @@protoc_insertion_point(class_scope:robot.LimitParameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float a_speedup_f_max_;
  float a_speedup_s_max_;
  float a_speedup_phi_max_;
  float a_brake_f_max_;
  float a_brake_s_max_;
  float a_brake_phi_max_;
  friend struct ::TableStruct_robot_2eproto;
};
// -------------------------------------------------------------------

class SimulationLimits PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:robot.SimulationLimits) */ {
 public:
  inline SimulationLimits() : SimulationLimits(nullptr) {};
  virtual ~SimulationLimits();

  SimulationLimits(const SimulationLimits& from);
  SimulationLimits(SimulationLimits&& from) noexcept
    : SimulationLimits() {
    *this = ::std::move(from);
  }

  inline SimulationLimits& operator=(const SimulationLimits& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimulationLimits& operator=(SimulationLimits&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SimulationLimits& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SimulationLimits* internal_default_instance() {
    return reinterpret_cast<const SimulationLimits*>(
               &_SimulationLimits_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SimulationLimits& a, SimulationLimits& b) {
    a.Swap(&b);
  }
  inline void Swap(SimulationLimits* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SimulationLimits* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SimulationLimits* New() const final {
    return CreateMaybeMessage<SimulationLimits>(nullptr);
  }

  SimulationLimits* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SimulationLimits>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SimulationLimits& from);
  void MergeFrom(const SimulationLimits& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimulationLimits* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "robot.SimulationLimits";
  }
  protected:
  explicit SimulationLimits(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_robot_2eproto);
    return ::descriptor_table_robot_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kASpeedupWheelMaxFieldNumber = 1,
    kABrakeWheelMaxFieldNumber = 2,
  };
  // optional float a_speedup_wheel_max = 1;
  bool has_a_speedup_wheel_max() const;
  private:
  bool _internal_has_a_speedup_wheel_max() const;
  public:
  void clear_a_speedup_wheel_max();
  float a_speedup_wheel_max() const;
  void set_a_speedup_wheel_max(float value);
  private:
  float _internal_a_speedup_wheel_max() const;
  void _internal_set_a_speedup_wheel_max(float value);
  public:

  // optional float a_brake_wheel_max = 2;
  bool has_a_brake_wheel_max() const;
  private:
  bool _internal_has_a_brake_wheel_max() const;
  public:
  void clear_a_brake_wheel_max();
  float a_brake_wheel_max() const;
  void set_a_brake_wheel_max(float value);
  private:
  float _internal_a_brake_wheel_max() const;
  void _internal_set_a_brake_wheel_max(float value);
  public:

  // @@protoc_insertion_point(class_scope:robot.SimulationLimits)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float a_speedup_wheel_max_;
  float a_brake_wheel_max_;
  friend struct ::TableStruct_robot_2eproto;
};
// -------------------------------------------------------------------

class Specs PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:robot.Specs) */ {
 public:
  inline Specs() : Specs(nullptr) {};
  virtual ~Specs();

  Specs(const Specs& from);
  Specs(Specs&& from) noexcept
    : Specs() {
    *this = ::std::move(from);
  }

  inline Specs& operator=(const Specs& from) {
    CopyFrom(from);
    return *this;
  }
  inline Specs& operator=(Specs&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Specs& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Specs* internal_default_instance() {
    return reinterpret_cast<const Specs*>(
               &_Specs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Specs& a, Specs& b) {
    a.Swap(&b);
  }
  inline void Swap(Specs* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Specs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Specs* New() const final {
    return CreateMaybeMessage<Specs>(nullptr);
  }

  Specs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Specs>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Specs& from);
  void MergeFrom(const Specs& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Specs* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "robot.Specs";
  }
  protected:
  explicit Specs(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_robot_2eproto);
    return ::descriptor_table_robot_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Specs_GenerationType GenerationType;
  static constexpr GenerationType Regular =
    Specs_GenerationType_Regular;
  static constexpr GenerationType Ally =
    Specs_GenerationType_Ally;
  static inline bool GenerationType_IsValid(int value) {
    return Specs_GenerationType_IsValid(value);
  }
  static constexpr GenerationType GenerationType_MIN =
    Specs_GenerationType_GenerationType_MIN;
  static constexpr GenerationType GenerationType_MAX =
    Specs_GenerationType_GenerationType_MAX;
  static constexpr int GenerationType_ARRAYSIZE =
    Specs_GenerationType_GenerationType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  GenerationType_descriptor() {
    return Specs_GenerationType_descriptor();
  }
  template<typename T>
  static inline const std::string& GenerationType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, GenerationType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function GenerationType_Name.");
    return Specs_GenerationType_Name(enum_t_value);
  }
  static inline bool GenerationType_Parse(const std::string& name,
      GenerationType* value) {
    return Specs_GenerationType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAccelerationFieldNumber = 13,
    kStrategyFieldNumber = 16,
    kSimulationLimitsFieldNumber = 21,
    kGenerationFieldNumber = 1,
    kYearFieldNumber = 2,
    kIdFieldNumber = 3,
    kMassFieldNumber = 6,
    kAngleFieldNumber = 7,
    kVMaxFieldNumber = 8,
    kOmegaMaxFieldNumber = 9,
    kShotChipMaxFieldNumber = 11,
    kDribblerWidthFieldNumber = 12,
    kIrParamFieldNumber = 15,
    kShootRadiusFieldNumber = 17,
    kDribblerHeightFieldNumber = 18,
    kCanShootFieldNumber = 22,
    kCanDribbleFieldNumber = 23,
    kRadiusFieldNumber = 4,
    kHeightFieldNumber = 5,
    kShotLinearMaxFieldNumber = 10,
    kTypeFieldNumber = 19,
  };
  // optional .robot.LimitParameters acceleration = 13;
  bool has_acceleration() const;
  private:
  bool _internal_has_acceleration() const;
  public:
  void clear_acceleration();
  const ::robot::LimitParameters& acceleration() const;
  ::robot::LimitParameters* release_acceleration();
  ::robot::LimitParameters* mutable_acceleration();
  void set_allocated_acceleration(::robot::LimitParameters* acceleration);
  private:
  const ::robot::LimitParameters& _internal_acceleration() const;
  ::robot::LimitParameters* _internal_mutable_acceleration();
  public:
  void unsafe_arena_set_allocated_acceleration(
      ::robot::LimitParameters* acceleration);
  ::robot::LimitParameters* unsafe_arena_release_acceleration();

  // optional .robot.LimitParameters strategy = 16;
  bool has_strategy() const;
  private:
  bool _internal_has_strategy() const;
  public:
  void clear_strategy();
  const ::robot::LimitParameters& strategy() const;
  ::robot::LimitParameters* release_strategy();
  ::robot::LimitParameters* mutable_strategy();
  void set_allocated_strategy(::robot::LimitParameters* strategy);
  private:
  const ::robot::LimitParameters& _internal_strategy() const;
  ::robot::LimitParameters* _internal_mutable_strategy();
  public:
  void unsafe_arena_set_allocated_strategy(
      ::robot::LimitParameters* strategy);
  ::robot::LimitParameters* unsafe_arena_release_strategy();

  // optional .robot.SimulationLimits simulation_limits = 21;
  bool has_simulation_limits() const;
  private:
  bool _internal_has_simulation_limits() const;
  public:
  void clear_simulation_limits();
  const ::robot::SimulationLimits& simulation_limits() const;
  ::robot::SimulationLimits* release_simulation_limits();
  ::robot::SimulationLimits* mutable_simulation_limits();
  void set_allocated_simulation_limits(::robot::SimulationLimits* simulation_limits);
  private:
  const ::robot::SimulationLimits& _internal_simulation_limits() const;
  ::robot::SimulationLimits* _internal_mutable_simulation_limits();
  public:
  void unsafe_arena_set_allocated_simulation_limits(
      ::robot::SimulationLimits* simulation_limits);
  ::robot::SimulationLimits* unsafe_arena_release_simulation_limits();

  // required uint32 generation = 1;
  bool has_generation() const;
  private:
  bool _internal_has_generation() const;
  public:
  void clear_generation();
  ::PROTOBUF_NAMESPACE_ID::uint32 generation() const;
  void set_generation(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_generation() const;
  void _internal_set_generation(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 year = 2;
  bool has_year() const;
  private:
  bool _internal_has_year() const;
  public:
  void clear_year();
  ::PROTOBUF_NAMESPACE_ID::uint32 year() const;
  void set_year(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_year() const;
  void _internal_set_year(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 id = 3;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional float mass = 6;
  bool has_mass() const;
  private:
  bool _internal_has_mass() const;
  public:
  void clear_mass();
  float mass() const;
  void set_mass(float value);
  private:
  float _internal_mass() const;
  void _internal_set_mass(float value);
  public:

  // optional float angle = 7;
  bool has_angle() const;
  private:
  bool _internal_has_angle() const;
  public:
  void clear_angle();
  float angle() const;
  void set_angle(float value);
  private:
  float _internal_angle() const;
  void _internal_set_angle(float value);
  public:

  // optional float v_max = 8;
  bool has_v_max() const;
  private:
  bool _internal_has_v_max() const;
  public:
  void clear_v_max();
  float v_max() const;
  void set_v_max(float value);
  private:
  float _internal_v_max() const;
  void _internal_set_v_max(float value);
  public:

  // optional float omega_max = 9;
  bool has_omega_max() const;
  private:
  bool _internal_has_omega_max() const;
  public:
  void clear_omega_max();
  float omega_max() const;
  void set_omega_max(float value);
  private:
  float _internal_omega_max() const;
  void _internal_set_omega_max(float value);
  public:

  // optional float shot_chip_max = 11;
  bool has_shot_chip_max() const;
  private:
  bool _internal_has_shot_chip_max() const;
  public:
  void clear_shot_chip_max();
  float shot_chip_max() const;
  void set_shot_chip_max(float value);
  private:
  float _internal_shot_chip_max() const;
  void _internal_set_shot_chip_max(float value);
  public:

  // optional float dribbler_width = 12;
  bool has_dribbler_width() const;
  private:
  bool _internal_has_dribbler_width() const;
  public:
  void clear_dribbler_width();
  float dribbler_width() const;
  void set_dribbler_width(float value);
  private:
  float _internal_dribbler_width() const;
  void _internal_set_dribbler_width(float value);
  public:

  // optional float ir_param = 15;
  bool has_ir_param() const;
  private:
  bool _internal_has_ir_param() const;
  public:
  void clear_ir_param();
  float ir_param() const;
  void set_ir_param(float value);
  private:
  float _internal_ir_param() const;
  void _internal_set_ir_param(float value);
  public:

  // optional float shoot_radius = 17;
  bool has_shoot_radius() const;
  private:
  bool _internal_has_shoot_radius() const;
  public:
  void clear_shoot_radius();
  float shoot_radius() const;
  void set_shoot_radius(float value);
  private:
  float _internal_shoot_radius() const;
  void _internal_set_shoot_radius(float value);
  public:

  // optional float dribbler_height = 18;
  bool has_dribbler_height() const;
  private:
  bool _internal_has_dribbler_height() const;
  public:
  void clear_dribbler_height();
  float dribbler_height() const;
  void set_dribbler_height(float value);
  private:
  float _internal_dribbler_height() const;
  void _internal_set_dribbler_height(float value);
  public:

  // optional bool can_shoot = 22 [default = true];
  bool has_can_shoot() const;
  private:
  bool _internal_has_can_shoot() const;
  public:
  void clear_can_shoot();
  bool can_shoot() const;
  void set_can_shoot(bool value);
  private:
  bool _internal_can_shoot() const;
  void _internal_set_can_shoot(bool value);
  public:

  // optional bool can_dribble = 23 [default = true];
  bool has_can_dribble() const;
  private:
  bool _internal_has_can_dribble() const;
  public:
  void clear_can_dribble();
  bool can_dribble() const;
  void set_can_dribble(bool value);
  private:
  bool _internal_can_dribble() const;
  void _internal_set_can_dribble(bool value);
  public:

  // optional float radius = 4 [default = 0.09];
  bool has_radius() const;
  private:
  bool _internal_has_radius() const;
  public:
  void clear_radius();
  float radius() const;
  void set_radius(float value);
  private:
  float _internal_radius() const;
  void _internal_set_radius(float value);
  public:

  // optional float height = 5 [default = 0.15];
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  float height() const;
  void set_height(float value);
  private:
  float _internal_height() const;
  void _internal_set_height(float value);
  public:

  // optional float shot_linear_max = 10 [default = 8];
  bool has_shot_linear_max() const;
  private:
  bool _internal_has_shot_linear_max() const;
  public:
  void clear_shot_linear_max();
  float shot_linear_max() const;
  void set_shot_linear_max(float value);
  private:
  float _internal_shot_linear_max() const;
  void _internal_set_shot_linear_max(float value);
  public:

  // optional .robot.Specs.GenerationType type = 19;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::robot::Specs_GenerationType type() const;
  void set_type(::robot::Specs_GenerationType value);
  private:
  ::robot::Specs_GenerationType _internal_type() const;
  void _internal_set_type(::robot::Specs_GenerationType value);
  public:

  // @@protoc_insertion_point(class_scope:robot.Specs)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::robot::LimitParameters* acceleration_;
  ::robot::LimitParameters* strategy_;
  ::robot::SimulationLimits* simulation_limits_;
  ::PROTOBUF_NAMESPACE_ID::uint32 generation_;
  ::PROTOBUF_NAMESPACE_ID::uint32 year_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  float mass_;
  float angle_;
  float v_max_;
  float omega_max_;
  float shot_chip_max_;
  float dribbler_width_;
  float ir_param_;
  float shoot_radius_;
  float dribbler_height_;
  bool can_shoot_;
  bool can_dribble_;
  float radius_;
  float height_;
  float shot_linear_max_;
  int type_;
  friend struct ::TableStruct_robot_2eproto;
};
// -------------------------------------------------------------------

class Generation PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:robot.Generation) */ {
 public:
  inline Generation() : Generation(nullptr) {};
  virtual ~Generation();

  Generation(const Generation& from);
  Generation(Generation&& from) noexcept
    : Generation() {
    *this = ::std::move(from);
  }

  inline Generation& operator=(const Generation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Generation& operator=(Generation&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Generation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Generation* internal_default_instance() {
    return reinterpret_cast<const Generation*>(
               &_Generation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Generation& a, Generation& b) {
    a.Swap(&b);
  }
  inline void Swap(Generation* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Generation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Generation* New() const final {
    return CreateMaybeMessage<Generation>(nullptr);
  }

  Generation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Generation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Generation& from);
  void MergeFrom(const Generation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Generation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "robot.Generation";
  }
  protected:
  explicit Generation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_robot_2eproto);
    return ::descriptor_table_robot_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotFieldNumber = 2,
    kDefaultFieldNumber = 1,
  };
  // repeated .robot.Specs robot = 2;
  int robot_size() const;
  private:
  int _internal_robot_size() const;
  public:
  void clear_robot();
  ::robot::Specs* mutable_robot(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::Specs >*
      mutable_robot();
  private:
  const ::robot::Specs& _internal_robot(int index) const;
  ::robot::Specs* _internal_add_robot();
  public:
  const ::robot::Specs& robot(int index) const;
  ::robot::Specs* add_robot();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::Specs >&
      robot() const;

  // required .robot.Specs default = 1;
  bool has_default_() const;
  private:
  bool _internal_has_default_() const;
  public:
  void clear_default_();
  const ::robot::Specs& default_() const;
  ::robot::Specs* release_default_();
  ::robot::Specs* mutable_default_();
  void set_allocated_default_(::robot::Specs* default_);
  private:
  const ::robot::Specs& _internal_default_() const;
  ::robot::Specs* _internal_mutable_default_();
  public:
  void unsafe_arena_set_allocated_default_(
      ::robot::Specs* default_);
  ::robot::Specs* unsafe_arena_release_default_();

  // @@protoc_insertion_point(class_scope:robot.Generation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::Specs > robot_;
  ::robot::Specs* default__;
  friend struct ::TableStruct_robot_2eproto;
};
// -------------------------------------------------------------------

class Team PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:robot.Team) */ {
 public:
  inline Team() : Team(nullptr) {};
  virtual ~Team();

  Team(const Team& from);
  Team(Team&& from) noexcept
    : Team() {
    *this = ::std::move(from);
  }

  inline Team& operator=(const Team& from) {
    CopyFrom(from);
    return *this;
  }
  inline Team& operator=(Team&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Team& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Team* internal_default_instance() {
    return reinterpret_cast<const Team*>(
               &_Team_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Team& a, Team& b) {
    a.Swap(&b);
  }
  inline void Swap(Team* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Team* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Team* New() const final {
    return CreateMaybeMessage<Team>(nullptr);
  }

  Team* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Team>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Team& from);
  void MergeFrom(const Team& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Team* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "robot.Team";
  }
  protected:
  explicit Team(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_robot_2eproto);
    return ::descriptor_table_robot_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotFieldNumber = 1,
  };
  // repeated .robot.Specs robot = 1;
  int robot_size() const;
  private:
  int _internal_robot_size() const;
  public:
  void clear_robot();
  ::robot::Specs* mutable_robot(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::Specs >*
      mutable_robot();
  private:
  const ::robot::Specs& _internal_robot(int index) const;
  ::robot::Specs* _internal_add_robot();
  public:
  const ::robot::Specs& robot(int index) const;
  ::robot::Specs* add_robot();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::Specs >&
      robot() const;

  // @@protoc_insertion_point(class_scope:robot.Team)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::Specs > robot_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_2eproto;
};
// -------------------------------------------------------------------

class Polynomial PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:robot.Polynomial) */ {
 public:
  inline Polynomial() : Polynomial(nullptr) {};
  virtual ~Polynomial();

  Polynomial(const Polynomial& from);
  Polynomial(Polynomial&& from) noexcept
    : Polynomial() {
    *this = ::std::move(from);
  }

  inline Polynomial& operator=(const Polynomial& from) {
    CopyFrom(from);
    return *this;
  }
  inline Polynomial& operator=(Polynomial&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Polynomial& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Polynomial* internal_default_instance() {
    return reinterpret_cast<const Polynomial*>(
               &_Polynomial_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Polynomial& a, Polynomial& b) {
    a.Swap(&b);
  }
  inline void Swap(Polynomial* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Polynomial* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Polynomial* New() const final {
    return CreateMaybeMessage<Polynomial>(nullptr);
  }

  Polynomial* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Polynomial>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Polynomial& from);
  void MergeFrom(const Polynomial& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Polynomial* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "robot.Polynomial";
  }
  protected:
  explicit Polynomial(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_robot_2eproto);
    return ::descriptor_table_robot_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kA0FieldNumber = 1,
    kA1FieldNumber = 2,
    kA2FieldNumber = 3,
    kA3FieldNumber = 4,
  };
  // required float a0 = 1;
  bool has_a0() const;
  private:
  bool _internal_has_a0() const;
  public:
  void clear_a0();
  float a0() const;
  void set_a0(float value);
  private:
  float _internal_a0() const;
  void _internal_set_a0(float value);
  public:

  // required float a1 = 2;
  bool has_a1() const;
  private:
  bool _internal_has_a1() const;
  public:
  void clear_a1();
  float a1() const;
  void set_a1(float value);
  private:
  float _internal_a1() const;
  void _internal_set_a1(float value);
  public:

  // required float a2 = 3;
  bool has_a2() const;
  private:
  bool _internal_has_a2() const;
  public:
  void clear_a2();
  float a2() const;
  void set_a2(float value);
  private:
  float _internal_a2() const;
  void _internal_set_a2(float value);
  public:

  // required float a3 = 4;
  bool has_a3() const;
  private:
  bool _internal_has_a3() const;
  public:
  void clear_a3();
  float a3() const;
  void set_a3(float value);
  private:
  float _internal_a3() const;
  void _internal_set_a3(float value);
  public:

  // @@protoc_insertion_point(class_scope:robot.Polynomial)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float a0_;
  float a1_;
  float a2_;
  float a3_;
  friend struct ::TableStruct_robot_2eproto;
};
// -------------------------------------------------------------------

class Spline PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:robot.Spline) */ {
 public:
  inline Spline() : Spline(nullptr) {};
  virtual ~Spline();

  Spline(const Spline& from);
  Spline(Spline&& from) noexcept
    : Spline() {
    *this = ::std::move(from);
  }

  inline Spline& operator=(const Spline& from) {
    CopyFrom(from);
    return *this;
  }
  inline Spline& operator=(Spline&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Spline& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Spline* internal_default_instance() {
    return reinterpret_cast<const Spline*>(
               &_Spline_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Spline& a, Spline& b) {
    a.Swap(&b);
  }
  inline void Swap(Spline* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Spline* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Spline* New() const final {
    return CreateMaybeMessage<Spline>(nullptr);
  }

  Spline* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Spline>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Spline& from);
  void MergeFrom(const Spline& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Spline* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "robot.Spline";
  }
  protected:
  explicit Spline(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_robot_2eproto);
    return ::descriptor_table_robot_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 3,
    kYFieldNumber = 4,
    kPhiFieldNumber = 5,
    kTStartFieldNumber = 1,
    kTEndFieldNumber = 2,
  };
  // required .robot.Polynomial x = 3;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  const ::robot::Polynomial& x() const;
  ::robot::Polynomial* release_x();
  ::robot::Polynomial* mutable_x();
  void set_allocated_x(::robot::Polynomial* x);
  private:
  const ::robot::Polynomial& _internal_x() const;
  ::robot::Polynomial* _internal_mutable_x();
  public:
  void unsafe_arena_set_allocated_x(
      ::robot::Polynomial* x);
  ::robot::Polynomial* unsafe_arena_release_x();

  // required .robot.Polynomial y = 4;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  const ::robot::Polynomial& y() const;
  ::robot::Polynomial* release_y();
  ::robot::Polynomial* mutable_y();
  void set_allocated_y(::robot::Polynomial* y);
  private:
  const ::robot::Polynomial& _internal_y() const;
  ::robot::Polynomial* _internal_mutable_y();
  public:
  void unsafe_arena_set_allocated_y(
      ::robot::Polynomial* y);
  ::robot::Polynomial* unsafe_arena_release_y();

  // required .robot.Polynomial phi = 5;
  bool has_phi() const;
  private:
  bool _internal_has_phi() const;
  public:
  void clear_phi();
  const ::robot::Polynomial& phi() const;
  ::robot::Polynomial* release_phi();
  ::robot::Polynomial* mutable_phi();
  void set_allocated_phi(::robot::Polynomial* phi);
  private:
  const ::robot::Polynomial& _internal_phi() const;
  ::robot::Polynomial* _internal_mutable_phi();
  public:
  void unsafe_arena_set_allocated_phi(
      ::robot::Polynomial* phi);
  ::robot::Polynomial* unsafe_arena_release_phi();

  // required float t_start = 1;
  bool has_t_start() const;
  private:
  bool _internal_has_t_start() const;
  public:
  void clear_t_start();
  float t_start() const;
  void set_t_start(float value);
  private:
  float _internal_t_start() const;
  void _internal_set_t_start(float value);
  public:

  // required float t_end = 2;
  bool has_t_end() const;
  private:
  bool _internal_has_t_end() const;
  public:
  void clear_t_end();
  float t_end() const;
  void set_t_end(float value);
  private:
  float _internal_t_end() const;
  void _internal_set_t_end(float value);
  public:

  // @@protoc_insertion_point(class_scope:robot.Spline)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::robot::Polynomial* x_;
  ::robot::Polynomial* y_;
  ::robot::Polynomial* phi_;
  float t_start_;
  float t_end_;
  friend struct ::TableStruct_robot_2eproto;
};
// -------------------------------------------------------------------

class ControllerInput PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:robot.ControllerInput) */ {
 public:
  inline ControllerInput() : ControllerInput(nullptr) {};
  virtual ~ControllerInput();

  ControllerInput(const ControllerInput& from);
  ControllerInput(ControllerInput&& from) noexcept
    : ControllerInput() {
    *this = ::std::move(from);
  }

  inline ControllerInput& operator=(const ControllerInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControllerInput& operator=(ControllerInput&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ControllerInput& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControllerInput* internal_default_instance() {
    return reinterpret_cast<const ControllerInput*>(
               &_ControllerInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ControllerInput& a, ControllerInput& b) {
    a.Swap(&b);
  }
  inline void Swap(ControllerInput* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControllerInput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ControllerInput* New() const final {
    return CreateMaybeMessage<ControllerInput>(nullptr);
  }

  ControllerInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ControllerInput>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ControllerInput& from);
  void MergeFrom(const ControllerInput& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControllerInput* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "robot.ControllerInput";
  }
  protected:
  explicit ControllerInput(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_robot_2eproto);
    return ::descriptor_table_robot_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSplineFieldNumber = 1,
  };
  // repeated .robot.Spline spline = 1;
  int spline_size() const;
  private:
  int _internal_spline_size() const;
  public:
  void clear_spline();
  ::robot::Spline* mutable_spline(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::Spline >*
      mutable_spline();
  private:
  const ::robot::Spline& _internal_spline(int index) const;
  ::robot::Spline* _internal_add_spline();
  public:
  const ::robot::Spline& spline(int index) const;
  ::robot::Spline* add_spline();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::Spline >&
      spline() const;

  // @@protoc_insertion_point(class_scope:robot.ControllerInput)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::Spline > spline_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_robot_2eproto;
};
// -------------------------------------------------------------------

class SpeedVector PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:robot.SpeedVector) */ {
 public:
  inline SpeedVector() : SpeedVector(nullptr) {};
  virtual ~SpeedVector();

  SpeedVector(const SpeedVector& from);
  SpeedVector(SpeedVector&& from) noexcept
    : SpeedVector() {
    *this = ::std::move(from);
  }

  inline SpeedVector& operator=(const SpeedVector& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpeedVector& operator=(SpeedVector&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SpeedVector& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpeedVector* internal_default_instance() {
    return reinterpret_cast<const SpeedVector*>(
               &_SpeedVector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SpeedVector& a, SpeedVector& b) {
    a.Swap(&b);
  }
  inline void Swap(SpeedVector* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpeedVector* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpeedVector* New() const final {
    return CreateMaybeMessage<SpeedVector>(nullptr);
  }

  SpeedVector* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpeedVector>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpeedVector& from);
  void MergeFrom(const SpeedVector& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpeedVector* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "robot.SpeedVector";
  }
  protected:
  explicit SpeedVector(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_robot_2eproto);
    return ::descriptor_table_robot_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVSFieldNumber = 1,
    kVFFieldNumber = 2,
    kOmegaFieldNumber = 3,
  };
  // optional float v_s = 1;
  bool has_v_s() const;
  private:
  bool _internal_has_v_s() const;
  public:
  void clear_v_s();
  float v_s() const;
  void set_v_s(float value);
  private:
  float _internal_v_s() const;
  void _internal_set_v_s(float value);
  public:

  // optional float v_f = 2;
  bool has_v_f() const;
  private:
  bool _internal_has_v_f() const;
  public:
  void clear_v_f();
  float v_f() const;
  void set_v_f(float value);
  private:
  float _internal_v_f() const;
  void _internal_set_v_f(float value);
  public:

  // optional float omega = 3;
  bool has_omega() const;
  private:
  bool _internal_has_omega() const;
  public:
  void clear_omega();
  float omega() const;
  void set_omega(float value);
  private:
  float _internal_omega() const;
  void _internal_set_omega(float value);
  public:

  // @@protoc_insertion_point(class_scope:robot.SpeedVector)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float v_s_;
  float v_f_;
  float omega_;
  friend struct ::TableStruct_robot_2eproto;
};
// -------------------------------------------------------------------

class Command PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:robot.Command) */ {
 public:
  inline Command() : Command(nullptr) {};
  virtual ~Command();

  Command(const Command& from);
  Command(Command&& from) noexcept
    : Command() {
    *this = ::std::move(from);
  }

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }
  inline Command& operator=(Command&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Command& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Command* internal_default_instance() {
    return reinterpret_cast<const Command*>(
               &_Command_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Command& a, Command& b) {
    a.Swap(&b);
  }
  inline void Swap(Command* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Command* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Command* New() const final {
    return CreateMaybeMessage<Command>(nullptr);
  }

  Command* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Command>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Command* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "robot.Command";
  }
  protected:
  explicit Command(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_robot_2eproto);
    return ::descriptor_table_robot_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Command_KickStyle KickStyle;
  static constexpr KickStyle Linear =
    Command_KickStyle_Linear;
  static constexpr KickStyle Chip =
    Command_KickStyle_Chip;
  static inline bool KickStyle_IsValid(int value) {
    return Command_KickStyle_IsValid(value);
  }
  static constexpr KickStyle KickStyle_MIN =
    Command_KickStyle_KickStyle_MIN;
  static constexpr KickStyle KickStyle_MAX =
    Command_KickStyle_KickStyle_MAX;
  static constexpr int KickStyle_ARRAYSIZE =
    Command_KickStyle_KickStyle_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  KickStyle_descriptor() {
    return Command_KickStyle_descriptor();
  }
  template<typename T>
  static inline const std::string& KickStyle_Name(T enum_t_value) {
    static_assert(::std::is_same<T, KickStyle>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function KickStyle_Name.");
    return Command_KickStyle_Name(enum_t_value);
  }
  static inline bool KickStyle_Parse(const std::string& name,
      KickStyle* value) {
    return Command_KickStyle_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kControllerFieldNumber = 1,
    kOutput0FieldNumber = 20,
    kOutput1FieldNumber = 21,
    kOutput2FieldNumber = 22,
    kVFFieldNumber = 2,
    kVSFieldNumber = 3,
    kOmegaFieldNumber = 4,
    kKickPowerFieldNumber = 6,
    kDribblerFieldNumber = 7,
    kLocalFieldNumber = 8,
    kStandbyFieldNumber = 11,
    kStrategyControlledFieldNumber = 13,
    kForceKickFieldNumber = 14,
    kNetworkControlledFieldNumber = 15,
    kEjectSdcardFieldNumber = 16,
    kCurVFFieldNumber = 17,
    kCurVSFieldNumber = 18,
    kCurOmegaFieldNumber = 19,
    kKickStyleFieldNumber = 5,
  };
  // optional .robot.ControllerInput controller = 1;
  bool has_controller() const;
  private:
  bool _internal_has_controller() const;
  public:
  void clear_controller();
  const ::robot::ControllerInput& controller() const;
  ::robot::ControllerInput* release_controller();
  ::robot::ControllerInput* mutable_controller();
  void set_allocated_controller(::robot::ControllerInput* controller);
  private:
  const ::robot::ControllerInput& _internal_controller() const;
  ::robot::ControllerInput* _internal_mutable_controller();
  public:
  void unsafe_arena_set_allocated_controller(
      ::robot::ControllerInput* controller);
  ::robot::ControllerInput* unsafe_arena_release_controller();

  // optional .robot.SpeedVector output0 = 20;
  bool has_output0() const;
  private:
  bool _internal_has_output0() const;
  public:
  void clear_output0();
  const ::robot::SpeedVector& output0() const;
  ::robot::SpeedVector* release_output0();
  ::robot::SpeedVector* mutable_output0();
  void set_allocated_output0(::robot::SpeedVector* output0);
  private:
  const ::robot::SpeedVector& _internal_output0() const;
  ::robot::SpeedVector* _internal_mutable_output0();
  public:
  void unsafe_arena_set_allocated_output0(
      ::robot::SpeedVector* output0);
  ::robot::SpeedVector* unsafe_arena_release_output0();

  // optional .robot.SpeedVector output1 = 21;
  bool has_output1() const;
  private:
  bool _internal_has_output1() const;
  public:
  void clear_output1();
  const ::robot::SpeedVector& output1() const;
  ::robot::SpeedVector* release_output1();
  ::robot::SpeedVector* mutable_output1();
  void set_allocated_output1(::robot::SpeedVector* output1);
  private:
  const ::robot::SpeedVector& _internal_output1() const;
  ::robot::SpeedVector* _internal_mutable_output1();
  public:
  void unsafe_arena_set_allocated_output1(
      ::robot::SpeedVector* output1);
  ::robot::SpeedVector* unsafe_arena_release_output1();

  // optional .robot.SpeedVector output2 = 22;
  bool has_output2() const;
  private:
  bool _internal_has_output2() const;
  public:
  void clear_output2();
  const ::robot::SpeedVector& output2() const;
  ::robot::SpeedVector* release_output2();
  ::robot::SpeedVector* mutable_output2();
  void set_allocated_output2(::robot::SpeedVector* output2);
  private:
  const ::robot::SpeedVector& _internal_output2() const;
  ::robot::SpeedVector* _internal_mutable_output2();
  public:
  void unsafe_arena_set_allocated_output2(
      ::robot::SpeedVector* output2);
  ::robot::SpeedVector* unsafe_arena_release_output2();

  // optional float v_f = 2;
  bool has_v_f() const;
  private:
  bool _internal_has_v_f() const;
  public:
  void clear_v_f();
  float v_f() const;
  void set_v_f(float value);
  private:
  float _internal_v_f() const;
  void _internal_set_v_f(float value);
  public:

  // optional float v_s = 3;
  bool has_v_s() const;
  private:
  bool _internal_has_v_s() const;
  public:
  void clear_v_s();
  float v_s() const;
  void set_v_s(float value);
  private:
  float _internal_v_s() const;
  void _internal_set_v_s(float value);
  public:

  // optional float omega = 4;
  bool has_omega() const;
  private:
  bool _internal_has_omega() const;
  public:
  void clear_omega();
  float omega() const;
  void set_omega(float value);
  private:
  float _internal_omega() const;
  void _internal_set_omega(float value);
  public:

  // optional float kick_power = 6;
  bool has_kick_power() const;
  private:
  bool _internal_has_kick_power() const;
  public:
  void clear_kick_power();
  float kick_power() const;
  void set_kick_power(float value);
  private:
  float _internal_kick_power() const;
  void _internal_set_kick_power(float value);
  public:

  // optional float dribbler = 7;
  bool has_dribbler() const;
  private:
  bool _internal_has_dribbler() const;
  public:
  void clear_dribbler();
  float dribbler() const;
  void set_dribbler(float value);
  private:
  float _internal_dribbler() const;
  void _internal_set_dribbler(float value);
  public:

  // optional bool local = 8;
  bool has_local() const;
  private:
  bool _internal_has_local() const;
  public:
  void clear_local();
  bool local() const;
  void set_local(bool value);
  private:
  bool _internal_local() const;
  void _internal_set_local(bool value);
  public:

  // optional bool standby = 11;
  bool has_standby() const;
  private:
  bool _internal_has_standby() const;
  public:
  void clear_standby();
  bool standby() const;
  void set_standby(bool value);
  private:
  bool _internal_standby() const;
  void _internal_set_standby(bool value);
  public:

  // optional bool strategy_controlled = 13;
  bool has_strategy_controlled() const;
  private:
  bool _internal_has_strategy_controlled() const;
  public:
  void clear_strategy_controlled();
  bool strategy_controlled() const;
  void set_strategy_controlled(bool value);
  private:
  bool _internal_strategy_controlled() const;
  void _internal_set_strategy_controlled(bool value);
  public:

  // optional bool force_kick = 14;
  bool has_force_kick() const;
  private:
  bool _internal_has_force_kick() const;
  public:
  void clear_force_kick();
  bool force_kick() const;
  void set_force_kick(bool value);
  private:
  bool _internal_force_kick() const;
  void _internal_set_force_kick(bool value);
  public:

  // optional bool network_controlled = 15;
  bool has_network_controlled() const;
  private:
  bool _internal_has_network_controlled() const;
  public:
  void clear_network_controlled();
  bool network_controlled() const;
  void set_network_controlled(bool value);
  private:
  bool _internal_network_controlled() const;
  void _internal_set_network_controlled(bool value);
  public:

  // optional bool eject_sdcard = 16;
  bool has_eject_sdcard() const;
  private:
  bool _internal_has_eject_sdcard() const;
  public:
  void clear_eject_sdcard();
  bool eject_sdcard() const;
  void set_eject_sdcard(bool value);
  private:
  bool _internal_eject_sdcard() const;
  void _internal_set_eject_sdcard(bool value);
  public:

  // optional float cur_v_f = 17;
  bool has_cur_v_f() const;
  private:
  bool _internal_has_cur_v_f() const;
  public:
  void clear_cur_v_f();
  float cur_v_f() const;
  void set_cur_v_f(float value);
  private:
  float _internal_cur_v_f() const;
  void _internal_set_cur_v_f(float value);
  public:

  // optional float cur_v_s = 18;
  bool has_cur_v_s() const;
  private:
  bool _internal_has_cur_v_s() const;
  public:
  void clear_cur_v_s();
  float cur_v_s() const;
  void set_cur_v_s(float value);
  private:
  float _internal_cur_v_s() const;
  void _internal_set_cur_v_s(float value);
  public:

  // optional float cur_omega = 19;
  bool has_cur_omega() const;
  private:
  bool _internal_has_cur_omega() const;
  public:
  void clear_cur_omega();
  float cur_omega() const;
  void set_cur_omega(float value);
  private:
  float _internal_cur_omega() const;
  void _internal_set_cur_omega(float value);
  public:

  // optional .robot.Command.KickStyle kick_style = 5;
  bool has_kick_style() const;
  private:
  bool _internal_has_kick_style() const;
  public:
  void clear_kick_style();
  ::robot::Command_KickStyle kick_style() const;
  void set_kick_style(::robot::Command_KickStyle value);
  private:
  ::robot::Command_KickStyle _internal_kick_style() const;
  void _internal_set_kick_style(::robot::Command_KickStyle value);
  public:

  // @@protoc_insertion_point(class_scope:robot.Command)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::robot::ControllerInput* controller_;
  ::robot::SpeedVector* output0_;
  ::robot::SpeedVector* output1_;
  ::robot::SpeedVector* output2_;
  float v_f_;
  float v_s_;
  float omega_;
  float kick_power_;
  float dribbler_;
  bool local_;
  bool standby_;
  bool strategy_controlled_;
  bool force_kick_;
  bool network_controlled_;
  bool eject_sdcard_;
  float cur_v_f_;
  float cur_v_s_;
  float cur_omega_;
  int kick_style_;
  friend struct ::TableStruct_robot_2eproto;
};
// -------------------------------------------------------------------

class RadioCommand PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:robot.RadioCommand) */ {
 public:
  inline RadioCommand() : RadioCommand(nullptr) {};
  virtual ~RadioCommand();

  RadioCommand(const RadioCommand& from);
  RadioCommand(RadioCommand&& from) noexcept
    : RadioCommand() {
    *this = ::std::move(from);
  }

  inline RadioCommand& operator=(const RadioCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline RadioCommand& operator=(RadioCommand&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RadioCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RadioCommand* internal_default_instance() {
    return reinterpret_cast<const RadioCommand*>(
               &_RadioCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(RadioCommand& a, RadioCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(RadioCommand* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RadioCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RadioCommand* New() const final {
    return CreateMaybeMessage<RadioCommand>(nullptr);
  }

  RadioCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RadioCommand>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RadioCommand& from);
  void MergeFrom(const RadioCommand& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RadioCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "robot.RadioCommand";
  }
  protected:
  explicit RadioCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_robot_2eproto);
    return ::descriptor_table_robot_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommandFieldNumber = 3,
    kGenerationFieldNumber = 1,
    kIdFieldNumber = 2,
    kCommandTimeFieldNumber = 5,
    kIsBlueFieldNumber = 4,
  };
  // required .robot.Command command = 3;
  bool has_command() const;
  private:
  bool _internal_has_command() const;
  public:
  void clear_command();
  const ::robot::Command& command() const;
  ::robot::Command* release_command();
  ::robot::Command* mutable_command();
  void set_allocated_command(::robot::Command* command);
  private:
  const ::robot::Command& _internal_command() const;
  ::robot::Command* _internal_mutable_command();
  public:
  void unsafe_arena_set_allocated_command(
      ::robot::Command* command);
  ::robot::Command* unsafe_arena_release_command();

  // required uint32 generation = 1;
  bool has_generation() const;
  private:
  bool _internal_has_generation() const;
  public:
  void clear_generation();
  ::PROTOBUF_NAMESPACE_ID::uint32 generation() const;
  void set_generation(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_generation() const;
  void _internal_set_generation(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 id = 2;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional int64 command_time = 5;
  bool has_command_time() const;
  private:
  bool _internal_has_command_time() const;
  public:
  void clear_command_time();
  ::PROTOBUF_NAMESPACE_ID::int64 command_time() const;
  void set_command_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_command_time() const;
  void _internal_set_command_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional bool is_blue = 4;
  bool has_is_blue() const;
  private:
  bool _internal_has_is_blue() const;
  public:
  void clear_is_blue();
  bool is_blue() const;
  void set_is_blue(bool value);
  private:
  bool _internal_is_blue() const;
  void _internal_set_is_blue(bool value);
  public:

  // @@protoc_insertion_point(class_scope:robot.RadioCommand)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::robot::Command* command_;
  ::PROTOBUF_NAMESPACE_ID::uint32 generation_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  ::PROTOBUF_NAMESPACE_ID::int64 command_time_;
  bool is_blue_;
  friend struct ::TableStruct_robot_2eproto;
};
// -------------------------------------------------------------------

class SpeedStatus PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:robot.SpeedStatus) */ {
 public:
  inline SpeedStatus() : SpeedStatus(nullptr) {};
  virtual ~SpeedStatus();

  SpeedStatus(const SpeedStatus& from);
  SpeedStatus(SpeedStatus&& from) noexcept
    : SpeedStatus() {
    *this = ::std::move(from);
  }

  inline SpeedStatus& operator=(const SpeedStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpeedStatus& operator=(SpeedStatus&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SpeedStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpeedStatus* internal_default_instance() {
    return reinterpret_cast<const SpeedStatus*>(
               &_SpeedStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SpeedStatus& a, SpeedStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(SpeedStatus* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpeedStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpeedStatus* New() const final {
    return CreateMaybeMessage<SpeedStatus>(nullptr);
  }

  SpeedStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpeedStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpeedStatus& from);
  void MergeFrom(const SpeedStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpeedStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "robot.SpeedStatus";
  }
  protected:
  explicit SpeedStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_robot_2eproto);
    return ::descriptor_table_robot_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVFFieldNumber = 1,
    kVSFieldNumber = 2,
    kOmegaFieldNumber = 3,
  };
  // required float v_f = 1;
  bool has_v_f() const;
  private:
  bool _internal_has_v_f() const;
  public:
  void clear_v_f();
  float v_f() const;
  void set_v_f(float value);
  private:
  float _internal_v_f() const;
  void _internal_set_v_f(float value);
  public:

  // required float v_s = 2;
  bool has_v_s() const;
  private:
  bool _internal_has_v_s() const;
  public:
  void clear_v_s();
  float v_s() const;
  void set_v_s(float value);
  private:
  float _internal_v_s() const;
  void _internal_set_v_s(float value);
  public:

  // required float omega = 3;
  bool has_omega() const;
  private:
  bool _internal_has_omega() const;
  public:
  void clear_omega();
  float omega() const;
  void set_omega(float value);
  private:
  float _internal_omega() const;
  void _internal_set_omega(float value);
  public:

  // @@protoc_insertion_point(class_scope:robot.SpeedStatus)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float v_f_;
  float v_s_;
  float omega_;
  friend struct ::TableStruct_robot_2eproto;
};
// -------------------------------------------------------------------

class ExtendedError PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:robot.ExtendedError) */ {
 public:
  inline ExtendedError() : ExtendedError(nullptr) {};
  virtual ~ExtendedError();

  ExtendedError(const ExtendedError& from);
  ExtendedError(ExtendedError&& from) noexcept
    : ExtendedError() {
    *this = ::std::move(from);
  }

  inline ExtendedError& operator=(const ExtendedError& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExtendedError& operator=(ExtendedError&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ExtendedError& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExtendedError* internal_default_instance() {
    return reinterpret_cast<const ExtendedError*>(
               &_ExtendedError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ExtendedError& a, ExtendedError& b) {
    a.Swap(&b);
  }
  inline void Swap(ExtendedError* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExtendedError* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExtendedError* New() const final {
    return CreateMaybeMessage<ExtendedError>(nullptr);
  }

  ExtendedError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExtendedError>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ExtendedError& from);
  void MergeFrom(const ExtendedError& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExtendedError* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "robot.ExtendedError";
  }
  protected:
  explicit ExtendedError(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_robot_2eproto);
    return ::descriptor_table_robot_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMotor1ErrorFieldNumber = 1,
    kMotor2ErrorFieldNumber = 2,
    kMotor3ErrorFieldNumber = 3,
    kMotor4ErrorFieldNumber = 4,
    kTemperatureFieldNumber = 7,
    kDribblerErrorFieldNumber = 5,
    kKickerErrorFieldNumber = 6,
    kKickerBreakBeamErrorFieldNumber = 11,
    kMotorEncoderErrorFieldNumber = 9,
    kMainSensorErrorFieldNumber = 10,
  };
  // required bool motor_1_error = 1;
  bool has_motor_1_error() const;
  private:
  bool _internal_has_motor_1_error() const;
  public:
  void clear_motor_1_error();
  bool motor_1_error() const;
  void set_motor_1_error(bool value);
  private:
  bool _internal_motor_1_error() const;
  void _internal_set_motor_1_error(bool value);
  public:

  // required bool motor_2_error = 2;
  bool has_motor_2_error() const;
  private:
  bool _internal_has_motor_2_error() const;
  public:
  void clear_motor_2_error();
  bool motor_2_error() const;
  void set_motor_2_error(bool value);
  private:
  bool _internal_motor_2_error() const;
  void _internal_set_motor_2_error(bool value);
  public:

  // required bool motor_3_error = 3;
  bool has_motor_3_error() const;
  private:
  bool _internal_has_motor_3_error() const;
  public:
  void clear_motor_3_error();
  bool motor_3_error() const;
  void set_motor_3_error(bool value);
  private:
  bool _internal_motor_3_error() const;
  void _internal_set_motor_3_error(bool value);
  public:

  // required bool motor_4_error = 4;
  bool has_motor_4_error() const;
  private:
  bool _internal_has_motor_4_error() const;
  public:
  void clear_motor_4_error();
  bool motor_4_error() const;
  void set_motor_4_error(bool value);
  private:
  bool _internal_motor_4_error() const;
  void _internal_set_motor_4_error(bool value);
  public:

  // optional int32 temperature = 7;
  bool has_temperature() const;
  private:
  bool _internal_has_temperature() const;
  public:
  void clear_temperature();
  ::PROTOBUF_NAMESPACE_ID::int32 temperature() const;
  void set_temperature(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_temperature() const;
  void _internal_set_temperature(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required bool dribbler_error = 5;
  bool has_dribbler_error() const;
  private:
  bool _internal_has_dribbler_error() const;
  public:
  void clear_dribbler_error();
  bool dribbler_error() const;
  void set_dribbler_error(bool value);
  private:
  bool _internal_dribbler_error() const;
  void _internal_set_dribbler_error(bool value);
  public:

  // required bool kicker_error = 6;
  bool has_kicker_error() const;
  private:
  bool _internal_has_kicker_error() const;
  public:
  void clear_kicker_error();
  bool kicker_error() const;
  void set_kicker_error(bool value);
  private:
  bool _internal_kicker_error() const;
  void _internal_set_kicker_error(bool value);
  public:

  // optional bool kicker_break_beam_error = 11;
  bool has_kicker_break_beam_error() const;
  private:
  bool _internal_has_kicker_break_beam_error() const;
  public:
  void clear_kicker_break_beam_error();
  bool kicker_break_beam_error() const;
  void set_kicker_break_beam_error(bool value);
  private:
  bool _internal_kicker_break_beam_error() const;
  void _internal_set_kicker_break_beam_error(bool value);
  public:

  // optional bool motor_encoder_error = 9;
  bool has_motor_encoder_error() const;
  private:
  bool _internal_has_motor_encoder_error() const;
  public:
  void clear_motor_encoder_error();
  bool motor_encoder_error() const;
  void set_motor_encoder_error(bool value);
  private:
  bool _internal_motor_encoder_error() const;
  void _internal_set_motor_encoder_error(bool value);
  public:

  // optional bool main_sensor_error = 10;
  bool has_main_sensor_error() const;
  private:
  bool _internal_has_main_sensor_error() const;
  public:
  void clear_main_sensor_error();
  bool main_sensor_error() const;
  void set_main_sensor_error(bool value);
  private:
  bool _internal_main_sensor_error() const;
  void _internal_set_main_sensor_error(bool value);
  public:

  // @@protoc_insertion_point(class_scope:robot.ExtendedError)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool motor_1_error_;
  bool motor_2_error_;
  bool motor_3_error_;
  bool motor_4_error_;
  ::PROTOBUF_NAMESPACE_ID::int32 temperature_;
  bool dribbler_error_;
  bool kicker_error_;
  bool kicker_break_beam_error_;
  bool motor_encoder_error_;
  bool main_sensor_error_;
  friend struct ::TableStruct_robot_2eproto;
};
// -------------------------------------------------------------------

class RadioResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:robot.RadioResponse) */ {
 public:
  inline RadioResponse() : RadioResponse(nullptr) {};
  virtual ~RadioResponse();

  RadioResponse(const RadioResponse& from);
  RadioResponse(RadioResponse&& from) noexcept
    : RadioResponse() {
    *this = ::std::move(from);
  }

  inline RadioResponse& operator=(const RadioResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RadioResponse& operator=(RadioResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RadioResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RadioResponse* internal_default_instance() {
    return reinterpret_cast<const RadioResponse*>(
               &_RadioResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(RadioResponse& a, RadioResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RadioResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RadioResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RadioResponse* New() const final {
    return CreateMaybeMessage<RadioResponse>(nullptr);
  }

  RadioResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RadioResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RadioResponse& from);
  void MergeFrom(const RadioResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RadioResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "robot.RadioResponse";
  }
  protected:
  explicit RadioResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_robot_2eproto);
    return ::descriptor_table_robot_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEstimatedSpeedFieldNumber = 6,
    kExtendedErrorFieldNumber = 12,
    kGenerationFieldNumber = 1,
    kIdFieldNumber = 2,
    kBatteryFieldNumber = 3,
    kPacketLossRxFieldNumber = 4,
    kPacketLossTxFieldNumber = 5,
    kBallDetectedFieldNumber = 7,
    kCapChargedFieldNumber = 8,
    kErrorPresentFieldNumber = 9,
    kIsBlueFieldNumber = 13,
    kTimeFieldNumber = 10,
    kRadioRttFieldNumber = 11,
  };
  // optional .robot.SpeedStatus estimated_speed = 6;
  bool has_estimated_speed() const;
  private:
  bool _internal_has_estimated_speed() const;
  public:
  void clear_estimated_speed();
  const ::robot::SpeedStatus& estimated_speed() const;
  ::robot::SpeedStatus* release_estimated_speed();
  ::robot::SpeedStatus* mutable_estimated_speed();
  void set_allocated_estimated_speed(::robot::SpeedStatus* estimated_speed);
  private:
  const ::robot::SpeedStatus& _internal_estimated_speed() const;
  ::robot::SpeedStatus* _internal_mutable_estimated_speed();
  public:
  void unsafe_arena_set_allocated_estimated_speed(
      ::robot::SpeedStatus* estimated_speed);
  ::robot::SpeedStatus* unsafe_arena_release_estimated_speed();

  // optional .robot.ExtendedError extended_error = 12;
  bool has_extended_error() const;
  private:
  bool _internal_has_extended_error() const;
  public:
  void clear_extended_error();
  const ::robot::ExtendedError& extended_error() const;
  ::robot::ExtendedError* release_extended_error();
  ::robot::ExtendedError* mutable_extended_error();
  void set_allocated_extended_error(::robot::ExtendedError* extended_error);
  private:
  const ::robot::ExtendedError& _internal_extended_error() const;
  ::robot::ExtendedError* _internal_mutable_extended_error();
  public:
  void unsafe_arena_set_allocated_extended_error(
      ::robot::ExtendedError* extended_error);
  ::robot::ExtendedError* unsafe_arena_release_extended_error();

  // required uint32 generation = 1;
  bool has_generation() const;
  private:
  bool _internal_has_generation() const;
  public:
  void clear_generation();
  ::PROTOBUF_NAMESPACE_ID::uint32 generation() const;
  void set_generation(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_generation() const;
  void _internal_set_generation(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 id = 2;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional float battery = 3;
  bool has_battery() const;
  private:
  bool _internal_has_battery() const;
  public:
  void clear_battery();
  float battery() const;
  void set_battery(float value);
  private:
  float _internal_battery() const;
  void _internal_set_battery(float value);
  public:

  // optional float packet_loss_rx = 4;
  bool has_packet_loss_rx() const;
  private:
  bool _internal_has_packet_loss_rx() const;
  public:
  void clear_packet_loss_rx();
  float packet_loss_rx() const;
  void set_packet_loss_rx(float value);
  private:
  float _internal_packet_loss_rx() const;
  void _internal_set_packet_loss_rx(float value);
  public:

  // optional float packet_loss_tx = 5;
  bool has_packet_loss_tx() const;
  private:
  bool _internal_has_packet_loss_tx() const;
  public:
  void clear_packet_loss_tx();
  float packet_loss_tx() const;
  void set_packet_loss_tx(float value);
  private:
  float _internal_packet_loss_tx() const;
  void _internal_set_packet_loss_tx(float value);
  public:

  // optional bool ball_detected = 7;
  bool has_ball_detected() const;
  private:
  bool _internal_has_ball_detected() const;
  public:
  void clear_ball_detected();
  bool ball_detected() const;
  void set_ball_detected(bool value);
  private:
  bool _internal_ball_detected() const;
  void _internal_set_ball_detected(bool value);
  public:

  // optional bool cap_charged = 8;
  bool has_cap_charged() const;
  private:
  bool _internal_has_cap_charged() const;
  public:
  void clear_cap_charged();
  bool cap_charged() const;
  void set_cap_charged(bool value);
  private:
  bool _internal_cap_charged() const;
  void _internal_set_cap_charged(bool value);
  public:

  // optional bool error_present = 9;
  bool has_error_present() const;
  private:
  bool _internal_has_error_present() const;
  public:
  void clear_error_present();
  bool error_present() const;
  void set_error_present(bool value);
  private:
  bool _internal_error_present() const;
  void _internal_set_error_present(bool value);
  public:

  // optional bool is_blue = 13;
  bool has_is_blue() const;
  private:
  bool _internal_has_is_blue() const;
  public:
  void clear_is_blue();
  bool is_blue() const;
  void set_is_blue(bool value);
  private:
  bool _internal_is_blue() const;
  void _internal_set_is_blue(bool value);
  public:

  // optional int64 time = 10;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  ::PROTOBUF_NAMESPACE_ID::int64 time() const;
  void set_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_time() const;
  void _internal_set_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional float radio_rtt = 11;
  bool has_radio_rtt() const;
  private:
  bool _internal_has_radio_rtt() const;
  public:
  void clear_radio_rtt();
  float radio_rtt() const;
  void set_radio_rtt(float value);
  private:
  float _internal_radio_rtt() const;
  void _internal_set_radio_rtt(float value);
  public:

  // @@protoc_insertion_point(class_scope:robot.RadioResponse)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::robot::SpeedStatus* estimated_speed_;
  ::robot::ExtendedError* extended_error_;
  ::PROTOBUF_NAMESPACE_ID::uint32 generation_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  float battery_;
  float packet_loss_rx_;
  float packet_loss_tx_;
  bool ball_detected_;
  bool cap_charged_;
  bool error_present_;
  bool is_blue_;
  ::PROTOBUF_NAMESPACE_ID::int64 time_;
  float radio_rtt_;
  friend struct ::TableStruct_robot_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LimitParameters

// optional float a_speedup_f_max = 1;
inline bool LimitParameters::_internal_has_a_speedup_f_max() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LimitParameters::has_a_speedup_f_max() const {
  return _internal_has_a_speedup_f_max();
}
inline void LimitParameters::clear_a_speedup_f_max() {
  a_speedup_f_max_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float LimitParameters::_internal_a_speedup_f_max() const {
  return a_speedup_f_max_;
}
inline float LimitParameters::a_speedup_f_max() const {
  // @@protoc_insertion_point(field_get:robot.LimitParameters.a_speedup_f_max)
  return _internal_a_speedup_f_max();
}
inline void LimitParameters::_internal_set_a_speedup_f_max(float value) {
  _has_bits_[0] |= 0x00000001u;
  a_speedup_f_max_ = value;
}
inline void LimitParameters::set_a_speedup_f_max(float value) {
  _internal_set_a_speedup_f_max(value);
  // @@protoc_insertion_point(field_set:robot.LimitParameters.a_speedup_f_max)
}

// optional float a_speedup_s_max = 2;
inline bool LimitParameters::_internal_has_a_speedup_s_max() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LimitParameters::has_a_speedup_s_max() const {
  return _internal_has_a_speedup_s_max();
}
inline void LimitParameters::clear_a_speedup_s_max() {
  a_speedup_s_max_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float LimitParameters::_internal_a_speedup_s_max() const {
  return a_speedup_s_max_;
}
inline float LimitParameters::a_speedup_s_max() const {
  // @@protoc_insertion_point(field_get:robot.LimitParameters.a_speedup_s_max)
  return _internal_a_speedup_s_max();
}
inline void LimitParameters::_internal_set_a_speedup_s_max(float value) {
  _has_bits_[0] |= 0x00000002u;
  a_speedup_s_max_ = value;
}
inline void LimitParameters::set_a_speedup_s_max(float value) {
  _internal_set_a_speedup_s_max(value);
  // @@protoc_insertion_point(field_set:robot.LimitParameters.a_speedup_s_max)
}

// optional float a_speedup_phi_max = 3;
inline bool LimitParameters::_internal_has_a_speedup_phi_max() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool LimitParameters::has_a_speedup_phi_max() const {
  return _internal_has_a_speedup_phi_max();
}
inline void LimitParameters::clear_a_speedup_phi_max() {
  a_speedup_phi_max_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float LimitParameters::_internal_a_speedup_phi_max() const {
  return a_speedup_phi_max_;
}
inline float LimitParameters::a_speedup_phi_max() const {
  // @@protoc_insertion_point(field_get:robot.LimitParameters.a_speedup_phi_max)
  return _internal_a_speedup_phi_max();
}
inline void LimitParameters::_internal_set_a_speedup_phi_max(float value) {
  _has_bits_[0] |= 0x00000004u;
  a_speedup_phi_max_ = value;
}
inline void LimitParameters::set_a_speedup_phi_max(float value) {
  _internal_set_a_speedup_phi_max(value);
  // @@protoc_insertion_point(field_set:robot.LimitParameters.a_speedup_phi_max)
}

// optional float a_brake_f_max = 4;
inline bool LimitParameters::_internal_has_a_brake_f_max() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool LimitParameters::has_a_brake_f_max() const {
  return _internal_has_a_brake_f_max();
}
inline void LimitParameters::clear_a_brake_f_max() {
  a_brake_f_max_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float LimitParameters::_internal_a_brake_f_max() const {
  return a_brake_f_max_;
}
inline float LimitParameters::a_brake_f_max() const {
  // @@protoc_insertion_point(field_get:robot.LimitParameters.a_brake_f_max)
  return _internal_a_brake_f_max();
}
inline void LimitParameters::_internal_set_a_brake_f_max(float value) {
  _has_bits_[0] |= 0x00000008u;
  a_brake_f_max_ = value;
}
inline void LimitParameters::set_a_brake_f_max(float value) {
  _internal_set_a_brake_f_max(value);
  // @@protoc_insertion_point(field_set:robot.LimitParameters.a_brake_f_max)
}

// optional float a_brake_s_max = 5;
inline bool LimitParameters::_internal_has_a_brake_s_max() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool LimitParameters::has_a_brake_s_max() const {
  return _internal_has_a_brake_s_max();
}
inline void LimitParameters::clear_a_brake_s_max() {
  a_brake_s_max_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float LimitParameters::_internal_a_brake_s_max() const {
  return a_brake_s_max_;
}
inline float LimitParameters::a_brake_s_max() const {
  // @@protoc_insertion_point(field_get:robot.LimitParameters.a_brake_s_max)
  return _internal_a_brake_s_max();
}
inline void LimitParameters::_internal_set_a_brake_s_max(float value) {
  _has_bits_[0] |= 0x00000010u;
  a_brake_s_max_ = value;
}
inline void LimitParameters::set_a_brake_s_max(float value) {
  _internal_set_a_brake_s_max(value);
  // @@protoc_insertion_point(field_set:robot.LimitParameters.a_brake_s_max)
}

// optional float a_brake_phi_max = 6;
inline bool LimitParameters::_internal_has_a_brake_phi_max() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool LimitParameters::has_a_brake_phi_max() const {
  return _internal_has_a_brake_phi_max();
}
inline void LimitParameters::clear_a_brake_phi_max() {
  a_brake_phi_max_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline float LimitParameters::_internal_a_brake_phi_max() const {
  return a_brake_phi_max_;
}
inline float LimitParameters::a_brake_phi_max() const {
  // @@protoc_insertion_point(field_get:robot.LimitParameters.a_brake_phi_max)
  return _internal_a_brake_phi_max();
}
inline void LimitParameters::_internal_set_a_brake_phi_max(float value) {
  _has_bits_[0] |= 0x00000020u;
  a_brake_phi_max_ = value;
}
inline void LimitParameters::set_a_brake_phi_max(float value) {
  _internal_set_a_brake_phi_max(value);
  // @@protoc_insertion_point(field_set:robot.LimitParameters.a_brake_phi_max)
}

// -------------------------------------------------------------------

// SimulationLimits

// optional float a_speedup_wheel_max = 1;
inline bool SimulationLimits::_internal_has_a_speedup_wheel_max() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SimulationLimits::has_a_speedup_wheel_max() const {
  return _internal_has_a_speedup_wheel_max();
}
inline void SimulationLimits::clear_a_speedup_wheel_max() {
  a_speedup_wheel_max_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float SimulationLimits::_internal_a_speedup_wheel_max() const {
  return a_speedup_wheel_max_;
}
inline float SimulationLimits::a_speedup_wheel_max() const {
  // @@protoc_insertion_point(field_get:robot.SimulationLimits.a_speedup_wheel_max)
  return _internal_a_speedup_wheel_max();
}
inline void SimulationLimits::_internal_set_a_speedup_wheel_max(float value) {
  _has_bits_[0] |= 0x00000001u;
  a_speedup_wheel_max_ = value;
}
inline void SimulationLimits::set_a_speedup_wheel_max(float value) {
  _internal_set_a_speedup_wheel_max(value);
  // @@protoc_insertion_point(field_set:robot.SimulationLimits.a_speedup_wheel_max)
}

// optional float a_brake_wheel_max = 2;
inline bool SimulationLimits::_internal_has_a_brake_wheel_max() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SimulationLimits::has_a_brake_wheel_max() const {
  return _internal_has_a_brake_wheel_max();
}
inline void SimulationLimits::clear_a_brake_wheel_max() {
  a_brake_wheel_max_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float SimulationLimits::_internal_a_brake_wheel_max() const {
  return a_brake_wheel_max_;
}
inline float SimulationLimits::a_brake_wheel_max() const {
  // @@protoc_insertion_point(field_get:robot.SimulationLimits.a_brake_wheel_max)
  return _internal_a_brake_wheel_max();
}
inline void SimulationLimits::_internal_set_a_brake_wheel_max(float value) {
  _has_bits_[0] |= 0x00000002u;
  a_brake_wheel_max_ = value;
}
inline void SimulationLimits::set_a_brake_wheel_max(float value) {
  _internal_set_a_brake_wheel_max(value);
  // @@protoc_insertion_point(field_set:robot.SimulationLimits.a_brake_wheel_max)
}

// -------------------------------------------------------------------

// Specs

// required uint32 generation = 1;
inline bool Specs::_internal_has_generation() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Specs::has_generation() const {
  return _internal_has_generation();
}
inline void Specs::clear_generation() {
  generation_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Specs::_internal_generation() const {
  return generation_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Specs::generation() const {
  // @@protoc_insertion_point(field_get:robot.Specs.generation)
  return _internal_generation();
}
inline void Specs::_internal_set_generation(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  generation_ = value;
}
inline void Specs::set_generation(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_generation(value);
  // @@protoc_insertion_point(field_set:robot.Specs.generation)
}

// required uint32 year = 2;
inline bool Specs::_internal_has_year() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Specs::has_year() const {
  return _internal_has_year();
}
inline void Specs::clear_year() {
  year_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Specs::_internal_year() const {
  return year_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Specs::year() const {
  // @@protoc_insertion_point(field_get:robot.Specs.year)
  return _internal_year();
}
inline void Specs::_internal_set_year(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  year_ = value;
}
inline void Specs::set_year(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_year(value);
  // @@protoc_insertion_point(field_set:robot.Specs.year)
}

// required uint32 id = 3;
inline bool Specs::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Specs::has_id() const {
  return _internal_has_id();
}
inline void Specs::clear_id() {
  id_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Specs::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Specs::id() const {
  // @@protoc_insertion_point(field_get:robot.Specs.id)
  return _internal_id();
}
inline void Specs::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  id_ = value;
}
inline void Specs::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:robot.Specs.id)
}

// optional .robot.Specs.GenerationType type = 19;
inline bool Specs::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool Specs::has_type() const {
  return _internal_has_type();
}
inline void Specs::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00100000u;
}
inline ::robot::Specs_GenerationType Specs::_internal_type() const {
  return static_cast< ::robot::Specs_GenerationType >(type_);
}
inline ::robot::Specs_GenerationType Specs::type() const {
  // @@protoc_insertion_point(field_get:robot.Specs.type)
  return _internal_type();
}
inline void Specs::_internal_set_type(::robot::Specs_GenerationType value) {
  assert(::robot::Specs_GenerationType_IsValid(value));
  _has_bits_[0] |= 0x00100000u;
  type_ = value;
}
inline void Specs::set_type(::robot::Specs_GenerationType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:robot.Specs.type)
}

// optional float radius = 4 [default = 0.09];
inline bool Specs::_internal_has_radius() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool Specs::has_radius() const {
  return _internal_has_radius();
}
inline void Specs::clear_radius() {
  radius_ = 0.09f;
  _has_bits_[0] &= ~0x00020000u;
}
inline float Specs::_internal_radius() const {
  return radius_;
}
inline float Specs::radius() const {
  // @@protoc_insertion_point(field_get:robot.Specs.radius)
  return _internal_radius();
}
inline void Specs::_internal_set_radius(float value) {
  _has_bits_[0] |= 0x00020000u;
  radius_ = value;
}
inline void Specs::set_radius(float value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:robot.Specs.radius)
}

// optional float height = 5 [default = 0.15];
inline bool Specs::_internal_has_height() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool Specs::has_height() const {
  return _internal_has_height();
}
inline void Specs::clear_height() {
  height_ = 0.15f;
  _has_bits_[0] &= ~0x00040000u;
}
inline float Specs::_internal_height() const {
  return height_;
}
inline float Specs::height() const {
  // @@protoc_insertion_point(field_get:robot.Specs.height)
  return _internal_height();
}
inline void Specs::_internal_set_height(float value) {
  _has_bits_[0] |= 0x00040000u;
  height_ = value;
}
inline void Specs::set_height(float value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:robot.Specs.height)
}

// optional float mass = 6;
inline bool Specs::_internal_has_mass() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Specs::has_mass() const {
  return _internal_has_mass();
}
inline void Specs::clear_mass() {
  mass_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline float Specs::_internal_mass() const {
  return mass_;
}
inline float Specs::mass() const {
  // @@protoc_insertion_point(field_get:robot.Specs.mass)
  return _internal_mass();
}
inline void Specs::_internal_set_mass(float value) {
  _has_bits_[0] |= 0x00000040u;
  mass_ = value;
}
inline void Specs::set_mass(float value) {
  _internal_set_mass(value);
  // @@protoc_insertion_point(field_set:robot.Specs.mass)
}

// optional float angle = 7;
inline bool Specs::_internal_has_angle() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Specs::has_angle() const {
  return _internal_has_angle();
}
inline void Specs::clear_angle() {
  angle_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline float Specs::_internal_angle() const {
  return angle_;
}
inline float Specs::angle() const {
  // @@protoc_insertion_point(field_get:robot.Specs.angle)
  return _internal_angle();
}
inline void Specs::_internal_set_angle(float value) {
  _has_bits_[0] |= 0x00000080u;
  angle_ = value;
}
inline void Specs::set_angle(float value) {
  _internal_set_angle(value);
  // @@protoc_insertion_point(field_set:robot.Specs.angle)
}

// optional float v_max = 8;
inline bool Specs::_internal_has_v_max() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Specs::has_v_max() const {
  return _internal_has_v_max();
}
inline void Specs::clear_v_max() {
  v_max_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline float Specs::_internal_v_max() const {
  return v_max_;
}
inline float Specs::v_max() const {
  // @@protoc_insertion_point(field_get:robot.Specs.v_max)
  return _internal_v_max();
}
inline void Specs::_internal_set_v_max(float value) {
  _has_bits_[0] |= 0x00000100u;
  v_max_ = value;
}
inline void Specs::set_v_max(float value) {
  _internal_set_v_max(value);
  // @@protoc_insertion_point(field_set:robot.Specs.v_max)
}

// optional float omega_max = 9;
inline bool Specs::_internal_has_omega_max() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Specs::has_omega_max() const {
  return _internal_has_omega_max();
}
inline void Specs::clear_omega_max() {
  omega_max_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline float Specs::_internal_omega_max() const {
  return omega_max_;
}
inline float Specs::omega_max() const {
  // @@protoc_insertion_point(field_get:robot.Specs.omega_max)
  return _internal_omega_max();
}
inline void Specs::_internal_set_omega_max(float value) {
  _has_bits_[0] |= 0x00000200u;
  omega_max_ = value;
}
inline void Specs::set_omega_max(float value) {
  _internal_set_omega_max(value);
  // @@protoc_insertion_point(field_set:robot.Specs.omega_max)
}

// optional float shot_linear_max = 10 [default = 8];
inline bool Specs::_internal_has_shot_linear_max() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool Specs::has_shot_linear_max() const {
  return _internal_has_shot_linear_max();
}
inline void Specs::clear_shot_linear_max() {
  shot_linear_max_ = 8;
  _has_bits_[0] &= ~0x00080000u;
}
inline float Specs::_internal_shot_linear_max() const {
  return shot_linear_max_;
}
inline float Specs::shot_linear_max() const {
  // @@protoc_insertion_point(field_get:robot.Specs.shot_linear_max)
  return _internal_shot_linear_max();
}
inline void Specs::_internal_set_shot_linear_max(float value) {
  _has_bits_[0] |= 0x00080000u;
  shot_linear_max_ = value;
}
inline void Specs::set_shot_linear_max(float value) {
  _internal_set_shot_linear_max(value);
  // @@protoc_insertion_point(field_set:robot.Specs.shot_linear_max)
}

// optional float shot_chip_max = 11;
inline bool Specs::_internal_has_shot_chip_max() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool Specs::has_shot_chip_max() const {
  return _internal_has_shot_chip_max();
}
inline void Specs::clear_shot_chip_max() {
  shot_chip_max_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline float Specs::_internal_shot_chip_max() const {
  return shot_chip_max_;
}
inline float Specs::shot_chip_max() const {
  // @@protoc_insertion_point(field_get:robot.Specs.shot_chip_max)
  return _internal_shot_chip_max();
}
inline void Specs::_internal_set_shot_chip_max(float value) {
  _has_bits_[0] |= 0x00000400u;
  shot_chip_max_ = value;
}
inline void Specs::set_shot_chip_max(float value) {
  _internal_set_shot_chip_max(value);
  // @@protoc_insertion_point(field_set:robot.Specs.shot_chip_max)
}

// optional float dribbler_width = 12;
inline bool Specs::_internal_has_dribbler_width() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool Specs::has_dribbler_width() const {
  return _internal_has_dribbler_width();
}
inline void Specs::clear_dribbler_width() {
  dribbler_width_ = 0;
  _has_bits_[0] &= ~0x00000800u;
}
inline float Specs::_internal_dribbler_width() const {
  return dribbler_width_;
}
inline float Specs::dribbler_width() const {
  // @@protoc_insertion_point(field_get:robot.Specs.dribbler_width)
  return _internal_dribbler_width();
}
inline void Specs::_internal_set_dribbler_width(float value) {
  _has_bits_[0] |= 0x00000800u;
  dribbler_width_ = value;
}
inline void Specs::set_dribbler_width(float value) {
  _internal_set_dribbler_width(value);
  // @@protoc_insertion_point(field_set:robot.Specs.dribbler_width)
}

// optional .robot.LimitParameters acceleration = 13;
inline bool Specs::_internal_has_acceleration() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || acceleration_ != nullptr);
  return value;
}
inline bool Specs::has_acceleration() const {
  return _internal_has_acceleration();
}
inline void Specs::clear_acceleration() {
  if (acceleration_ != nullptr) acceleration_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::robot::LimitParameters& Specs::_internal_acceleration() const {
  const ::robot::LimitParameters* p = acceleration_;
  return p != nullptr ? *p : *reinterpret_cast<const ::robot::LimitParameters*>(
      &::robot::_LimitParameters_default_instance_);
}
inline const ::robot::LimitParameters& Specs::acceleration() const {
  // @@protoc_insertion_point(field_get:robot.Specs.acceleration)
  return _internal_acceleration();
}
inline void Specs::unsafe_arena_set_allocated_acceleration(
    ::robot::LimitParameters* acceleration) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(acceleration_);
  }
  acceleration_ = acceleration;
  if (acceleration) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:robot.Specs.acceleration)
}
inline ::robot::LimitParameters* Specs::release_acceleration() {
  auto temp = unsafe_arena_release_acceleration();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::robot::LimitParameters* Specs::unsafe_arena_release_acceleration() {
  // @@protoc_insertion_point(field_release:robot.Specs.acceleration)
  _has_bits_[0] &= ~0x00000001u;
  ::robot::LimitParameters* temp = acceleration_;
  acceleration_ = nullptr;
  return temp;
}
inline ::robot::LimitParameters* Specs::_internal_mutable_acceleration() {
  _has_bits_[0] |= 0x00000001u;
  if (acceleration_ == nullptr) {
    auto* p = CreateMaybeMessage<::robot::LimitParameters>(GetArena());
    acceleration_ = p;
  }
  return acceleration_;
}
inline ::robot::LimitParameters* Specs::mutable_acceleration() {
  // @@protoc_insertion_point(field_mutable:robot.Specs.acceleration)
  return _internal_mutable_acceleration();
}
inline void Specs::set_allocated_acceleration(::robot::LimitParameters* acceleration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete acceleration_;
  }
  if (acceleration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(acceleration);
    if (message_arena != submessage_arena) {
      acceleration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, acceleration, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  acceleration_ = acceleration;
  // @@protoc_insertion_point(field_set_allocated:robot.Specs.acceleration)
}

// optional .robot.LimitParameters strategy = 16;
inline bool Specs::_internal_has_strategy() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || strategy_ != nullptr);
  return value;
}
inline bool Specs::has_strategy() const {
  return _internal_has_strategy();
}
inline void Specs::clear_strategy() {
  if (strategy_ != nullptr) strategy_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::robot::LimitParameters& Specs::_internal_strategy() const {
  const ::robot::LimitParameters* p = strategy_;
  return p != nullptr ? *p : *reinterpret_cast<const ::robot::LimitParameters*>(
      &::robot::_LimitParameters_default_instance_);
}
inline const ::robot::LimitParameters& Specs::strategy() const {
  // @@protoc_insertion_point(field_get:robot.Specs.strategy)
  return _internal_strategy();
}
inline void Specs::unsafe_arena_set_allocated_strategy(
    ::robot::LimitParameters* strategy) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(strategy_);
  }
  strategy_ = strategy;
  if (strategy) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:robot.Specs.strategy)
}
inline ::robot::LimitParameters* Specs::release_strategy() {
  auto temp = unsafe_arena_release_strategy();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::robot::LimitParameters* Specs::unsafe_arena_release_strategy() {
  // @@protoc_insertion_point(field_release:robot.Specs.strategy)
  _has_bits_[0] &= ~0x00000002u;
  ::robot::LimitParameters* temp = strategy_;
  strategy_ = nullptr;
  return temp;
}
inline ::robot::LimitParameters* Specs::_internal_mutable_strategy() {
  _has_bits_[0] |= 0x00000002u;
  if (strategy_ == nullptr) {
    auto* p = CreateMaybeMessage<::robot::LimitParameters>(GetArena());
    strategy_ = p;
  }
  return strategy_;
}
inline ::robot::LimitParameters* Specs::mutable_strategy() {
  // @@protoc_insertion_point(field_mutable:robot.Specs.strategy)
  return _internal_mutable_strategy();
}
inline void Specs::set_allocated_strategy(::robot::LimitParameters* strategy) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete strategy_;
  }
  if (strategy) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(strategy);
    if (message_arena != submessage_arena) {
      strategy = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, strategy, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  strategy_ = strategy;
  // @@protoc_insertion_point(field_set_allocated:robot.Specs.strategy)
}

// optional float ir_param = 15;
inline bool Specs::_internal_has_ir_param() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool Specs::has_ir_param() const {
  return _internal_has_ir_param();
}
inline void Specs::clear_ir_param() {
  ir_param_ = 0;
  _has_bits_[0] &= ~0x00001000u;
}
inline float Specs::_internal_ir_param() const {
  return ir_param_;
}
inline float Specs::ir_param() const {
  // @@protoc_insertion_point(field_get:robot.Specs.ir_param)
  return _internal_ir_param();
}
inline void Specs::_internal_set_ir_param(float value) {
  _has_bits_[0] |= 0x00001000u;
  ir_param_ = value;
}
inline void Specs::set_ir_param(float value) {
  _internal_set_ir_param(value);
  // @@protoc_insertion_point(field_set:robot.Specs.ir_param)
}

// optional float shoot_radius = 17;
inline bool Specs::_internal_has_shoot_radius() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool Specs::has_shoot_radius() const {
  return _internal_has_shoot_radius();
}
inline void Specs::clear_shoot_radius() {
  shoot_radius_ = 0;
  _has_bits_[0] &= ~0x00002000u;
}
inline float Specs::_internal_shoot_radius() const {
  return shoot_radius_;
}
inline float Specs::shoot_radius() const {
  // @@protoc_insertion_point(field_get:robot.Specs.shoot_radius)
  return _internal_shoot_radius();
}
inline void Specs::_internal_set_shoot_radius(float value) {
  _has_bits_[0] |= 0x00002000u;
  shoot_radius_ = value;
}
inline void Specs::set_shoot_radius(float value) {
  _internal_set_shoot_radius(value);
  // @@protoc_insertion_point(field_set:robot.Specs.shoot_radius)
}

// optional float dribbler_height = 18;
inline bool Specs::_internal_has_dribbler_height() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool Specs::has_dribbler_height() const {
  return _internal_has_dribbler_height();
}
inline void Specs::clear_dribbler_height() {
  dribbler_height_ = 0;
  _has_bits_[0] &= ~0x00004000u;
}
inline float Specs::_internal_dribbler_height() const {
  return dribbler_height_;
}
inline float Specs::dribbler_height() const {
  // @@protoc_insertion_point(field_get:robot.Specs.dribbler_height)
  return _internal_dribbler_height();
}
inline void Specs::_internal_set_dribbler_height(float value) {
  _has_bits_[0] |= 0x00004000u;
  dribbler_height_ = value;
}
inline void Specs::set_dribbler_height(float value) {
  _internal_set_dribbler_height(value);
  // @@protoc_insertion_point(field_set:robot.Specs.dribbler_height)
}

// optional .robot.SimulationLimits simulation_limits = 21;
inline bool Specs::_internal_has_simulation_limits() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || simulation_limits_ != nullptr);
  return value;
}
inline bool Specs::has_simulation_limits() const {
  return _internal_has_simulation_limits();
}
inline void Specs::clear_simulation_limits() {
  if (simulation_limits_ != nullptr) simulation_limits_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::robot::SimulationLimits& Specs::_internal_simulation_limits() const {
  const ::robot::SimulationLimits* p = simulation_limits_;
  return p != nullptr ? *p : *reinterpret_cast<const ::robot::SimulationLimits*>(
      &::robot::_SimulationLimits_default_instance_);
}
inline const ::robot::SimulationLimits& Specs::simulation_limits() const {
  // @@protoc_insertion_point(field_get:robot.Specs.simulation_limits)
  return _internal_simulation_limits();
}
inline void Specs::unsafe_arena_set_allocated_simulation_limits(
    ::robot::SimulationLimits* simulation_limits) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(simulation_limits_);
  }
  simulation_limits_ = simulation_limits;
  if (simulation_limits) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:robot.Specs.simulation_limits)
}
inline ::robot::SimulationLimits* Specs::release_simulation_limits() {
  auto temp = unsafe_arena_release_simulation_limits();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::robot::SimulationLimits* Specs::unsafe_arena_release_simulation_limits() {
  // @@protoc_insertion_point(field_release:robot.Specs.simulation_limits)
  _has_bits_[0] &= ~0x00000004u;
  ::robot::SimulationLimits* temp = simulation_limits_;
  simulation_limits_ = nullptr;
  return temp;
}
inline ::robot::SimulationLimits* Specs::_internal_mutable_simulation_limits() {
  _has_bits_[0] |= 0x00000004u;
  if (simulation_limits_ == nullptr) {
    auto* p = CreateMaybeMessage<::robot::SimulationLimits>(GetArena());
    simulation_limits_ = p;
  }
  return simulation_limits_;
}
inline ::robot::SimulationLimits* Specs::mutable_simulation_limits() {
  // @@protoc_insertion_point(field_mutable:robot.Specs.simulation_limits)
  return _internal_mutable_simulation_limits();
}
inline void Specs::set_allocated_simulation_limits(::robot::SimulationLimits* simulation_limits) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete simulation_limits_;
  }
  if (simulation_limits) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(simulation_limits);
    if (message_arena != submessage_arena) {
      simulation_limits = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, simulation_limits, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  simulation_limits_ = simulation_limits;
  // @@protoc_insertion_point(field_set_allocated:robot.Specs.simulation_limits)
}

// optional bool can_shoot = 22 [default = true];
inline bool Specs::_internal_has_can_shoot() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool Specs::has_can_shoot() const {
  return _internal_has_can_shoot();
}
inline void Specs::clear_can_shoot() {
  can_shoot_ = true;
  _has_bits_[0] &= ~0x00008000u;
}
inline bool Specs::_internal_can_shoot() const {
  return can_shoot_;
}
inline bool Specs::can_shoot() const {
  // @@protoc_insertion_point(field_get:robot.Specs.can_shoot)
  return _internal_can_shoot();
}
inline void Specs::_internal_set_can_shoot(bool value) {
  _has_bits_[0] |= 0x00008000u;
  can_shoot_ = value;
}
inline void Specs::set_can_shoot(bool value) {
  _internal_set_can_shoot(value);
  // @@protoc_insertion_point(field_set:robot.Specs.can_shoot)
}

// optional bool can_dribble = 23 [default = true];
inline bool Specs::_internal_has_can_dribble() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool Specs::has_can_dribble() const {
  return _internal_has_can_dribble();
}
inline void Specs::clear_can_dribble() {
  can_dribble_ = true;
  _has_bits_[0] &= ~0x00010000u;
}
inline bool Specs::_internal_can_dribble() const {
  return can_dribble_;
}
inline bool Specs::can_dribble() const {
  // @@protoc_insertion_point(field_get:robot.Specs.can_dribble)
  return _internal_can_dribble();
}
inline void Specs::_internal_set_can_dribble(bool value) {
  _has_bits_[0] |= 0x00010000u;
  can_dribble_ = value;
}
inline void Specs::set_can_dribble(bool value) {
  _internal_set_can_dribble(value);
  // @@protoc_insertion_point(field_set:robot.Specs.can_dribble)
}

// -------------------------------------------------------------------

// Generation

// required .robot.Specs default = 1;
inline bool Generation::_internal_has_default_() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || default__ != nullptr);
  return value;
}
inline bool Generation::has_default_() const {
  return _internal_has_default_();
}
inline void Generation::clear_default_() {
  if (default__ != nullptr) default__->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::robot::Specs& Generation::_internal_default_() const {
  const ::robot::Specs* p = default__;
  return p != nullptr ? *p : *reinterpret_cast<const ::robot::Specs*>(
      &::robot::_Specs_default_instance_);
}
inline const ::robot::Specs& Generation::default_() const {
  // @@protoc_insertion_point(field_get:robot.Generation.default)
  return _internal_default_();
}
inline void Generation::unsafe_arena_set_allocated_default_(
    ::robot::Specs* default_) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(default__);
  }
  default__ = default_;
  if (default_) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:robot.Generation.default)
}
inline ::robot::Specs* Generation::release_default_() {
  auto temp = unsafe_arena_release_default_();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::robot::Specs* Generation::unsafe_arena_release_default_() {
  // @@protoc_insertion_point(field_release:robot.Generation.default)
  _has_bits_[0] &= ~0x00000001u;
  ::robot::Specs* temp = default__;
  default__ = nullptr;
  return temp;
}
inline ::robot::Specs* Generation::_internal_mutable_default_() {
  _has_bits_[0] |= 0x00000001u;
  if (default__ == nullptr) {
    auto* p = CreateMaybeMessage<::robot::Specs>(GetArena());
    default__ = p;
  }
  return default__;
}
inline ::robot::Specs* Generation::mutable_default_() {
  // @@protoc_insertion_point(field_mutable:robot.Generation.default)
  return _internal_mutable_default_();
}
inline void Generation::set_allocated_default_(::robot::Specs* default_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete default__;
  }
  if (default_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(default_);
    if (message_arena != submessage_arena) {
      default_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, default_, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  default__ = default_;
  // @@protoc_insertion_point(field_set_allocated:robot.Generation.default)
}

// repeated .robot.Specs robot = 2;
inline int Generation::_internal_robot_size() const {
  return robot_.size();
}
inline int Generation::robot_size() const {
  return _internal_robot_size();
}
inline void Generation::clear_robot() {
  robot_.Clear();
}
inline ::robot::Specs* Generation::mutable_robot(int index) {
  // @@protoc_insertion_point(field_mutable:robot.Generation.robot)
  return robot_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::Specs >*
Generation::mutable_robot() {
  // @@protoc_insertion_point(field_mutable_list:robot.Generation.robot)
  return &robot_;
}
inline const ::robot::Specs& Generation::_internal_robot(int index) const {
  return robot_.Get(index);
}
inline const ::robot::Specs& Generation::robot(int index) const {
  // @@protoc_insertion_point(field_get:robot.Generation.robot)
  return _internal_robot(index);
}
inline ::robot::Specs* Generation::_internal_add_robot() {
  return robot_.Add();
}
inline ::robot::Specs* Generation::add_robot() {
  // @@protoc_insertion_point(field_add:robot.Generation.robot)
  return _internal_add_robot();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::Specs >&
Generation::robot() const {
  // @@protoc_insertion_point(field_list:robot.Generation.robot)
  return robot_;
}

// -------------------------------------------------------------------

// Team

// repeated .robot.Specs robot = 1;
inline int Team::_internal_robot_size() const {
  return robot_.size();
}
inline int Team::robot_size() const {
  return _internal_robot_size();
}
inline void Team::clear_robot() {
  robot_.Clear();
}
inline ::robot::Specs* Team::mutable_robot(int index) {
  // @@protoc_insertion_point(field_mutable:robot.Team.robot)
  return robot_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::Specs >*
Team::mutable_robot() {
  // @@protoc_insertion_point(field_mutable_list:robot.Team.robot)
  return &robot_;
}
inline const ::robot::Specs& Team::_internal_robot(int index) const {
  return robot_.Get(index);
}
inline const ::robot::Specs& Team::robot(int index) const {
  // @@protoc_insertion_point(field_get:robot.Team.robot)
  return _internal_robot(index);
}
inline ::robot::Specs* Team::_internal_add_robot() {
  return robot_.Add();
}
inline ::robot::Specs* Team::add_robot() {
  // @@protoc_insertion_point(field_add:robot.Team.robot)
  return _internal_add_robot();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::Specs >&
Team::robot() const {
  // @@protoc_insertion_point(field_list:robot.Team.robot)
  return robot_;
}

// -------------------------------------------------------------------

// Polynomial

// required float a0 = 1;
inline bool Polynomial::_internal_has_a0() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Polynomial::has_a0() const {
  return _internal_has_a0();
}
inline void Polynomial::clear_a0() {
  a0_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float Polynomial::_internal_a0() const {
  return a0_;
}
inline float Polynomial::a0() const {
  // @@protoc_insertion_point(field_get:robot.Polynomial.a0)
  return _internal_a0();
}
inline void Polynomial::_internal_set_a0(float value) {
  _has_bits_[0] |= 0x00000001u;
  a0_ = value;
}
inline void Polynomial::set_a0(float value) {
  _internal_set_a0(value);
  // @@protoc_insertion_point(field_set:robot.Polynomial.a0)
}

// required float a1 = 2;
inline bool Polynomial::_internal_has_a1() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Polynomial::has_a1() const {
  return _internal_has_a1();
}
inline void Polynomial::clear_a1() {
  a1_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float Polynomial::_internal_a1() const {
  return a1_;
}
inline float Polynomial::a1() const {
  // @@protoc_insertion_point(field_get:robot.Polynomial.a1)
  return _internal_a1();
}
inline void Polynomial::_internal_set_a1(float value) {
  _has_bits_[0] |= 0x00000002u;
  a1_ = value;
}
inline void Polynomial::set_a1(float value) {
  _internal_set_a1(value);
  // @@protoc_insertion_point(field_set:robot.Polynomial.a1)
}

// required float a2 = 3;
inline bool Polynomial::_internal_has_a2() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Polynomial::has_a2() const {
  return _internal_has_a2();
}
inline void Polynomial::clear_a2() {
  a2_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float Polynomial::_internal_a2() const {
  return a2_;
}
inline float Polynomial::a2() const {
  // @@protoc_insertion_point(field_get:robot.Polynomial.a2)
  return _internal_a2();
}
inline void Polynomial::_internal_set_a2(float value) {
  _has_bits_[0] |= 0x00000004u;
  a2_ = value;
}
inline void Polynomial::set_a2(float value) {
  _internal_set_a2(value);
  // @@protoc_insertion_point(field_set:robot.Polynomial.a2)
}

// required float a3 = 4;
inline bool Polynomial::_internal_has_a3() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Polynomial::has_a3() const {
  return _internal_has_a3();
}
inline void Polynomial::clear_a3() {
  a3_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float Polynomial::_internal_a3() const {
  return a3_;
}
inline float Polynomial::a3() const {
  // @@protoc_insertion_point(field_get:robot.Polynomial.a3)
  return _internal_a3();
}
inline void Polynomial::_internal_set_a3(float value) {
  _has_bits_[0] |= 0x00000008u;
  a3_ = value;
}
inline void Polynomial::set_a3(float value) {
  _internal_set_a3(value);
  // @@protoc_insertion_point(field_set:robot.Polynomial.a3)
}

// -------------------------------------------------------------------

// Spline

// required float t_start = 1;
inline bool Spline::_internal_has_t_start() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Spline::has_t_start() const {
  return _internal_has_t_start();
}
inline void Spline::clear_t_start() {
  t_start_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float Spline::_internal_t_start() const {
  return t_start_;
}
inline float Spline::t_start() const {
  // @@protoc_insertion_point(field_get:robot.Spline.t_start)
  return _internal_t_start();
}
inline void Spline::_internal_set_t_start(float value) {
  _has_bits_[0] |= 0x00000008u;
  t_start_ = value;
}
inline void Spline::set_t_start(float value) {
  _internal_set_t_start(value);
  // @@protoc_insertion_point(field_set:robot.Spline.t_start)
}

// required float t_end = 2;
inline bool Spline::_internal_has_t_end() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Spline::has_t_end() const {
  return _internal_has_t_end();
}
inline void Spline::clear_t_end() {
  t_end_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float Spline::_internal_t_end() const {
  return t_end_;
}
inline float Spline::t_end() const {
  // @@protoc_insertion_point(field_get:robot.Spline.t_end)
  return _internal_t_end();
}
inline void Spline::_internal_set_t_end(float value) {
  _has_bits_[0] |= 0x00000010u;
  t_end_ = value;
}
inline void Spline::set_t_end(float value) {
  _internal_set_t_end(value);
  // @@protoc_insertion_point(field_set:robot.Spline.t_end)
}

// required .robot.Polynomial x = 3;
inline bool Spline::_internal_has_x() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || x_ != nullptr);
  return value;
}
inline bool Spline::has_x() const {
  return _internal_has_x();
}
inline void Spline::clear_x() {
  if (x_ != nullptr) x_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::robot::Polynomial& Spline::_internal_x() const {
  const ::robot::Polynomial* p = x_;
  return p != nullptr ? *p : *reinterpret_cast<const ::robot::Polynomial*>(
      &::robot::_Polynomial_default_instance_);
}
inline const ::robot::Polynomial& Spline::x() const {
  // @@protoc_insertion_point(field_get:robot.Spline.x)
  return _internal_x();
}
inline void Spline::unsafe_arena_set_allocated_x(
    ::robot::Polynomial* x) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(x_);
  }
  x_ = x;
  if (x) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:robot.Spline.x)
}
inline ::robot::Polynomial* Spline::release_x() {
  auto temp = unsafe_arena_release_x();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::robot::Polynomial* Spline::unsafe_arena_release_x() {
  // @@protoc_insertion_point(field_release:robot.Spline.x)
  _has_bits_[0] &= ~0x00000001u;
  ::robot::Polynomial* temp = x_;
  x_ = nullptr;
  return temp;
}
inline ::robot::Polynomial* Spline::_internal_mutable_x() {
  _has_bits_[0] |= 0x00000001u;
  if (x_ == nullptr) {
    auto* p = CreateMaybeMessage<::robot::Polynomial>(GetArena());
    x_ = p;
  }
  return x_;
}
inline ::robot::Polynomial* Spline::mutable_x() {
  // @@protoc_insertion_point(field_mutable:robot.Spline.x)
  return _internal_mutable_x();
}
inline void Spline::set_allocated_x(::robot::Polynomial* x) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete x_;
  }
  if (x) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(x);
    if (message_arena != submessage_arena) {
      x = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, x, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  x_ = x;
  // @@protoc_insertion_point(field_set_allocated:robot.Spline.x)
}

// required .robot.Polynomial y = 4;
inline bool Spline::_internal_has_y() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || y_ != nullptr);
  return value;
}
inline bool Spline::has_y() const {
  return _internal_has_y();
}
inline void Spline::clear_y() {
  if (y_ != nullptr) y_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::robot::Polynomial& Spline::_internal_y() const {
  const ::robot::Polynomial* p = y_;
  return p != nullptr ? *p : *reinterpret_cast<const ::robot::Polynomial*>(
      &::robot::_Polynomial_default_instance_);
}
inline const ::robot::Polynomial& Spline::y() const {
  // @@protoc_insertion_point(field_get:robot.Spline.y)
  return _internal_y();
}
inline void Spline::unsafe_arena_set_allocated_y(
    ::robot::Polynomial* y) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(y_);
  }
  y_ = y;
  if (y) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:robot.Spline.y)
}
inline ::robot::Polynomial* Spline::release_y() {
  auto temp = unsafe_arena_release_y();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::robot::Polynomial* Spline::unsafe_arena_release_y() {
  // @@protoc_insertion_point(field_release:robot.Spline.y)
  _has_bits_[0] &= ~0x00000002u;
  ::robot::Polynomial* temp = y_;
  y_ = nullptr;
  return temp;
}
inline ::robot::Polynomial* Spline::_internal_mutable_y() {
  _has_bits_[0] |= 0x00000002u;
  if (y_ == nullptr) {
    auto* p = CreateMaybeMessage<::robot::Polynomial>(GetArena());
    y_ = p;
  }
  return y_;
}
inline ::robot::Polynomial* Spline::mutable_y() {
  // @@protoc_insertion_point(field_mutable:robot.Spline.y)
  return _internal_mutable_y();
}
inline void Spline::set_allocated_y(::robot::Polynomial* y) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete y_;
  }
  if (y) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(y);
    if (message_arena != submessage_arena) {
      y = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, y, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  y_ = y;
  // @@protoc_insertion_point(field_set_allocated:robot.Spline.y)
}

// required .robot.Polynomial phi = 5;
inline bool Spline::_internal_has_phi() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || phi_ != nullptr);
  return value;
}
inline bool Spline::has_phi() const {
  return _internal_has_phi();
}
inline void Spline::clear_phi() {
  if (phi_ != nullptr) phi_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::robot::Polynomial& Spline::_internal_phi() const {
  const ::robot::Polynomial* p = phi_;
  return p != nullptr ? *p : *reinterpret_cast<const ::robot::Polynomial*>(
      &::robot::_Polynomial_default_instance_);
}
inline const ::robot::Polynomial& Spline::phi() const {
  // @@protoc_insertion_point(field_get:robot.Spline.phi)
  return _internal_phi();
}
inline void Spline::unsafe_arena_set_allocated_phi(
    ::robot::Polynomial* phi) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(phi_);
  }
  phi_ = phi;
  if (phi) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:robot.Spline.phi)
}
inline ::robot::Polynomial* Spline::release_phi() {
  auto temp = unsafe_arena_release_phi();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::robot::Polynomial* Spline::unsafe_arena_release_phi() {
  // @@protoc_insertion_point(field_release:robot.Spline.phi)
  _has_bits_[0] &= ~0x00000004u;
  ::robot::Polynomial* temp = phi_;
  phi_ = nullptr;
  return temp;
}
inline ::robot::Polynomial* Spline::_internal_mutable_phi() {
  _has_bits_[0] |= 0x00000004u;
  if (phi_ == nullptr) {
    auto* p = CreateMaybeMessage<::robot::Polynomial>(GetArena());
    phi_ = p;
  }
  return phi_;
}
inline ::robot::Polynomial* Spline::mutable_phi() {
  // @@protoc_insertion_point(field_mutable:robot.Spline.phi)
  return _internal_mutable_phi();
}
inline void Spline::set_allocated_phi(::robot::Polynomial* phi) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete phi_;
  }
  if (phi) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(phi);
    if (message_arena != submessage_arena) {
      phi = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, phi, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  phi_ = phi;
  // @@protoc_insertion_point(field_set_allocated:robot.Spline.phi)
}

// -------------------------------------------------------------------

// ControllerInput

// repeated .robot.Spline spline = 1;
inline int ControllerInput::_internal_spline_size() const {
  return spline_.size();
}
inline int ControllerInput::spline_size() const {
  return _internal_spline_size();
}
inline void ControllerInput::clear_spline() {
  spline_.Clear();
}
inline ::robot::Spline* ControllerInput::mutable_spline(int index) {
  // @@protoc_insertion_point(field_mutable:robot.ControllerInput.spline)
  return spline_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::Spline >*
ControllerInput::mutable_spline() {
  // @@protoc_insertion_point(field_mutable_list:robot.ControllerInput.spline)
  return &spline_;
}
inline const ::robot::Spline& ControllerInput::_internal_spline(int index) const {
  return spline_.Get(index);
}
inline const ::robot::Spline& ControllerInput::spline(int index) const {
  // @@protoc_insertion_point(field_get:robot.ControllerInput.spline)
  return _internal_spline(index);
}
inline ::robot::Spline* ControllerInput::_internal_add_spline() {
  return spline_.Add();
}
inline ::robot::Spline* ControllerInput::add_spline() {
  // @@protoc_insertion_point(field_add:robot.ControllerInput.spline)
  return _internal_add_spline();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::Spline >&
ControllerInput::spline() const {
  // @@protoc_insertion_point(field_list:robot.ControllerInput.spline)
  return spline_;
}

// -------------------------------------------------------------------

// SpeedVector

// optional float v_s = 1;
inline bool SpeedVector::_internal_has_v_s() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SpeedVector::has_v_s() const {
  return _internal_has_v_s();
}
inline void SpeedVector::clear_v_s() {
  v_s_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float SpeedVector::_internal_v_s() const {
  return v_s_;
}
inline float SpeedVector::v_s() const {
  // @@protoc_insertion_point(field_get:robot.SpeedVector.v_s)
  return _internal_v_s();
}
inline void SpeedVector::_internal_set_v_s(float value) {
  _has_bits_[0] |= 0x00000001u;
  v_s_ = value;
}
inline void SpeedVector::set_v_s(float value) {
  _internal_set_v_s(value);
  // @@protoc_insertion_point(field_set:robot.SpeedVector.v_s)
}

// optional float v_f = 2;
inline bool SpeedVector::_internal_has_v_f() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SpeedVector::has_v_f() const {
  return _internal_has_v_f();
}
inline void SpeedVector::clear_v_f() {
  v_f_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float SpeedVector::_internal_v_f() const {
  return v_f_;
}
inline float SpeedVector::v_f() const {
  // @@protoc_insertion_point(field_get:robot.SpeedVector.v_f)
  return _internal_v_f();
}
inline void SpeedVector::_internal_set_v_f(float value) {
  _has_bits_[0] |= 0x00000002u;
  v_f_ = value;
}
inline void SpeedVector::set_v_f(float value) {
  _internal_set_v_f(value);
  // @@protoc_insertion_point(field_set:robot.SpeedVector.v_f)
}

// optional float omega = 3;
inline bool SpeedVector::_internal_has_omega() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SpeedVector::has_omega() const {
  return _internal_has_omega();
}
inline void SpeedVector::clear_omega() {
  omega_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float SpeedVector::_internal_omega() const {
  return omega_;
}
inline float SpeedVector::omega() const {
  // @@protoc_insertion_point(field_get:robot.SpeedVector.omega)
  return _internal_omega();
}
inline void SpeedVector::_internal_set_omega(float value) {
  _has_bits_[0] |= 0x00000004u;
  omega_ = value;
}
inline void SpeedVector::set_omega(float value) {
  _internal_set_omega(value);
  // @@protoc_insertion_point(field_set:robot.SpeedVector.omega)
}

// -------------------------------------------------------------------

// Command

// optional .robot.ControllerInput controller = 1;
inline bool Command::_internal_has_controller() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || controller_ != nullptr);
  return value;
}
inline bool Command::has_controller() const {
  return _internal_has_controller();
}
inline void Command::clear_controller() {
  if (controller_ != nullptr) controller_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::robot::ControllerInput& Command::_internal_controller() const {
  const ::robot::ControllerInput* p = controller_;
  return p != nullptr ? *p : *reinterpret_cast<const ::robot::ControllerInput*>(
      &::robot::_ControllerInput_default_instance_);
}
inline const ::robot::ControllerInput& Command::controller() const {
  // @@protoc_insertion_point(field_get:robot.Command.controller)
  return _internal_controller();
}
inline void Command::unsafe_arena_set_allocated_controller(
    ::robot::ControllerInput* controller) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(controller_);
  }
  controller_ = controller;
  if (controller) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:robot.Command.controller)
}
inline ::robot::ControllerInput* Command::release_controller() {
  auto temp = unsafe_arena_release_controller();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::robot::ControllerInput* Command::unsafe_arena_release_controller() {
  // @@protoc_insertion_point(field_release:robot.Command.controller)
  _has_bits_[0] &= ~0x00000001u;
  ::robot::ControllerInput* temp = controller_;
  controller_ = nullptr;
  return temp;
}
inline ::robot::ControllerInput* Command::_internal_mutable_controller() {
  _has_bits_[0] |= 0x00000001u;
  if (controller_ == nullptr) {
    auto* p = CreateMaybeMessage<::robot::ControllerInput>(GetArena());
    controller_ = p;
  }
  return controller_;
}
inline ::robot::ControllerInput* Command::mutable_controller() {
  // @@protoc_insertion_point(field_mutable:robot.Command.controller)
  return _internal_mutable_controller();
}
inline void Command::set_allocated_controller(::robot::ControllerInput* controller) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete controller_;
  }
  if (controller) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(controller);
    if (message_arena != submessage_arena) {
      controller = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, controller, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  controller_ = controller;
  // @@protoc_insertion_point(field_set_allocated:robot.Command.controller)
}

// optional float v_f = 2;
inline bool Command::_internal_has_v_f() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Command::has_v_f() const {
  return _internal_has_v_f();
}
inline void Command::clear_v_f() {
  v_f_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float Command::_internal_v_f() const {
  return v_f_;
}
inline float Command::v_f() const {
  // @@protoc_insertion_point(field_get:robot.Command.v_f)
  return _internal_v_f();
}
inline void Command::_internal_set_v_f(float value) {
  _has_bits_[0] |= 0x00000010u;
  v_f_ = value;
}
inline void Command::set_v_f(float value) {
  _internal_set_v_f(value);
  // @@protoc_insertion_point(field_set:robot.Command.v_f)
}

// optional float v_s = 3;
inline bool Command::_internal_has_v_s() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Command::has_v_s() const {
  return _internal_has_v_s();
}
inline void Command::clear_v_s() {
  v_s_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline float Command::_internal_v_s() const {
  return v_s_;
}
inline float Command::v_s() const {
  // @@protoc_insertion_point(field_get:robot.Command.v_s)
  return _internal_v_s();
}
inline void Command::_internal_set_v_s(float value) {
  _has_bits_[0] |= 0x00000020u;
  v_s_ = value;
}
inline void Command::set_v_s(float value) {
  _internal_set_v_s(value);
  // @@protoc_insertion_point(field_set:robot.Command.v_s)
}

// optional float omega = 4;
inline bool Command::_internal_has_omega() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Command::has_omega() const {
  return _internal_has_omega();
}
inline void Command::clear_omega() {
  omega_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline float Command::_internal_omega() const {
  return omega_;
}
inline float Command::omega() const {
  // @@protoc_insertion_point(field_get:robot.Command.omega)
  return _internal_omega();
}
inline void Command::_internal_set_omega(float value) {
  _has_bits_[0] |= 0x00000040u;
  omega_ = value;
}
inline void Command::set_omega(float value) {
  _internal_set_omega(value);
  // @@protoc_insertion_point(field_set:robot.Command.omega)
}

// optional .robot.Command.KickStyle kick_style = 5;
inline bool Command::_internal_has_kick_style() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool Command::has_kick_style() const {
  return _internal_has_kick_style();
}
inline void Command::clear_kick_style() {
  kick_style_ = 1;
  _has_bits_[0] &= ~0x00040000u;
}
inline ::robot::Command_KickStyle Command::_internal_kick_style() const {
  return static_cast< ::robot::Command_KickStyle >(kick_style_);
}
inline ::robot::Command_KickStyle Command::kick_style() const {
  // @@protoc_insertion_point(field_get:robot.Command.kick_style)
  return _internal_kick_style();
}
inline void Command::_internal_set_kick_style(::robot::Command_KickStyle value) {
  assert(::robot::Command_KickStyle_IsValid(value));
  _has_bits_[0] |= 0x00040000u;
  kick_style_ = value;
}
inline void Command::set_kick_style(::robot::Command_KickStyle value) {
  _internal_set_kick_style(value);
  // @@protoc_insertion_point(field_set:robot.Command.kick_style)
}

// optional float kick_power = 6;
inline bool Command::_internal_has_kick_power() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Command::has_kick_power() const {
  return _internal_has_kick_power();
}
inline void Command::clear_kick_power() {
  kick_power_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline float Command::_internal_kick_power() const {
  return kick_power_;
}
inline float Command::kick_power() const {
  // @@protoc_insertion_point(field_get:robot.Command.kick_power)
  return _internal_kick_power();
}
inline void Command::_internal_set_kick_power(float value) {
  _has_bits_[0] |= 0x00000080u;
  kick_power_ = value;
}
inline void Command::set_kick_power(float value) {
  _internal_set_kick_power(value);
  // @@protoc_insertion_point(field_set:robot.Command.kick_power)
}

// optional float dribbler = 7;
inline bool Command::_internal_has_dribbler() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Command::has_dribbler() const {
  return _internal_has_dribbler();
}
inline void Command::clear_dribbler() {
  dribbler_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline float Command::_internal_dribbler() const {
  return dribbler_;
}
inline float Command::dribbler() const {
  // @@protoc_insertion_point(field_get:robot.Command.dribbler)
  return _internal_dribbler();
}
inline void Command::_internal_set_dribbler(float value) {
  _has_bits_[0] |= 0x00000100u;
  dribbler_ = value;
}
inline void Command::set_dribbler(float value) {
  _internal_set_dribbler(value);
  // @@protoc_insertion_point(field_set:robot.Command.dribbler)
}

// optional bool local = 8;
inline bool Command::_internal_has_local() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Command::has_local() const {
  return _internal_has_local();
}
inline void Command::clear_local() {
  local_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool Command::_internal_local() const {
  return local_;
}
inline bool Command::local() const {
  // @@protoc_insertion_point(field_get:robot.Command.local)
  return _internal_local();
}
inline void Command::_internal_set_local(bool value) {
  _has_bits_[0] |= 0x00000200u;
  local_ = value;
}
inline void Command::set_local(bool value) {
  _internal_set_local(value);
  // @@protoc_insertion_point(field_set:robot.Command.local)
}

// optional bool standby = 11;
inline bool Command::_internal_has_standby() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool Command::has_standby() const {
  return _internal_has_standby();
}
inline void Command::clear_standby() {
  standby_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool Command::_internal_standby() const {
  return standby_;
}
inline bool Command::standby() const {
  // @@protoc_insertion_point(field_get:robot.Command.standby)
  return _internal_standby();
}
inline void Command::_internal_set_standby(bool value) {
  _has_bits_[0] |= 0x00000400u;
  standby_ = value;
}
inline void Command::set_standby(bool value) {
  _internal_set_standby(value);
  // @@protoc_insertion_point(field_set:robot.Command.standby)
}

// optional bool strategy_controlled = 13;
inline bool Command::_internal_has_strategy_controlled() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool Command::has_strategy_controlled() const {
  return _internal_has_strategy_controlled();
}
inline void Command::clear_strategy_controlled() {
  strategy_controlled_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool Command::_internal_strategy_controlled() const {
  return strategy_controlled_;
}
inline bool Command::strategy_controlled() const {
  // @@protoc_insertion_point(field_get:robot.Command.strategy_controlled)
  return _internal_strategy_controlled();
}
inline void Command::_internal_set_strategy_controlled(bool value) {
  _has_bits_[0] |= 0x00000800u;
  strategy_controlled_ = value;
}
inline void Command::set_strategy_controlled(bool value) {
  _internal_set_strategy_controlled(value);
  // @@protoc_insertion_point(field_set:robot.Command.strategy_controlled)
}

// optional bool force_kick = 14;
inline bool Command::_internal_has_force_kick() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool Command::has_force_kick() const {
  return _internal_has_force_kick();
}
inline void Command::clear_force_kick() {
  force_kick_ = false;
  _has_bits_[0] &= ~0x00001000u;
}
inline bool Command::_internal_force_kick() const {
  return force_kick_;
}
inline bool Command::force_kick() const {
  // @@protoc_insertion_point(field_get:robot.Command.force_kick)
  return _internal_force_kick();
}
inline void Command::_internal_set_force_kick(bool value) {
  _has_bits_[0] |= 0x00001000u;
  force_kick_ = value;
}
inline void Command::set_force_kick(bool value) {
  _internal_set_force_kick(value);
  // @@protoc_insertion_point(field_set:robot.Command.force_kick)
}

// optional bool network_controlled = 15;
inline bool Command::_internal_has_network_controlled() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool Command::has_network_controlled() const {
  return _internal_has_network_controlled();
}
inline void Command::clear_network_controlled() {
  network_controlled_ = false;
  _has_bits_[0] &= ~0x00002000u;
}
inline bool Command::_internal_network_controlled() const {
  return network_controlled_;
}
inline bool Command::network_controlled() const {
  // @@protoc_insertion_point(field_get:robot.Command.network_controlled)
  return _internal_network_controlled();
}
inline void Command::_internal_set_network_controlled(bool value) {
  _has_bits_[0] |= 0x00002000u;
  network_controlled_ = value;
}
inline void Command::set_network_controlled(bool value) {
  _internal_set_network_controlled(value);
  // @@protoc_insertion_point(field_set:robot.Command.network_controlled)
}

// optional bool eject_sdcard = 16;
inline bool Command::_internal_has_eject_sdcard() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool Command::has_eject_sdcard() const {
  return _internal_has_eject_sdcard();
}
inline void Command::clear_eject_sdcard() {
  eject_sdcard_ = false;
  _has_bits_[0] &= ~0x00004000u;
}
inline bool Command::_internal_eject_sdcard() const {
  return eject_sdcard_;
}
inline bool Command::eject_sdcard() const {
  // @@protoc_insertion_point(field_get:robot.Command.eject_sdcard)
  return _internal_eject_sdcard();
}
inline void Command::_internal_set_eject_sdcard(bool value) {
  _has_bits_[0] |= 0x00004000u;
  eject_sdcard_ = value;
}
inline void Command::set_eject_sdcard(bool value) {
  _internal_set_eject_sdcard(value);
  // @@protoc_insertion_point(field_set:robot.Command.eject_sdcard)
}

// optional float cur_v_f = 17;
inline bool Command::_internal_has_cur_v_f() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool Command::has_cur_v_f() const {
  return _internal_has_cur_v_f();
}
inline void Command::clear_cur_v_f() {
  cur_v_f_ = 0;
  _has_bits_[0] &= ~0x00008000u;
}
inline float Command::_internal_cur_v_f() const {
  return cur_v_f_;
}
inline float Command::cur_v_f() const {
  // @@protoc_insertion_point(field_get:robot.Command.cur_v_f)
  return _internal_cur_v_f();
}
inline void Command::_internal_set_cur_v_f(float value) {
  _has_bits_[0] |= 0x00008000u;
  cur_v_f_ = value;
}
inline void Command::set_cur_v_f(float value) {
  _internal_set_cur_v_f(value);
  // @@protoc_insertion_point(field_set:robot.Command.cur_v_f)
}

// optional float cur_v_s = 18;
inline bool Command::_internal_has_cur_v_s() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool Command::has_cur_v_s() const {
  return _internal_has_cur_v_s();
}
inline void Command::clear_cur_v_s() {
  cur_v_s_ = 0;
  _has_bits_[0] &= ~0x00010000u;
}
inline float Command::_internal_cur_v_s() const {
  return cur_v_s_;
}
inline float Command::cur_v_s() const {
  // @@protoc_insertion_point(field_get:robot.Command.cur_v_s)
  return _internal_cur_v_s();
}
inline void Command::_internal_set_cur_v_s(float value) {
  _has_bits_[0] |= 0x00010000u;
  cur_v_s_ = value;
}
inline void Command::set_cur_v_s(float value) {
  _internal_set_cur_v_s(value);
  // @@protoc_insertion_point(field_set:robot.Command.cur_v_s)
}

// optional float cur_omega = 19;
inline bool Command::_internal_has_cur_omega() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool Command::has_cur_omega() const {
  return _internal_has_cur_omega();
}
inline void Command::clear_cur_omega() {
  cur_omega_ = 0;
  _has_bits_[0] &= ~0x00020000u;
}
inline float Command::_internal_cur_omega() const {
  return cur_omega_;
}
inline float Command::cur_omega() const {
  // @@protoc_insertion_point(field_get:robot.Command.cur_omega)
  return _internal_cur_omega();
}
inline void Command::_internal_set_cur_omega(float value) {
  _has_bits_[0] |= 0x00020000u;
  cur_omega_ = value;
}
inline void Command::set_cur_omega(float value) {
  _internal_set_cur_omega(value);
  // @@protoc_insertion_point(field_set:robot.Command.cur_omega)
}

// optional .robot.SpeedVector output0 = 20;
inline bool Command::_internal_has_output0() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || output0_ != nullptr);
  return value;
}
inline bool Command::has_output0() const {
  return _internal_has_output0();
}
inline void Command::clear_output0() {
  if (output0_ != nullptr) output0_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::robot::SpeedVector& Command::_internal_output0() const {
  const ::robot::SpeedVector* p = output0_;
  return p != nullptr ? *p : *reinterpret_cast<const ::robot::SpeedVector*>(
      &::robot::_SpeedVector_default_instance_);
}
inline const ::robot::SpeedVector& Command::output0() const {
  // @@protoc_insertion_point(field_get:robot.Command.output0)
  return _internal_output0();
}
inline void Command::unsafe_arena_set_allocated_output0(
    ::robot::SpeedVector* output0) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(output0_);
  }
  output0_ = output0;
  if (output0) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:robot.Command.output0)
}
inline ::robot::SpeedVector* Command::release_output0() {
  auto temp = unsafe_arena_release_output0();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::robot::SpeedVector* Command::unsafe_arena_release_output0() {
  // @@protoc_insertion_point(field_release:robot.Command.output0)
  _has_bits_[0] &= ~0x00000002u;
  ::robot::SpeedVector* temp = output0_;
  output0_ = nullptr;
  return temp;
}
inline ::robot::SpeedVector* Command::_internal_mutable_output0() {
  _has_bits_[0] |= 0x00000002u;
  if (output0_ == nullptr) {
    auto* p = CreateMaybeMessage<::robot::SpeedVector>(GetArena());
    output0_ = p;
  }
  return output0_;
}
inline ::robot::SpeedVector* Command::mutable_output0() {
  // @@protoc_insertion_point(field_mutable:robot.Command.output0)
  return _internal_mutable_output0();
}
inline void Command::set_allocated_output0(::robot::SpeedVector* output0) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete output0_;
  }
  if (output0) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(output0);
    if (message_arena != submessage_arena) {
      output0 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, output0, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  output0_ = output0;
  // @@protoc_insertion_point(field_set_allocated:robot.Command.output0)
}

// optional .robot.SpeedVector output1 = 21;
inline bool Command::_internal_has_output1() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || output1_ != nullptr);
  return value;
}
inline bool Command::has_output1() const {
  return _internal_has_output1();
}
inline void Command::clear_output1() {
  if (output1_ != nullptr) output1_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::robot::SpeedVector& Command::_internal_output1() const {
  const ::robot::SpeedVector* p = output1_;
  return p != nullptr ? *p : *reinterpret_cast<const ::robot::SpeedVector*>(
      &::robot::_SpeedVector_default_instance_);
}
inline const ::robot::SpeedVector& Command::output1() const {
  // @@protoc_insertion_point(field_get:robot.Command.output1)
  return _internal_output1();
}
inline void Command::unsafe_arena_set_allocated_output1(
    ::robot::SpeedVector* output1) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(output1_);
  }
  output1_ = output1;
  if (output1) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:robot.Command.output1)
}
inline ::robot::SpeedVector* Command::release_output1() {
  auto temp = unsafe_arena_release_output1();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::robot::SpeedVector* Command::unsafe_arena_release_output1() {
  // @@protoc_insertion_point(field_release:robot.Command.output1)
  _has_bits_[0] &= ~0x00000004u;
  ::robot::SpeedVector* temp = output1_;
  output1_ = nullptr;
  return temp;
}
inline ::robot::SpeedVector* Command::_internal_mutable_output1() {
  _has_bits_[0] |= 0x00000004u;
  if (output1_ == nullptr) {
    auto* p = CreateMaybeMessage<::robot::SpeedVector>(GetArena());
    output1_ = p;
  }
  return output1_;
}
inline ::robot::SpeedVector* Command::mutable_output1() {
  // @@protoc_insertion_point(field_mutable:robot.Command.output1)
  return _internal_mutable_output1();
}
inline void Command::set_allocated_output1(::robot::SpeedVector* output1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete output1_;
  }
  if (output1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(output1);
    if (message_arena != submessage_arena) {
      output1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, output1, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  output1_ = output1;
  // @@protoc_insertion_point(field_set_allocated:robot.Command.output1)
}

// optional .robot.SpeedVector output2 = 22;
inline bool Command::_internal_has_output2() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || output2_ != nullptr);
  return value;
}
inline bool Command::has_output2() const {
  return _internal_has_output2();
}
inline void Command::clear_output2() {
  if (output2_ != nullptr) output2_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::robot::SpeedVector& Command::_internal_output2() const {
  const ::robot::SpeedVector* p = output2_;
  return p != nullptr ? *p : *reinterpret_cast<const ::robot::SpeedVector*>(
      &::robot::_SpeedVector_default_instance_);
}
inline const ::robot::SpeedVector& Command::output2() const {
  // @@protoc_insertion_point(field_get:robot.Command.output2)
  return _internal_output2();
}
inline void Command::unsafe_arena_set_allocated_output2(
    ::robot::SpeedVector* output2) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(output2_);
  }
  output2_ = output2;
  if (output2) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:robot.Command.output2)
}
inline ::robot::SpeedVector* Command::release_output2() {
  auto temp = unsafe_arena_release_output2();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::robot::SpeedVector* Command::unsafe_arena_release_output2() {
  // @@protoc_insertion_point(field_release:robot.Command.output2)
  _has_bits_[0] &= ~0x00000008u;
  ::robot::SpeedVector* temp = output2_;
  output2_ = nullptr;
  return temp;
}
inline ::robot::SpeedVector* Command::_internal_mutable_output2() {
  _has_bits_[0] |= 0x00000008u;
  if (output2_ == nullptr) {
    auto* p = CreateMaybeMessage<::robot::SpeedVector>(GetArena());
    output2_ = p;
  }
  return output2_;
}
inline ::robot::SpeedVector* Command::mutable_output2() {
  // @@protoc_insertion_point(field_mutable:robot.Command.output2)
  return _internal_mutable_output2();
}
inline void Command::set_allocated_output2(::robot::SpeedVector* output2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete output2_;
  }
  if (output2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(output2);
    if (message_arena != submessage_arena) {
      output2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, output2, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  output2_ = output2;
  // @@protoc_insertion_point(field_set_allocated:robot.Command.output2)
}

// -------------------------------------------------------------------

// RadioCommand

// required uint32 generation = 1;
inline bool RadioCommand::_internal_has_generation() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RadioCommand::has_generation() const {
  return _internal_has_generation();
}
inline void RadioCommand::clear_generation() {
  generation_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RadioCommand::_internal_generation() const {
  return generation_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RadioCommand::generation() const {
  // @@protoc_insertion_point(field_get:robot.RadioCommand.generation)
  return _internal_generation();
}
inline void RadioCommand::_internal_set_generation(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  generation_ = value;
}
inline void RadioCommand::set_generation(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_generation(value);
  // @@protoc_insertion_point(field_set:robot.RadioCommand.generation)
}

// required uint32 id = 2;
inline bool RadioCommand::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RadioCommand::has_id() const {
  return _internal_has_id();
}
inline void RadioCommand::clear_id() {
  id_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RadioCommand::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RadioCommand::id() const {
  // @@protoc_insertion_point(field_get:robot.RadioCommand.id)
  return _internal_id();
}
inline void RadioCommand::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  id_ = value;
}
inline void RadioCommand::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:robot.RadioCommand.id)
}

// optional bool is_blue = 4;
inline bool RadioCommand::_internal_has_is_blue() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RadioCommand::has_is_blue() const {
  return _internal_has_is_blue();
}
inline void RadioCommand::clear_is_blue() {
  is_blue_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool RadioCommand::_internal_is_blue() const {
  return is_blue_;
}
inline bool RadioCommand::is_blue() const {
  // @@protoc_insertion_point(field_get:robot.RadioCommand.is_blue)
  return _internal_is_blue();
}
inline void RadioCommand::_internal_set_is_blue(bool value) {
  _has_bits_[0] |= 0x00000010u;
  is_blue_ = value;
}
inline void RadioCommand::set_is_blue(bool value) {
  _internal_set_is_blue(value);
  // @@protoc_insertion_point(field_set:robot.RadioCommand.is_blue)
}

// required .robot.Command command = 3;
inline bool RadioCommand::_internal_has_command() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || command_ != nullptr);
  return value;
}
inline bool RadioCommand::has_command() const {
  return _internal_has_command();
}
inline void RadioCommand::clear_command() {
  if (command_ != nullptr) command_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::robot::Command& RadioCommand::_internal_command() const {
  const ::robot::Command* p = command_;
  return p != nullptr ? *p : *reinterpret_cast<const ::robot::Command*>(
      &::robot::_Command_default_instance_);
}
inline const ::robot::Command& RadioCommand::command() const {
  // @@protoc_insertion_point(field_get:robot.RadioCommand.command)
  return _internal_command();
}
inline void RadioCommand::unsafe_arena_set_allocated_command(
    ::robot::Command* command) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(command_);
  }
  command_ = command;
  if (command) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:robot.RadioCommand.command)
}
inline ::robot::Command* RadioCommand::release_command() {
  auto temp = unsafe_arena_release_command();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::robot::Command* RadioCommand::unsafe_arena_release_command() {
  // @@protoc_insertion_point(field_release:robot.RadioCommand.command)
  _has_bits_[0] &= ~0x00000001u;
  ::robot::Command* temp = command_;
  command_ = nullptr;
  return temp;
}
inline ::robot::Command* RadioCommand::_internal_mutable_command() {
  _has_bits_[0] |= 0x00000001u;
  if (command_ == nullptr) {
    auto* p = CreateMaybeMessage<::robot::Command>(GetArena());
    command_ = p;
  }
  return command_;
}
inline ::robot::Command* RadioCommand::mutable_command() {
  // @@protoc_insertion_point(field_mutable:robot.RadioCommand.command)
  return _internal_mutable_command();
}
inline void RadioCommand::set_allocated_command(::robot::Command* command) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete command_;
  }
  if (command) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(command);
    if (message_arena != submessage_arena) {
      command = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, command, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  command_ = command;
  // @@protoc_insertion_point(field_set_allocated:robot.RadioCommand.command)
}

// optional int64 command_time = 5;
inline bool RadioCommand::_internal_has_command_time() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RadioCommand::has_command_time() const {
  return _internal_has_command_time();
}
inline void RadioCommand::clear_command_time() {
  command_time_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RadioCommand::_internal_command_time() const {
  return command_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RadioCommand::command_time() const {
  // @@protoc_insertion_point(field_get:robot.RadioCommand.command_time)
  return _internal_command_time();
}
inline void RadioCommand::_internal_set_command_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  command_time_ = value;
}
inline void RadioCommand::set_command_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_command_time(value);
  // @@protoc_insertion_point(field_set:robot.RadioCommand.command_time)
}

// -------------------------------------------------------------------

// SpeedStatus

// required float v_f = 1;
inline bool SpeedStatus::_internal_has_v_f() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SpeedStatus::has_v_f() const {
  return _internal_has_v_f();
}
inline void SpeedStatus::clear_v_f() {
  v_f_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float SpeedStatus::_internal_v_f() const {
  return v_f_;
}
inline float SpeedStatus::v_f() const {
  // @@protoc_insertion_point(field_get:robot.SpeedStatus.v_f)
  return _internal_v_f();
}
inline void SpeedStatus::_internal_set_v_f(float value) {
  _has_bits_[0] |= 0x00000001u;
  v_f_ = value;
}
inline void SpeedStatus::set_v_f(float value) {
  _internal_set_v_f(value);
  // @@protoc_insertion_point(field_set:robot.SpeedStatus.v_f)
}

// required float v_s = 2;
inline bool SpeedStatus::_internal_has_v_s() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SpeedStatus::has_v_s() const {
  return _internal_has_v_s();
}
inline void SpeedStatus::clear_v_s() {
  v_s_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float SpeedStatus::_internal_v_s() const {
  return v_s_;
}
inline float SpeedStatus::v_s() const {
  // @@protoc_insertion_point(field_get:robot.SpeedStatus.v_s)
  return _internal_v_s();
}
inline void SpeedStatus::_internal_set_v_s(float value) {
  _has_bits_[0] |= 0x00000002u;
  v_s_ = value;
}
inline void SpeedStatus::set_v_s(float value) {
  _internal_set_v_s(value);
  // @@protoc_insertion_point(field_set:robot.SpeedStatus.v_s)
}

// required float omega = 3;
inline bool SpeedStatus::_internal_has_omega() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SpeedStatus::has_omega() const {
  return _internal_has_omega();
}
inline void SpeedStatus::clear_omega() {
  omega_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float SpeedStatus::_internal_omega() const {
  return omega_;
}
inline float SpeedStatus::omega() const {
  // @@protoc_insertion_point(field_get:robot.SpeedStatus.omega)
  return _internal_omega();
}
inline void SpeedStatus::_internal_set_omega(float value) {
  _has_bits_[0] |= 0x00000004u;
  omega_ = value;
}
inline void SpeedStatus::set_omega(float value) {
  _internal_set_omega(value);
  // @@protoc_insertion_point(field_set:robot.SpeedStatus.omega)
}

// -------------------------------------------------------------------

// ExtendedError

// required bool motor_1_error = 1;
inline bool ExtendedError::_internal_has_motor_1_error() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ExtendedError::has_motor_1_error() const {
  return _internal_has_motor_1_error();
}
inline void ExtendedError::clear_motor_1_error() {
  motor_1_error_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool ExtendedError::_internal_motor_1_error() const {
  return motor_1_error_;
}
inline bool ExtendedError::motor_1_error() const {
  // @@protoc_insertion_point(field_get:robot.ExtendedError.motor_1_error)
  return _internal_motor_1_error();
}
inline void ExtendedError::_internal_set_motor_1_error(bool value) {
  _has_bits_[0] |= 0x00000001u;
  motor_1_error_ = value;
}
inline void ExtendedError::set_motor_1_error(bool value) {
  _internal_set_motor_1_error(value);
  // @@protoc_insertion_point(field_set:robot.ExtendedError.motor_1_error)
}

// required bool motor_2_error = 2;
inline bool ExtendedError::_internal_has_motor_2_error() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ExtendedError::has_motor_2_error() const {
  return _internal_has_motor_2_error();
}
inline void ExtendedError::clear_motor_2_error() {
  motor_2_error_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool ExtendedError::_internal_motor_2_error() const {
  return motor_2_error_;
}
inline bool ExtendedError::motor_2_error() const {
  // @@protoc_insertion_point(field_get:robot.ExtendedError.motor_2_error)
  return _internal_motor_2_error();
}
inline void ExtendedError::_internal_set_motor_2_error(bool value) {
  _has_bits_[0] |= 0x00000002u;
  motor_2_error_ = value;
}
inline void ExtendedError::set_motor_2_error(bool value) {
  _internal_set_motor_2_error(value);
  // @@protoc_insertion_point(field_set:robot.ExtendedError.motor_2_error)
}

// required bool motor_3_error = 3;
inline bool ExtendedError::_internal_has_motor_3_error() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ExtendedError::has_motor_3_error() const {
  return _internal_has_motor_3_error();
}
inline void ExtendedError::clear_motor_3_error() {
  motor_3_error_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool ExtendedError::_internal_motor_3_error() const {
  return motor_3_error_;
}
inline bool ExtendedError::motor_3_error() const {
  // @@protoc_insertion_point(field_get:robot.ExtendedError.motor_3_error)
  return _internal_motor_3_error();
}
inline void ExtendedError::_internal_set_motor_3_error(bool value) {
  _has_bits_[0] |= 0x00000004u;
  motor_3_error_ = value;
}
inline void ExtendedError::set_motor_3_error(bool value) {
  _internal_set_motor_3_error(value);
  // @@protoc_insertion_point(field_set:robot.ExtendedError.motor_3_error)
}

// required bool motor_4_error = 4;
inline bool ExtendedError::_internal_has_motor_4_error() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ExtendedError::has_motor_4_error() const {
  return _internal_has_motor_4_error();
}
inline void ExtendedError::clear_motor_4_error() {
  motor_4_error_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool ExtendedError::_internal_motor_4_error() const {
  return motor_4_error_;
}
inline bool ExtendedError::motor_4_error() const {
  // @@protoc_insertion_point(field_get:robot.ExtendedError.motor_4_error)
  return _internal_motor_4_error();
}
inline void ExtendedError::_internal_set_motor_4_error(bool value) {
  _has_bits_[0] |= 0x00000008u;
  motor_4_error_ = value;
}
inline void ExtendedError::set_motor_4_error(bool value) {
  _internal_set_motor_4_error(value);
  // @@protoc_insertion_point(field_set:robot.ExtendedError.motor_4_error)
}

// required bool dribbler_error = 5;
inline bool ExtendedError::_internal_has_dribbler_error() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ExtendedError::has_dribbler_error() const {
  return _internal_has_dribbler_error();
}
inline void ExtendedError::clear_dribbler_error() {
  dribbler_error_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool ExtendedError::_internal_dribbler_error() const {
  return dribbler_error_;
}
inline bool ExtendedError::dribbler_error() const {
  // @@protoc_insertion_point(field_get:robot.ExtendedError.dribbler_error)
  return _internal_dribbler_error();
}
inline void ExtendedError::_internal_set_dribbler_error(bool value) {
  _has_bits_[0] |= 0x00000020u;
  dribbler_error_ = value;
}
inline void ExtendedError::set_dribbler_error(bool value) {
  _internal_set_dribbler_error(value);
  // @@protoc_insertion_point(field_set:robot.ExtendedError.dribbler_error)
}

// required bool kicker_error = 6;
inline bool ExtendedError::_internal_has_kicker_error() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ExtendedError::has_kicker_error() const {
  return _internal_has_kicker_error();
}
inline void ExtendedError::clear_kicker_error() {
  kicker_error_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool ExtendedError::_internal_kicker_error() const {
  return kicker_error_;
}
inline bool ExtendedError::kicker_error() const {
  // @@protoc_insertion_point(field_get:robot.ExtendedError.kicker_error)
  return _internal_kicker_error();
}
inline void ExtendedError::_internal_set_kicker_error(bool value) {
  _has_bits_[0] |= 0x00000040u;
  kicker_error_ = value;
}
inline void ExtendedError::set_kicker_error(bool value) {
  _internal_set_kicker_error(value);
  // @@protoc_insertion_point(field_set:robot.ExtendedError.kicker_error)
}

// optional bool kicker_break_beam_error = 11;
inline bool ExtendedError::_internal_has_kicker_break_beam_error() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ExtendedError::has_kicker_break_beam_error() const {
  return _internal_has_kicker_break_beam_error();
}
inline void ExtendedError::clear_kicker_break_beam_error() {
  kicker_break_beam_error_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool ExtendedError::_internal_kicker_break_beam_error() const {
  return kicker_break_beam_error_;
}
inline bool ExtendedError::kicker_break_beam_error() const {
  // @@protoc_insertion_point(field_get:robot.ExtendedError.kicker_break_beam_error)
  return _internal_kicker_break_beam_error();
}
inline void ExtendedError::_internal_set_kicker_break_beam_error(bool value) {
  _has_bits_[0] |= 0x00000080u;
  kicker_break_beam_error_ = value;
}
inline void ExtendedError::set_kicker_break_beam_error(bool value) {
  _internal_set_kicker_break_beam_error(value);
  // @@protoc_insertion_point(field_set:robot.ExtendedError.kicker_break_beam_error)
}

// optional bool motor_encoder_error = 9;
inline bool ExtendedError::_internal_has_motor_encoder_error() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ExtendedError::has_motor_encoder_error() const {
  return _internal_has_motor_encoder_error();
}
inline void ExtendedError::clear_motor_encoder_error() {
  motor_encoder_error_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool ExtendedError::_internal_motor_encoder_error() const {
  return motor_encoder_error_;
}
inline bool ExtendedError::motor_encoder_error() const {
  // @@protoc_insertion_point(field_get:robot.ExtendedError.motor_encoder_error)
  return _internal_motor_encoder_error();
}
inline void ExtendedError::_internal_set_motor_encoder_error(bool value) {
  _has_bits_[0] |= 0x00000100u;
  motor_encoder_error_ = value;
}
inline void ExtendedError::set_motor_encoder_error(bool value) {
  _internal_set_motor_encoder_error(value);
  // @@protoc_insertion_point(field_set:robot.ExtendedError.motor_encoder_error)
}

// optional bool main_sensor_error = 10;
inline bool ExtendedError::_internal_has_main_sensor_error() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ExtendedError::has_main_sensor_error() const {
  return _internal_has_main_sensor_error();
}
inline void ExtendedError::clear_main_sensor_error() {
  main_sensor_error_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool ExtendedError::_internal_main_sensor_error() const {
  return main_sensor_error_;
}
inline bool ExtendedError::main_sensor_error() const {
  // @@protoc_insertion_point(field_get:robot.ExtendedError.main_sensor_error)
  return _internal_main_sensor_error();
}
inline void ExtendedError::_internal_set_main_sensor_error(bool value) {
  _has_bits_[0] |= 0x00000200u;
  main_sensor_error_ = value;
}
inline void ExtendedError::set_main_sensor_error(bool value) {
  _internal_set_main_sensor_error(value);
  // @@protoc_insertion_point(field_set:robot.ExtendedError.main_sensor_error)
}

// optional int32 temperature = 7;
inline bool ExtendedError::_internal_has_temperature() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ExtendedError::has_temperature() const {
  return _internal_has_temperature();
}
inline void ExtendedError::clear_temperature() {
  temperature_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ExtendedError::_internal_temperature() const {
  return temperature_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ExtendedError::temperature() const {
  // @@protoc_insertion_point(field_get:robot.ExtendedError.temperature)
  return _internal_temperature();
}
inline void ExtendedError::_internal_set_temperature(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  temperature_ = value;
}
inline void ExtendedError::set_temperature(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_temperature(value);
  // @@protoc_insertion_point(field_set:robot.ExtendedError.temperature)
}

// -------------------------------------------------------------------

// RadioResponse

// optional int64 time = 10;
inline bool RadioResponse::_internal_has_time() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool RadioResponse::has_time() const {
  return _internal_has_time();
}
inline void RadioResponse::clear_time() {
  time_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RadioResponse::_internal_time() const {
  return time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RadioResponse::time() const {
  // @@protoc_insertion_point(field_get:robot.RadioResponse.time)
  return _internal_time();
}
inline void RadioResponse::_internal_set_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000800u;
  time_ = value;
}
inline void RadioResponse::set_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:robot.RadioResponse.time)
}

// required uint32 generation = 1;
inline bool RadioResponse::_internal_has_generation() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RadioResponse::has_generation() const {
  return _internal_has_generation();
}
inline void RadioResponse::clear_generation() {
  generation_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RadioResponse::_internal_generation() const {
  return generation_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RadioResponse::generation() const {
  // @@protoc_insertion_point(field_get:robot.RadioResponse.generation)
  return _internal_generation();
}
inline void RadioResponse::_internal_set_generation(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  generation_ = value;
}
inline void RadioResponse::set_generation(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_generation(value);
  // @@protoc_insertion_point(field_set:robot.RadioResponse.generation)
}

// required uint32 id = 2;
inline bool RadioResponse::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RadioResponse::has_id() const {
  return _internal_has_id();
}
inline void RadioResponse::clear_id() {
  id_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RadioResponse::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RadioResponse::id() const {
  // @@protoc_insertion_point(field_get:robot.RadioResponse.id)
  return _internal_id();
}
inline void RadioResponse::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  id_ = value;
}
inline void RadioResponse::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:robot.RadioResponse.id)
}

// optional float battery = 3;
inline bool RadioResponse::_internal_has_battery() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool RadioResponse::has_battery() const {
  return _internal_has_battery();
}
inline void RadioResponse::clear_battery() {
  battery_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float RadioResponse::_internal_battery() const {
  return battery_;
}
inline float RadioResponse::battery() const {
  // @@protoc_insertion_point(field_get:robot.RadioResponse.battery)
  return _internal_battery();
}
inline void RadioResponse::_internal_set_battery(float value) {
  _has_bits_[0] |= 0x00000010u;
  battery_ = value;
}
inline void RadioResponse::set_battery(float value) {
  _internal_set_battery(value);
  // @@protoc_insertion_point(field_set:robot.RadioResponse.battery)
}

// optional float packet_loss_rx = 4;
inline bool RadioResponse::_internal_has_packet_loss_rx() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool RadioResponse::has_packet_loss_rx() const {
  return _internal_has_packet_loss_rx();
}
inline void RadioResponse::clear_packet_loss_rx() {
  packet_loss_rx_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline float RadioResponse::_internal_packet_loss_rx() const {
  return packet_loss_rx_;
}
inline float RadioResponse::packet_loss_rx() const {
  // @@protoc_insertion_point(field_get:robot.RadioResponse.packet_loss_rx)
  return _internal_packet_loss_rx();
}
inline void RadioResponse::_internal_set_packet_loss_rx(float value) {
  _has_bits_[0] |= 0x00000020u;
  packet_loss_rx_ = value;
}
inline void RadioResponse::set_packet_loss_rx(float value) {
  _internal_set_packet_loss_rx(value);
  // @@protoc_insertion_point(field_set:robot.RadioResponse.packet_loss_rx)
}

// optional float packet_loss_tx = 5;
inline bool RadioResponse::_internal_has_packet_loss_tx() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool RadioResponse::has_packet_loss_tx() const {
  return _internal_has_packet_loss_tx();
}
inline void RadioResponse::clear_packet_loss_tx() {
  packet_loss_tx_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline float RadioResponse::_internal_packet_loss_tx() const {
  return packet_loss_tx_;
}
inline float RadioResponse::packet_loss_tx() const {
  // @@protoc_insertion_point(field_get:robot.RadioResponse.packet_loss_tx)
  return _internal_packet_loss_tx();
}
inline void RadioResponse::_internal_set_packet_loss_tx(float value) {
  _has_bits_[0] |= 0x00000040u;
  packet_loss_tx_ = value;
}
inline void RadioResponse::set_packet_loss_tx(float value) {
  _internal_set_packet_loss_tx(value);
  // @@protoc_insertion_point(field_set:robot.RadioResponse.packet_loss_tx)
}

// optional .robot.SpeedStatus estimated_speed = 6;
inline bool RadioResponse::_internal_has_estimated_speed() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || estimated_speed_ != nullptr);
  return value;
}
inline bool RadioResponse::has_estimated_speed() const {
  return _internal_has_estimated_speed();
}
inline void RadioResponse::clear_estimated_speed() {
  if (estimated_speed_ != nullptr) estimated_speed_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::robot::SpeedStatus& RadioResponse::_internal_estimated_speed() const {
  const ::robot::SpeedStatus* p = estimated_speed_;
  return p != nullptr ? *p : *reinterpret_cast<const ::robot::SpeedStatus*>(
      &::robot::_SpeedStatus_default_instance_);
}
inline const ::robot::SpeedStatus& RadioResponse::estimated_speed() const {
  // @@protoc_insertion_point(field_get:robot.RadioResponse.estimated_speed)
  return _internal_estimated_speed();
}
inline void RadioResponse::unsafe_arena_set_allocated_estimated_speed(
    ::robot::SpeedStatus* estimated_speed) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(estimated_speed_);
  }
  estimated_speed_ = estimated_speed;
  if (estimated_speed) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:robot.RadioResponse.estimated_speed)
}
inline ::robot::SpeedStatus* RadioResponse::release_estimated_speed() {
  auto temp = unsafe_arena_release_estimated_speed();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::robot::SpeedStatus* RadioResponse::unsafe_arena_release_estimated_speed() {
  // @@protoc_insertion_point(field_release:robot.RadioResponse.estimated_speed)
  _has_bits_[0] &= ~0x00000001u;
  ::robot::SpeedStatus* temp = estimated_speed_;
  estimated_speed_ = nullptr;
  return temp;
}
inline ::robot::SpeedStatus* RadioResponse::_internal_mutable_estimated_speed() {
  _has_bits_[0] |= 0x00000001u;
  if (estimated_speed_ == nullptr) {
    auto* p = CreateMaybeMessage<::robot::SpeedStatus>(GetArena());
    estimated_speed_ = p;
  }
  return estimated_speed_;
}
inline ::robot::SpeedStatus* RadioResponse::mutable_estimated_speed() {
  // @@protoc_insertion_point(field_mutable:robot.RadioResponse.estimated_speed)
  return _internal_mutable_estimated_speed();
}
inline void RadioResponse::set_allocated_estimated_speed(::robot::SpeedStatus* estimated_speed) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete estimated_speed_;
  }
  if (estimated_speed) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(estimated_speed);
    if (message_arena != submessage_arena) {
      estimated_speed = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, estimated_speed, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  estimated_speed_ = estimated_speed;
  // @@protoc_insertion_point(field_set_allocated:robot.RadioResponse.estimated_speed)
}

// optional bool ball_detected = 7;
inline bool RadioResponse::_internal_has_ball_detected() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool RadioResponse::has_ball_detected() const {
  return _internal_has_ball_detected();
}
inline void RadioResponse::clear_ball_detected() {
  ball_detected_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool RadioResponse::_internal_ball_detected() const {
  return ball_detected_;
}
inline bool RadioResponse::ball_detected() const {
  // @@protoc_insertion_point(field_get:robot.RadioResponse.ball_detected)
  return _internal_ball_detected();
}
inline void RadioResponse::_internal_set_ball_detected(bool value) {
  _has_bits_[0] |= 0x00000080u;
  ball_detected_ = value;
}
inline void RadioResponse::set_ball_detected(bool value) {
  _internal_set_ball_detected(value);
  // @@protoc_insertion_point(field_set:robot.RadioResponse.ball_detected)
}

// optional bool cap_charged = 8;
inline bool RadioResponse::_internal_has_cap_charged() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool RadioResponse::has_cap_charged() const {
  return _internal_has_cap_charged();
}
inline void RadioResponse::clear_cap_charged() {
  cap_charged_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool RadioResponse::_internal_cap_charged() const {
  return cap_charged_;
}
inline bool RadioResponse::cap_charged() const {
  // @@protoc_insertion_point(field_get:robot.RadioResponse.cap_charged)
  return _internal_cap_charged();
}
inline void RadioResponse::_internal_set_cap_charged(bool value) {
  _has_bits_[0] |= 0x00000100u;
  cap_charged_ = value;
}
inline void RadioResponse::set_cap_charged(bool value) {
  _internal_set_cap_charged(value);
  // @@protoc_insertion_point(field_set:robot.RadioResponse.cap_charged)
}

// optional bool error_present = 9;
inline bool RadioResponse::_internal_has_error_present() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool RadioResponse::has_error_present() const {
  return _internal_has_error_present();
}
inline void RadioResponse::clear_error_present() {
  error_present_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool RadioResponse::_internal_error_present() const {
  return error_present_;
}
inline bool RadioResponse::error_present() const {
  // @@protoc_insertion_point(field_get:robot.RadioResponse.error_present)
  return _internal_error_present();
}
inline void RadioResponse::_internal_set_error_present(bool value) {
  _has_bits_[0] |= 0x00000200u;
  error_present_ = value;
}
inline void RadioResponse::set_error_present(bool value) {
  _internal_set_error_present(value);
  // @@protoc_insertion_point(field_set:robot.RadioResponse.error_present)
}

// optional float radio_rtt = 11;
inline bool RadioResponse::_internal_has_radio_rtt() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool RadioResponse::has_radio_rtt() const {
  return _internal_has_radio_rtt();
}
inline void RadioResponse::clear_radio_rtt() {
  radio_rtt_ = 0;
  _has_bits_[0] &= ~0x00001000u;
}
inline float RadioResponse::_internal_radio_rtt() const {
  return radio_rtt_;
}
inline float RadioResponse::radio_rtt() const {
  // @@protoc_insertion_point(field_get:robot.RadioResponse.radio_rtt)
  return _internal_radio_rtt();
}
inline void RadioResponse::_internal_set_radio_rtt(float value) {
  _has_bits_[0] |= 0x00001000u;
  radio_rtt_ = value;
}
inline void RadioResponse::set_radio_rtt(float value) {
  _internal_set_radio_rtt(value);
  // @@protoc_insertion_point(field_set:robot.RadioResponse.radio_rtt)
}

// optional .robot.ExtendedError extended_error = 12;
inline bool RadioResponse::_internal_has_extended_error() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || extended_error_ != nullptr);
  return value;
}
inline bool RadioResponse::has_extended_error() const {
  return _internal_has_extended_error();
}
inline void RadioResponse::clear_extended_error() {
  if (extended_error_ != nullptr) extended_error_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::robot::ExtendedError& RadioResponse::_internal_extended_error() const {
  const ::robot::ExtendedError* p = extended_error_;
  return p != nullptr ? *p : *reinterpret_cast<const ::robot::ExtendedError*>(
      &::robot::_ExtendedError_default_instance_);
}
inline const ::robot::ExtendedError& RadioResponse::extended_error() const {
  // @@protoc_insertion_point(field_get:robot.RadioResponse.extended_error)
  return _internal_extended_error();
}
inline void RadioResponse::unsafe_arena_set_allocated_extended_error(
    ::robot::ExtendedError* extended_error) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(extended_error_);
  }
  extended_error_ = extended_error;
  if (extended_error) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:robot.RadioResponse.extended_error)
}
inline ::robot::ExtendedError* RadioResponse::release_extended_error() {
  auto temp = unsafe_arena_release_extended_error();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::robot::ExtendedError* RadioResponse::unsafe_arena_release_extended_error() {
  // @@protoc_insertion_point(field_release:robot.RadioResponse.extended_error)
  _has_bits_[0] &= ~0x00000002u;
  ::robot::ExtendedError* temp = extended_error_;
  extended_error_ = nullptr;
  return temp;
}
inline ::robot::ExtendedError* RadioResponse::_internal_mutable_extended_error() {
  _has_bits_[0] |= 0x00000002u;
  if (extended_error_ == nullptr) {
    auto* p = CreateMaybeMessage<::robot::ExtendedError>(GetArena());
    extended_error_ = p;
  }
  return extended_error_;
}
inline ::robot::ExtendedError* RadioResponse::mutable_extended_error() {
  // @@protoc_insertion_point(field_mutable:robot.RadioResponse.extended_error)
  return _internal_mutable_extended_error();
}
inline void RadioResponse::set_allocated_extended_error(::robot::ExtendedError* extended_error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete extended_error_;
  }
  if (extended_error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(extended_error);
    if (message_arena != submessage_arena) {
      extended_error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, extended_error, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  extended_error_ = extended_error;
  // @@protoc_insertion_point(field_set_allocated:robot.RadioResponse.extended_error)
}

// optional bool is_blue = 13;
inline bool RadioResponse::_internal_has_is_blue() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool RadioResponse::has_is_blue() const {
  return _internal_has_is_blue();
}
inline void RadioResponse::clear_is_blue() {
  is_blue_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool RadioResponse::_internal_is_blue() const {
  return is_blue_;
}
inline bool RadioResponse::is_blue() const {
  // @@protoc_insertion_point(field_get:robot.RadioResponse.is_blue)
  return _internal_is_blue();
}
inline void RadioResponse::_internal_set_is_blue(bool value) {
  _has_bits_[0] |= 0x00000400u;
  is_blue_ = value;
}
inline void RadioResponse::set_is_blue(bool value) {
  _internal_set_is_blue(value);
  // @@protoc_insertion_point(field_set:robot.RadioResponse.is_blue)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace robot

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::robot::Specs_GenerationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::robot::Specs_GenerationType>() {
  return ::robot::Specs_GenerationType_descriptor();
}
template <> struct is_proto_enum< ::robot::Command_KickStyle> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::robot::Command_KickStyle>() {
  return ::robot::Command_KickStyle_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_robot_2eproto
