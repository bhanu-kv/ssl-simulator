// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pathfinding.proto

#include "pathfinding.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_pathfinding_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_CircleObstacle_pathfinding_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_pathfinding_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_FriendlyRobotObstacle_pathfinding_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_pathfinding_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_LineObstacle_pathfinding_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_pathfinding_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_MovingCircleObstacle_pathfinding_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_pathfinding_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_MovingLineObstacle_pathfinding_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_pathfinding_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<8> scc_info_Obstacle_pathfinding_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_pathfinding_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_OpponentRobotObstacle_pathfinding_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_pathfinding_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_RectObstacle_pathfinding_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_pathfinding_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_StandardSamplerPoint_pathfinding_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_pathfinding_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_StandardSamplerPrecomputationSegment_pathfinding_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_pathfinding_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_TrajectoryInput_pathfinding_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_pathfinding_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_TrajectoryPoint_pathfinding_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_pathfinding_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_TriangleObstacle_pathfinding_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_pathfinding_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Vector_pathfinding_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_pathfinding_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_WorldState_pathfinding_2eproto;
namespace pathfinding {
class VectorDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Vector> _instance;
} _Vector_default_instance_;
class CircleObstacleDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<CircleObstacle> _instance;
} _CircleObstacle_default_instance_;
class RectObstacleDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<RectObstacle> _instance;
} _RectObstacle_default_instance_;
class TriangleObstacleDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TriangleObstacle> _instance;
} _TriangleObstacle_default_instance_;
class LineObstacleDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<LineObstacle> _instance;
} _LineObstacle_default_instance_;
class MovingCircleObstacleDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<MovingCircleObstacle> _instance;
} _MovingCircleObstacle_default_instance_;
class MovingLineObstacleDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<MovingLineObstacle> _instance;
} _MovingLineObstacle_default_instance_;
class TrajectoryPointDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TrajectoryPoint> _instance;
} _TrajectoryPoint_default_instance_;
class FriendlyRobotObstacleDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<FriendlyRobotObstacle> _instance;
} _FriendlyRobotObstacle_default_instance_;
class OpponentRobotObstacleDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<OpponentRobotObstacle> _instance;
} _OpponentRobotObstacle_default_instance_;
class ObstacleDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Obstacle> _instance;
  const ::pathfinding::CircleObstacle* circle_;
  const ::pathfinding::RectObstacle* rectangle_;
  const ::pathfinding::TriangleObstacle* triangle_;
  const ::pathfinding::LineObstacle* line_;
  const ::pathfinding::MovingCircleObstacle* moving_circle_;
  const ::pathfinding::MovingLineObstacle* moving_line_;
  const ::pathfinding::FriendlyRobotObstacle* friendly_robot_;
  const ::pathfinding::OpponentRobotObstacle* opponent_robot_;
} _Obstacle_default_instance_;
class WorldStateDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<WorldState> _instance;
} _WorldState_default_instance_;
class TrajectoryInputDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TrajectoryInput> _instance;
} _TrajectoryInput_default_instance_;
class PathFindingTaskDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<PathFindingTask> _instance;
} _PathFindingTask_default_instance_;
class StandardSamplerPointDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<StandardSamplerPoint> _instance;
} _StandardSamplerPoint_default_instance_;
class StandardSamplerPrecomputationSegmentDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<StandardSamplerPrecomputationSegment> _instance;
} _StandardSamplerPrecomputationSegment_default_instance_;
class StandardSamplerPrecomputationDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<StandardSamplerPrecomputation> _instance;
} _StandardSamplerPrecomputation_default_instance_;
}  // namespace pathfinding
static void InitDefaultsscc_info_CircleObstacle_pathfinding_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pathfinding::_CircleObstacle_default_instance_;
    new (ptr) ::pathfinding::CircleObstacle();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pathfinding::CircleObstacle::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_CircleObstacle_pathfinding_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_CircleObstacle_pathfinding_2eproto}, {
      &scc_info_Vector_pathfinding_2eproto.base,}};

static void InitDefaultsscc_info_FriendlyRobotObstacle_pathfinding_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pathfinding::_FriendlyRobotObstacle_default_instance_;
    new (ptr) ::pathfinding::FriendlyRobotObstacle();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pathfinding::FriendlyRobotObstacle::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_FriendlyRobotObstacle_pathfinding_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_FriendlyRobotObstacle_pathfinding_2eproto}, {
      &scc_info_TrajectoryPoint_pathfinding_2eproto.base,}};

static void InitDefaultsscc_info_LineObstacle_pathfinding_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pathfinding::_LineObstacle_default_instance_;
    new (ptr) ::pathfinding::LineObstacle();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pathfinding::LineObstacle::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_LineObstacle_pathfinding_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_LineObstacle_pathfinding_2eproto}, {
      &scc_info_Vector_pathfinding_2eproto.base,}};

static void InitDefaultsscc_info_MovingCircleObstacle_pathfinding_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pathfinding::_MovingCircleObstacle_default_instance_;
    new (ptr) ::pathfinding::MovingCircleObstacle();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pathfinding::MovingCircleObstacle::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_MovingCircleObstacle_pathfinding_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_MovingCircleObstacle_pathfinding_2eproto}, {
      &scc_info_Vector_pathfinding_2eproto.base,}};

static void InitDefaultsscc_info_MovingLineObstacle_pathfinding_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pathfinding::_MovingLineObstacle_default_instance_;
    new (ptr) ::pathfinding::MovingLineObstacle();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pathfinding::MovingLineObstacle::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_MovingLineObstacle_pathfinding_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_MovingLineObstacle_pathfinding_2eproto}, {
      &scc_info_Vector_pathfinding_2eproto.base,}};

static void InitDefaultsscc_info_Obstacle_pathfinding_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pathfinding::_Obstacle_default_instance_;
    new (ptr) ::pathfinding::Obstacle();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pathfinding::Obstacle::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<8> scc_info_Obstacle_pathfinding_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 8, 0, InitDefaultsscc_info_Obstacle_pathfinding_2eproto}, {
      &scc_info_CircleObstacle_pathfinding_2eproto.base,
      &scc_info_RectObstacle_pathfinding_2eproto.base,
      &scc_info_TriangleObstacle_pathfinding_2eproto.base,
      &scc_info_LineObstacle_pathfinding_2eproto.base,
      &scc_info_MovingCircleObstacle_pathfinding_2eproto.base,
      &scc_info_MovingLineObstacle_pathfinding_2eproto.base,
      &scc_info_FriendlyRobotObstacle_pathfinding_2eproto.base,
      &scc_info_OpponentRobotObstacle_pathfinding_2eproto.base,}};

static void InitDefaultsscc_info_OpponentRobotObstacle_pathfinding_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pathfinding::_OpponentRobotObstacle_default_instance_;
    new (ptr) ::pathfinding::OpponentRobotObstacle();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pathfinding::OpponentRobotObstacle::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_OpponentRobotObstacle_pathfinding_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_OpponentRobotObstacle_pathfinding_2eproto}, {
      &scc_info_Vector_pathfinding_2eproto.base,}};

static void InitDefaultsscc_info_PathFindingTask_pathfinding_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pathfinding::_PathFindingTask_default_instance_;
    new (ptr) ::pathfinding::PathFindingTask();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pathfinding::PathFindingTask::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_PathFindingTask_pathfinding_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_PathFindingTask_pathfinding_2eproto}, {
      &scc_info_WorldState_pathfinding_2eproto.base,
      &scc_info_TrajectoryInput_pathfinding_2eproto.base,}};

static void InitDefaultsscc_info_RectObstacle_pathfinding_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pathfinding::_RectObstacle_default_instance_;
    new (ptr) ::pathfinding::RectObstacle();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pathfinding::RectObstacle::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_RectObstacle_pathfinding_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_RectObstacle_pathfinding_2eproto}, {
      &scc_info_Vector_pathfinding_2eproto.base,}};

static void InitDefaultsscc_info_StandardSamplerPoint_pathfinding_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pathfinding::_StandardSamplerPoint_default_instance_;
    new (ptr) ::pathfinding::StandardSamplerPoint();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pathfinding::StandardSamplerPoint::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_StandardSamplerPoint_pathfinding_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_StandardSamplerPoint_pathfinding_2eproto}, {}};

static void InitDefaultsscc_info_StandardSamplerPrecomputation_pathfinding_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pathfinding::_StandardSamplerPrecomputation_default_instance_;
    new (ptr) ::pathfinding::StandardSamplerPrecomputation();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pathfinding::StandardSamplerPrecomputation::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_StandardSamplerPrecomputation_pathfinding_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_StandardSamplerPrecomputation_pathfinding_2eproto}, {
      &scc_info_StandardSamplerPrecomputationSegment_pathfinding_2eproto.base,}};

static void InitDefaultsscc_info_StandardSamplerPrecomputationSegment_pathfinding_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pathfinding::_StandardSamplerPrecomputationSegment_default_instance_;
    new (ptr) ::pathfinding::StandardSamplerPrecomputationSegment();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pathfinding::StandardSamplerPrecomputationSegment::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_StandardSamplerPrecomputationSegment_pathfinding_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_StandardSamplerPrecomputationSegment_pathfinding_2eproto}, {
      &scc_info_StandardSamplerPoint_pathfinding_2eproto.base,}};

static void InitDefaultsscc_info_TrajectoryInput_pathfinding_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pathfinding::_TrajectoryInput_default_instance_;
    new (ptr) ::pathfinding::TrajectoryInput();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pathfinding::TrajectoryInput::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_TrajectoryInput_pathfinding_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_TrajectoryInput_pathfinding_2eproto}, {
      &scc_info_Vector_pathfinding_2eproto.base,}};

static void InitDefaultsscc_info_TrajectoryPoint_pathfinding_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pathfinding::_TrajectoryPoint_default_instance_;
    new (ptr) ::pathfinding::TrajectoryPoint();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pathfinding::TrajectoryPoint::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_TrajectoryPoint_pathfinding_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_TrajectoryPoint_pathfinding_2eproto}, {
      &scc_info_Vector_pathfinding_2eproto.base,}};

static void InitDefaultsscc_info_TriangleObstacle_pathfinding_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pathfinding::_TriangleObstacle_default_instance_;
    new (ptr) ::pathfinding::TriangleObstacle();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pathfinding::TriangleObstacle::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_TriangleObstacle_pathfinding_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_TriangleObstacle_pathfinding_2eproto}, {
      &scc_info_Vector_pathfinding_2eproto.base,}};

static void InitDefaultsscc_info_Vector_pathfinding_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pathfinding::_Vector_default_instance_;
    new (ptr) ::pathfinding::Vector();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pathfinding::Vector::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Vector_pathfinding_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_Vector_pathfinding_2eproto}, {}};

static void InitDefaultsscc_info_WorldState_pathfinding_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::pathfinding::_WorldState_default_instance_;
    new (ptr) ::pathfinding::WorldState();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::pathfinding::WorldState::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_WorldState_pathfinding_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_WorldState_pathfinding_2eproto}, {
      &scc_info_Obstacle_pathfinding_2eproto.base,
      &scc_info_RectObstacle_pathfinding_2eproto.base,}};

static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_pathfinding_2eproto[17];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_pathfinding_2eproto[1];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_pathfinding_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_pathfinding_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::pathfinding::Vector, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::Vector, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::pathfinding::Vector, x_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::Vector, y_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::pathfinding::CircleObstacle, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::CircleObstacle, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::pathfinding::CircleObstacle, center_),
  0,
  PROTOBUF_FIELD_OFFSET(::pathfinding::RectObstacle, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::RectObstacle, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::pathfinding::RectObstacle, bottom_left_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::RectObstacle, top_right_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::pathfinding::TriangleObstacle, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::TriangleObstacle, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::pathfinding::TriangleObstacle, p1_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::TriangleObstacle, p2_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::TriangleObstacle, p3_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::pathfinding::LineObstacle, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::LineObstacle, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::pathfinding::LineObstacle, start_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::LineObstacle, end_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::pathfinding::MovingCircleObstacle, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::MovingCircleObstacle, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::pathfinding::MovingCircleObstacle, start_pos_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::MovingCircleObstacle, speed_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::MovingCircleObstacle, acc_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::MovingCircleObstacle, start_time_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::MovingCircleObstacle, end_time_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::pathfinding::MovingLineObstacle, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::MovingLineObstacle, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::pathfinding::MovingLineObstacle, start_pos1_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::MovingLineObstacle, speed1_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::MovingLineObstacle, acc1_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::MovingLineObstacle, start_pos2_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::MovingLineObstacle, speed2_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::MovingLineObstacle, acc2_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::MovingLineObstacle, start_time_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::MovingLineObstacle, end_time_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  PROTOBUF_FIELD_OFFSET(::pathfinding::TrajectoryPoint, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::TrajectoryPoint, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::pathfinding::TrajectoryPoint, pos_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::TrajectoryPoint, speed_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::TrajectoryPoint, time_),
  0,
  1,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pathfinding::FriendlyRobotObstacle, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::pathfinding::FriendlyRobotObstacle, robot_trajectory_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::OpponentRobotObstacle, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::OpponentRobotObstacle, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::pathfinding::OpponentRobotObstacle, start_pos_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::OpponentRobotObstacle, speed_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::pathfinding::Obstacle, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::Obstacle, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::pathfinding::Obstacle, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::pathfinding::Obstacle, name_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::Obstacle, prio_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::Obstacle, radius_),
  offsetof(::pathfinding::ObstacleDefaultTypeInternal, circle_),
  offsetof(::pathfinding::ObstacleDefaultTypeInternal, rectangle_),
  offsetof(::pathfinding::ObstacleDefaultTypeInternal, triangle_),
  offsetof(::pathfinding::ObstacleDefaultTypeInternal, line_),
  offsetof(::pathfinding::ObstacleDefaultTypeInternal, moving_circle_),
  offsetof(::pathfinding::ObstacleDefaultTypeInternal, moving_line_),
  offsetof(::pathfinding::ObstacleDefaultTypeInternal, friendly_robot_),
  offsetof(::pathfinding::ObstacleDefaultTypeInternal, opponent_robot_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::Obstacle, obstacle_),
  0,
  1,
  2,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::pathfinding::WorldState, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::WorldState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::pathfinding::WorldState, obstacles_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::WorldState, out_of_field_priority_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::WorldState, boundary_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::WorldState, radius_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::WorldState, robot_id_),
  ~0u,
  1,
  0,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::pathfinding::TrajectoryInput, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::TrajectoryInput, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::pathfinding::TrajectoryInput, v0_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::TrajectoryInput, v1_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::TrajectoryInput, s0_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::TrajectoryInput, s1_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::TrajectoryInput, max_speed_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::TrajectoryInput, acceleration_),
  0,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::pathfinding::PathFindingTask, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::PathFindingTask, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::pathfinding::PathFindingTask, state_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::PathFindingTask, input_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::PathFindingTask, type_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::pathfinding::StandardSamplerPoint, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::StandardSamplerPoint, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::pathfinding::StandardSamplerPoint, time_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::StandardSamplerPoint, angle_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::StandardSamplerPoint, mid_speed_x_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::StandardSamplerPoint, mid_speed_y_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::pathfinding::StandardSamplerPrecomputationSegment, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::StandardSamplerPrecomputationSegment, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::pathfinding::StandardSamplerPrecomputationSegment, precomputed_points_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::StandardSamplerPrecomputationSegment, min_distance_),
  PROTOBUF_FIELD_OFFSET(::pathfinding::StandardSamplerPrecomputationSegment, max_distance_),
  ~0u,
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::pathfinding::StandardSamplerPrecomputation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::pathfinding::StandardSamplerPrecomputation, segments_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 7, sizeof(::pathfinding::Vector)},
  { 9, 15, sizeof(::pathfinding::CircleObstacle)},
  { 16, 23, sizeof(::pathfinding::RectObstacle)},
  { 25, 33, sizeof(::pathfinding::TriangleObstacle)},
  { 36, 43, sizeof(::pathfinding::LineObstacle)},
  { 45, 55, sizeof(::pathfinding::MovingCircleObstacle)},
  { 60, 73, sizeof(::pathfinding::MovingLineObstacle)},
  { 81, 89, sizeof(::pathfinding::TrajectoryPoint)},
  { 92, -1, sizeof(::pathfinding::FriendlyRobotObstacle)},
  { 98, 105, sizeof(::pathfinding::OpponentRobotObstacle)},
  { 107, 124, sizeof(::pathfinding::Obstacle)},
  { 135, 145, sizeof(::pathfinding::WorldState)},
  { 150, 161, sizeof(::pathfinding::TrajectoryInput)},
  { 167, 175, sizeof(::pathfinding::PathFindingTask)},
  { 178, 187, sizeof(::pathfinding::StandardSamplerPoint)},
  { 191, 199, sizeof(::pathfinding::StandardSamplerPrecomputationSegment)},
  { 202, -1, sizeof(::pathfinding::StandardSamplerPrecomputation)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::pathfinding::_Vector_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::pathfinding::_CircleObstacle_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::pathfinding::_RectObstacle_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::pathfinding::_TriangleObstacle_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::pathfinding::_LineObstacle_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::pathfinding::_MovingCircleObstacle_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::pathfinding::_MovingLineObstacle_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::pathfinding::_TrajectoryPoint_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::pathfinding::_FriendlyRobotObstacle_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::pathfinding::_OpponentRobotObstacle_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::pathfinding::_Obstacle_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::pathfinding::_WorldState_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::pathfinding::_TrajectoryInput_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::pathfinding::_PathFindingTask_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::pathfinding::_StandardSamplerPoint_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::pathfinding::_StandardSamplerPrecomputationSegment_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::pathfinding::_StandardSamplerPrecomputation_default_instance_),
};

const char descriptor_table_protodef_pathfinding_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\021pathfinding.proto\022\013pathfinding\"\036\n\006Vect"
  "or\022\t\n\001x\030\001 \001(\002\022\t\n\001y\030\002 \001(\002\"5\n\016CircleObstac"
  "le\022#\n\006center\030\001 \001(\0132\023.pathfinding.Vector\""
  "`\n\014RectObstacle\022(\n\013bottom_left\030\001 \001(\0132\023.p"
  "athfinding.Vector\022&\n\ttop_right\030\002 \001(\0132\023.p"
  "athfinding.Vector\"u\n\020TriangleObstacle\022\037\n"
  "\002p1\030\001 \001(\0132\023.pathfinding.Vector\022\037\n\002p2\030\002 \001"
  "(\0132\023.pathfinding.Vector\022\037\n\002p3\030\003 \001(\0132\023.pa"
  "thfinding.Vector\"T\n\014LineObstacle\022\"\n\005star"
  "t\030\001 \001(\0132\023.pathfinding.Vector\022 \n\003end\030\002 \001("
  "\0132\023.pathfinding.Vector\"\252\001\n\024MovingCircleO"
  "bstacle\022&\n\tstart_pos\030\001 \001(\0132\023.pathfinding"
  ".Vector\022\"\n\005speed\030\002 \001(\0132\023.pathfinding.Vec"
  "tor\022 \n\003acc\030\003 \001(\0132\023.pathfinding.Vector\022\022\n"
  "\nstart_time\030\004 \001(\002\022\020\n\010end_time\030\005 \001(\002\"\234\002\n\022"
  "MovingLineObstacle\022\'\n\nstart_pos1\030\001 \001(\0132\023"
  ".pathfinding.Vector\022#\n\006speed1\030\002 \001(\0132\023.pa"
  "thfinding.Vector\022!\n\004acc1\030\003 \001(\0132\023.pathfin"
  "ding.Vector\022\'\n\nstart_pos2\030\004 \001(\0132\023.pathfi"
  "nding.Vector\022#\n\006speed2\030\005 \001(\0132\023.pathfindi"
  "ng.Vector\022!\n\004acc2\030\006 \001(\0132\023.pathfinding.Ve"
  "ctor\022\022\n\nstart_time\030\007 \001(\002\022\020\n\010end_time\030\010 \001"
  "(\002\"e\n\017TrajectoryPoint\022 \n\003pos\030\001 \001(\0132\023.pat"
  "hfinding.Vector\022\"\n\005speed\030\002 \001(\0132\023.pathfin"
  "ding.Vector\022\014\n\004time\030\003 \001(\002\"O\n\025FriendlyRob"
  "otObstacle\0226\n\020robot_trajectory\030\001 \003(\0132\034.p"
  "athfinding.TrajectoryPoint\"c\n\025OpponentRo"
  "botObstacle\022&\n\tstart_pos\030\001 \001(\0132\023.pathfin"
  "ding.Vector\022\"\n\005speed\030\002 \001(\0132\023.pathfinding"
  ".Vector\"\357\003\n\010Obstacle\022\014\n\004name\030\001 \001(\t\022\014\n\004pr"
  "io\030\002 \001(\005\022\016\n\006radius\030\003 \001(\002\022-\n\006circle\030\004 \001(\013"
  "2\033.pathfinding.CircleObstacleH\000\022.\n\trecta"
  "ngle\030\005 \001(\0132\031.pathfinding.RectObstacleH\000\022"
  "1\n\010triangle\030\006 \001(\0132\035.pathfinding.Triangle"
  "ObstacleH\000\022)\n\004line\030\007 \001(\0132\031.pathfinding.L"
  "ineObstacleH\000\022:\n\rmoving_circle\030\t \001(\0132!.p"
  "athfinding.MovingCircleObstacleH\000\0226\n\013mov"
  "ing_line\030\n \001(\0132\037.pathfinding.MovingLineO"
  "bstacleH\000\022<\n\016friendly_robot\030\013 \001(\0132\".path"
  "finding.FriendlyRobotObstacleH\000\022<\n\016oppon"
  "ent_robot\030\014 \001(\0132\".pathfinding.OpponentRo"
  "botObstacleH\000B\n\n\010obstacle\"\244\001\n\nWorldState"
  "\022(\n\tobstacles\030\001 \003(\0132\025.pathfinding.Obstac"
  "le\022\035\n\025out_of_field_priority\030\002 \001(\r\022+\n\010bou"
  "ndary\030\003 \001(\0132\031.pathfinding.RectObstacle\022\016"
  "\n\006radius\030\004 \001(\002\022\020\n\010robot_id\030\005 \001(\r\"\276\001\n\017Tra"
  "jectoryInput\022\037\n\002v0\030\001 \001(\0132\023.pathfinding.V"
  "ector\022\037\n\002v1\030\002 \001(\0132\023.pathfinding.Vector\022\037"
  "\n\002s0\030\004 \001(\0132\023.pathfinding.Vector\022\037\n\002s1\030\005 "
  "\001(\0132\023.pathfinding.Vector\022\021\n\tmax_speed\030\006 "
  "\001(\002\022\024\n\014acceleration\030\007 \001(\002\"\222\001\n\017PathFindin"
  "gTask\022&\n\005state\030\001 \001(\0132\027.pathfinding.World"
  "State\022+\n\005input\030\002 \001(\0132\034.pathfinding.Traje"
  "ctoryInput\022*\n\004type\030\003 \001(\0162\034.pathfinding.I"
  "nputSourceType\"]\n\024StandardSamplerPoint\022\014"
  "\n\004time\030\001 \001(\002\022\r\n\005angle\030\002 \001(\002\022\023\n\013mid_speed"
  "_x\030\003 \001(\002\022\023\n\013mid_speed_y\030\004 \001(\002\"\221\001\n$Standa"
  "rdSamplerPrecomputationSegment\022=\n\022precom"
  "puted_points\030\001 \003(\0132!.pathfinding.Standar"
  "dSamplerPoint\022\024\n\014min_distance\030\002 \001(\002\022\024\n\014m"
  "ax_distance\030\003 \001(\002\"d\n\035StandardSamplerPrec"
  "omputation\022C\n\010segments\030\001 \003(\01321.pathfindi"
  "ng.StandardSamplerPrecomputationSegment*"
  "v\n\017InputSourceType\022\010\n\004None\020\000\022\017\n\013AllSampl"
  "ers\020\001\022\023\n\017StandardSampler\020\002\022\030\n\024EndInObsta"
  "cleSampler\020\003\022\031\n\025EscapeObstacleSampler\020\004"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_pathfinding_2eproto_deps[1] = {
};
static ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase*const descriptor_table_pathfinding_2eproto_sccs[17] = {
  &scc_info_CircleObstacle_pathfinding_2eproto.base,
  &scc_info_FriendlyRobotObstacle_pathfinding_2eproto.base,
  &scc_info_LineObstacle_pathfinding_2eproto.base,
  &scc_info_MovingCircleObstacle_pathfinding_2eproto.base,
  &scc_info_MovingLineObstacle_pathfinding_2eproto.base,
  &scc_info_Obstacle_pathfinding_2eproto.base,
  &scc_info_OpponentRobotObstacle_pathfinding_2eproto.base,
  &scc_info_PathFindingTask_pathfinding_2eproto.base,
  &scc_info_RectObstacle_pathfinding_2eproto.base,
  &scc_info_StandardSamplerPoint_pathfinding_2eproto.base,
  &scc_info_StandardSamplerPrecomputation_pathfinding_2eproto.base,
  &scc_info_StandardSamplerPrecomputationSegment_pathfinding_2eproto.base,
  &scc_info_TrajectoryInput_pathfinding_2eproto.base,
  &scc_info_TrajectoryPoint_pathfinding_2eproto.base,
  &scc_info_TriangleObstacle_pathfinding_2eproto.base,
  &scc_info_Vector_pathfinding_2eproto.base,
  &scc_info_WorldState_pathfinding_2eproto.base,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_pathfinding_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_pathfinding_2eproto = {
  false, false, descriptor_table_protodef_pathfinding_2eproto, "pathfinding.proto", 2639,
  &descriptor_table_pathfinding_2eproto_once, descriptor_table_pathfinding_2eproto_sccs, descriptor_table_pathfinding_2eproto_deps, 17, 0,
  schemas, file_default_instances, TableStruct_pathfinding_2eproto::offsets,
  file_level_metadata_pathfinding_2eproto, 17, file_level_enum_descriptors_pathfinding_2eproto, file_level_service_descriptors_pathfinding_2eproto,
};

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_pathfinding_2eproto = (static_cast<void>(::PROTOBUF_NAMESPACE_ID::internal::AddDescriptors(&descriptor_table_pathfinding_2eproto)), true);
namespace pathfinding {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* InputSourceType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_pathfinding_2eproto);
  return file_level_enum_descriptors_pathfinding_2eproto[0];
}
bool InputSourceType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}


// ===================================================================

void Vector::InitAsDefaultInstance() {
}
class Vector::_Internal {
 public:
  using HasBits = decltype(std::declval<Vector>()._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Vector::Vector(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:pathfinding.Vector)
}
Vector::Vector(const Vector& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&y_) -
    reinterpret_cast<char*>(&x_)) + sizeof(y_));
  // @@protoc_insertion_point(copy_constructor:pathfinding.Vector)
}

void Vector::SharedCtor() {
  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&y_) -
      reinterpret_cast<char*>(&x_)) + sizeof(y_));
}

Vector::~Vector() {
  // @@protoc_insertion_point(destructor:pathfinding.Vector)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Vector::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void Vector::ArenaDtor(void* object) {
  Vector* _this = reinterpret_cast< Vector* >(object);
  (void)_this;
}
void Vector::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Vector::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Vector& Vector::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Vector_pathfinding_2eproto.base);
  return *internal_default_instance();
}


void Vector::Clear() {
// @@protoc_insertion_point(message_clear_start:pathfinding.Vector)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&y_) -
        reinterpret_cast<char*>(&x_)) + sizeof(y_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Vector::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_x(&has_bits);
          x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_y(&has_bits);
          y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Vector::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pathfinding.Vector)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_x(), target);
  }

  // optional float y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pathfinding.Vector)
  return target;
}

size_t Vector::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pathfinding.Vector)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional float x = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float y = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Vector::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:pathfinding.Vector)
  GOOGLE_DCHECK_NE(&from, this);
  const Vector* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Vector>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:pathfinding.Vector)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:pathfinding.Vector)
    MergeFrom(*source);
  }
}

void Vector::MergeFrom(const Vector& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pathfinding.Vector)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      y_ = from.y_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Vector::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:pathfinding.Vector)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Vector::CopyFrom(const Vector& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pathfinding.Vector)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Vector::IsInitialized() const {
  return true;
}

void Vector::InternalSwap(Vector* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Vector, y_)
      + sizeof(Vector::y_)
      - PROTOBUF_FIELD_OFFSET(Vector, x_)>(
          reinterpret_cast<char*>(&x_),
          reinterpret_cast<char*>(&other->x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Vector::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void CircleObstacle::InitAsDefaultInstance() {
  ::pathfinding::_CircleObstacle_default_instance_._instance.get_mutable()->center_ = const_cast< ::pathfinding::Vector*>(
      ::pathfinding::Vector::internal_default_instance());
}
class CircleObstacle::_Internal {
 public:
  using HasBits = decltype(std::declval<CircleObstacle>()._has_bits_);
  static const ::pathfinding::Vector& center(const CircleObstacle* msg);
  static void set_has_center(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::pathfinding::Vector&
CircleObstacle::_Internal::center(const CircleObstacle* msg) {
  return *msg->center_;
}
CircleObstacle::CircleObstacle(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:pathfinding.CircleObstacle)
}
CircleObstacle::CircleObstacle(const CircleObstacle& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_center()) {
    center_ = new ::pathfinding::Vector(*from.center_);
  } else {
    center_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:pathfinding.CircleObstacle)
}

void CircleObstacle::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_CircleObstacle_pathfinding_2eproto.base);
  center_ = nullptr;
}

CircleObstacle::~CircleObstacle() {
  // @@protoc_insertion_point(destructor:pathfinding.CircleObstacle)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void CircleObstacle::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete center_;
}

void CircleObstacle::ArenaDtor(void* object) {
  CircleObstacle* _this = reinterpret_cast< CircleObstacle* >(object);
  (void)_this;
}
void CircleObstacle::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CircleObstacle::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CircleObstacle& CircleObstacle::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_CircleObstacle_pathfinding_2eproto.base);
  return *internal_default_instance();
}


void CircleObstacle::Clear() {
// @@protoc_insertion_point(message_clear_start:pathfinding.CircleObstacle)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(center_ != nullptr);
    center_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CircleObstacle::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .pathfinding.Vector center = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_center(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CircleObstacle::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pathfinding.CircleObstacle)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .pathfinding.Vector center = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::center(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pathfinding.CircleObstacle)
  return target;
}

size_t CircleObstacle::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pathfinding.CircleObstacle)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .pathfinding.Vector center = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *center_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CircleObstacle::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:pathfinding.CircleObstacle)
  GOOGLE_DCHECK_NE(&from, this);
  const CircleObstacle* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CircleObstacle>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:pathfinding.CircleObstacle)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:pathfinding.CircleObstacle)
    MergeFrom(*source);
  }
}

void CircleObstacle::MergeFrom(const CircleObstacle& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pathfinding.CircleObstacle)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_center()) {
    _internal_mutable_center()->::pathfinding::Vector::MergeFrom(from._internal_center());
  }
}

void CircleObstacle::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:pathfinding.CircleObstacle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CircleObstacle::CopyFrom(const CircleObstacle& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pathfinding.CircleObstacle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CircleObstacle::IsInitialized() const {
  return true;
}

void CircleObstacle::InternalSwap(CircleObstacle* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(center_, other->center_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CircleObstacle::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void RectObstacle::InitAsDefaultInstance() {
  ::pathfinding::_RectObstacle_default_instance_._instance.get_mutable()->bottom_left_ = const_cast< ::pathfinding::Vector*>(
      ::pathfinding::Vector::internal_default_instance());
  ::pathfinding::_RectObstacle_default_instance_._instance.get_mutable()->top_right_ = const_cast< ::pathfinding::Vector*>(
      ::pathfinding::Vector::internal_default_instance());
}
class RectObstacle::_Internal {
 public:
  using HasBits = decltype(std::declval<RectObstacle>()._has_bits_);
  static const ::pathfinding::Vector& bottom_left(const RectObstacle* msg);
  static void set_has_bottom_left(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::pathfinding::Vector& top_right(const RectObstacle* msg);
  static void set_has_top_right(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::pathfinding::Vector&
RectObstacle::_Internal::bottom_left(const RectObstacle* msg) {
  return *msg->bottom_left_;
}
const ::pathfinding::Vector&
RectObstacle::_Internal::top_right(const RectObstacle* msg) {
  return *msg->top_right_;
}
RectObstacle::RectObstacle(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:pathfinding.RectObstacle)
}
RectObstacle::RectObstacle(const RectObstacle& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_bottom_left()) {
    bottom_left_ = new ::pathfinding::Vector(*from.bottom_left_);
  } else {
    bottom_left_ = nullptr;
  }
  if (from._internal_has_top_right()) {
    top_right_ = new ::pathfinding::Vector(*from.top_right_);
  } else {
    top_right_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:pathfinding.RectObstacle)
}

void RectObstacle::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_RectObstacle_pathfinding_2eproto.base);
  ::memset(&bottom_left_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&top_right_) -
      reinterpret_cast<char*>(&bottom_left_)) + sizeof(top_right_));
}

RectObstacle::~RectObstacle() {
  // @@protoc_insertion_point(destructor:pathfinding.RectObstacle)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void RectObstacle::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete bottom_left_;
  if (this != internal_default_instance()) delete top_right_;
}

void RectObstacle::ArenaDtor(void* object) {
  RectObstacle* _this = reinterpret_cast< RectObstacle* >(object);
  (void)_this;
}
void RectObstacle::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void RectObstacle::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const RectObstacle& RectObstacle::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_RectObstacle_pathfinding_2eproto.base);
  return *internal_default_instance();
}


void RectObstacle::Clear() {
// @@protoc_insertion_point(message_clear_start:pathfinding.RectObstacle)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(bottom_left_ != nullptr);
      bottom_left_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(top_right_ != nullptr);
      top_right_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RectObstacle::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .pathfinding.Vector bottom_left = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_bottom_left(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pathfinding.Vector top_right = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_top_right(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* RectObstacle::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pathfinding.RectObstacle)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .pathfinding.Vector bottom_left = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::bottom_left(this), target, stream);
  }

  // optional .pathfinding.Vector top_right = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::top_right(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pathfinding.RectObstacle)
  return target;
}

size_t RectObstacle::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pathfinding.RectObstacle)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .pathfinding.Vector bottom_left = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *bottom_left_);
    }

    // optional .pathfinding.Vector top_right = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *top_right_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RectObstacle::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:pathfinding.RectObstacle)
  GOOGLE_DCHECK_NE(&from, this);
  const RectObstacle* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<RectObstacle>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:pathfinding.RectObstacle)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:pathfinding.RectObstacle)
    MergeFrom(*source);
  }
}

void RectObstacle::MergeFrom(const RectObstacle& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pathfinding.RectObstacle)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_bottom_left()->::pathfinding::Vector::MergeFrom(from._internal_bottom_left());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_top_right()->::pathfinding::Vector::MergeFrom(from._internal_top_right());
    }
  }
}

void RectObstacle::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:pathfinding.RectObstacle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RectObstacle::CopyFrom(const RectObstacle& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pathfinding.RectObstacle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RectObstacle::IsInitialized() const {
  return true;
}

void RectObstacle::InternalSwap(RectObstacle* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RectObstacle, top_right_)
      + sizeof(RectObstacle::top_right_)
      - PROTOBUF_FIELD_OFFSET(RectObstacle, bottom_left_)>(
          reinterpret_cast<char*>(&bottom_left_),
          reinterpret_cast<char*>(&other->bottom_left_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RectObstacle::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TriangleObstacle::InitAsDefaultInstance() {
  ::pathfinding::_TriangleObstacle_default_instance_._instance.get_mutable()->p1_ = const_cast< ::pathfinding::Vector*>(
      ::pathfinding::Vector::internal_default_instance());
  ::pathfinding::_TriangleObstacle_default_instance_._instance.get_mutable()->p2_ = const_cast< ::pathfinding::Vector*>(
      ::pathfinding::Vector::internal_default_instance());
  ::pathfinding::_TriangleObstacle_default_instance_._instance.get_mutable()->p3_ = const_cast< ::pathfinding::Vector*>(
      ::pathfinding::Vector::internal_default_instance());
}
class TriangleObstacle::_Internal {
 public:
  using HasBits = decltype(std::declval<TriangleObstacle>()._has_bits_);
  static const ::pathfinding::Vector& p1(const TriangleObstacle* msg);
  static void set_has_p1(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::pathfinding::Vector& p2(const TriangleObstacle* msg);
  static void set_has_p2(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::pathfinding::Vector& p3(const TriangleObstacle* msg);
  static void set_has_p3(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::pathfinding::Vector&
TriangleObstacle::_Internal::p1(const TriangleObstacle* msg) {
  return *msg->p1_;
}
const ::pathfinding::Vector&
TriangleObstacle::_Internal::p2(const TriangleObstacle* msg) {
  return *msg->p2_;
}
const ::pathfinding::Vector&
TriangleObstacle::_Internal::p3(const TriangleObstacle* msg) {
  return *msg->p3_;
}
TriangleObstacle::TriangleObstacle(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:pathfinding.TriangleObstacle)
}
TriangleObstacle::TriangleObstacle(const TriangleObstacle& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_p1()) {
    p1_ = new ::pathfinding::Vector(*from.p1_);
  } else {
    p1_ = nullptr;
  }
  if (from._internal_has_p2()) {
    p2_ = new ::pathfinding::Vector(*from.p2_);
  } else {
    p2_ = nullptr;
  }
  if (from._internal_has_p3()) {
    p3_ = new ::pathfinding::Vector(*from.p3_);
  } else {
    p3_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:pathfinding.TriangleObstacle)
}

void TriangleObstacle::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TriangleObstacle_pathfinding_2eproto.base);
  ::memset(&p1_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&p3_) -
      reinterpret_cast<char*>(&p1_)) + sizeof(p3_));
}

TriangleObstacle::~TriangleObstacle() {
  // @@protoc_insertion_point(destructor:pathfinding.TriangleObstacle)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TriangleObstacle::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete p1_;
  if (this != internal_default_instance()) delete p2_;
  if (this != internal_default_instance()) delete p3_;
}

void TriangleObstacle::ArenaDtor(void* object) {
  TriangleObstacle* _this = reinterpret_cast< TriangleObstacle* >(object);
  (void)_this;
}
void TriangleObstacle::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TriangleObstacle::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TriangleObstacle& TriangleObstacle::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TriangleObstacle_pathfinding_2eproto.base);
  return *internal_default_instance();
}


void TriangleObstacle::Clear() {
// @@protoc_insertion_point(message_clear_start:pathfinding.TriangleObstacle)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(p1_ != nullptr);
      p1_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(p2_ != nullptr);
      p2_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(p3_ != nullptr);
      p3_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TriangleObstacle::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .pathfinding.Vector p1 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_p1(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pathfinding.Vector p2 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_p2(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pathfinding.Vector p3 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_p3(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TriangleObstacle::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pathfinding.TriangleObstacle)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .pathfinding.Vector p1 = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::p1(this), target, stream);
  }

  // optional .pathfinding.Vector p2 = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::p2(this), target, stream);
  }

  // optional .pathfinding.Vector p3 = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::p3(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pathfinding.TriangleObstacle)
  return target;
}

size_t TriangleObstacle::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pathfinding.TriangleObstacle)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .pathfinding.Vector p1 = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *p1_);
    }

    // optional .pathfinding.Vector p2 = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *p2_);
    }

    // optional .pathfinding.Vector p3 = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *p3_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TriangleObstacle::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:pathfinding.TriangleObstacle)
  GOOGLE_DCHECK_NE(&from, this);
  const TriangleObstacle* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TriangleObstacle>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:pathfinding.TriangleObstacle)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:pathfinding.TriangleObstacle)
    MergeFrom(*source);
  }
}

void TriangleObstacle::MergeFrom(const TriangleObstacle& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pathfinding.TriangleObstacle)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_p1()->::pathfinding::Vector::MergeFrom(from._internal_p1());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_p2()->::pathfinding::Vector::MergeFrom(from._internal_p2());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_p3()->::pathfinding::Vector::MergeFrom(from._internal_p3());
    }
  }
}

void TriangleObstacle::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:pathfinding.TriangleObstacle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TriangleObstacle::CopyFrom(const TriangleObstacle& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pathfinding.TriangleObstacle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TriangleObstacle::IsInitialized() const {
  return true;
}

void TriangleObstacle::InternalSwap(TriangleObstacle* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TriangleObstacle, p3_)
      + sizeof(TriangleObstacle::p3_)
      - PROTOBUF_FIELD_OFFSET(TriangleObstacle, p1_)>(
          reinterpret_cast<char*>(&p1_),
          reinterpret_cast<char*>(&other->p1_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TriangleObstacle::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void LineObstacle::InitAsDefaultInstance() {
  ::pathfinding::_LineObstacle_default_instance_._instance.get_mutable()->start_ = const_cast< ::pathfinding::Vector*>(
      ::pathfinding::Vector::internal_default_instance());
  ::pathfinding::_LineObstacle_default_instance_._instance.get_mutable()->end_ = const_cast< ::pathfinding::Vector*>(
      ::pathfinding::Vector::internal_default_instance());
}
class LineObstacle::_Internal {
 public:
  using HasBits = decltype(std::declval<LineObstacle>()._has_bits_);
  static const ::pathfinding::Vector& start(const LineObstacle* msg);
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::pathfinding::Vector& end(const LineObstacle* msg);
  static void set_has_end(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::pathfinding::Vector&
LineObstacle::_Internal::start(const LineObstacle* msg) {
  return *msg->start_;
}
const ::pathfinding::Vector&
LineObstacle::_Internal::end(const LineObstacle* msg) {
  return *msg->end_;
}
LineObstacle::LineObstacle(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:pathfinding.LineObstacle)
}
LineObstacle::LineObstacle(const LineObstacle& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_start()) {
    start_ = new ::pathfinding::Vector(*from.start_);
  } else {
    start_ = nullptr;
  }
  if (from._internal_has_end()) {
    end_ = new ::pathfinding::Vector(*from.end_);
  } else {
    end_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:pathfinding.LineObstacle)
}

void LineObstacle::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_LineObstacle_pathfinding_2eproto.base);
  ::memset(&start_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&end_) -
      reinterpret_cast<char*>(&start_)) + sizeof(end_));
}

LineObstacle::~LineObstacle() {
  // @@protoc_insertion_point(destructor:pathfinding.LineObstacle)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void LineObstacle::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete start_;
  if (this != internal_default_instance()) delete end_;
}

void LineObstacle::ArenaDtor(void* object) {
  LineObstacle* _this = reinterpret_cast< LineObstacle* >(object);
  (void)_this;
}
void LineObstacle::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LineObstacle::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const LineObstacle& LineObstacle::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_LineObstacle_pathfinding_2eproto.base);
  return *internal_default_instance();
}


void LineObstacle::Clear() {
// @@protoc_insertion_point(message_clear_start:pathfinding.LineObstacle)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(start_ != nullptr);
      start_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(end_ != nullptr);
      end_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LineObstacle::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .pathfinding.Vector start = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_start(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pathfinding.Vector end = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_end(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* LineObstacle::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pathfinding.LineObstacle)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .pathfinding.Vector start = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::start(this), target, stream);
  }

  // optional .pathfinding.Vector end = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::end(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pathfinding.LineObstacle)
  return target;
}

size_t LineObstacle::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pathfinding.LineObstacle)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .pathfinding.Vector start = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *start_);
    }

    // optional .pathfinding.Vector end = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *end_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LineObstacle::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:pathfinding.LineObstacle)
  GOOGLE_DCHECK_NE(&from, this);
  const LineObstacle* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<LineObstacle>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:pathfinding.LineObstacle)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:pathfinding.LineObstacle)
    MergeFrom(*source);
  }
}

void LineObstacle::MergeFrom(const LineObstacle& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pathfinding.LineObstacle)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_start()->::pathfinding::Vector::MergeFrom(from._internal_start());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_end()->::pathfinding::Vector::MergeFrom(from._internal_end());
    }
  }
}

void LineObstacle::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:pathfinding.LineObstacle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LineObstacle::CopyFrom(const LineObstacle& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pathfinding.LineObstacle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LineObstacle::IsInitialized() const {
  return true;
}

void LineObstacle::InternalSwap(LineObstacle* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LineObstacle, end_)
      + sizeof(LineObstacle::end_)
      - PROTOBUF_FIELD_OFFSET(LineObstacle, start_)>(
          reinterpret_cast<char*>(&start_),
          reinterpret_cast<char*>(&other->start_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LineObstacle::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void MovingCircleObstacle::InitAsDefaultInstance() {
  ::pathfinding::_MovingCircleObstacle_default_instance_._instance.get_mutable()->start_pos_ = const_cast< ::pathfinding::Vector*>(
      ::pathfinding::Vector::internal_default_instance());
  ::pathfinding::_MovingCircleObstacle_default_instance_._instance.get_mutable()->speed_ = const_cast< ::pathfinding::Vector*>(
      ::pathfinding::Vector::internal_default_instance());
  ::pathfinding::_MovingCircleObstacle_default_instance_._instance.get_mutable()->acc_ = const_cast< ::pathfinding::Vector*>(
      ::pathfinding::Vector::internal_default_instance());
}
class MovingCircleObstacle::_Internal {
 public:
  using HasBits = decltype(std::declval<MovingCircleObstacle>()._has_bits_);
  static const ::pathfinding::Vector& start_pos(const MovingCircleObstacle* msg);
  static void set_has_start_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::pathfinding::Vector& speed(const MovingCircleObstacle* msg);
  static void set_has_speed(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::pathfinding::Vector& acc(const MovingCircleObstacle* msg);
  static void set_has_acc(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_start_time(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_end_time(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::pathfinding::Vector&
MovingCircleObstacle::_Internal::start_pos(const MovingCircleObstacle* msg) {
  return *msg->start_pos_;
}
const ::pathfinding::Vector&
MovingCircleObstacle::_Internal::speed(const MovingCircleObstacle* msg) {
  return *msg->speed_;
}
const ::pathfinding::Vector&
MovingCircleObstacle::_Internal::acc(const MovingCircleObstacle* msg) {
  return *msg->acc_;
}
MovingCircleObstacle::MovingCircleObstacle(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:pathfinding.MovingCircleObstacle)
}
MovingCircleObstacle::MovingCircleObstacle(const MovingCircleObstacle& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_start_pos()) {
    start_pos_ = new ::pathfinding::Vector(*from.start_pos_);
  } else {
    start_pos_ = nullptr;
  }
  if (from._internal_has_speed()) {
    speed_ = new ::pathfinding::Vector(*from.speed_);
  } else {
    speed_ = nullptr;
  }
  if (from._internal_has_acc()) {
    acc_ = new ::pathfinding::Vector(*from.acc_);
  } else {
    acc_ = nullptr;
  }
  ::memcpy(&start_time_, &from.start_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&end_time_) -
    reinterpret_cast<char*>(&start_time_)) + sizeof(end_time_));
  // @@protoc_insertion_point(copy_constructor:pathfinding.MovingCircleObstacle)
}

void MovingCircleObstacle::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_MovingCircleObstacle_pathfinding_2eproto.base);
  ::memset(&start_pos_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&end_time_) -
      reinterpret_cast<char*>(&start_pos_)) + sizeof(end_time_));
}

MovingCircleObstacle::~MovingCircleObstacle() {
  // @@protoc_insertion_point(destructor:pathfinding.MovingCircleObstacle)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void MovingCircleObstacle::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete start_pos_;
  if (this != internal_default_instance()) delete speed_;
  if (this != internal_default_instance()) delete acc_;
}

void MovingCircleObstacle::ArenaDtor(void* object) {
  MovingCircleObstacle* _this = reinterpret_cast< MovingCircleObstacle* >(object);
  (void)_this;
}
void MovingCircleObstacle::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MovingCircleObstacle::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const MovingCircleObstacle& MovingCircleObstacle::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_MovingCircleObstacle_pathfinding_2eproto.base);
  return *internal_default_instance();
}


void MovingCircleObstacle::Clear() {
// @@protoc_insertion_point(message_clear_start:pathfinding.MovingCircleObstacle)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(start_pos_ != nullptr);
      start_pos_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(speed_ != nullptr);
      speed_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(acc_ != nullptr);
      acc_->Clear();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&start_time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&end_time_) -
        reinterpret_cast<char*>(&start_time_)) + sizeof(end_time_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MovingCircleObstacle::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .pathfinding.Vector start_pos = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_start_pos(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pathfinding.Vector speed = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_speed(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pathfinding.Vector acc = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_acc(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float start_time = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_start_time(&has_bits);
          start_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float end_time = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          _Internal::set_has_end_time(&has_bits);
          end_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* MovingCircleObstacle::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pathfinding.MovingCircleObstacle)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .pathfinding.Vector start_pos = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::start_pos(this), target, stream);
  }

  // optional .pathfinding.Vector speed = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::speed(this), target, stream);
  }

  // optional .pathfinding.Vector acc = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::acc(this), target, stream);
  }

  // optional float start_time = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_start_time(), target);
  }

  // optional float end_time = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_end_time(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pathfinding.MovingCircleObstacle)
  return target;
}

size_t MovingCircleObstacle::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pathfinding.MovingCircleObstacle)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .pathfinding.Vector start_pos = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *start_pos_);
    }

    // optional .pathfinding.Vector speed = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *speed_);
    }

    // optional .pathfinding.Vector acc = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *acc_);
    }

    // optional float start_time = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float end_time = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MovingCircleObstacle::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:pathfinding.MovingCircleObstacle)
  GOOGLE_DCHECK_NE(&from, this);
  const MovingCircleObstacle* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<MovingCircleObstacle>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:pathfinding.MovingCircleObstacle)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:pathfinding.MovingCircleObstacle)
    MergeFrom(*source);
  }
}

void MovingCircleObstacle::MergeFrom(const MovingCircleObstacle& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pathfinding.MovingCircleObstacle)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_start_pos()->::pathfinding::Vector::MergeFrom(from._internal_start_pos());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_speed()->::pathfinding::Vector::MergeFrom(from._internal_speed());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_acc()->::pathfinding::Vector::MergeFrom(from._internal_acc());
    }
    if (cached_has_bits & 0x00000008u) {
      start_time_ = from.start_time_;
    }
    if (cached_has_bits & 0x00000010u) {
      end_time_ = from.end_time_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void MovingCircleObstacle::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:pathfinding.MovingCircleObstacle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MovingCircleObstacle::CopyFrom(const MovingCircleObstacle& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pathfinding.MovingCircleObstacle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MovingCircleObstacle::IsInitialized() const {
  return true;
}

void MovingCircleObstacle::InternalSwap(MovingCircleObstacle* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MovingCircleObstacle, end_time_)
      + sizeof(MovingCircleObstacle::end_time_)
      - PROTOBUF_FIELD_OFFSET(MovingCircleObstacle, start_pos_)>(
          reinterpret_cast<char*>(&start_pos_),
          reinterpret_cast<char*>(&other->start_pos_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MovingCircleObstacle::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void MovingLineObstacle::InitAsDefaultInstance() {
  ::pathfinding::_MovingLineObstacle_default_instance_._instance.get_mutable()->start_pos1_ = const_cast< ::pathfinding::Vector*>(
      ::pathfinding::Vector::internal_default_instance());
  ::pathfinding::_MovingLineObstacle_default_instance_._instance.get_mutable()->speed1_ = const_cast< ::pathfinding::Vector*>(
      ::pathfinding::Vector::internal_default_instance());
  ::pathfinding::_MovingLineObstacle_default_instance_._instance.get_mutable()->acc1_ = const_cast< ::pathfinding::Vector*>(
      ::pathfinding::Vector::internal_default_instance());
  ::pathfinding::_MovingLineObstacle_default_instance_._instance.get_mutable()->start_pos2_ = const_cast< ::pathfinding::Vector*>(
      ::pathfinding::Vector::internal_default_instance());
  ::pathfinding::_MovingLineObstacle_default_instance_._instance.get_mutable()->speed2_ = const_cast< ::pathfinding::Vector*>(
      ::pathfinding::Vector::internal_default_instance());
  ::pathfinding::_MovingLineObstacle_default_instance_._instance.get_mutable()->acc2_ = const_cast< ::pathfinding::Vector*>(
      ::pathfinding::Vector::internal_default_instance());
}
class MovingLineObstacle::_Internal {
 public:
  using HasBits = decltype(std::declval<MovingLineObstacle>()._has_bits_);
  static const ::pathfinding::Vector& start_pos1(const MovingLineObstacle* msg);
  static void set_has_start_pos1(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::pathfinding::Vector& speed1(const MovingLineObstacle* msg);
  static void set_has_speed1(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::pathfinding::Vector& acc1(const MovingLineObstacle* msg);
  static void set_has_acc1(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::pathfinding::Vector& start_pos2(const MovingLineObstacle* msg);
  static void set_has_start_pos2(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::pathfinding::Vector& speed2(const MovingLineObstacle* msg);
  static void set_has_speed2(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::pathfinding::Vector& acc2(const MovingLineObstacle* msg);
  static void set_has_acc2(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_start_time(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_end_time(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

const ::pathfinding::Vector&
MovingLineObstacle::_Internal::start_pos1(const MovingLineObstacle* msg) {
  return *msg->start_pos1_;
}
const ::pathfinding::Vector&
MovingLineObstacle::_Internal::speed1(const MovingLineObstacle* msg) {
  return *msg->speed1_;
}
const ::pathfinding::Vector&
MovingLineObstacle::_Internal::acc1(const MovingLineObstacle* msg) {
  return *msg->acc1_;
}
const ::pathfinding::Vector&
MovingLineObstacle::_Internal::start_pos2(const MovingLineObstacle* msg) {
  return *msg->start_pos2_;
}
const ::pathfinding::Vector&
MovingLineObstacle::_Internal::speed2(const MovingLineObstacle* msg) {
  return *msg->speed2_;
}
const ::pathfinding::Vector&
MovingLineObstacle::_Internal::acc2(const MovingLineObstacle* msg) {
  return *msg->acc2_;
}
MovingLineObstacle::MovingLineObstacle(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:pathfinding.MovingLineObstacle)
}
MovingLineObstacle::MovingLineObstacle(const MovingLineObstacle& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_start_pos1()) {
    start_pos1_ = new ::pathfinding::Vector(*from.start_pos1_);
  } else {
    start_pos1_ = nullptr;
  }
  if (from._internal_has_speed1()) {
    speed1_ = new ::pathfinding::Vector(*from.speed1_);
  } else {
    speed1_ = nullptr;
  }
  if (from._internal_has_acc1()) {
    acc1_ = new ::pathfinding::Vector(*from.acc1_);
  } else {
    acc1_ = nullptr;
  }
  if (from._internal_has_start_pos2()) {
    start_pos2_ = new ::pathfinding::Vector(*from.start_pos2_);
  } else {
    start_pos2_ = nullptr;
  }
  if (from._internal_has_speed2()) {
    speed2_ = new ::pathfinding::Vector(*from.speed2_);
  } else {
    speed2_ = nullptr;
  }
  if (from._internal_has_acc2()) {
    acc2_ = new ::pathfinding::Vector(*from.acc2_);
  } else {
    acc2_ = nullptr;
  }
  ::memcpy(&start_time_, &from.start_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&end_time_) -
    reinterpret_cast<char*>(&start_time_)) + sizeof(end_time_));
  // @@protoc_insertion_point(copy_constructor:pathfinding.MovingLineObstacle)
}

void MovingLineObstacle::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_MovingLineObstacle_pathfinding_2eproto.base);
  ::memset(&start_pos1_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&end_time_) -
      reinterpret_cast<char*>(&start_pos1_)) + sizeof(end_time_));
}

MovingLineObstacle::~MovingLineObstacle() {
  // @@protoc_insertion_point(destructor:pathfinding.MovingLineObstacle)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void MovingLineObstacle::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete start_pos1_;
  if (this != internal_default_instance()) delete speed1_;
  if (this != internal_default_instance()) delete acc1_;
  if (this != internal_default_instance()) delete start_pos2_;
  if (this != internal_default_instance()) delete speed2_;
  if (this != internal_default_instance()) delete acc2_;
}

void MovingLineObstacle::ArenaDtor(void* object) {
  MovingLineObstacle* _this = reinterpret_cast< MovingLineObstacle* >(object);
  (void)_this;
}
void MovingLineObstacle::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void MovingLineObstacle::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const MovingLineObstacle& MovingLineObstacle::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_MovingLineObstacle_pathfinding_2eproto.base);
  return *internal_default_instance();
}


void MovingLineObstacle::Clear() {
// @@protoc_insertion_point(message_clear_start:pathfinding.MovingLineObstacle)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(start_pos1_ != nullptr);
      start_pos1_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(speed1_ != nullptr);
      speed1_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(acc1_ != nullptr);
      acc1_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(start_pos2_ != nullptr);
      start_pos2_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(speed2_ != nullptr);
      speed2_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(acc2_ != nullptr);
      acc2_->Clear();
    }
  }
  if (cached_has_bits & 0x000000c0u) {
    ::memset(&start_time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&end_time_) -
        reinterpret_cast<char*>(&start_time_)) + sizeof(end_time_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* MovingLineObstacle::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .pathfinding.Vector start_pos1 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_start_pos1(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pathfinding.Vector speed1 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_speed1(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pathfinding.Vector acc1 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_acc1(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pathfinding.Vector start_pos2 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_start_pos2(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pathfinding.Vector speed2 = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_speed2(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pathfinding.Vector acc2 = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_acc2(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float start_time = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 61)) {
          _Internal::set_has_start_time(&has_bits);
          start_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float end_time = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 69)) {
          _Internal::set_has_end_time(&has_bits);
          end_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* MovingLineObstacle::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pathfinding.MovingLineObstacle)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .pathfinding.Vector start_pos1 = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::start_pos1(this), target, stream);
  }

  // optional .pathfinding.Vector speed1 = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::speed1(this), target, stream);
  }

  // optional .pathfinding.Vector acc1 = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::acc1(this), target, stream);
  }

  // optional .pathfinding.Vector start_pos2 = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::start_pos2(this), target, stream);
  }

  // optional .pathfinding.Vector speed2 = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::speed2(this), target, stream);
  }

  // optional .pathfinding.Vector acc2 = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::acc2(this), target, stream);
  }

  // optional float start_time = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(7, this->_internal_start_time(), target);
  }

  // optional float end_time = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(8, this->_internal_end_time(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pathfinding.MovingLineObstacle)
  return target;
}

size_t MovingLineObstacle::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pathfinding.MovingLineObstacle)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .pathfinding.Vector start_pos1 = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *start_pos1_);
    }

    // optional .pathfinding.Vector speed1 = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *speed1_);
    }

    // optional .pathfinding.Vector acc1 = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *acc1_);
    }

    // optional .pathfinding.Vector start_pos2 = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *start_pos2_);
    }

    // optional .pathfinding.Vector speed2 = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *speed2_);
    }

    // optional .pathfinding.Vector acc2 = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *acc2_);
    }

    // optional float start_time = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional float end_time = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MovingLineObstacle::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:pathfinding.MovingLineObstacle)
  GOOGLE_DCHECK_NE(&from, this);
  const MovingLineObstacle* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<MovingLineObstacle>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:pathfinding.MovingLineObstacle)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:pathfinding.MovingLineObstacle)
    MergeFrom(*source);
  }
}

void MovingLineObstacle::MergeFrom(const MovingLineObstacle& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pathfinding.MovingLineObstacle)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_start_pos1()->::pathfinding::Vector::MergeFrom(from._internal_start_pos1());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_speed1()->::pathfinding::Vector::MergeFrom(from._internal_speed1());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_acc1()->::pathfinding::Vector::MergeFrom(from._internal_acc1());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_start_pos2()->::pathfinding::Vector::MergeFrom(from._internal_start_pos2());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_speed2()->::pathfinding::Vector::MergeFrom(from._internal_speed2());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_acc2()->::pathfinding::Vector::MergeFrom(from._internal_acc2());
    }
    if (cached_has_bits & 0x00000040u) {
      start_time_ = from.start_time_;
    }
    if (cached_has_bits & 0x00000080u) {
      end_time_ = from.end_time_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void MovingLineObstacle::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:pathfinding.MovingLineObstacle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MovingLineObstacle::CopyFrom(const MovingLineObstacle& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pathfinding.MovingLineObstacle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MovingLineObstacle::IsInitialized() const {
  return true;
}

void MovingLineObstacle::InternalSwap(MovingLineObstacle* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MovingLineObstacle, end_time_)
      + sizeof(MovingLineObstacle::end_time_)
      - PROTOBUF_FIELD_OFFSET(MovingLineObstacle, start_pos1_)>(
          reinterpret_cast<char*>(&start_pos1_),
          reinterpret_cast<char*>(&other->start_pos1_));
}

::PROTOBUF_NAMESPACE_ID::Metadata MovingLineObstacle::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TrajectoryPoint::InitAsDefaultInstance() {
  ::pathfinding::_TrajectoryPoint_default_instance_._instance.get_mutable()->pos_ = const_cast< ::pathfinding::Vector*>(
      ::pathfinding::Vector::internal_default_instance());
  ::pathfinding::_TrajectoryPoint_default_instance_._instance.get_mutable()->speed_ = const_cast< ::pathfinding::Vector*>(
      ::pathfinding::Vector::internal_default_instance());
}
class TrajectoryPoint::_Internal {
 public:
  using HasBits = decltype(std::declval<TrajectoryPoint>()._has_bits_);
  static const ::pathfinding::Vector& pos(const TrajectoryPoint* msg);
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::pathfinding::Vector& speed(const TrajectoryPoint* msg);
  static void set_has_speed(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_time(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::pathfinding::Vector&
TrajectoryPoint::_Internal::pos(const TrajectoryPoint* msg) {
  return *msg->pos_;
}
const ::pathfinding::Vector&
TrajectoryPoint::_Internal::speed(const TrajectoryPoint* msg) {
  return *msg->speed_;
}
TrajectoryPoint::TrajectoryPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:pathfinding.TrajectoryPoint)
}
TrajectoryPoint::TrajectoryPoint(const TrajectoryPoint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_pos()) {
    pos_ = new ::pathfinding::Vector(*from.pos_);
  } else {
    pos_ = nullptr;
  }
  if (from._internal_has_speed()) {
    speed_ = new ::pathfinding::Vector(*from.speed_);
  } else {
    speed_ = nullptr;
  }
  time_ = from.time_;
  // @@protoc_insertion_point(copy_constructor:pathfinding.TrajectoryPoint)
}

void TrajectoryPoint::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TrajectoryPoint_pathfinding_2eproto.base);
  ::memset(&pos_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&time_) -
      reinterpret_cast<char*>(&pos_)) + sizeof(time_));
}

TrajectoryPoint::~TrajectoryPoint() {
  // @@protoc_insertion_point(destructor:pathfinding.TrajectoryPoint)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TrajectoryPoint::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete pos_;
  if (this != internal_default_instance()) delete speed_;
}

void TrajectoryPoint::ArenaDtor(void* object) {
  TrajectoryPoint* _this = reinterpret_cast< TrajectoryPoint* >(object);
  (void)_this;
}
void TrajectoryPoint::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TrajectoryPoint::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TrajectoryPoint& TrajectoryPoint::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TrajectoryPoint_pathfinding_2eproto.base);
  return *internal_default_instance();
}


void TrajectoryPoint::Clear() {
// @@protoc_insertion_point(message_clear_start:pathfinding.TrajectoryPoint)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(pos_ != nullptr);
      pos_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(speed_ != nullptr);
      speed_->Clear();
    }
  }
  time_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TrajectoryPoint::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .pathfinding.Vector pos = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_pos(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pathfinding.Vector speed = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_speed(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float time = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_time(&has_bits);
          time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TrajectoryPoint::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pathfinding.TrajectoryPoint)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .pathfinding.Vector pos = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::pos(this), target, stream);
  }

  // optional .pathfinding.Vector speed = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::speed(this), target, stream);
  }

  // optional float time = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_time(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pathfinding.TrajectoryPoint)
  return target;
}

size_t TrajectoryPoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pathfinding.TrajectoryPoint)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .pathfinding.Vector pos = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *pos_);
    }

    // optional .pathfinding.Vector speed = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *speed_);
    }

    // optional float time = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TrajectoryPoint::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:pathfinding.TrajectoryPoint)
  GOOGLE_DCHECK_NE(&from, this);
  const TrajectoryPoint* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TrajectoryPoint>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:pathfinding.TrajectoryPoint)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:pathfinding.TrajectoryPoint)
    MergeFrom(*source);
  }
}

void TrajectoryPoint::MergeFrom(const TrajectoryPoint& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pathfinding.TrajectoryPoint)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_pos()->::pathfinding::Vector::MergeFrom(from._internal_pos());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_speed()->::pathfinding::Vector::MergeFrom(from._internal_speed());
    }
    if (cached_has_bits & 0x00000004u) {
      time_ = from.time_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TrajectoryPoint::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:pathfinding.TrajectoryPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TrajectoryPoint::CopyFrom(const TrajectoryPoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pathfinding.TrajectoryPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrajectoryPoint::IsInitialized() const {
  return true;
}

void TrajectoryPoint::InternalSwap(TrajectoryPoint* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TrajectoryPoint, time_)
      + sizeof(TrajectoryPoint::time_)
      - PROTOBUF_FIELD_OFFSET(TrajectoryPoint, pos_)>(
          reinterpret_cast<char*>(&pos_),
          reinterpret_cast<char*>(&other->pos_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TrajectoryPoint::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void FriendlyRobotObstacle::InitAsDefaultInstance() {
}
class FriendlyRobotObstacle::_Internal {
 public:
};

FriendlyRobotObstacle::FriendlyRobotObstacle(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  robot_trajectory_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:pathfinding.FriendlyRobotObstacle)
}
FriendlyRobotObstacle::FriendlyRobotObstacle(const FriendlyRobotObstacle& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      robot_trajectory_(from.robot_trajectory_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:pathfinding.FriendlyRobotObstacle)
}

void FriendlyRobotObstacle::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_FriendlyRobotObstacle_pathfinding_2eproto.base);
}

FriendlyRobotObstacle::~FriendlyRobotObstacle() {
  // @@protoc_insertion_point(destructor:pathfinding.FriendlyRobotObstacle)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void FriendlyRobotObstacle::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void FriendlyRobotObstacle::ArenaDtor(void* object) {
  FriendlyRobotObstacle* _this = reinterpret_cast< FriendlyRobotObstacle* >(object);
  (void)_this;
}
void FriendlyRobotObstacle::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void FriendlyRobotObstacle::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const FriendlyRobotObstacle& FriendlyRobotObstacle::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_FriendlyRobotObstacle_pathfinding_2eproto.base);
  return *internal_default_instance();
}


void FriendlyRobotObstacle::Clear() {
// @@protoc_insertion_point(message_clear_start:pathfinding.FriendlyRobotObstacle)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  robot_trajectory_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FriendlyRobotObstacle::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .pathfinding.TrajectoryPoint robot_trajectory = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_robot_trajectory(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* FriendlyRobotObstacle::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pathfinding.FriendlyRobotObstacle)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .pathfinding.TrajectoryPoint robot_trajectory = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_robot_trajectory_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_robot_trajectory(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pathfinding.FriendlyRobotObstacle)
  return target;
}

size_t FriendlyRobotObstacle::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pathfinding.FriendlyRobotObstacle)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pathfinding.TrajectoryPoint robot_trajectory = 1;
  total_size += 1UL * this->_internal_robot_trajectory_size();
  for (const auto& msg : this->robot_trajectory_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FriendlyRobotObstacle::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:pathfinding.FriendlyRobotObstacle)
  GOOGLE_DCHECK_NE(&from, this);
  const FriendlyRobotObstacle* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<FriendlyRobotObstacle>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:pathfinding.FriendlyRobotObstacle)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:pathfinding.FriendlyRobotObstacle)
    MergeFrom(*source);
  }
}

void FriendlyRobotObstacle::MergeFrom(const FriendlyRobotObstacle& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pathfinding.FriendlyRobotObstacle)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  robot_trajectory_.MergeFrom(from.robot_trajectory_);
}

void FriendlyRobotObstacle::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:pathfinding.FriendlyRobotObstacle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FriendlyRobotObstacle::CopyFrom(const FriendlyRobotObstacle& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pathfinding.FriendlyRobotObstacle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FriendlyRobotObstacle::IsInitialized() const {
  return true;
}

void FriendlyRobotObstacle::InternalSwap(FriendlyRobotObstacle* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  robot_trajectory_.InternalSwap(&other->robot_trajectory_);
}

::PROTOBUF_NAMESPACE_ID::Metadata FriendlyRobotObstacle::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void OpponentRobotObstacle::InitAsDefaultInstance() {
  ::pathfinding::_OpponentRobotObstacle_default_instance_._instance.get_mutable()->start_pos_ = const_cast< ::pathfinding::Vector*>(
      ::pathfinding::Vector::internal_default_instance());
  ::pathfinding::_OpponentRobotObstacle_default_instance_._instance.get_mutable()->speed_ = const_cast< ::pathfinding::Vector*>(
      ::pathfinding::Vector::internal_default_instance());
}
class OpponentRobotObstacle::_Internal {
 public:
  using HasBits = decltype(std::declval<OpponentRobotObstacle>()._has_bits_);
  static const ::pathfinding::Vector& start_pos(const OpponentRobotObstacle* msg);
  static void set_has_start_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::pathfinding::Vector& speed(const OpponentRobotObstacle* msg);
  static void set_has_speed(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::pathfinding::Vector&
OpponentRobotObstacle::_Internal::start_pos(const OpponentRobotObstacle* msg) {
  return *msg->start_pos_;
}
const ::pathfinding::Vector&
OpponentRobotObstacle::_Internal::speed(const OpponentRobotObstacle* msg) {
  return *msg->speed_;
}
OpponentRobotObstacle::OpponentRobotObstacle(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:pathfinding.OpponentRobotObstacle)
}
OpponentRobotObstacle::OpponentRobotObstacle(const OpponentRobotObstacle& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_start_pos()) {
    start_pos_ = new ::pathfinding::Vector(*from.start_pos_);
  } else {
    start_pos_ = nullptr;
  }
  if (from._internal_has_speed()) {
    speed_ = new ::pathfinding::Vector(*from.speed_);
  } else {
    speed_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:pathfinding.OpponentRobotObstacle)
}

void OpponentRobotObstacle::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_OpponentRobotObstacle_pathfinding_2eproto.base);
  ::memset(&start_pos_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&speed_) -
      reinterpret_cast<char*>(&start_pos_)) + sizeof(speed_));
}

OpponentRobotObstacle::~OpponentRobotObstacle() {
  // @@protoc_insertion_point(destructor:pathfinding.OpponentRobotObstacle)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void OpponentRobotObstacle::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete start_pos_;
  if (this != internal_default_instance()) delete speed_;
}

void OpponentRobotObstacle::ArenaDtor(void* object) {
  OpponentRobotObstacle* _this = reinterpret_cast< OpponentRobotObstacle* >(object);
  (void)_this;
}
void OpponentRobotObstacle::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void OpponentRobotObstacle::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const OpponentRobotObstacle& OpponentRobotObstacle::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_OpponentRobotObstacle_pathfinding_2eproto.base);
  return *internal_default_instance();
}


void OpponentRobotObstacle::Clear() {
// @@protoc_insertion_point(message_clear_start:pathfinding.OpponentRobotObstacle)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(start_pos_ != nullptr);
      start_pos_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(speed_ != nullptr);
      speed_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* OpponentRobotObstacle::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .pathfinding.Vector start_pos = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_start_pos(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pathfinding.Vector speed = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_speed(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* OpponentRobotObstacle::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pathfinding.OpponentRobotObstacle)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .pathfinding.Vector start_pos = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::start_pos(this), target, stream);
  }

  // optional .pathfinding.Vector speed = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::speed(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pathfinding.OpponentRobotObstacle)
  return target;
}

size_t OpponentRobotObstacle::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pathfinding.OpponentRobotObstacle)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .pathfinding.Vector start_pos = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *start_pos_);
    }

    // optional .pathfinding.Vector speed = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *speed_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OpponentRobotObstacle::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:pathfinding.OpponentRobotObstacle)
  GOOGLE_DCHECK_NE(&from, this);
  const OpponentRobotObstacle* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<OpponentRobotObstacle>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:pathfinding.OpponentRobotObstacle)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:pathfinding.OpponentRobotObstacle)
    MergeFrom(*source);
  }
}

void OpponentRobotObstacle::MergeFrom(const OpponentRobotObstacle& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pathfinding.OpponentRobotObstacle)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_start_pos()->::pathfinding::Vector::MergeFrom(from._internal_start_pos());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_speed()->::pathfinding::Vector::MergeFrom(from._internal_speed());
    }
  }
}

void OpponentRobotObstacle::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:pathfinding.OpponentRobotObstacle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void OpponentRobotObstacle::CopyFrom(const OpponentRobotObstacle& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pathfinding.OpponentRobotObstacle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OpponentRobotObstacle::IsInitialized() const {
  return true;
}

void OpponentRobotObstacle::InternalSwap(OpponentRobotObstacle* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OpponentRobotObstacle, speed_)
      + sizeof(OpponentRobotObstacle::speed_)
      - PROTOBUF_FIELD_OFFSET(OpponentRobotObstacle, start_pos_)>(
          reinterpret_cast<char*>(&start_pos_),
          reinterpret_cast<char*>(&other->start_pos_));
}

::PROTOBUF_NAMESPACE_ID::Metadata OpponentRobotObstacle::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Obstacle::InitAsDefaultInstance() {
  ::pathfinding::_Obstacle_default_instance_.circle_ = const_cast< ::pathfinding::CircleObstacle*>(
      ::pathfinding::CircleObstacle::internal_default_instance());
  ::pathfinding::_Obstacle_default_instance_.rectangle_ = const_cast< ::pathfinding::RectObstacle*>(
      ::pathfinding::RectObstacle::internal_default_instance());
  ::pathfinding::_Obstacle_default_instance_.triangle_ = const_cast< ::pathfinding::TriangleObstacle*>(
      ::pathfinding::TriangleObstacle::internal_default_instance());
  ::pathfinding::_Obstacle_default_instance_.line_ = const_cast< ::pathfinding::LineObstacle*>(
      ::pathfinding::LineObstacle::internal_default_instance());
  ::pathfinding::_Obstacle_default_instance_.moving_circle_ = const_cast< ::pathfinding::MovingCircleObstacle*>(
      ::pathfinding::MovingCircleObstacle::internal_default_instance());
  ::pathfinding::_Obstacle_default_instance_.moving_line_ = const_cast< ::pathfinding::MovingLineObstacle*>(
      ::pathfinding::MovingLineObstacle::internal_default_instance());
  ::pathfinding::_Obstacle_default_instance_.friendly_robot_ = const_cast< ::pathfinding::FriendlyRobotObstacle*>(
      ::pathfinding::FriendlyRobotObstacle::internal_default_instance());
  ::pathfinding::_Obstacle_default_instance_.opponent_robot_ = const_cast< ::pathfinding::OpponentRobotObstacle*>(
      ::pathfinding::OpponentRobotObstacle::internal_default_instance());
}
class Obstacle::_Internal {
 public:
  using HasBits = decltype(std::declval<Obstacle>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_prio(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_radius(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::pathfinding::CircleObstacle& circle(const Obstacle* msg);
  static const ::pathfinding::RectObstacle& rectangle(const Obstacle* msg);
  static const ::pathfinding::TriangleObstacle& triangle(const Obstacle* msg);
  static const ::pathfinding::LineObstacle& line(const Obstacle* msg);
  static const ::pathfinding::MovingCircleObstacle& moving_circle(const Obstacle* msg);
  static const ::pathfinding::MovingLineObstacle& moving_line(const Obstacle* msg);
  static const ::pathfinding::FriendlyRobotObstacle& friendly_robot(const Obstacle* msg);
  static const ::pathfinding::OpponentRobotObstacle& opponent_robot(const Obstacle* msg);
};

const ::pathfinding::CircleObstacle&
Obstacle::_Internal::circle(const Obstacle* msg) {
  return *msg->obstacle_.circle_;
}
const ::pathfinding::RectObstacle&
Obstacle::_Internal::rectangle(const Obstacle* msg) {
  return *msg->obstacle_.rectangle_;
}
const ::pathfinding::TriangleObstacle&
Obstacle::_Internal::triangle(const Obstacle* msg) {
  return *msg->obstacle_.triangle_;
}
const ::pathfinding::LineObstacle&
Obstacle::_Internal::line(const Obstacle* msg) {
  return *msg->obstacle_.line_;
}
const ::pathfinding::MovingCircleObstacle&
Obstacle::_Internal::moving_circle(const Obstacle* msg) {
  return *msg->obstacle_.moving_circle_;
}
const ::pathfinding::MovingLineObstacle&
Obstacle::_Internal::moving_line(const Obstacle* msg) {
  return *msg->obstacle_.moving_line_;
}
const ::pathfinding::FriendlyRobotObstacle&
Obstacle::_Internal::friendly_robot(const Obstacle* msg) {
  return *msg->obstacle_.friendly_robot_;
}
const ::pathfinding::OpponentRobotObstacle&
Obstacle::_Internal::opponent_robot(const Obstacle* msg) {
  return *msg->obstacle_.opponent_robot_;
}
void Obstacle::set_allocated_circle(::pathfinding::CircleObstacle* circle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_obstacle();
  if (circle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(circle);
    if (message_arena != submessage_arena) {
      circle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, circle, submessage_arena);
    }
    set_has_circle();
    obstacle_.circle_ = circle;
  }
  // @@protoc_insertion_point(field_set_allocated:pathfinding.Obstacle.circle)
}
void Obstacle::set_allocated_rectangle(::pathfinding::RectObstacle* rectangle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_obstacle();
  if (rectangle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(rectangle);
    if (message_arena != submessage_arena) {
      rectangle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rectangle, submessage_arena);
    }
    set_has_rectangle();
    obstacle_.rectangle_ = rectangle;
  }
  // @@protoc_insertion_point(field_set_allocated:pathfinding.Obstacle.rectangle)
}
void Obstacle::set_allocated_triangle(::pathfinding::TriangleObstacle* triangle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_obstacle();
  if (triangle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(triangle);
    if (message_arena != submessage_arena) {
      triangle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, triangle, submessage_arena);
    }
    set_has_triangle();
    obstacle_.triangle_ = triangle;
  }
  // @@protoc_insertion_point(field_set_allocated:pathfinding.Obstacle.triangle)
}
void Obstacle::set_allocated_line(::pathfinding::LineObstacle* line) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_obstacle();
  if (line) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(line);
    if (message_arena != submessage_arena) {
      line = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, line, submessage_arena);
    }
    set_has_line();
    obstacle_.line_ = line;
  }
  // @@protoc_insertion_point(field_set_allocated:pathfinding.Obstacle.line)
}
void Obstacle::set_allocated_moving_circle(::pathfinding::MovingCircleObstacle* moving_circle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_obstacle();
  if (moving_circle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(moving_circle);
    if (message_arena != submessage_arena) {
      moving_circle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, moving_circle, submessage_arena);
    }
    set_has_moving_circle();
    obstacle_.moving_circle_ = moving_circle;
  }
  // @@protoc_insertion_point(field_set_allocated:pathfinding.Obstacle.moving_circle)
}
void Obstacle::set_allocated_moving_line(::pathfinding::MovingLineObstacle* moving_line) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_obstacle();
  if (moving_line) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(moving_line);
    if (message_arena != submessage_arena) {
      moving_line = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, moving_line, submessage_arena);
    }
    set_has_moving_line();
    obstacle_.moving_line_ = moving_line;
  }
  // @@protoc_insertion_point(field_set_allocated:pathfinding.Obstacle.moving_line)
}
void Obstacle::set_allocated_friendly_robot(::pathfinding::FriendlyRobotObstacle* friendly_robot) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_obstacle();
  if (friendly_robot) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(friendly_robot);
    if (message_arena != submessage_arena) {
      friendly_robot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, friendly_robot, submessage_arena);
    }
    set_has_friendly_robot();
    obstacle_.friendly_robot_ = friendly_robot;
  }
  // @@protoc_insertion_point(field_set_allocated:pathfinding.Obstacle.friendly_robot)
}
void Obstacle::set_allocated_opponent_robot(::pathfinding::OpponentRobotObstacle* opponent_robot) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  clear_obstacle();
  if (opponent_robot) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(opponent_robot);
    if (message_arena != submessage_arena) {
      opponent_robot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, opponent_robot, submessage_arena);
    }
    set_has_opponent_robot();
    obstacle_.opponent_robot_ = opponent_robot;
  }
  // @@protoc_insertion_point(field_set_allocated:pathfinding.Obstacle.opponent_robot)
}
Obstacle::Obstacle(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:pathfinding.Obstacle)
}
Obstacle::Obstacle(const Obstacle& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_name()) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_name(),
      GetArena());
  }
  ::memcpy(&prio_, &from.prio_,
    static_cast<size_t>(reinterpret_cast<char*>(&radius_) -
    reinterpret_cast<char*>(&prio_)) + sizeof(radius_));
  clear_has_obstacle();
  switch (from.obstacle_case()) {
    case kCircle: {
      _internal_mutable_circle()->::pathfinding::CircleObstacle::MergeFrom(from._internal_circle());
      break;
    }
    case kRectangle: {
      _internal_mutable_rectangle()->::pathfinding::RectObstacle::MergeFrom(from._internal_rectangle());
      break;
    }
    case kTriangle: {
      _internal_mutable_triangle()->::pathfinding::TriangleObstacle::MergeFrom(from._internal_triangle());
      break;
    }
    case kLine: {
      _internal_mutable_line()->::pathfinding::LineObstacle::MergeFrom(from._internal_line());
      break;
    }
    case kMovingCircle: {
      _internal_mutable_moving_circle()->::pathfinding::MovingCircleObstacle::MergeFrom(from._internal_moving_circle());
      break;
    }
    case kMovingLine: {
      _internal_mutable_moving_line()->::pathfinding::MovingLineObstacle::MergeFrom(from._internal_moving_line());
      break;
    }
    case kFriendlyRobot: {
      _internal_mutable_friendly_robot()->::pathfinding::FriendlyRobotObstacle::MergeFrom(from._internal_friendly_robot());
      break;
    }
    case kOpponentRobot: {
      _internal_mutable_opponent_robot()->::pathfinding::OpponentRobotObstacle::MergeFrom(from._internal_opponent_robot());
      break;
    }
    case OBSTACLE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:pathfinding.Obstacle)
}

void Obstacle::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Obstacle_pathfinding_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&prio_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&radius_) -
      reinterpret_cast<char*>(&prio_)) + sizeof(radius_));
  clear_has_obstacle();
}

Obstacle::~Obstacle() {
  // @@protoc_insertion_point(destructor:pathfinding.Obstacle)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Obstacle::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (has_obstacle()) {
    clear_obstacle();
  }
}

void Obstacle::ArenaDtor(void* object) {
  Obstacle* _this = reinterpret_cast< Obstacle* >(object);
  (void)_this;
}
void Obstacle::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Obstacle::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Obstacle& Obstacle::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Obstacle_pathfinding_2eproto.base);
  return *internal_default_instance();
}


void Obstacle::clear_obstacle() {
// @@protoc_insertion_point(one_of_clear_start:pathfinding.Obstacle)
  switch (obstacle_case()) {
    case kCircle: {
      if (GetArena() == nullptr) {
        delete obstacle_.circle_;
      }
      break;
    }
    case kRectangle: {
      if (GetArena() == nullptr) {
        delete obstacle_.rectangle_;
      }
      break;
    }
    case kTriangle: {
      if (GetArena() == nullptr) {
        delete obstacle_.triangle_;
      }
      break;
    }
    case kLine: {
      if (GetArena() == nullptr) {
        delete obstacle_.line_;
      }
      break;
    }
    case kMovingCircle: {
      if (GetArena() == nullptr) {
        delete obstacle_.moving_circle_;
      }
      break;
    }
    case kMovingLine: {
      if (GetArena() == nullptr) {
        delete obstacle_.moving_line_;
      }
      break;
    }
    case kFriendlyRobot: {
      if (GetArena() == nullptr) {
        delete obstacle_.friendly_robot_;
      }
      break;
    }
    case kOpponentRobot: {
      if (GetArena() == nullptr) {
        delete obstacle_.opponent_robot_;
      }
      break;
    }
    case OBSTACLE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = OBSTACLE_NOT_SET;
}


void Obstacle::Clear() {
// @@protoc_insertion_point(message_clear_start:pathfinding.Obstacle)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&prio_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&radius_) -
        reinterpret_cast<char*>(&prio_)) + sizeof(radius_));
  }
  clear_obstacle();
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Obstacle::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "pathfinding.Obstacle.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 prio = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_prio(&has_bits);
          prio_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float radius = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_radius(&has_bits);
          radius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // .pathfinding.CircleObstacle circle = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_circle(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pathfinding.RectObstacle rectangle = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_rectangle(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pathfinding.TriangleObstacle triangle = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_triangle(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pathfinding.LineObstacle line = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_line(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pathfinding.MovingCircleObstacle moving_circle = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_moving_circle(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pathfinding.MovingLineObstacle moving_line = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_moving_line(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pathfinding.FriendlyRobotObstacle friendly_robot = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_friendly_robot(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .pathfinding.OpponentRobotObstacle opponent_robot = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_opponent_robot(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Obstacle::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pathfinding.Obstacle)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "pathfinding.Obstacle.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional int32 prio = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_prio(), target);
  }

  // optional float radius = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_radius(), target);
  }

  switch (obstacle_case()) {
    case kCircle: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          4, _Internal::circle(this), target, stream);
      break;
    }
    case kRectangle: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          5, _Internal::rectangle(this), target, stream);
      break;
    }
    case kTriangle: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          6, _Internal::triangle(this), target, stream);
      break;
    }
    case kLine: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          7, _Internal::line(this), target, stream);
      break;
    }
    case kMovingCircle: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          9, _Internal::moving_circle(this), target, stream);
      break;
    }
    case kMovingLine: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          10, _Internal::moving_line(this), target, stream);
      break;
    }
    case kFriendlyRobot: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          11, _Internal::friendly_robot(this), target, stream);
      break;
    }
    case kOpponentRobot: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          12, _Internal::opponent_robot(this), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pathfinding.Obstacle)
  return target;
}

size_t Obstacle::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pathfinding.Obstacle)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional int32 prio = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_prio());
    }

    // optional float radius = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

  }
  switch (obstacle_case()) {
    // .pathfinding.CircleObstacle circle = 4;
    case kCircle: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *obstacle_.circle_);
      break;
    }
    // .pathfinding.RectObstacle rectangle = 5;
    case kRectangle: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *obstacle_.rectangle_);
      break;
    }
    // .pathfinding.TriangleObstacle triangle = 6;
    case kTriangle: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *obstacle_.triangle_);
      break;
    }
    // .pathfinding.LineObstacle line = 7;
    case kLine: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *obstacle_.line_);
      break;
    }
    // .pathfinding.MovingCircleObstacle moving_circle = 9;
    case kMovingCircle: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *obstacle_.moving_circle_);
      break;
    }
    // .pathfinding.MovingLineObstacle moving_line = 10;
    case kMovingLine: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *obstacle_.moving_line_);
      break;
    }
    // .pathfinding.FriendlyRobotObstacle friendly_robot = 11;
    case kFriendlyRobot: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *obstacle_.friendly_robot_);
      break;
    }
    // .pathfinding.OpponentRobotObstacle opponent_robot = 12;
    case kOpponentRobot: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *obstacle_.opponent_robot_);
      break;
    }
    case OBSTACLE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Obstacle::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:pathfinding.Obstacle)
  GOOGLE_DCHECK_NE(&from, this);
  const Obstacle* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Obstacle>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:pathfinding.Obstacle)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:pathfinding.Obstacle)
    MergeFrom(*source);
  }
}

void Obstacle::MergeFrom(const Obstacle& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pathfinding.Obstacle)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      prio_ = from.prio_;
    }
    if (cached_has_bits & 0x00000004u) {
      radius_ = from.radius_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  switch (from.obstacle_case()) {
    case kCircle: {
      _internal_mutable_circle()->::pathfinding::CircleObstacle::MergeFrom(from._internal_circle());
      break;
    }
    case kRectangle: {
      _internal_mutable_rectangle()->::pathfinding::RectObstacle::MergeFrom(from._internal_rectangle());
      break;
    }
    case kTriangle: {
      _internal_mutable_triangle()->::pathfinding::TriangleObstacle::MergeFrom(from._internal_triangle());
      break;
    }
    case kLine: {
      _internal_mutable_line()->::pathfinding::LineObstacle::MergeFrom(from._internal_line());
      break;
    }
    case kMovingCircle: {
      _internal_mutable_moving_circle()->::pathfinding::MovingCircleObstacle::MergeFrom(from._internal_moving_circle());
      break;
    }
    case kMovingLine: {
      _internal_mutable_moving_line()->::pathfinding::MovingLineObstacle::MergeFrom(from._internal_moving_line());
      break;
    }
    case kFriendlyRobot: {
      _internal_mutable_friendly_robot()->::pathfinding::FriendlyRobotObstacle::MergeFrom(from._internal_friendly_robot());
      break;
    }
    case kOpponentRobot: {
      _internal_mutable_opponent_robot()->::pathfinding::OpponentRobotObstacle::MergeFrom(from._internal_opponent_robot());
      break;
    }
    case OBSTACLE_NOT_SET: {
      break;
    }
  }
}

void Obstacle::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:pathfinding.Obstacle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Obstacle::CopyFrom(const Obstacle& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pathfinding.Obstacle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Obstacle::IsInitialized() const {
  return true;
}

void Obstacle::InternalSwap(Obstacle* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Obstacle, radius_)
      + sizeof(Obstacle::radius_)
      - PROTOBUF_FIELD_OFFSET(Obstacle, prio_)>(
          reinterpret_cast<char*>(&prio_),
          reinterpret_cast<char*>(&other->prio_));
  swap(obstacle_, other->obstacle_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Obstacle::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void WorldState::InitAsDefaultInstance() {
  ::pathfinding::_WorldState_default_instance_._instance.get_mutable()->boundary_ = const_cast< ::pathfinding::RectObstacle*>(
      ::pathfinding::RectObstacle::internal_default_instance());
}
class WorldState::_Internal {
 public:
  using HasBits = decltype(std::declval<WorldState>()._has_bits_);
  static void set_has_out_of_field_priority(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::pathfinding::RectObstacle& boundary(const WorldState* msg);
  static void set_has_boundary(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_radius(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_robot_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::pathfinding::RectObstacle&
WorldState::_Internal::boundary(const WorldState* msg) {
  return *msg->boundary_;
}
WorldState::WorldState(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  obstacles_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:pathfinding.WorldState)
}
WorldState::WorldState(const WorldState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      obstacles_(from.obstacles_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_boundary()) {
    boundary_ = new ::pathfinding::RectObstacle(*from.boundary_);
  } else {
    boundary_ = nullptr;
  }
  ::memcpy(&out_of_field_priority_, &from.out_of_field_priority_,
    static_cast<size_t>(reinterpret_cast<char*>(&robot_id_) -
    reinterpret_cast<char*>(&out_of_field_priority_)) + sizeof(robot_id_));
  // @@protoc_insertion_point(copy_constructor:pathfinding.WorldState)
}

void WorldState::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_WorldState_pathfinding_2eproto.base);
  ::memset(&boundary_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&robot_id_) -
      reinterpret_cast<char*>(&boundary_)) + sizeof(robot_id_));
}

WorldState::~WorldState() {
  // @@protoc_insertion_point(destructor:pathfinding.WorldState)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void WorldState::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete boundary_;
}

void WorldState::ArenaDtor(void* object) {
  WorldState* _this = reinterpret_cast< WorldState* >(object);
  (void)_this;
}
void WorldState::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void WorldState::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const WorldState& WorldState::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_WorldState_pathfinding_2eproto.base);
  return *internal_default_instance();
}


void WorldState::Clear() {
// @@protoc_insertion_point(message_clear_start:pathfinding.WorldState)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  obstacles_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(boundary_ != nullptr);
    boundary_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&out_of_field_priority_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&robot_id_) -
        reinterpret_cast<char*>(&out_of_field_priority_)) + sizeof(robot_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* WorldState::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .pathfinding.Obstacle obstacles = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_obstacles(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      // optional uint32 out_of_field_priority = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_out_of_field_priority(&has_bits);
          out_of_field_priority_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pathfinding.RectObstacle boundary = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_boundary(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float radius = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_radius(&has_bits);
          radius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional uint32 robot_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_robot_id(&has_bits);
          robot_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* WorldState::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pathfinding.WorldState)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .pathfinding.Obstacle obstacles = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_obstacles_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_obstacles(i), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional uint32 out_of_field_priority = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_out_of_field_priority(), target);
  }

  // optional .pathfinding.RectObstacle boundary = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::boundary(this), target, stream);
  }

  // optional float radius = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_radius(), target);
  }

  // optional uint32 robot_id = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_robot_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pathfinding.WorldState)
  return target;
}

size_t WorldState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pathfinding.WorldState)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pathfinding.Obstacle obstacles = 1;
  total_size += 1UL * this->_internal_obstacles_size();
  for (const auto& msg : this->obstacles_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .pathfinding.RectObstacle boundary = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *boundary_);
    }

    // optional uint32 out_of_field_priority = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_out_of_field_priority());
    }

    // optional float radius = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional uint32 robot_id = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_robot_id());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void WorldState::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:pathfinding.WorldState)
  GOOGLE_DCHECK_NE(&from, this);
  const WorldState* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<WorldState>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:pathfinding.WorldState)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:pathfinding.WorldState)
    MergeFrom(*source);
  }
}

void WorldState::MergeFrom(const WorldState& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pathfinding.WorldState)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  obstacles_.MergeFrom(from.obstacles_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_boundary()->::pathfinding::RectObstacle::MergeFrom(from._internal_boundary());
    }
    if (cached_has_bits & 0x00000002u) {
      out_of_field_priority_ = from.out_of_field_priority_;
    }
    if (cached_has_bits & 0x00000004u) {
      radius_ = from.radius_;
    }
    if (cached_has_bits & 0x00000008u) {
      robot_id_ = from.robot_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void WorldState::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:pathfinding.WorldState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WorldState::CopyFrom(const WorldState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pathfinding.WorldState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WorldState::IsInitialized() const {
  return true;
}

void WorldState::InternalSwap(WorldState* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  obstacles_.InternalSwap(&other->obstacles_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(WorldState, robot_id_)
      + sizeof(WorldState::robot_id_)
      - PROTOBUF_FIELD_OFFSET(WorldState, boundary_)>(
          reinterpret_cast<char*>(&boundary_),
          reinterpret_cast<char*>(&other->boundary_));
}

::PROTOBUF_NAMESPACE_ID::Metadata WorldState::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TrajectoryInput::InitAsDefaultInstance() {
  ::pathfinding::_TrajectoryInput_default_instance_._instance.get_mutable()->v0_ = const_cast< ::pathfinding::Vector*>(
      ::pathfinding::Vector::internal_default_instance());
  ::pathfinding::_TrajectoryInput_default_instance_._instance.get_mutable()->v1_ = const_cast< ::pathfinding::Vector*>(
      ::pathfinding::Vector::internal_default_instance());
  ::pathfinding::_TrajectoryInput_default_instance_._instance.get_mutable()->s0_ = const_cast< ::pathfinding::Vector*>(
      ::pathfinding::Vector::internal_default_instance());
  ::pathfinding::_TrajectoryInput_default_instance_._instance.get_mutable()->s1_ = const_cast< ::pathfinding::Vector*>(
      ::pathfinding::Vector::internal_default_instance());
}
class TrajectoryInput::_Internal {
 public:
  using HasBits = decltype(std::declval<TrajectoryInput>()._has_bits_);
  static const ::pathfinding::Vector& v0(const TrajectoryInput* msg);
  static void set_has_v0(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::pathfinding::Vector& v1(const TrajectoryInput* msg);
  static void set_has_v1(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::pathfinding::Vector& s0(const TrajectoryInput* msg);
  static void set_has_s0(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::pathfinding::Vector& s1(const TrajectoryInput* msg);
  static void set_has_s1(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_max_speed(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_acceleration(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::pathfinding::Vector&
TrajectoryInput::_Internal::v0(const TrajectoryInput* msg) {
  return *msg->v0_;
}
const ::pathfinding::Vector&
TrajectoryInput::_Internal::v1(const TrajectoryInput* msg) {
  return *msg->v1_;
}
const ::pathfinding::Vector&
TrajectoryInput::_Internal::s0(const TrajectoryInput* msg) {
  return *msg->s0_;
}
const ::pathfinding::Vector&
TrajectoryInput::_Internal::s1(const TrajectoryInput* msg) {
  return *msg->s1_;
}
TrajectoryInput::TrajectoryInput(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:pathfinding.TrajectoryInput)
}
TrajectoryInput::TrajectoryInput(const TrajectoryInput& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_v0()) {
    v0_ = new ::pathfinding::Vector(*from.v0_);
  } else {
    v0_ = nullptr;
  }
  if (from._internal_has_v1()) {
    v1_ = new ::pathfinding::Vector(*from.v1_);
  } else {
    v1_ = nullptr;
  }
  if (from._internal_has_s0()) {
    s0_ = new ::pathfinding::Vector(*from.s0_);
  } else {
    s0_ = nullptr;
  }
  if (from._internal_has_s1()) {
    s1_ = new ::pathfinding::Vector(*from.s1_);
  } else {
    s1_ = nullptr;
  }
  ::memcpy(&max_speed_, &from.max_speed_,
    static_cast<size_t>(reinterpret_cast<char*>(&acceleration_) -
    reinterpret_cast<char*>(&max_speed_)) + sizeof(acceleration_));
  // @@protoc_insertion_point(copy_constructor:pathfinding.TrajectoryInput)
}

void TrajectoryInput::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TrajectoryInput_pathfinding_2eproto.base);
  ::memset(&v0_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&acceleration_) -
      reinterpret_cast<char*>(&v0_)) + sizeof(acceleration_));
}

TrajectoryInput::~TrajectoryInput() {
  // @@protoc_insertion_point(destructor:pathfinding.TrajectoryInput)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TrajectoryInput::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete v0_;
  if (this != internal_default_instance()) delete v1_;
  if (this != internal_default_instance()) delete s0_;
  if (this != internal_default_instance()) delete s1_;
}

void TrajectoryInput::ArenaDtor(void* object) {
  TrajectoryInput* _this = reinterpret_cast< TrajectoryInput* >(object);
  (void)_this;
}
void TrajectoryInput::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TrajectoryInput::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TrajectoryInput& TrajectoryInput::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TrajectoryInput_pathfinding_2eproto.base);
  return *internal_default_instance();
}


void TrajectoryInput::Clear() {
// @@protoc_insertion_point(message_clear_start:pathfinding.TrajectoryInput)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(v0_ != nullptr);
      v0_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(v1_ != nullptr);
      v1_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(s0_ != nullptr);
      s0_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(s1_ != nullptr);
      s1_->Clear();
    }
  }
  if (cached_has_bits & 0x00000030u) {
    ::memset(&max_speed_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&acceleration_) -
        reinterpret_cast<char*>(&max_speed_)) + sizeof(acceleration_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TrajectoryInput::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .pathfinding.Vector v0 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_v0(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pathfinding.Vector v1 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_v1(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pathfinding.Vector s0 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_s0(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pathfinding.Vector s1 = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_s1(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float max_speed = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 53)) {
          _Internal::set_has_max_speed(&has_bits);
          max_speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float acceleration = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 61)) {
          _Internal::set_has_acceleration(&has_bits);
          acceleration_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TrajectoryInput::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pathfinding.TrajectoryInput)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .pathfinding.Vector v0 = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::v0(this), target, stream);
  }

  // optional .pathfinding.Vector v1 = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::v1(this), target, stream);
  }

  // optional .pathfinding.Vector s0 = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::s0(this), target, stream);
  }

  // optional .pathfinding.Vector s1 = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::s1(this), target, stream);
  }

  // optional float max_speed = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(6, this->_internal_max_speed(), target);
  }

  // optional float acceleration = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(7, this->_internal_acceleration(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pathfinding.TrajectoryInput)
  return target;
}

size_t TrajectoryInput::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pathfinding.TrajectoryInput)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .pathfinding.Vector v0 = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *v0_);
    }

    // optional .pathfinding.Vector v1 = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *v1_);
    }

    // optional .pathfinding.Vector s0 = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *s0_);
    }

    // optional .pathfinding.Vector s1 = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *s1_);
    }

    // optional float max_speed = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float acceleration = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TrajectoryInput::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:pathfinding.TrajectoryInput)
  GOOGLE_DCHECK_NE(&from, this);
  const TrajectoryInput* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TrajectoryInput>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:pathfinding.TrajectoryInput)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:pathfinding.TrajectoryInput)
    MergeFrom(*source);
  }
}

void TrajectoryInput::MergeFrom(const TrajectoryInput& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pathfinding.TrajectoryInput)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_v0()->::pathfinding::Vector::MergeFrom(from._internal_v0());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_v1()->::pathfinding::Vector::MergeFrom(from._internal_v1());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_s0()->::pathfinding::Vector::MergeFrom(from._internal_s0());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_s1()->::pathfinding::Vector::MergeFrom(from._internal_s1());
    }
    if (cached_has_bits & 0x00000010u) {
      max_speed_ = from.max_speed_;
    }
    if (cached_has_bits & 0x00000020u) {
      acceleration_ = from.acceleration_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TrajectoryInput::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:pathfinding.TrajectoryInput)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TrajectoryInput::CopyFrom(const TrajectoryInput& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pathfinding.TrajectoryInput)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrajectoryInput::IsInitialized() const {
  return true;
}

void TrajectoryInput::InternalSwap(TrajectoryInput* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TrajectoryInput, acceleration_)
      + sizeof(TrajectoryInput::acceleration_)
      - PROTOBUF_FIELD_OFFSET(TrajectoryInput, v0_)>(
          reinterpret_cast<char*>(&v0_),
          reinterpret_cast<char*>(&other->v0_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TrajectoryInput::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void PathFindingTask::InitAsDefaultInstance() {
  ::pathfinding::_PathFindingTask_default_instance_._instance.get_mutable()->state_ = const_cast< ::pathfinding::WorldState*>(
      ::pathfinding::WorldState::internal_default_instance());
  ::pathfinding::_PathFindingTask_default_instance_._instance.get_mutable()->input_ = const_cast< ::pathfinding::TrajectoryInput*>(
      ::pathfinding::TrajectoryInput::internal_default_instance());
}
class PathFindingTask::_Internal {
 public:
  using HasBits = decltype(std::declval<PathFindingTask>()._has_bits_);
  static const ::pathfinding::WorldState& state(const PathFindingTask* msg);
  static void set_has_state(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::pathfinding::TrajectoryInput& input(const PathFindingTask* msg);
  static void set_has_input(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::pathfinding::WorldState&
PathFindingTask::_Internal::state(const PathFindingTask* msg) {
  return *msg->state_;
}
const ::pathfinding::TrajectoryInput&
PathFindingTask::_Internal::input(const PathFindingTask* msg) {
  return *msg->input_;
}
PathFindingTask::PathFindingTask(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:pathfinding.PathFindingTask)
}
PathFindingTask::PathFindingTask(const PathFindingTask& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_state()) {
    state_ = new ::pathfinding::WorldState(*from.state_);
  } else {
    state_ = nullptr;
  }
  if (from._internal_has_input()) {
    input_ = new ::pathfinding::TrajectoryInput(*from.input_);
  } else {
    input_ = nullptr;
  }
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:pathfinding.PathFindingTask)
}

void PathFindingTask::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_PathFindingTask_pathfinding_2eproto.base);
  ::memset(&state_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&type_) -
      reinterpret_cast<char*>(&state_)) + sizeof(type_));
}

PathFindingTask::~PathFindingTask() {
  // @@protoc_insertion_point(destructor:pathfinding.PathFindingTask)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void PathFindingTask::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete state_;
  if (this != internal_default_instance()) delete input_;
}

void PathFindingTask::ArenaDtor(void* object) {
  PathFindingTask* _this = reinterpret_cast< PathFindingTask* >(object);
  (void)_this;
}
void PathFindingTask::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PathFindingTask::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const PathFindingTask& PathFindingTask::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_PathFindingTask_pathfinding_2eproto.base);
  return *internal_default_instance();
}


void PathFindingTask::Clear() {
// @@protoc_insertion_point(message_clear_start:pathfinding.PathFindingTask)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(state_ != nullptr);
      state_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(input_ != nullptr);
      input_->Clear();
    }
  }
  type_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PathFindingTask::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .pathfinding.WorldState state = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_state(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pathfinding.TrajectoryInput input = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_input(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .pathfinding.InputSourceType type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::pathfinding::InputSourceType_IsValid(val))) {
            _internal_set_type(static_cast<::pathfinding::InputSourceType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* PathFindingTask::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pathfinding.PathFindingTask)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .pathfinding.WorldState state = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::state(this), target, stream);
  }

  // optional .pathfinding.TrajectoryInput input = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::input(this), target, stream);
  }

  // optional .pathfinding.InputSourceType type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pathfinding.PathFindingTask)
  return target;
}

size_t PathFindingTask::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pathfinding.PathFindingTask)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .pathfinding.WorldState state = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *state_);
    }

    // optional .pathfinding.TrajectoryInput input = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *input_);
    }

    // optional .pathfinding.InputSourceType type = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PathFindingTask::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:pathfinding.PathFindingTask)
  GOOGLE_DCHECK_NE(&from, this);
  const PathFindingTask* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<PathFindingTask>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:pathfinding.PathFindingTask)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:pathfinding.PathFindingTask)
    MergeFrom(*source);
  }
}

void PathFindingTask::MergeFrom(const PathFindingTask& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pathfinding.PathFindingTask)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_state()->::pathfinding::WorldState::MergeFrom(from._internal_state());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_input()->::pathfinding::TrajectoryInput::MergeFrom(from._internal_input());
    }
    if (cached_has_bits & 0x00000004u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void PathFindingTask::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:pathfinding.PathFindingTask)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PathFindingTask::CopyFrom(const PathFindingTask& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pathfinding.PathFindingTask)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PathFindingTask::IsInitialized() const {
  return true;
}

void PathFindingTask::InternalSwap(PathFindingTask* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PathFindingTask, type_)
      + sizeof(PathFindingTask::type_)
      - PROTOBUF_FIELD_OFFSET(PathFindingTask, state_)>(
          reinterpret_cast<char*>(&state_),
          reinterpret_cast<char*>(&other->state_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PathFindingTask::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void StandardSamplerPoint::InitAsDefaultInstance() {
}
class StandardSamplerPoint::_Internal {
 public:
  using HasBits = decltype(std::declval<StandardSamplerPoint>()._has_bits_);
  static void set_has_time(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_angle(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_mid_speed_x(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_mid_speed_y(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

StandardSamplerPoint::StandardSamplerPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:pathfinding.StandardSamplerPoint)
}
StandardSamplerPoint::StandardSamplerPoint(const StandardSamplerPoint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&time_, &from.time_,
    static_cast<size_t>(reinterpret_cast<char*>(&mid_speed_y_) -
    reinterpret_cast<char*>(&time_)) + sizeof(mid_speed_y_));
  // @@protoc_insertion_point(copy_constructor:pathfinding.StandardSamplerPoint)
}

void StandardSamplerPoint::SharedCtor() {
  ::memset(&time_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&mid_speed_y_) -
      reinterpret_cast<char*>(&time_)) + sizeof(mid_speed_y_));
}

StandardSamplerPoint::~StandardSamplerPoint() {
  // @@protoc_insertion_point(destructor:pathfinding.StandardSamplerPoint)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void StandardSamplerPoint::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void StandardSamplerPoint::ArenaDtor(void* object) {
  StandardSamplerPoint* _this = reinterpret_cast< StandardSamplerPoint* >(object);
  (void)_this;
}
void StandardSamplerPoint::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StandardSamplerPoint::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const StandardSamplerPoint& StandardSamplerPoint::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_StandardSamplerPoint_pathfinding_2eproto.base);
  return *internal_default_instance();
}


void StandardSamplerPoint::Clear() {
// @@protoc_insertion_point(message_clear_start:pathfinding.StandardSamplerPoint)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&mid_speed_y_) -
        reinterpret_cast<char*>(&time_)) + sizeof(mid_speed_y_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StandardSamplerPoint::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional float time = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_time(&has_bits);
          time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float angle = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_angle(&has_bits);
          angle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float mid_speed_x = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_mid_speed_x(&has_bits);
          mid_speed_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float mid_speed_y = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_mid_speed_y(&has_bits);
          mid_speed_y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* StandardSamplerPoint::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pathfinding.StandardSamplerPoint)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float time = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_time(), target);
  }

  // optional float angle = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_angle(), target);
  }

  // optional float mid_speed_x = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_mid_speed_x(), target);
  }

  // optional float mid_speed_y = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_mid_speed_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pathfinding.StandardSamplerPoint)
  return target;
}

size_t StandardSamplerPoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pathfinding.StandardSamplerPoint)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional float time = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float angle = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float mid_speed_x = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float mid_speed_y = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StandardSamplerPoint::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:pathfinding.StandardSamplerPoint)
  GOOGLE_DCHECK_NE(&from, this);
  const StandardSamplerPoint* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<StandardSamplerPoint>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:pathfinding.StandardSamplerPoint)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:pathfinding.StandardSamplerPoint)
    MergeFrom(*source);
  }
}

void StandardSamplerPoint::MergeFrom(const StandardSamplerPoint& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pathfinding.StandardSamplerPoint)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      time_ = from.time_;
    }
    if (cached_has_bits & 0x00000002u) {
      angle_ = from.angle_;
    }
    if (cached_has_bits & 0x00000004u) {
      mid_speed_x_ = from.mid_speed_x_;
    }
    if (cached_has_bits & 0x00000008u) {
      mid_speed_y_ = from.mid_speed_y_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void StandardSamplerPoint::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:pathfinding.StandardSamplerPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StandardSamplerPoint::CopyFrom(const StandardSamplerPoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pathfinding.StandardSamplerPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StandardSamplerPoint::IsInitialized() const {
  return true;
}

void StandardSamplerPoint::InternalSwap(StandardSamplerPoint* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StandardSamplerPoint, mid_speed_y_)
      + sizeof(StandardSamplerPoint::mid_speed_y_)
      - PROTOBUF_FIELD_OFFSET(StandardSamplerPoint, time_)>(
          reinterpret_cast<char*>(&time_),
          reinterpret_cast<char*>(&other->time_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StandardSamplerPoint::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void StandardSamplerPrecomputationSegment::InitAsDefaultInstance() {
}
class StandardSamplerPrecomputationSegment::_Internal {
 public:
  using HasBits = decltype(std::declval<StandardSamplerPrecomputationSegment>()._has_bits_);
  static void set_has_min_distance(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_max_distance(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

StandardSamplerPrecomputationSegment::StandardSamplerPrecomputationSegment(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  precomputed_points_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:pathfinding.StandardSamplerPrecomputationSegment)
}
StandardSamplerPrecomputationSegment::StandardSamplerPrecomputationSegment(const StandardSamplerPrecomputationSegment& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      precomputed_points_(from.precomputed_points_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&min_distance_, &from.min_distance_,
    static_cast<size_t>(reinterpret_cast<char*>(&max_distance_) -
    reinterpret_cast<char*>(&min_distance_)) + sizeof(max_distance_));
  // @@protoc_insertion_point(copy_constructor:pathfinding.StandardSamplerPrecomputationSegment)
}

void StandardSamplerPrecomputationSegment::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_StandardSamplerPrecomputationSegment_pathfinding_2eproto.base);
  ::memset(&min_distance_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&max_distance_) -
      reinterpret_cast<char*>(&min_distance_)) + sizeof(max_distance_));
}

StandardSamplerPrecomputationSegment::~StandardSamplerPrecomputationSegment() {
  // @@protoc_insertion_point(destructor:pathfinding.StandardSamplerPrecomputationSegment)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void StandardSamplerPrecomputationSegment::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void StandardSamplerPrecomputationSegment::ArenaDtor(void* object) {
  StandardSamplerPrecomputationSegment* _this = reinterpret_cast< StandardSamplerPrecomputationSegment* >(object);
  (void)_this;
}
void StandardSamplerPrecomputationSegment::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StandardSamplerPrecomputationSegment::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const StandardSamplerPrecomputationSegment& StandardSamplerPrecomputationSegment::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_StandardSamplerPrecomputationSegment_pathfinding_2eproto.base);
  return *internal_default_instance();
}


void StandardSamplerPrecomputationSegment::Clear() {
// @@protoc_insertion_point(message_clear_start:pathfinding.StandardSamplerPrecomputationSegment)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  precomputed_points_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&min_distance_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&max_distance_) -
        reinterpret_cast<char*>(&min_distance_)) + sizeof(max_distance_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StandardSamplerPrecomputationSegment::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .pathfinding.StandardSamplerPoint precomputed_points = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_precomputed_points(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      // optional float min_distance = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_min_distance(&has_bits);
          min_distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float max_distance = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_max_distance(&has_bits);
          max_distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* StandardSamplerPrecomputationSegment::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pathfinding.StandardSamplerPrecomputationSegment)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .pathfinding.StandardSamplerPoint precomputed_points = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_precomputed_points_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_precomputed_points(i), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional float min_distance = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_min_distance(), target);
  }

  // optional float max_distance = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_max_distance(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pathfinding.StandardSamplerPrecomputationSegment)
  return target;
}

size_t StandardSamplerPrecomputationSegment::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pathfinding.StandardSamplerPrecomputationSegment)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pathfinding.StandardSamplerPoint precomputed_points = 1;
  total_size += 1UL * this->_internal_precomputed_points_size();
  for (const auto& msg : this->precomputed_points_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional float min_distance = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float max_distance = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StandardSamplerPrecomputationSegment::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:pathfinding.StandardSamplerPrecomputationSegment)
  GOOGLE_DCHECK_NE(&from, this);
  const StandardSamplerPrecomputationSegment* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<StandardSamplerPrecomputationSegment>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:pathfinding.StandardSamplerPrecomputationSegment)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:pathfinding.StandardSamplerPrecomputationSegment)
    MergeFrom(*source);
  }
}

void StandardSamplerPrecomputationSegment::MergeFrom(const StandardSamplerPrecomputationSegment& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pathfinding.StandardSamplerPrecomputationSegment)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  precomputed_points_.MergeFrom(from.precomputed_points_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      min_distance_ = from.min_distance_;
    }
    if (cached_has_bits & 0x00000002u) {
      max_distance_ = from.max_distance_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void StandardSamplerPrecomputationSegment::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:pathfinding.StandardSamplerPrecomputationSegment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StandardSamplerPrecomputationSegment::CopyFrom(const StandardSamplerPrecomputationSegment& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pathfinding.StandardSamplerPrecomputationSegment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StandardSamplerPrecomputationSegment::IsInitialized() const {
  return true;
}

void StandardSamplerPrecomputationSegment::InternalSwap(StandardSamplerPrecomputationSegment* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  precomputed_points_.InternalSwap(&other->precomputed_points_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StandardSamplerPrecomputationSegment, max_distance_)
      + sizeof(StandardSamplerPrecomputationSegment::max_distance_)
      - PROTOBUF_FIELD_OFFSET(StandardSamplerPrecomputationSegment, min_distance_)>(
          reinterpret_cast<char*>(&min_distance_),
          reinterpret_cast<char*>(&other->min_distance_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StandardSamplerPrecomputationSegment::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void StandardSamplerPrecomputation::InitAsDefaultInstance() {
}
class StandardSamplerPrecomputation::_Internal {
 public:
};

StandardSamplerPrecomputation::StandardSamplerPrecomputation(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  segments_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:pathfinding.StandardSamplerPrecomputation)
}
StandardSamplerPrecomputation::StandardSamplerPrecomputation(const StandardSamplerPrecomputation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      segments_(from.segments_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:pathfinding.StandardSamplerPrecomputation)
}

void StandardSamplerPrecomputation::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_StandardSamplerPrecomputation_pathfinding_2eproto.base);
}

StandardSamplerPrecomputation::~StandardSamplerPrecomputation() {
  // @@protoc_insertion_point(destructor:pathfinding.StandardSamplerPrecomputation)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void StandardSamplerPrecomputation::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void StandardSamplerPrecomputation::ArenaDtor(void* object) {
  StandardSamplerPrecomputation* _this = reinterpret_cast< StandardSamplerPrecomputation* >(object);
  (void)_this;
}
void StandardSamplerPrecomputation::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StandardSamplerPrecomputation::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const StandardSamplerPrecomputation& StandardSamplerPrecomputation::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_StandardSamplerPrecomputation_pathfinding_2eproto.base);
  return *internal_default_instance();
}


void StandardSamplerPrecomputation::Clear() {
// @@protoc_insertion_point(message_clear_start:pathfinding.StandardSamplerPrecomputation)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  segments_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StandardSamplerPrecomputation::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .pathfinding.StandardSamplerPrecomputationSegment segments = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_segments(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* StandardSamplerPrecomputation::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pathfinding.StandardSamplerPrecomputation)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .pathfinding.StandardSamplerPrecomputationSegment segments = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_segments_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_segments(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pathfinding.StandardSamplerPrecomputation)
  return target;
}

size_t StandardSamplerPrecomputation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pathfinding.StandardSamplerPrecomputation)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pathfinding.StandardSamplerPrecomputationSegment segments = 1;
  total_size += 1UL * this->_internal_segments_size();
  for (const auto& msg : this->segments_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StandardSamplerPrecomputation::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:pathfinding.StandardSamplerPrecomputation)
  GOOGLE_DCHECK_NE(&from, this);
  const StandardSamplerPrecomputation* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<StandardSamplerPrecomputation>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:pathfinding.StandardSamplerPrecomputation)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:pathfinding.StandardSamplerPrecomputation)
    MergeFrom(*source);
  }
}

void StandardSamplerPrecomputation::MergeFrom(const StandardSamplerPrecomputation& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:pathfinding.StandardSamplerPrecomputation)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  segments_.MergeFrom(from.segments_);
}

void StandardSamplerPrecomputation::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:pathfinding.StandardSamplerPrecomputation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StandardSamplerPrecomputation::CopyFrom(const StandardSamplerPrecomputation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pathfinding.StandardSamplerPrecomputation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StandardSamplerPrecomputation::IsInitialized() const {
  return true;
}

void StandardSamplerPrecomputation::InternalSwap(StandardSamplerPrecomputation* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  segments_.InternalSwap(&other->segments_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StandardSamplerPrecomputation::GetMetadata() const {
  return GetMetadataStatic();
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace pathfinding
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::pathfinding::Vector* Arena::CreateMaybeMessage< ::pathfinding::Vector >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pathfinding::Vector >(arena);
}
template<> PROTOBUF_NOINLINE ::pathfinding::CircleObstacle* Arena::CreateMaybeMessage< ::pathfinding::CircleObstacle >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pathfinding::CircleObstacle >(arena);
}
template<> PROTOBUF_NOINLINE ::pathfinding::RectObstacle* Arena::CreateMaybeMessage< ::pathfinding::RectObstacle >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pathfinding::RectObstacle >(arena);
}
template<> PROTOBUF_NOINLINE ::pathfinding::TriangleObstacle* Arena::CreateMaybeMessage< ::pathfinding::TriangleObstacle >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pathfinding::TriangleObstacle >(arena);
}
template<> PROTOBUF_NOINLINE ::pathfinding::LineObstacle* Arena::CreateMaybeMessage< ::pathfinding::LineObstacle >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pathfinding::LineObstacle >(arena);
}
template<> PROTOBUF_NOINLINE ::pathfinding::MovingCircleObstacle* Arena::CreateMaybeMessage< ::pathfinding::MovingCircleObstacle >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pathfinding::MovingCircleObstacle >(arena);
}
template<> PROTOBUF_NOINLINE ::pathfinding::MovingLineObstacle* Arena::CreateMaybeMessage< ::pathfinding::MovingLineObstacle >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pathfinding::MovingLineObstacle >(arena);
}
template<> PROTOBUF_NOINLINE ::pathfinding::TrajectoryPoint* Arena::CreateMaybeMessage< ::pathfinding::TrajectoryPoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pathfinding::TrajectoryPoint >(arena);
}
template<> PROTOBUF_NOINLINE ::pathfinding::FriendlyRobotObstacle* Arena::CreateMaybeMessage< ::pathfinding::FriendlyRobotObstacle >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pathfinding::FriendlyRobotObstacle >(arena);
}
template<> PROTOBUF_NOINLINE ::pathfinding::OpponentRobotObstacle* Arena::CreateMaybeMessage< ::pathfinding::OpponentRobotObstacle >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pathfinding::OpponentRobotObstacle >(arena);
}
template<> PROTOBUF_NOINLINE ::pathfinding::Obstacle* Arena::CreateMaybeMessage< ::pathfinding::Obstacle >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pathfinding::Obstacle >(arena);
}
template<> PROTOBUF_NOINLINE ::pathfinding::WorldState* Arena::CreateMaybeMessage< ::pathfinding::WorldState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pathfinding::WorldState >(arena);
}
template<> PROTOBUF_NOINLINE ::pathfinding::TrajectoryInput* Arena::CreateMaybeMessage< ::pathfinding::TrajectoryInput >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pathfinding::TrajectoryInput >(arena);
}
template<> PROTOBUF_NOINLINE ::pathfinding::PathFindingTask* Arena::CreateMaybeMessage< ::pathfinding::PathFindingTask >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pathfinding::PathFindingTask >(arena);
}
template<> PROTOBUF_NOINLINE ::pathfinding::StandardSamplerPoint* Arena::CreateMaybeMessage< ::pathfinding::StandardSamplerPoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pathfinding::StandardSamplerPoint >(arena);
}
template<> PROTOBUF_NOINLINE ::pathfinding::StandardSamplerPrecomputationSegment* Arena::CreateMaybeMessage< ::pathfinding::StandardSamplerPrecomputationSegment >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pathfinding::StandardSamplerPrecomputationSegment >(arena);
}
template<> PROTOBUF_NOINLINE ::pathfinding::StandardSamplerPrecomputation* Arena::CreateMaybeMessage< ::pathfinding::StandardSamplerPrecomputation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pathfinding::StandardSamplerPrecomputation >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
